/* Generated code for Python module 'cryptography.x509.extensions'
 * created by Nuitka version 0.6.6
 *
 * This code is in part copyright 2019 Kay Hayen.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "nuitka/prelude.h"

#include "__helpers.h"

/* The "_module_cryptography$x509$extensions" is a Python object pointer of module type.
 *
 * Note: For full compatibility with CPython, every module variable access
 * needs to go through it except for cases where the module cannot possibly
 * have changed in the mean time.
 */

PyObject *module_cryptography$x509$extensions;
PyDictObject *moduledict_cryptography$x509$extensions;

/* The declarations of module constants used, if any. */
static PyObject *const_str_plain__crl_issuer;
extern PyObject *const_str_plain_TLS_FEATURE;
static PyObject *const_str_plain__decipher_only;
extern PyObject *const_str_plain_data;
static PyObject *const_tuple_30cc927ede2fc9470dffcd81c25765bb_tuple;
extern PyObject *const_tuple_str_plain_self_str_plain_other_tuple;
static PyObject *const_str_digest_a0744842c59ec0ec1342dee683ec7ac8;
extern PyObject *const_str_plain_get_values_for_type;
static PyObject *const_str_digest_f37468dd5629ccacfbc304506e5ed113;
static PyObject *const_str_digest_28228272e91a15a54ff010026fcf7af8;
extern PyObject *const_str_digest_b9c4baf879ebd882d40843df3a4dead7;
static PyObject *const_str_digest_096877126149ba9ef6483d7f63c2f65e;
extern PyObject *const_str_plain_IPv6Network;
extern PyObject *const_str_plain_digital_signature;
extern PyObject *const_str_plain_KEY_USAGE;
static PyObject *const_str_digest_e29a6013213dd6497cd7c55bc7864351;
static PyObject *const_str_digest_76d9dc3b971abafb272069e298f2eb0c;
extern PyObject *const_str_plain_UncompressedPoint;
static PyObject *const_str_plain__organization;
static PyObject *const_str_digest_a173082fd91f8794530005b1589bf6b2;
static PyObject *const_tuple_str_plain__notice_reference_tuple;
static PyObject *const_tuple_str_plain__key_encipherment_tuple;
extern PyObject *const_str_plain_reason;
extern PyObject *const_str_plain_int;
static PyObject *const_tuple_02fac2eed0ac0dd060a0301d0bd9ba98_tuple;
extern PyObject *const_str_plain_read_only_property;
extern PyObject *const_str_plain_ExtensionOID;
extern PyObject *const_str_plain_text_type;
static PyObject *const_str_plain__access_location;
static PyObject *const_str_digest_73d50e8900e7f2ac40a53b664096aa15;
static PyObject *const_str_digest_91034dde8ef1b9b2896e23f094ab68ec;
extern PyObject *const_str_plain_abstractproperty;
extern PyObject *const_str_plain__extensions;
extern PyObject *const_str_digest_9db3cdd3cd765463b4eec6754eb8e087;
extern PyObject *const_str_plain__value;
static PyObject *const_str_plain__only_contains_ca_certs;
static PyObject *const_str_digest_548641877ac6c51da15a8285d67846ee;
static PyObject *const_tuple_571ef8230a0f951e7e814a3a1b007a73_tuple;
extern PyObject *const_str_plain_x;
static PyObject *const_str_digest_e796fffc6f5e8d4c3d564875b854a9ed;
extern PyObject *const_str_plain_AccessDescription;
extern PyObject *const_str_plain_NoticeReference;
extern PyObject *const_str_plain_SubjectPublicKeyInfo;
extern PyObject *const_str_plain_relative_name;
extern PyObject *const_str_digest_d8b4cb10b00d6765b713cf768245d18d;
static PyObject *const_tuple_str_plain_self_str_plain_ca_str_plain_path_length_tuple;
extern PyObject *const_str_plain_IPAddress;
extern PyObject *const_str_plain_require_explicit_policy;
extern PyObject *const_str_plain_cls;
static PyObject *const_str_plain__key_encipherment;
extern PyObject *const_str_plain_UnrecognizedExtension;
static PyObject *const_str_digest_de9abd61df15d9c64a5a616e9749f115;
extern PyObject *const_str_plain_SUBJECT_ALTERNATIVE_NAME;
static PyObject *const_str_plain_cACompromise;
extern PyObject *const_str_plain_SignedCertificateTimestamp;
extern PyObject *const_str_plain_RelativeDistinguishedName;
static PyObject *const_str_plain_serialized;
extern PyObject *const_str_plain_sha1;
extern PyObject *const_str_plain_OtherName;
extern PyObject *const_str_plain_CRLReason;
extern PyObject *const_str_plain___init__;
extern PyObject *const_str_plain_CRLEntryExtensionOID;
extern PyObject *const_str_plain_permitted_subtrees;
static PyObject *const_str_digest_aedab8e33f4a55e03d8255716673252f;
static PyObject *const_str_plain__only_contains_attribute_certs;
extern PyObject *const_str_plain_policy_identifier;
static PyObject *const_str_digest_de1714430c844d988a0d091fac0a73d4;
static PyObject *const_str_digest_f7714799e19abc5d09ccbaf8366649ea;
extern PyObject *const_str_plain_extensions;
extern PyObject *const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_x_tuple;
static PyObject *const_str_digest_ba0ace4d3ab5fb435146fa7a7a8c5e76;
static PyObject *const_str_plain__data_encipherment;
extern PyObject *const_str_plain_crl_sign;
extern PyObject *const_str_plain_str;
static PyObject *const_tuple_a73b8498e05ac6f54cfbc844a1aafead_tuple;
static PyObject *const_str_plain__skip_certs;
static PyObject *const_tuple_str_plain__organization_tuple;
extern PyObject *const_str_digest_b76ace6e0c7782d7cadb4695052eca5a;
static PyObject *const_unicode_digest_91632884773c30442b9e2ac13e53950d;
static PyObject *const_tuple_str_plain_cls_str_plain_ski_tuple;
static PyObject *const_tuple_str_plain__key_identifier_tuple;
extern PyObject *const_str_plain_content_commitment;
extern PyObject *const_str_digest_0dcb6991fe0fe1dc113b1f3e65627e35;
extern PyObject *const_str_plain_crl_issuer;
static PyObject *const_str_digest_2e6a7667e25628285e79573956cb938f;
extern PyObject *const_str_plain_general_names;
extern PyObject *const_str_plain_DeltaCRLIndicator;
extern PyObject *const_str_plain_TLSFeature;
extern PyObject *const_str_plain_ski;
extern PyObject *const_str_plain_excluded_subtrees;
static PyObject *const_str_plain_policies;
extern PyObject *const_str_plain_key_identifier;
extern PyObject *const_str_plain_nonce;
static PyObject *const_str_digest_0c5b9c1eebf18567ca6eef13eba8418b;
static PyObject *const_tuple_str_plain_self_str_plain_distribution_points_tuple;
extern PyObject *const_str_plain_register_interface;
extern PyObject *const_str_plain_integer_types;
static PyObject *const_tuple_str_plain_RelativeDistinguishedName_tuple;
static PyObject *const_str_plain_aci;
static PyObject *const_tuple_str_plain_self_str_plain_aci_tuple;
extern PyObject *const_str_plain_AUTHORITY_INFORMATION_ACCESS;
static PyObject *const_str_digest_6e39999ae9fa2f733baa4157c3ce7ef9;
extern PyObject *const_str_plain_cessation_of_operation;
extern PyObject *const_str_plain_PrecertPoison;
extern PyObject *const_str_plain_privilege_withdrawn;
extern PyObject *const_str_plain_load;
extern PyObject *const_str_plain_indirect_crl;
static PyObject *const_str_plain_aACompromise;
static PyObject *const_tuple_str_plain_self_str_plain_invalidity_date_tuple;
static PyObject *const_tuple_str_plain_public_key_str_plain_serialized_str_plain_data_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_crl_issuer_str_plain_fn_tuple;
extern PyObject *const_str_plain_CERTIFICATE_POLICIES;
static PyObject *const_str_plain__policies;
extern PyObject *const_str_plain_INVALIDITY_DATE;
static PyObject *const_str_plain_from_public_key;
extern PyObject *const_str_plain_ISSUING_DISTRIBUTION_POINT;
static PyObject *const_str_plain_tree;
static PyObject *const_tuple_str_plain__crl_number_tuple;
extern PyObject *const_str_plain__nonce;
extern PyObject *const_str_plain_AUTHORITY_KEY_IDENTIFIER;
static PyObject *const_str_plain__path_length;
static PyObject *const_tuple_str_plain_self_str_plain_oid_str_plain_value_tuple;
static PyObject *const_str_digest_7689dc38f9edab5e0154168296ac4aa7;
static PyObject *const_tuple_40c66ae610f06e095b8a28b392d109cb_tuple;
static PyObject *const_str_plain__critical;
extern PyObject *const_str_plain__TLS_FEATURE_TYPE_TO_ENUM;
static PyObject *const_tuple_str_plain__crl_issuer_tuple;
extern PyObject *const_str_plain_bool;
static PyObject *const_str_plain__policy_identifier;
static PyObject *const_str_digest_350fb76bfa2c81c3db35fe4ad0c5cc28;
static PyObject *const_str_digest_d3e161c72eca6237cebf732e747f2482;
static PyObject *const_tuple_str_plain_cls_str_plain_public_key_str_plain_digest_tuple;
extern PyObject *const_str_plain_policy_qualifiers;
extern PyObject *const_str_plain_ObjectIdentifier;
extern PyObject *const_str_plain_Encoding;
extern PyObject *const_str_plain_notice_numbers;
extern PyObject *const_str_plain_authority_cert_issuer;
static PyObject *const_str_digest_a4add4111fbe02d06da1613741f3d5ca;
extern PyObject *const_str_plain_NAME_CONSTRAINTS;
extern PyObject *const_str_plain_OCSPNoCheck;
static PyObject *const_str_plain__permitted_subtrees;
static PyObject *const_str_plain__key_cert_sign;
static PyObject *const_str_digest_98ddab5a38618a53af9688f12b4a5b05;
static PyObject *const_str_plain_removeFromCRL;
static PyObject *const_str_digest_3a0a1109b8c268ad95ea7f220c74ef61;
static PyObject *const_str_digest_1695020c9fca9629cae2bba3b13ed98d;
extern PyObject *const_tuple_empty;
static PyObject *const_tuple_str_plain_self_str_plain_ps_str_plain_es_tuple;
extern PyObject *const_str_plain_Enum;
extern PyObject *const_tuple_str_plain__value_tuple;
extern PyObject *const_tuple_str_plain_Enum_tuple;
static PyObject *const_str_digest_5576b3ba482b3c884e20c0f0f9889daf;
static PyObject *const_tuple_str_plain_self_str_plain_descriptions_tuple;
extern PyObject *const_tuple_str_plain_self_str_plain_idx_tuple;
static PyObject *const_str_digest_d0363a16b2327897c21c9e61fd2edb1e;
static PyObject *const_str_plain__relative_name;
static PyObject *const_str_digest_171541ce3e17f273a42b3961194a7b72;
extern PyObject *const_tuple_str_plain_utils_tuple;
static PyObject *const_str_digest_acc45e336b0d5f3376f4867fb94a18e6;
static PyObject *const_str_digest_024b912fa6151b94263fc1d09ce49af2;
extern PyObject *const_str_plain__digest;
static PyObject *const_str_plain__indirect_crl;
static PyObject *const_str_digest_92ebfd7d825e182438411c24725c884a;
extern PyObject *const_str_plain_datetime;
extern PyObject *const_str_plain_digest;
static PyObject *const_str_digest_d0cacbb4febc1bdb60a26b048c7bb9b6;
extern PyObject *const_str_plain___file__;
static PyObject *const_tuple_str_plain__only_contains_attribute_certs_tuple;
extern PyObject *const_str_plain_path_length;
extern PyObject *const_str_plain_hashlib;
static PyObject *const_str_digest_908210834a8fb4c8eaca7a64e23a4bed;
static PyObject *const_tuple_str_plain__only_contains_ca_certs_tuple;
extern PyObject *const_str_plain___getitem__;
static PyObject *const_str_digest_ccd052a57d9b2466ec6174083baebf1e;
extern PyObject *const_str_plain___metaclass__;
extern PyObject *const_str_plain_skip_certs;
static PyObject *const_tuple_str_plain_cls_str_plain_public_key_tuple;
static PyObject *const_tuple_str_plain__relative_name_tuple;
static PyObject *const_tuple_b58c59c90f8b7ff71dbfd006f561c9fe_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_reason_tuple;
extern PyObject *const_str_plain_CRL_DISTRIBUTION_POINTS;
static PyObject *const_str_digest_f63518e696f94cef547d30428c9b8408;
static PyObject *const_tuple_str_plain__policy_qualifiers_tuple;
extern PyObject *const_str_plain_EXTENDED_KEY_USAGE;
extern PyObject *const_str_plain_PolicyInformation;
static PyObject *const_tuple_35bfa5acc69c9c72494218df80b094f1_tuple;
extern PyObject *const_str_plain_InhibitAnyPolicy;
static PyObject *const_str_plain__require_explicit_policy;
static PyObject *const_str_digest_d04c4a4e63138db9ecc900ec9847717c;
extern PyObject *const_str_plain_CRL_NUMBER;
static PyObject *const_tuple_str_plain_self_str_plain_crl_number_tuple;
static PyObject *const_str_digest_da5560b5b28f3c84a1c556751340bb55;
static PyObject *const_str_digest_2fedee8d2e8553cc3a2acd1bc300acd1;
static PyObject *const_str_digest_f7d33cb69a7dc22294881ff5b1fe0ec9;
static PyObject *const_tuple_str_plain_PublicKeyInfo_tuple;
static PyObject *const_tuple_str_plain__permitted_subtrees_tuple;
extern PyObject *const_str_plain_object;
extern PyObject *const_str_plain_name;
static PyObject *const_tuple_str_plain__authority_cert_issuer_tuple;
extern PyObject *const_str_plain_authority_cert_serial_number;
static PyObject *const_tuple_str_plain__notice_numbers_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_features_tuple;
static PyObject *const_str_digest_11b049dd960f5e8f8d4550cdd9caf427;
static PyObject *const_str_digest_4896564d0ed5e6b06237436d00bf3cad;
static PyObject *const_tuple_str_plain__key_cert_sign_tuple;
extern PyObject *const_str_plain_sct;
extern PyObject *const_str_plain_msg;
extern PyObject *const_str_plain_CRLNumber;
extern PyObject *const_str_plain_DistributionPoint;
static PyObject *const_tuple_str_plain_self_str_plain_general_names_tuple;
static PyObject *const_str_plain_status_request_v2;
extern PyObject *const_str_plain_invalidity_date;
static PyObject *const_str_digest_f68da15c98dbc7b7660e8e5bee0179e6;
static PyObject *const_str_digest_ad140184cf2507dc997c5c6a9d0f3e94;
static PyObject *const_str_digest_a2ae3825a8b7f0237bc2c108542b8be9;
static PyObject *const_str_plain_signed_certificate_timestamps;
static PyObject *const_str_digest_114372ae17a491041cc1a4b677269f5b;
extern PyObject *const_str_plain__reason;
static PyObject *const_str_plain__general_names;
extern PyObject *const_str_plain_ca;
static PyObject *const_str_plain_usages;
extern PyObject *const_str_plain_FRESHEST_CRL;
static PyObject *const_str_plain_crl_constraints;
static PyObject *const_tuple_str_plain_self_str_plain_policies_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_tree_tuple;
static PyObject *const_tuple_str_plain__key_agreement_tuple;
static PyObject *const_str_digest_2622a0002f5b5df69415ebf4bce9a343;
static PyObject *const_tuple_str_plain_self_str_plain_skip_certs_tuple;
extern PyObject *const_str_plain_AuthorityInformationAccess;
extern PyObject *const_str_plain_ca_compromise;
static PyObject *const_str_digest_9cc2c8377ce78bc1b198ac0906717d7f;
extern PyObject *const_str_plain_crl_number;
extern PyObject *const_str_plain_full_name;
extern PyObject *const_str_plain_InvalidityDate;
static PyObject *const_tuple_str_plain_SignedCertificateTimestamp_tuple;
static PyObject *const_str_plain__encipher_only;
extern PyObject *const_str_plain_SubjectKeyIdentifier;
static PyObject *const_str_digest_881d5fa81af108f32d6b1d8d2d35a638;
extern PyObject *const_str_plain_division;
extern PyObject *const_str_plain_only_contains_user_certs;
static PyObject *const_tuple_str_plain__explicit_text_tuple;
static PyObject *const_str_digest_c3da50fdd18d409ebf6fe1322cd35c5d;
extern PyObject *const_str_plain_public_bytes;
extern PyObject *const_str_plain_only_contains_ca_certs;
static PyObject *const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_sct_tuple;
static PyObject *const_tuple_str_plain__skip_certs_tuple;
static PyObject *const_str_digest_520475ee9f753bee090d1ecadd4c727e;
extern PyObject *const_str_plain_IPv4Network;
static PyObject *const_tuple_str_plain__digital_signature_tuple;
extern PyObject *const_str_plain_POLICY_CONSTRAINTS;
extern PyObject *const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
static PyObject *const_str_digest_d2a030963ea7fa46a452128daffceb24;
extern PyObject *const_str_plain_IssuerAlternativeName;
extern PyObject *const_str_plain_CRLDistributionPoints;
extern PyObject *const_tuple_type_object_tuple;
static PyObject *const_tuple_str_plain__ca_tuple;
static PyObject *const_str_digest_2a0138f3ee2cd707fb386e46f1612821;
extern PyObject *const_str_plain_FreshestCRL;
extern PyObject *const_str_plain_type;
static PyObject *const_str_plain__notice_numbers;
static PyObject *const_tuple_str_plain__excluded_subtrees_tuple;
static PyObject *const_str_plain__key_agreement;
static PyObject *const_str_digest_c6c3dada1f7f971d20a3492ccb208681;
extern PyObject *const_str_plain_constant_time;
static PyObject *const_str_plain__reasons;
extern PyObject *const_str_plain_PublicKeyInfo;
static PyObject *const_str_digest_b436a97f38724e3583df19a1d449e278;
extern PyObject *const_str_plain_ExtendedKeyUsage;
static PyObject *const_str_digest_fdf88dfad66dd7b1bb721469f9f06736;
static PyObject *const_tuple_str_plain__require_explicit_policy_tuple;
static PyObject *const_tuple_str_plain__inhibit_policy_mapping_tuple;
extern PyObject *const_tuple_str_plain_self_str_plain_nonce_tuple;
static PyObject *const_str_plain__validate_ip_name;
extern PyObject *const_str_plain___ne__;
static PyObject *const_tuple_str_plain_self_str_plain_pq_tuple;
extern PyObject *const_str_plain_PRECERT_SIGNED_CERTIFICATE_TIMESTAMPS;
static PyObject *const_tuple_str_plain_self_str_plain_usages_tuple;
extern PyObject *const_str_plain_self;
extern PyObject *const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_name_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_type_str_plain_objs_tuple;
extern PyObject *const_str_digest_bd71b5d9106eb6b876b65e57bcd30837;
static PyObject *const_str_plain_status_request;
extern PyObject *const_str_plain_ISSUER_ALTERNATIVE_NAME;
extern PyObject *const_str_plain_DELTA_CRL_INDICATOR;
extern PyObject *const_str_plain_value;
extern PyObject *const_str_plain_certificateHold;
extern PyObject *const_str_plain_NameConstraints;
static PyObject *const_str_plain__key_identifier_from_public_key;
static PyObject *const_str_plain__notice_reference;
static PyObject *const_str_digest_15f4645c15394598b5ad3d887ad62f4a;
extern PyObject *const_str_plain_BasicConstraints;
static PyObject *const_str_plain__only_some_reasons;
static PyObject *const_str_digest_26a75172f55108334b01cdc8efcbab38;
static PyObject *const_str_digest_cb90e2fbaafbf44b381aafdbc54043e2;
extern PyObject *const_int_pos_17;
static PyObject *const_tuple_0249ced4da5e72f251db066d967b15dd_tuple;
extern PyObject *const_str_digest_9c4dcd45c628f51f60b0e74617698ea7;
extern PyObject *const_tuple_str_plain_self_str_plain_digest_tuple;
extern PyObject *const_str_plain_aa_compromise;
extern PyObject *const_str_plain_CertificatePolicies;
extern PyObject *const_tuple_str_plain__reason_tuple;
static PyObject *const_str_plain__distribution_points;
static PyObject *const_tuple_str_plain__critical_tuple;
extern PyObject *const_int_pos_5;
extern PyObject *const_str_plain_key_cert_sign;
extern PyObject *const_int_pos_1;
static PyObject *const_tuple_str_plain__reasons_tuple;
extern PyObject *const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_i_tuple;
extern PyObject *const_str_plain_remove_from_crl;
extern PyObject *const_str_plain_CertificateIssuer;
extern PyObject *const_str_plain_property;
static PyObject *const_tuple_str_plain_constant_time_str_plain_serialization_tuple;
static PyObject *const_str_plain__features;
extern PyObject *const_str_plain_utils;
extern PyObject *const_str_plain_bytes_eq;
extern PyObject *const_str_plain_serialization;
extern PyObject *const_str_plain_decipher_only;
static PyObject *const_str_plain__full_name;
static PyObject *const_str_plain_objs;
extern PyObject *const_str_digest_becb7ddc5eba88bda421a9fc23a1539c;
extern PyObject *const_str_plain___hash__;
static PyObject *const_tuple_str_plain_EllipticCurvePublicKey_tuple;
static PyObject *const_tuple_str_plain__data_encipherment_tuple;
extern PyObject *const_str_plain_SUBJECT_KEY_IDENTIFIER;
static PyObject *const_str_plain__excluded_subtrees;
static PyObject *const_tuple_96332c2a391d63d358e15081c1debfb6_tuple;
static PyObject *const_str_plain_frozenset;
extern PyObject *const_str_plain___eq__;
extern PyObject *const_str_plain_NONCE;
extern PyObject *const_str_plain_inhibit_policy_mapping;
extern PyObject *const_str_plain_IssuingDistributionPoint;
extern PyObject *const_str_plain_fn;
extern PyObject *const_str_plain_ReasonFlags;
extern PyObject *const_str_plain_PublicFormat;
static PyObject *const_str_plain__crl_number;
static PyObject *const_str_plain__authority_cert_serial_number;
extern PyObject *const_str_plain_key_agreement;
static PyObject *const_tuple_9e442608387cffc806b1f25d569bdb89_tuple;
extern PyObject *const_str_plain_i;
extern PyObject *const_str_plain_only_contains_attribute_certs;
static PyObject *const_str_plain_features;
extern PyObject *const_str_plain_CRL_REASON;
static PyObject *const_tuple_str_plain_self_str_plain_type_tuple;
extern PyObject *const_str_plain_public_key;
static PyObject *const_str_plain_get_extension_for_oid;
static PyObject *const_str_plain__invalidity_date;
extern PyObject *const_str_plain_INHIBIT_ANY_POLICY;
static PyObject *const_tuple_str_plain_RSAPublicKey_tuple;
extern PyObject *const_str_plain_GeneralNames;
extern PyObject *const_str_plain_cryptography;
extern PyObject *const_str_plain_organization;
extern PyObject *const_str_plain_UserNotice;
static PyObject *const_str_digest_1dfb7a6265a6e9db387c1d41869616b8;
static PyObject *const_str_digest_c47beb1c7d1e047c9170d20aad4fb97b;
static PyObject *const_str_digest_2a63548c17bc773344f27e5819855b7b;
extern PyObject *const_str_plain_superseded;
extern PyObject *const_int_0;
extern PyObject *const_str_plain_six;
extern PyObject *const_str_plain_idx;
static PyObject *const_tuple_str_plain__only_some_reasons_tuple;
extern PyObject *const_tuple_str_plain__oid_tuple;
extern PyObject *const_str_digest_957c81bc7a15c28c0c453fa3270dbc10;
extern PyObject *const_str_plain_data_encipherment;
static PyObject *const_str_plain__explicit_text;
static PyObject *const_str_plain__crl_sign;
static PyObject *const_tuple_str_plain__digest_tuple;
static PyObject *const_str_plain__descriptions;
static PyObject *const_str_plain__key_identifier;
static PyObject *const_str_digest_2615a61b30c6d1612864004a5b3409b1;
static PyObject *const_str_plain_pq;
static PyObject *const_str_digest_7d42ffe02af672349902ee30e189a05b;
static PyObject *const_str_plain_ps;
static PyObject *const_str_digest_35185795abbb3b5bbc0cab5aa03aab83;
extern PyObject *const_str_plain_add_metaclass;
static PyObject *const_str_plain_descriptions;
extern PyObject *const_str_plain_print_function;
extern PyObject *const_str_plain_ExtensionType;
extern PyObject *const_str_plain_ABCMeta;
static PyObject *const_tuple_79831141b0c54263bd4ba55a91ef27c4_tuple;
extern PyObject *const_tuple_str_plain__nonce_tuple;
static PyObject *const_str_plain_es;
static PyObject *const_str_plain__policy_qualifiers;
static PyObject *const_str_plain__only_contains_user_certs;
static PyObject *const_str_plain__access_method;
static PyObject *const_str_digest_198893d8157c272d69767f46f86316c2;
extern PyObject *const_str_plain_X962;
extern PyObject *const_str_plain_access_method;
static PyObject *const_tuple_str_plain__access_location_tuple;
extern PyObject *const_str_digest_97ac982b098bfd0facb64df38773c335;
extern PyObject *const_tuple_str_plain_self_tuple;
extern PyObject *const_str_plain_access_location;
extern PyObject *const_str_plain___repr__;
static PyObject *const_str_digest_de6ca45cc2c0d21b3ea9542eeb752d64;
static PyObject *const_tuple_str_plain__access_method_tuple;
extern PyObject *const_str_plain_reasons;
extern PyObject *const_str_plain_ext;
extern PyObject *const_str_plain_affiliation_changed;
extern PyObject *const_str_plain_key_compromise;
extern PyObject *const_str_plain_Extensions;
static PyObject *const_tuple_6d08159ea13672603ee689286b27f535_tuple;
extern PyObject *const_str_plain_format;
extern PyObject *const_str_plain_EllipticCurvePublicKey;
extern PyObject *const_str_plain_BASIC_CONSTRAINTS;
static PyObject *const_tuple_c9093e158a1a3426ce5fb16319f2926f_tuple;
static PyObject *const_str_plain__authority_cert_issuer;
extern PyObject *const_str_plain_DuplicateExtension;
extern PyObject *const_str_plain_affiliationChanged;
static PyObject *const_tuple_str_plain__crl_sign_tuple;
static PyObject *const_str_plain_privilegeWithdrawn;
static PyObject *const_tuple_str_plain__full_name_tuple;
extern PyObject *const_str_plain_abc;
extern PyObject *const_str_plain_GeneralName;
static PyObject *const_str_plain_extclass;
static PyObject *const_str_plain_distribution_points;
static PyObject *const_tuple_str_plain__invalidity_date_tuple;
extern PyObject *const_str_plain_Extension;
static PyObject *const_str_digest_afa42db89846e96e9cfc2ab56578058d;
extern PyObject *const_str_plain_unspecified;
extern PyObject *const_str_plain_encipher_only;
extern PyObject *const_str_plain___module__;
static PyObject *const_str_digest_1ea9692159fa7fd9f8e15a3506f4463c;
static PyObject *const_str_digest_421b43a5ec9f9f0f5f30b5a50ec3db96;
extern PyObject *const_str_plain___iter__;
extern PyObject *const_str_angle_genexpr;
static PyObject *const_tuple_str_plain_self_str_plain_msg_str_plain_oid_tuple;
extern PyObject *const_str_plain_critical;
static PyObject *const_tuple_str_plain__content_commitment_tuple;
static PyObject *const_str_digest_87fc424e9112e6987e5fe8e83a94ae22;
extern PyObject *const_str_plain_enum;
extern PyObject *const_str_plain_PRECERT_POISON;
extern PyObject *const_str_plain_OCSPNonce;
extern PyObject *const_str_digest_97cd6fd5c8579a7068d86fbfd40e2f84;
static PyObject *const_str_plain__digital_signature;
static PyObject *const_tuple_str_plain_self_str_plain_signed_certificate_timestamps_tuple;
extern PyObject *const_str_plain__oid;
static PyObject *const_str_digest_e41e00d6ec327bc9d8187afd927a45a2;
static PyObject *const_str_digest_449ea3887ada75d14dab0f566d0a778c;
static PyObject *const_str_digest_293839491199d08c5eee9ab993bbfcfe;
extern PyObject *const_str_plain_cessationOfOperation;
extern PyObject *const_str_plain_RSAPublicKey;
extern PyObject *const_str_plain_PKCS1;
static PyObject *const_str_digest_009ff6af115398b3dfb26f0926fdbea2;
static PyObject *const_unicode_digest_71b136bb2c4e9e2ce7c90a48ee86f246;
extern PyObject *const_str_plain_keyCompromise;
extern PyObject *const_str_plain_PolicyConstraints;
static PyObject *const_tuple_2a50e9eb562974724a6432490d012463_tuple;
extern PyObject *const_str_plain_explicit_text;
extern PyObject *const_str_plain_other;
extern PyObject *const_str_plain_notice_reference;
static PyObject *const_tuple_str_plain__path_length_tuple;
static PyObject *const_str_digest_837e2310df6009dd1b110accad73bb42;
static PyObject *const_str_digest_ac8667798ba70bb109d3e3236473ab02;
static PyObject *const_str_plain_from_issuer_public_key;
extern PyObject *const_str_plain_ipaddress;
static PyObject *const_str_plain__content_commitment;
static PyObject *const_str_digest_37a5813a8df88d549fa10cdd6f24a9b9;
static PyObject *const_tuple_str_plain_self_str_plain_extclass_str_plain_ext_tuple;
static PyObject *const_str_digest_52903da339eb426b3d703a3f30ce3e10;
static PyObject *const_tuple_str_plain__authority_cert_serial_number_tuple;
static PyObject *const_str_digest_1961eae2d00689b393091e3fc681acbe;
extern PyObject *const_str_plain_CERTIFICATE_ISSUER;
static PyObject *const_str_digest_3611def0515b06c31df0f70307f767f3;
static PyObject *const_str_plain__usages;
extern PyObject *const_str_plain_oid;
extern PyObject *const_str_plain_AuthorityKeyIdentifier;
static PyObject *const_tuple_str_plain__indirect_crl_tuple;
extern PyObject *const_str_plain_key_encipherment;
static PyObject *const_tuple_str_plain_self_str_plain_extensions_tuple;
static PyObject *const_str_plain__signed_certificate_timestamps;
extern PyObject *const_str_plain_TLSFeatureType;
extern PyObject *const_str_plain_absolute_import;
static PyObject *const_tuple_str_plain_self_str_plain_oid_str_plain_ext_tuple;
static PyObject *const_tuple_str_plain__only_contains_user_certs_tuple;
static PyObject *const_str_digest_42aaad2aaa6a1ee7d79f305ebfd1a58b;
extern PyObject *const_str_plain___doc__;
extern PyObject *const_str_plain_ExtensionNotFound;
static PyObject *const_str_plain_from_issuer_subject_key_identifier;
static PyObject *const_str_digest_56973e3a5f1a8b7f8ba81c36b603bcaa;
extern PyObject *const_tuple_type_Exception_tuple;
extern PyObject *const_str_plain_get_extension_for_class;
extern PyObject *const_str_plain___len__;
extern PyObject *const_str_plain_certificate_hold;
extern PyObject *const_str_plain_KeyUsage;
extern PyObject *const_str_plain_OCSPExtensionOID;
static PyObject *const_str_plain__ca;
static PyObject *const_tuple_str_plain__policy_identifier_tuple;
extern PyObject *const_str_plain_SubjectAlternativeName;
static PyObject *const_str_digest_e7bc751982d7cd4fe2e9c78dbf3e6347;
static PyObject *const_tuple_9d6859e57abe5ce2ca107f61cc5077a0_tuple;
extern PyObject *const_str_plain_DER;
static PyObject *const_str_plain__inhibit_policy_mapping;
extern PyObject *const_str_plain_OCSP_NO_CHECK;
extern PyObject *const_str_plain_only_some_reasons;
static PyObject *module_filename_obj;

/* Indicator if this modules private constants were created yet. */
static bool constants_created = false;

/* Function to create module private constants. */
static void createModuleConstants(void) {
    const_str_plain__crl_issuer = UNSTREAM_STRING(&constant_bin[ 622107 ], 11, 1);
    const_str_plain__decipher_only = UNSTREAM_STRING(&constant_bin[ 622118 ], 14, 1);
    const_tuple_30cc927ede2fc9470dffcd81c25765bb_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_30cc927ede2fc9470dffcd81c25765bb_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_30cc927ede2fc9470dffcd81c25765bb_tuple, 1, const_str_plain_notice_reference); Py_INCREF(const_str_plain_notice_reference);
    PyTuple_SET_ITEM(const_tuple_30cc927ede2fc9470dffcd81c25765bb_tuple, 2, const_str_plain_explicit_text); Py_INCREF(const_str_plain_explicit_text);
    const_str_digest_a0744842c59ec0ec1342dee683ec7ac8 = UNSTREAM_STRING(&constant_bin[ 622132 ], 63, 0);
    const_str_digest_f37468dd5629ccacfbc304506e5ed113 = UNSTREAM_STRING(&constant_bin[ 622195 ], 19, 0);
    const_str_digest_28228272e91a15a54ff010026fcf7af8 = UNSTREAM_STRING(&constant_bin[ 622214 ], 58, 0);
    const_str_digest_096877126149ba9ef6483d7f63c2f65e = UNSTREAM_STRING(&constant_bin[ 622272 ], 18, 0);
    const_str_digest_e29a6013213dd6497cd7c55bc7864351 = UNSTREAM_STRING(&constant_bin[ 622290 ], 16, 0);
    const_str_digest_76d9dc3b971abafb272069e298f2eb0c = UNSTREAM_STRING(&constant_bin[ 622306 ], 86, 0);
    const_str_plain__organization = UNSTREAM_STRING(&constant_bin[ 622392 ], 13, 1);
    const_str_digest_a173082fd91f8794530005b1589bf6b2 = UNSTREAM_STRING(&constant_bin[ 622405 ], 55, 0);
    const_tuple_str_plain__notice_reference_tuple = PyTuple_New(1);
    const_str_plain__notice_reference = UNSTREAM_STRING(&constant_bin[ 27582 ], 17, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain__notice_reference_tuple, 0, const_str_plain__notice_reference); Py_INCREF(const_str_plain__notice_reference);
    const_tuple_str_plain__key_encipherment_tuple = PyTuple_New(1);
    const_str_plain__key_encipherment = UNSTREAM_STRING(&constant_bin[ 622460 ], 17, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain__key_encipherment_tuple, 0, const_str_plain__key_encipherment); Py_INCREF(const_str_plain__key_encipherment);
    const_tuple_02fac2eed0ac0dd060a0301d0bd9ba98_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_02fac2eed0ac0dd060a0301d0bd9ba98_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_02fac2eed0ac0dd060a0301d0bd9ba98_tuple, 1, const_str_plain_key_identifier); Py_INCREF(const_str_plain_key_identifier);
    PyTuple_SET_ITEM(const_tuple_02fac2eed0ac0dd060a0301d0bd9ba98_tuple, 2, const_str_plain_authority_cert_issuer); Py_INCREF(const_str_plain_authority_cert_issuer);
    PyTuple_SET_ITEM(const_tuple_02fac2eed0ac0dd060a0301d0bd9ba98_tuple, 3, const_str_plain_authority_cert_serial_number); Py_INCREF(const_str_plain_authority_cert_serial_number);
    const_str_plain__access_location = UNSTREAM_STRING(&constant_bin[ 622477 ], 16, 1);
    const_str_digest_73d50e8900e7f2ac40a53b664096aa15 = UNSTREAM_STRING(&constant_bin[ 622493 ], 22, 0);
    const_str_digest_91034dde8ef1b9b2896e23f094ab68ec = UNSTREAM_STRING(&constant_bin[ 622515 ], 43, 0);
    const_str_plain__only_contains_ca_certs = UNSTREAM_STRING(&constant_bin[ 622558 ], 23, 1);
    const_str_digest_548641877ac6c51da15a8285d67846ee = UNSTREAM_STRING(&constant_bin[ 622581 ], 22, 0);
    const_tuple_571ef8230a0f951e7e814a3a1b007a73_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_571ef8230a0f951e7e814a3a1b007a73_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_571ef8230a0f951e7e814a3a1b007a73_tuple, 1, const_str_plain_organization); Py_INCREF(const_str_plain_organization);
    PyTuple_SET_ITEM(const_tuple_571ef8230a0f951e7e814a3a1b007a73_tuple, 2, const_str_plain_notice_numbers); Py_INCREF(const_str_plain_notice_numbers);
    const_str_digest_e796fffc6f5e8d4c3d564875b854a9ed = UNSTREAM_STRING(&constant_bin[ 622603 ], 29, 0);
    const_tuple_str_plain_self_str_plain_ca_str_plain_path_length_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_ca_str_plain_path_length_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_ca_str_plain_path_length_tuple, 1, const_str_plain_ca); Py_INCREF(const_str_plain_ca);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_ca_str_plain_path_length_tuple, 2, const_str_plain_path_length); Py_INCREF(const_str_plain_path_length);
    const_str_digest_de9abd61df15d9c64a5a616e9749f115 = UNSTREAM_STRING(&constant_bin[ 622632 ], 224, 0);
    const_str_plain_cACompromise = UNSTREAM_STRING(&constant_bin[ 622856 ], 12, 1);
    const_str_plain_serialized = UNSTREAM_STRING(&constant_bin[ 193106 ], 10, 1);
    const_str_digest_aedab8e33f4a55e03d8255716673252f = UNSTREAM_STRING(&constant_bin[ 622868 ], 17, 0);
    const_str_plain__only_contains_attribute_certs = UNSTREAM_STRING(&constant_bin[ 622885 ], 30, 1);
    const_str_digest_de1714430c844d988a0d091fac0a73d4 = UNSTREAM_STRING(&constant_bin[ 622915 ], 15, 0);
    const_str_digest_f7714799e19abc5d09ccbaf8366649ea = UNSTREAM_STRING(&constant_bin[ 622930 ], 29, 0);
    const_str_digest_ba0ace4d3ab5fb435146fa7a7a8c5e76 = UNSTREAM_STRING(&constant_bin[ 622959 ], 41, 0);
    const_str_plain__data_encipherment = UNSTREAM_STRING(&constant_bin[ 623000 ], 18, 1);
    const_tuple_a73b8498e05ac6f54cfbc844a1aafead_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_a73b8498e05ac6f54cfbc844a1aafead_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_a73b8498e05ac6f54cfbc844a1aafead_tuple, 1, const_str_plain_permitted_subtrees); Py_INCREF(const_str_plain_permitted_subtrees);
    PyTuple_SET_ITEM(const_tuple_a73b8498e05ac6f54cfbc844a1aafead_tuple, 2, const_str_plain_excluded_subtrees); Py_INCREF(const_str_plain_excluded_subtrees);
    const_str_plain__skip_certs = UNSTREAM_STRING(&constant_bin[ 623018 ], 11, 1);
    const_tuple_str_plain__organization_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_plain__organization_tuple, 0, const_str_plain__organization); Py_INCREF(const_str_plain__organization);
    const_unicode_digest_91632884773c30442b9e2ac13e53950d = UNSTREAM_UNICODE(&constant_bin[ 623029 ], 101);
    const_tuple_str_plain_cls_str_plain_ski_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_cls_str_plain_ski_tuple, 0, const_str_plain_cls); Py_INCREF(const_str_plain_cls);
    PyTuple_SET_ITEM(const_tuple_str_plain_cls_str_plain_ski_tuple, 1, const_str_plain_ski); Py_INCREF(const_str_plain_ski);
    const_tuple_str_plain__key_identifier_tuple = PyTuple_New(1);
    const_str_plain__key_identifier = UNSTREAM_STRING(&constant_bin[ 24290 ], 15, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain__key_identifier_tuple, 0, const_str_plain__key_identifier); Py_INCREF(const_str_plain__key_identifier);
    const_str_digest_2e6a7667e25628285e79573956cb938f = UNSTREAM_STRING(&constant_bin[ 623130 ], 36, 0);
    const_str_plain_policies = UNSTREAM_STRING(&constant_bin[ 24592 ], 8, 1);
    const_str_digest_0c5b9c1eebf18567ca6eef13eba8418b = UNSTREAM_STRING(&constant_bin[ 623166 ], 49, 0);
    const_tuple_str_plain_self_str_plain_distribution_points_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_distribution_points_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    const_str_plain_distribution_points = UNSTREAM_STRING(&constant_bin[ 24634 ], 19, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_distribution_points_tuple, 1, const_str_plain_distribution_points); Py_INCREF(const_str_plain_distribution_points);
    const_tuple_str_plain_RelativeDistinguishedName_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_plain_RelativeDistinguishedName_tuple, 0, const_str_plain_RelativeDistinguishedName); Py_INCREF(const_str_plain_RelativeDistinguishedName);
    const_str_plain_aci = UNSTREAM_STRING(&constant_bin[ 130438 ], 3, 1);
    const_tuple_str_plain_self_str_plain_aci_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_aci_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_aci_tuple, 1, const_str_plain_aci); Py_INCREF(const_str_plain_aci);
    const_str_digest_6e39999ae9fa2f733baa4157c3ce7ef9 = UNSTREAM_STRING(&constant_bin[ 623215 ], 25, 0);
    const_str_plain_aACompromise = UNSTREAM_STRING(&constant_bin[ 623240 ], 12, 1);
    const_tuple_str_plain_self_str_plain_invalidity_date_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_invalidity_date_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_invalidity_date_tuple, 1, const_str_plain_invalidity_date); Py_INCREF(const_str_plain_invalidity_date);
    const_tuple_str_plain_public_key_str_plain_serialized_str_plain_data_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_public_key_str_plain_serialized_str_plain_data_tuple, 0, const_str_plain_public_key); Py_INCREF(const_str_plain_public_key);
    PyTuple_SET_ITEM(const_tuple_str_plain_public_key_str_plain_serialized_str_plain_data_tuple, 1, const_str_plain_serialized); Py_INCREF(const_str_plain_serialized);
    PyTuple_SET_ITEM(const_tuple_str_plain_public_key_str_plain_serialized_str_plain_data_tuple, 2, const_str_plain_data); Py_INCREF(const_str_plain_data);
    const_tuple_str_plain_self_str_plain_crl_issuer_str_plain_fn_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_crl_issuer_str_plain_fn_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_crl_issuer_str_plain_fn_tuple, 1, const_str_plain_crl_issuer); Py_INCREF(const_str_plain_crl_issuer);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_crl_issuer_str_plain_fn_tuple, 2, const_str_plain_fn); Py_INCREF(const_str_plain_fn);
    const_str_plain__policies = UNSTREAM_STRING(&constant_bin[ 24591 ], 9, 1);
    const_str_plain_from_public_key = UNSTREAM_STRING(&constant_bin[ 36261 ], 15, 1);
    const_str_plain_tree = UNSTREAM_STRING(&constant_bin[ 23796 ], 4, 1);
    const_tuple_str_plain__crl_number_tuple = PyTuple_New(1);
    const_str_plain__crl_number = UNSTREAM_STRING(&constant_bin[ 25189 ], 11, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain__crl_number_tuple, 0, const_str_plain__crl_number); Py_INCREF(const_str_plain__crl_number);
    const_str_plain__path_length = UNSTREAM_STRING(&constant_bin[ 623252 ], 12, 1);
    const_tuple_str_plain_self_str_plain_oid_str_plain_value_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_oid_str_plain_value_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_oid_str_plain_value_tuple, 1, const_str_plain_oid); Py_INCREF(const_str_plain_oid);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_oid_str_plain_value_tuple, 2, const_str_plain_value); Py_INCREF(const_str_plain_value);
    const_str_digest_7689dc38f9edab5e0154168296ac4aa7 = UNSTREAM_STRING(&constant_bin[ 623264 ], 50, 0);
    const_tuple_40c66ae610f06e095b8a28b392d109cb_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_40c66ae610f06e095b8a28b392d109cb_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_40c66ae610f06e095b8a28b392d109cb_tuple, 1, const_str_plain_encipher_only); Py_INCREF(const_str_plain_encipher_only);
    PyTuple_SET_ITEM(const_tuple_40c66ae610f06e095b8a28b392d109cb_tuple, 2, const_str_plain_decipher_only); Py_INCREF(const_str_plain_decipher_only);
    const_str_plain__critical = UNSTREAM_STRING(&constant_bin[ 160564 ], 9, 1);
    const_tuple_str_plain__crl_issuer_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_plain__crl_issuer_tuple, 0, const_str_plain__crl_issuer); Py_INCREF(const_str_plain__crl_issuer);
    const_str_plain__policy_identifier = UNSTREAM_STRING(&constant_bin[ 623314 ], 18, 1);
    const_str_digest_350fb76bfa2c81c3db35fe4ad0c5cc28 = UNSTREAM_STRING(&constant_bin[ 623332 ], 50, 0);
    const_str_digest_d3e161c72eca6237cebf732e747f2482 = UNSTREAM_STRING(&constant_bin[ 623382 ], 89, 0);
    const_tuple_str_plain_cls_str_plain_public_key_str_plain_digest_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_cls_str_plain_public_key_str_plain_digest_tuple, 0, const_str_plain_cls); Py_INCREF(const_str_plain_cls);
    PyTuple_SET_ITEM(const_tuple_str_plain_cls_str_plain_public_key_str_plain_digest_tuple, 1, const_str_plain_public_key); Py_INCREF(const_str_plain_public_key);
    PyTuple_SET_ITEM(const_tuple_str_plain_cls_str_plain_public_key_str_plain_digest_tuple, 2, const_str_plain_digest); Py_INCREF(const_str_plain_digest);
    const_str_digest_a4add4111fbe02d06da1613741f3d5ca = UNSTREAM_STRING(&constant_bin[ 623471 ], 59, 0);
    const_str_plain__permitted_subtrees = UNSTREAM_STRING(&constant_bin[ 623530 ], 19, 1);
    const_str_plain__key_cert_sign = UNSTREAM_STRING(&constant_bin[ 623549 ], 14, 1);
    const_str_digest_98ddab5a38618a53af9688f12b4a5b05 = UNSTREAM_STRING(&constant_bin[ 623563 ], 25, 0);
    const_str_plain_removeFromCRL = UNSTREAM_STRING(&constant_bin[ 623588 ], 13, 1);
    const_str_digest_3a0a1109b8c268ad95ea7f220c74ef61 = UNSTREAM_STRING(&constant_bin[ 623601 ], 76, 0);
    const_str_digest_1695020c9fca9629cae2bba3b13ed98d = UNSTREAM_STRING(&constant_bin[ 623677 ], 75, 0);
    const_tuple_str_plain_self_str_plain_ps_str_plain_es_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_ps_str_plain_es_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    const_str_plain_ps = UNSTREAM_STRING(&constant_bin[ 152 ], 2, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_ps_str_plain_es_tuple, 1, const_str_plain_ps); Py_INCREF(const_str_plain_ps);
    const_str_plain_es = UNSTREAM_STRING(&constant_bin[ 400 ], 2, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_ps_str_plain_es_tuple, 2, const_str_plain_es); Py_INCREF(const_str_plain_es);
    const_str_digest_5576b3ba482b3c884e20c0f0f9889daf = UNSTREAM_STRING(&constant_bin[ 623752 ], 89, 0);
    const_tuple_str_plain_self_str_plain_descriptions_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_descriptions_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    const_str_plain_descriptions = UNSTREAM_STRING(&constant_bin[ 583499 ], 12, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_descriptions_tuple, 1, const_str_plain_descriptions); Py_INCREF(const_str_plain_descriptions);
    const_str_digest_d0363a16b2327897c21c9e61fd2edb1e = UNSTREAM_STRING(&constant_bin[ 623841 ], 58, 0);
    const_str_plain__relative_name = UNSTREAM_STRING(&constant_bin[ 27408 ], 14, 1);
    const_str_digest_171541ce3e17f273a42b3961194a7b72 = UNSTREAM_STRING(&constant_bin[ 623899 ], 47, 0);
    const_str_digest_acc45e336b0d5f3376f4867fb94a18e6 = UNSTREAM_STRING(&constant_bin[ 623946 ], 61, 0);
    const_str_digest_024b912fa6151b94263fc1d09ce49af2 = UNSTREAM_STRING(&constant_bin[ 624007 ], 47, 0);
    const_str_plain__indirect_crl = UNSTREAM_STRING(&constant_bin[ 624054 ], 13, 1);
    const_str_digest_92ebfd7d825e182438411c24725c884a = UNSTREAM_STRING(&constant_bin[ 624067 ], 30, 0);
    const_str_digest_d0cacbb4febc1bdb60a26b048c7bb9b6 = UNSTREAM_STRING(&constant_bin[ 624097 ], 27, 0);
    const_tuple_str_plain__only_contains_attribute_certs_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_plain__only_contains_attribute_certs_tuple, 0, const_str_plain__only_contains_attribute_certs); Py_INCREF(const_str_plain__only_contains_attribute_certs);
    const_str_digest_908210834a8fb4c8eaca7a64e23a4bed = UNSTREAM_STRING(&constant_bin[ 624124 ], 64, 0);
    const_tuple_str_plain__only_contains_ca_certs_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_plain__only_contains_ca_certs_tuple, 0, const_str_plain__only_contains_ca_certs); Py_INCREF(const_str_plain__only_contains_ca_certs);
    const_str_digest_ccd052a57d9b2466ec6174083baebf1e = UNSTREAM_STRING(&constant_bin[ 624188 ], 73, 0);
    const_tuple_str_plain_cls_str_plain_public_key_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_cls_str_plain_public_key_tuple, 0, const_str_plain_cls); Py_INCREF(const_str_plain_cls);
    PyTuple_SET_ITEM(const_tuple_str_plain_cls_str_plain_public_key_tuple, 1, const_str_plain_public_key); Py_INCREF(const_str_plain_public_key);
    const_tuple_str_plain__relative_name_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_plain__relative_name_tuple, 0, const_str_plain__relative_name); Py_INCREF(const_str_plain__relative_name);
    const_tuple_b58c59c90f8b7ff71dbfd006f561c9fe_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_b58c59c90f8b7ff71dbfd006f561c9fe_tuple, 0, const_str_plain_GeneralName); Py_INCREF(const_str_plain_GeneralName);
    PyTuple_SET_ITEM(const_tuple_b58c59c90f8b7ff71dbfd006f561c9fe_tuple, 1, const_str_plain_IPAddress); Py_INCREF(const_str_plain_IPAddress);
    PyTuple_SET_ITEM(const_tuple_b58c59c90f8b7ff71dbfd006f561c9fe_tuple, 2, const_str_plain_OtherName); Py_INCREF(const_str_plain_OtherName);
    const_tuple_str_plain_self_str_plain_reason_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_reason_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_reason_tuple, 1, const_str_plain_reason); Py_INCREF(const_str_plain_reason);
    const_str_digest_f63518e696f94cef547d30428c9b8408 = UNSTREAM_STRING(&constant_bin[ 624261 ], 31, 0);
    const_tuple_str_plain__policy_qualifiers_tuple = PyTuple_New(1);
    const_str_plain__policy_qualifiers = UNSTREAM_STRING(&constant_bin[ 624292 ], 18, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain__policy_qualifiers_tuple, 0, const_str_plain__policy_qualifiers); Py_INCREF(const_str_plain__policy_qualifiers);
    const_tuple_35bfa5acc69c9c72494218df80b094f1_tuple = PyTuple_New(5);
    PyTuple_SET_ITEM(const_tuple_35bfa5acc69c9c72494218df80b094f1_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_35bfa5acc69c9c72494218df80b094f1_tuple, 1, const_str_plain_full_name); Py_INCREF(const_str_plain_full_name);
    PyTuple_SET_ITEM(const_tuple_35bfa5acc69c9c72494218df80b094f1_tuple, 2, const_str_plain_relative_name); Py_INCREF(const_str_plain_relative_name);
    PyTuple_SET_ITEM(const_tuple_35bfa5acc69c9c72494218df80b094f1_tuple, 3, const_str_plain_reasons); Py_INCREF(const_str_plain_reasons);
    PyTuple_SET_ITEM(const_tuple_35bfa5acc69c9c72494218df80b094f1_tuple, 4, const_str_plain_crl_issuer); Py_INCREF(const_str_plain_crl_issuer);
    const_str_plain__require_explicit_policy = UNSTREAM_STRING(&constant_bin[ 624310 ], 24, 1);
    const_str_digest_d04c4a4e63138db9ecc900ec9847717c = UNSTREAM_STRING(&constant_bin[ 624334 ], 42, 0);
    const_tuple_str_plain_self_str_plain_crl_number_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_crl_number_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_crl_number_tuple, 1, const_str_plain_crl_number); Py_INCREF(const_str_plain_crl_number);
    const_str_digest_da5560b5b28f3c84a1c556751340bb55 = UNSTREAM_STRING(&constant_bin[ 624376 ], 88, 0);
    const_str_digest_2fedee8d2e8553cc3a2acd1bc300acd1 = UNSTREAM_STRING(&constant_bin[ 624464 ], 36, 0);
    const_str_digest_f7d33cb69a7dc22294881ff5b1fe0ec9 = UNSTREAM_STRING(&constant_bin[ 624500 ], 124, 0);
    const_tuple_str_plain_PublicKeyInfo_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_plain_PublicKeyInfo_tuple, 0, const_str_plain_PublicKeyInfo); Py_INCREF(const_str_plain_PublicKeyInfo);
    const_tuple_str_plain__permitted_subtrees_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_plain__permitted_subtrees_tuple, 0, const_str_plain__permitted_subtrees); Py_INCREF(const_str_plain__permitted_subtrees);
    const_tuple_str_plain__authority_cert_issuer_tuple = PyTuple_New(1);
    const_str_plain__authority_cert_issuer = UNSTREAM_STRING(&constant_bin[ 624624 ], 22, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain__authority_cert_issuer_tuple, 0, const_str_plain__authority_cert_issuer); Py_INCREF(const_str_plain__authority_cert_issuer);
    const_tuple_str_plain__notice_numbers_tuple = PyTuple_New(1);
    const_str_plain__notice_numbers = UNSTREAM_STRING(&constant_bin[ 624646 ], 15, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain__notice_numbers_tuple, 0, const_str_plain__notice_numbers); Py_INCREF(const_str_plain__notice_numbers);
    const_tuple_str_plain_self_str_plain_features_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_features_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    const_str_plain_features = UNSTREAM_STRING(&constant_bin[ 624124 ], 8, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_features_tuple, 1, const_str_plain_features); Py_INCREF(const_str_plain_features);
    const_str_digest_11b049dd960f5e8f8d4550cdd9caf427 = UNSTREAM_STRING(&constant_bin[ 624661 ], 79, 0);
    const_str_digest_4896564d0ed5e6b06237436d00bf3cad = UNSTREAM_STRING(&constant_bin[ 624740 ], 327, 0);
    const_tuple_str_plain__key_cert_sign_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_plain__key_cert_sign_tuple, 0, const_str_plain__key_cert_sign); Py_INCREF(const_str_plain__key_cert_sign);
    const_tuple_str_plain_self_str_plain_general_names_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_general_names_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_general_names_tuple, 1, const_str_plain_general_names); Py_INCREF(const_str_plain_general_names);
    const_str_plain_status_request_v2 = UNSTREAM_STRING(&constant_bin[ 625067 ], 17, 1);
    const_str_digest_f68da15c98dbc7b7660e8e5bee0179e6 = UNSTREAM_STRING(&constant_bin[ 625084 ], 36, 0);
    const_str_digest_ad140184cf2507dc997c5c6a9d0f3e94 = UNSTREAM_STRING(&constant_bin[ 625120 ], 45, 0);
    const_str_digest_a2ae3825a8b7f0237bc2c108542b8be9 = UNSTREAM_STRING(&constant_bin[ 625165 ], 57, 0);
    const_str_plain_signed_certificate_timestamps = UNSTREAM_STRING(&constant_bin[ 24963 ], 29, 1);
    const_str_digest_114372ae17a491041cc1a4b677269f5b = UNSTREAM_STRING(&constant_bin[ 625222 ], 85, 0);
    const_str_plain__general_names = UNSTREAM_STRING(&constant_bin[ 23674 ], 14, 1);
    const_str_plain_usages = UNSTREAM_STRING(&constant_bin[ 625183 ], 6, 1);
    const_str_plain_crl_constraints = UNSTREAM_STRING(&constant_bin[ 625307 ], 15, 1);
    const_tuple_str_plain_self_str_plain_policies_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_policies_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_policies_tuple, 1, const_str_plain_policies); Py_INCREF(const_str_plain_policies);
    const_tuple_str_plain_self_str_plain_tree_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_tree_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_tree_tuple, 1, const_str_plain_tree); Py_INCREF(const_str_plain_tree);
    const_tuple_str_plain__key_agreement_tuple = PyTuple_New(1);
    const_str_plain__key_agreement = UNSTREAM_STRING(&constant_bin[ 625322 ], 14, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain__key_agreement_tuple, 0, const_str_plain__key_agreement); Py_INCREF(const_str_plain__key_agreement);
    const_str_digest_2622a0002f5b5df69415ebf4bce9a343 = UNSTREAM_STRING(&constant_bin[ 625336 ], 94, 0);
    const_tuple_str_plain_self_str_plain_skip_certs_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_skip_certs_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_skip_certs_tuple, 1, const_str_plain_skip_certs); Py_INCREF(const_str_plain_skip_certs);
    const_str_digest_9cc2c8377ce78bc1b198ac0906717d7f = UNSTREAM_STRING(&constant_bin[ 625430 ], 101, 0);
    const_tuple_str_plain_SignedCertificateTimestamp_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_plain_SignedCertificateTimestamp_tuple, 0, const_str_plain_SignedCertificateTimestamp); Py_INCREF(const_str_plain_SignedCertificateTimestamp);
    const_str_plain__encipher_only = UNSTREAM_STRING(&constant_bin[ 625531 ], 14, 1);
    const_str_digest_881d5fa81af108f32d6b1d8d2d35a638 = UNSTREAM_STRING(&constant_bin[ 625545 ], 64, 0);
    const_tuple_str_plain__explicit_text_tuple = PyTuple_New(1);
    const_str_plain__explicit_text = UNSTREAM_STRING(&constant_bin[ 625609 ], 14, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain__explicit_text_tuple, 0, const_str_plain__explicit_text); Py_INCREF(const_str_plain__explicit_text);
    const_str_digest_c3da50fdd18d409ebf6fe1322cd35c5d = UNSTREAM_STRING(&constant_bin[ 625623 ], 301, 0);
    const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_sct_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_sct_tuple, 0, const_str_digest_b9c4baf879ebd882d40843df3a4dead7); Py_INCREF(const_str_digest_b9c4baf879ebd882d40843df3a4dead7);
    PyTuple_SET_ITEM(const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_sct_tuple, 1, const_str_plain_sct); Py_INCREF(const_str_plain_sct);
    const_tuple_str_plain__skip_certs_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_plain__skip_certs_tuple, 0, const_str_plain__skip_certs); Py_INCREF(const_str_plain__skip_certs);
    const_str_digest_520475ee9f753bee090d1ecadd4c727e = UNSTREAM_STRING(&constant_bin[ 625924 ], 31, 0);
    const_tuple_str_plain__digital_signature_tuple = PyTuple_New(1);
    const_str_plain__digital_signature = UNSTREAM_STRING(&constant_bin[ 625955 ], 18, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain__digital_signature_tuple, 0, const_str_plain__digital_signature); Py_INCREF(const_str_plain__digital_signature);
    const_str_digest_d2a030963ea7fa46a452128daffceb24 = UNSTREAM_STRING(&constant_bin[ 625973 ], 41, 0);
    const_tuple_str_plain__ca_tuple = PyTuple_New(1);
    const_str_plain__ca = UNSTREAM_STRING(&constant_bin[ 26156 ], 3, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain__ca_tuple, 0, const_str_plain__ca); Py_INCREF(const_str_plain__ca);
    const_str_digest_2a0138f3ee2cd707fb386e46f1612821 = UNSTREAM_STRING(&constant_bin[ 626014 ], 23, 0);
    const_tuple_str_plain__excluded_subtrees_tuple = PyTuple_New(1);
    const_str_plain__excluded_subtrees = UNSTREAM_STRING(&constant_bin[ 626037 ], 18, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain__excluded_subtrees_tuple, 0, const_str_plain__excluded_subtrees); Py_INCREF(const_str_plain__excluded_subtrees);
    const_str_digest_c6c3dada1f7f971d20a3492ccb208681 = UNSTREAM_STRING(&constant_bin[ 626055 ], 84, 0);
    const_str_plain__reasons = UNSTREAM_STRING(&constant_bin[ 23883 ], 8, 1);
    const_str_digest_b436a97f38724e3583df19a1d449e278 = UNSTREAM_STRING(&constant_bin[ 626139 ], 41, 0);
    const_str_digest_fdf88dfad66dd7b1bb721469f9f06736 = UNSTREAM_STRING(&constant_bin[ 626180 ], 55, 0);
    const_tuple_str_plain__require_explicit_policy_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_plain__require_explicit_policy_tuple, 0, const_str_plain__require_explicit_policy); Py_INCREF(const_str_plain__require_explicit_policy);
    const_tuple_str_plain__inhibit_policy_mapping_tuple = PyTuple_New(1);
    const_str_plain__inhibit_policy_mapping = UNSTREAM_STRING(&constant_bin[ 626235 ], 23, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain__inhibit_policy_mapping_tuple, 0, const_str_plain__inhibit_policy_mapping); Py_INCREF(const_str_plain__inhibit_policy_mapping);
    const_str_plain__validate_ip_name = UNSTREAM_STRING(&constant_bin[ 626258 ], 17, 1);
    const_tuple_str_plain_self_str_plain_pq_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_pq_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    const_str_plain_pq = UNSTREAM_STRING(&constant_bin[ 51579 ], 2, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_pq_tuple, 1, const_str_plain_pq); Py_INCREF(const_str_plain_pq);
    const_tuple_str_plain_self_str_plain_usages_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_usages_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_usages_tuple, 1, const_str_plain_usages); Py_INCREF(const_str_plain_usages);
    const_tuple_str_plain_self_str_plain_type_str_plain_objs_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_type_str_plain_objs_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_type_str_plain_objs_tuple, 1, const_str_plain_type); Py_INCREF(const_str_plain_type);
    const_str_plain_objs = UNSTREAM_STRING(&constant_bin[ 587093 ], 4, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_type_str_plain_objs_tuple, 2, const_str_plain_objs); Py_INCREF(const_str_plain_objs);
    const_str_plain_status_request = UNSTREAM_STRING(&constant_bin[ 625067 ], 14, 1);
    const_str_plain__key_identifier_from_public_key = UNSTREAM_STRING(&constant_bin[ 36245 ], 31, 1);
    const_str_digest_15f4645c15394598b5ad3d887ad62f4a = UNSTREAM_STRING(&constant_bin[ 626275 ], 64, 0);
    const_str_plain__only_some_reasons = UNSTREAM_STRING(&constant_bin[ 626339 ], 18, 1);
    const_str_digest_26a75172f55108334b01cdc8efcbab38 = UNSTREAM_STRING(&constant_bin[ 626357 ], 32, 0);
    const_str_digest_cb90e2fbaafbf44b381aafdbc54043e2 = UNSTREAM_STRING(&constant_bin[ 626389 ], 77, 0);
    const_tuple_0249ced4da5e72f251db066d967b15dd_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_0249ced4da5e72f251db066d967b15dd_tuple, 0, const_str_digest_b9c4baf879ebd882d40843df3a4dead7); Py_INCREF(const_str_digest_b9c4baf879ebd882d40843df3a4dead7);
    PyTuple_SET_ITEM(const_tuple_0249ced4da5e72f251db066d967b15dd_tuple, 1, const_str_plain_i); Py_INCREF(const_str_plain_i);
    PyTuple_SET_ITEM(const_tuple_0249ced4da5e72f251db066d967b15dd_tuple, 2, const_str_plain_type); Py_INCREF(const_str_plain_type);
    const_str_plain__distribution_points = UNSTREAM_STRING(&constant_bin[ 24633 ], 20, 1);
    const_tuple_str_plain__critical_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_plain__critical_tuple, 0, const_str_plain__critical); Py_INCREF(const_str_plain__critical);
    const_tuple_str_plain__reasons_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_plain__reasons_tuple, 0, const_str_plain__reasons); Py_INCREF(const_str_plain__reasons);
    const_tuple_str_plain_constant_time_str_plain_serialization_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_constant_time_str_plain_serialization_tuple, 0, const_str_plain_constant_time); Py_INCREF(const_str_plain_constant_time);
    PyTuple_SET_ITEM(const_tuple_str_plain_constant_time_str_plain_serialization_tuple, 1, const_str_plain_serialization); Py_INCREF(const_str_plain_serialization);
    const_str_plain__features = UNSTREAM_STRING(&constant_bin[ 625108 ], 9, 1);
    const_str_plain__full_name = UNSTREAM_STRING(&constant_bin[ 27362 ], 10, 1);
    const_tuple_str_plain_EllipticCurvePublicKey_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_plain_EllipticCurvePublicKey_tuple, 0, const_str_plain_EllipticCurvePublicKey); Py_INCREF(const_str_plain_EllipticCurvePublicKey);
    const_tuple_str_plain__data_encipherment_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_plain__data_encipherment_tuple, 0, const_str_plain__data_encipherment); Py_INCREF(const_str_plain__data_encipherment);
    const_tuple_96332c2a391d63d358e15081c1debfb6_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_96332c2a391d63d358e15081c1debfb6_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_96332c2a391d63d358e15081c1debfb6_tuple, 1, const_str_plain_oid); Py_INCREF(const_str_plain_oid);
    PyTuple_SET_ITEM(const_tuple_96332c2a391d63d358e15081c1debfb6_tuple, 2, const_str_plain_critical); Py_INCREF(const_str_plain_critical);
    PyTuple_SET_ITEM(const_tuple_96332c2a391d63d358e15081c1debfb6_tuple, 3, const_str_plain_value); Py_INCREF(const_str_plain_value);
    const_str_plain_frozenset = UNSTREAM_STRING(&constant_bin[ 622248 ], 9, 1);
    const_str_plain__authority_cert_serial_number = UNSTREAM_STRING(&constant_bin[ 626466 ], 29, 1);
    const_tuple_9e442608387cffc806b1f25d569bdb89_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_9e442608387cffc806b1f25d569bdb89_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_9e442608387cffc806b1f25d569bdb89_tuple, 1, const_str_plain_access_method); Py_INCREF(const_str_plain_access_method);
    PyTuple_SET_ITEM(const_tuple_9e442608387cffc806b1f25d569bdb89_tuple, 2, const_str_plain_access_location); Py_INCREF(const_str_plain_access_location);
    const_tuple_str_plain_self_str_plain_type_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_type_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_type_tuple, 1, const_str_plain_type); Py_INCREF(const_str_plain_type);
    const_str_plain_get_extension_for_oid = UNSTREAM_STRING(&constant_bin[ 626495 ], 21, 1);
    const_str_plain__invalidity_date = UNSTREAM_STRING(&constant_bin[ 25103 ], 16, 1);
    const_tuple_str_plain_RSAPublicKey_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_plain_RSAPublicKey_tuple, 0, const_str_plain_RSAPublicKey); Py_INCREF(const_str_plain_RSAPublicKey);
    const_str_digest_1dfb7a6265a6e9db387c1d41869616b8 = UNSTREAM_STRING(&constant_bin[ 626516 ], 37, 0);
    const_str_digest_c47beb1c7d1e047c9170d20aad4fb97b = UNSTREAM_STRING(&constant_bin[ 626553 ], 117, 0);
    const_str_digest_2a63548c17bc773344f27e5819855b7b = UNSTREAM_STRING(&constant_bin[ 626670 ], 45, 0);
    const_tuple_str_plain__only_some_reasons_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_plain__only_some_reasons_tuple, 0, const_str_plain__only_some_reasons); Py_INCREF(const_str_plain__only_some_reasons);
    const_str_plain__crl_sign = UNSTREAM_STRING(&constant_bin[ 626715 ], 9, 1);
    const_tuple_str_plain__digest_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_plain__digest_tuple, 0, const_str_plain__digest); Py_INCREF(const_str_plain__digest);
    const_str_plain__descriptions = UNSTREAM_STRING(&constant_bin[ 583498 ], 13, 1);
    const_str_digest_2615a61b30c6d1612864004a5b3409b1 = UNSTREAM_STRING(&constant_bin[ 622224 ], 48, 0);
    const_str_digest_7d42ffe02af672349902ee30e189a05b = UNSTREAM_STRING(&constant_bin[ 626724 ], 71, 0);
    const_str_digest_35185795abbb3b5bbc0cab5aa03aab83 = UNSTREAM_STRING(&constant_bin[ 626795 ], 75, 0);
    const_tuple_79831141b0c54263bd4ba55a91ef27c4_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_79831141b0c54263bd4ba55a91ef27c4_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_79831141b0c54263bd4ba55a91ef27c4_tuple, 1, const_str_plain_policy_identifier); Py_INCREF(const_str_plain_policy_identifier);
    PyTuple_SET_ITEM(const_tuple_79831141b0c54263bd4ba55a91ef27c4_tuple, 2, const_str_plain_policy_qualifiers); Py_INCREF(const_str_plain_policy_qualifiers);
    const_str_plain__only_contains_user_certs = UNSTREAM_STRING(&constant_bin[ 626870 ], 25, 1);
    const_str_plain__access_method = UNSTREAM_STRING(&constant_bin[ 626895 ], 14, 1);
    const_str_digest_198893d8157c272d69767f46f86316c2 = UNSTREAM_STRING(&constant_bin[ 626909 ], 80, 0);
    const_tuple_str_plain__access_location_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_plain__access_location_tuple, 0, const_str_plain__access_location); Py_INCREF(const_str_plain__access_location);
    const_str_digest_de6ca45cc2c0d21b3ea9542eeb752d64 = UNSTREAM_STRING(&constant_bin[ 626989 ], 28, 0);
    const_tuple_str_plain__access_method_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_plain__access_method_tuple, 0, const_str_plain__access_method); Py_INCREF(const_str_plain__access_method);
    const_tuple_6d08159ea13672603ee689286b27f535_tuple = PyTuple_New(10);
    PyTuple_SET_ITEM(const_tuple_6d08159ea13672603ee689286b27f535_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_6d08159ea13672603ee689286b27f535_tuple, 1, const_str_plain_digital_signature); Py_INCREF(const_str_plain_digital_signature);
    PyTuple_SET_ITEM(const_tuple_6d08159ea13672603ee689286b27f535_tuple, 2, const_str_plain_content_commitment); Py_INCREF(const_str_plain_content_commitment);
    PyTuple_SET_ITEM(const_tuple_6d08159ea13672603ee689286b27f535_tuple, 3, const_str_plain_key_encipherment); Py_INCREF(const_str_plain_key_encipherment);
    PyTuple_SET_ITEM(const_tuple_6d08159ea13672603ee689286b27f535_tuple, 4, const_str_plain_data_encipherment); Py_INCREF(const_str_plain_data_encipherment);
    PyTuple_SET_ITEM(const_tuple_6d08159ea13672603ee689286b27f535_tuple, 5, const_str_plain_key_agreement); Py_INCREF(const_str_plain_key_agreement);
    PyTuple_SET_ITEM(const_tuple_6d08159ea13672603ee689286b27f535_tuple, 6, const_str_plain_key_cert_sign); Py_INCREF(const_str_plain_key_cert_sign);
    PyTuple_SET_ITEM(const_tuple_6d08159ea13672603ee689286b27f535_tuple, 7, const_str_plain_crl_sign); Py_INCREF(const_str_plain_crl_sign);
    PyTuple_SET_ITEM(const_tuple_6d08159ea13672603ee689286b27f535_tuple, 8, const_str_plain_encipher_only); Py_INCREF(const_str_plain_encipher_only);
    PyTuple_SET_ITEM(const_tuple_6d08159ea13672603ee689286b27f535_tuple, 9, const_str_plain_decipher_only); Py_INCREF(const_str_plain_decipher_only);
    const_tuple_c9093e158a1a3426ce5fb16319f2926f_tuple = PyTuple_New(10);
    PyTuple_SET_ITEM(const_tuple_c9093e158a1a3426ce5fb16319f2926f_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_c9093e158a1a3426ce5fb16319f2926f_tuple, 1, const_str_plain_full_name); Py_INCREF(const_str_plain_full_name);
    PyTuple_SET_ITEM(const_tuple_c9093e158a1a3426ce5fb16319f2926f_tuple, 2, const_str_plain_relative_name); Py_INCREF(const_str_plain_relative_name);
    PyTuple_SET_ITEM(const_tuple_c9093e158a1a3426ce5fb16319f2926f_tuple, 3, const_str_plain_only_contains_user_certs); Py_INCREF(const_str_plain_only_contains_user_certs);
    PyTuple_SET_ITEM(const_tuple_c9093e158a1a3426ce5fb16319f2926f_tuple, 4, const_str_plain_only_contains_ca_certs); Py_INCREF(const_str_plain_only_contains_ca_certs);
    PyTuple_SET_ITEM(const_tuple_c9093e158a1a3426ce5fb16319f2926f_tuple, 5, const_str_plain_only_some_reasons); Py_INCREF(const_str_plain_only_some_reasons);
    PyTuple_SET_ITEM(const_tuple_c9093e158a1a3426ce5fb16319f2926f_tuple, 6, const_str_plain_indirect_crl); Py_INCREF(const_str_plain_indirect_crl);
    PyTuple_SET_ITEM(const_tuple_c9093e158a1a3426ce5fb16319f2926f_tuple, 7, const_str_plain_only_contains_attribute_certs); Py_INCREF(const_str_plain_only_contains_attribute_certs);
    PyTuple_SET_ITEM(const_tuple_c9093e158a1a3426ce5fb16319f2926f_tuple, 8, const_str_plain_crl_constraints); Py_INCREF(const_str_plain_crl_constraints);
    PyTuple_SET_ITEM(const_tuple_c9093e158a1a3426ce5fb16319f2926f_tuple, 9, const_str_plain_x); Py_INCREF(const_str_plain_x);
    const_tuple_str_plain__crl_sign_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_plain__crl_sign_tuple, 0, const_str_plain__crl_sign); Py_INCREF(const_str_plain__crl_sign);
    const_str_plain_privilegeWithdrawn = UNSTREAM_STRING(&constant_bin[ 627017 ], 18, 1);
    const_tuple_str_plain__full_name_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_plain__full_name_tuple, 0, const_str_plain__full_name); Py_INCREF(const_str_plain__full_name);
    const_str_plain_extclass = UNSTREAM_STRING(&constant_bin[ 627035 ], 8, 1);
    const_tuple_str_plain__invalidity_date_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_plain__invalidity_date_tuple, 0, const_str_plain__invalidity_date); Py_INCREF(const_str_plain__invalidity_date);
    const_str_digest_afa42db89846e96e9cfc2ab56578058d = UNSTREAM_STRING(&constant_bin[ 627043 ], 27, 0);
    const_str_digest_1ea9692159fa7fd9f8e15a3506f4463c = UNSTREAM_STRING(&constant_bin[ 627070 ], 139, 0);
    const_str_digest_421b43a5ec9f9f0f5f30b5a50ec3db96 = UNSTREAM_STRING(&constant_bin[ 627209 ], 26, 0);
    const_tuple_str_plain_self_str_plain_msg_str_plain_oid_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_msg_str_plain_oid_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_msg_str_plain_oid_tuple, 1, const_str_plain_msg); Py_INCREF(const_str_plain_msg);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_msg_str_plain_oid_tuple, 2, const_str_plain_oid); Py_INCREF(const_str_plain_oid);
    const_tuple_str_plain__content_commitment_tuple = PyTuple_New(1);
    const_str_plain__content_commitment = UNSTREAM_STRING(&constant_bin[ 627235 ], 19, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain__content_commitment_tuple, 0, const_str_plain__content_commitment); Py_INCREF(const_str_plain__content_commitment);
    const_str_digest_87fc424e9112e6987e5fe8e83a94ae22 = UNSTREAM_STRING(&constant_bin[ 627254 ], 41, 0);
    const_tuple_str_plain_self_str_plain_signed_certificate_timestamps_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_signed_certificate_timestamps_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_signed_certificate_timestamps_tuple, 1, const_str_plain_signed_certificate_timestamps); Py_INCREF(const_str_plain_signed_certificate_timestamps);
    const_str_digest_e41e00d6ec327bc9d8187afd927a45a2 = UNSTREAM_STRING(&constant_bin[ 627295 ], 59, 0);
    const_str_digest_449ea3887ada75d14dab0f566d0a778c = UNSTREAM_STRING(&constant_bin[ 627354 ], 47, 0);
    const_str_digest_293839491199d08c5eee9ab993bbfcfe = UNSTREAM_STRING(&constant_bin[ 627401 ], 55, 0);
    const_str_digest_009ff6af115398b3dfb26f0926fdbea2 = UNSTREAM_STRING(&constant_bin[ 627456 ], 46, 0);
    const_unicode_digest_71b136bb2c4e9e2ce7c90a48ee86f246 = UNSTREAM_UNICODE(&constant_bin[ 627502 ], 123);
    const_tuple_2a50e9eb562974724a6432490d012463_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_2a50e9eb562974724a6432490d012463_tuple, 0, const_str_plain_CRLEntryExtensionOID); Py_INCREF(const_str_plain_CRLEntryExtensionOID);
    PyTuple_SET_ITEM(const_tuple_2a50e9eb562974724a6432490d012463_tuple, 1, const_str_plain_ExtensionOID); Py_INCREF(const_str_plain_ExtensionOID);
    PyTuple_SET_ITEM(const_tuple_2a50e9eb562974724a6432490d012463_tuple, 2, const_str_plain_OCSPExtensionOID); Py_INCREF(const_str_plain_OCSPExtensionOID);
    PyTuple_SET_ITEM(const_tuple_2a50e9eb562974724a6432490d012463_tuple, 3, const_str_plain_ObjectIdentifier); Py_INCREF(const_str_plain_ObjectIdentifier);
    const_tuple_str_plain__path_length_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_plain__path_length_tuple, 0, const_str_plain__path_length); Py_INCREF(const_str_plain__path_length);
    const_str_digest_837e2310df6009dd1b110accad73bb42 = UNSTREAM_STRING(&constant_bin[ 627625 ], 50, 0);
    const_str_digest_ac8667798ba70bb109d3e3236473ab02 = UNSTREAM_STRING(&constant_bin[ 627675 ], 62, 0);
    const_str_plain_from_issuer_public_key = UNSTREAM_STRING(&constant_bin[ 627737 ], 22, 1);
    const_str_digest_37a5813a8df88d549fa10cdd6f24a9b9 = UNSTREAM_STRING(&constant_bin[ 627759 ], 63, 0);
    const_tuple_str_plain_self_str_plain_extclass_str_plain_ext_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_extclass_str_plain_ext_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_extclass_str_plain_ext_tuple, 1, const_str_plain_extclass); Py_INCREF(const_str_plain_extclass);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_extclass_str_plain_ext_tuple, 2, const_str_plain_ext); Py_INCREF(const_str_plain_ext);
    const_str_digest_52903da339eb426b3d703a3f30ce3e10 = UNSTREAM_STRING(&constant_bin[ 627822 ], 64, 0);
    const_tuple_str_plain__authority_cert_serial_number_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_plain__authority_cert_serial_number_tuple, 0, const_str_plain__authority_cert_serial_number); Py_INCREF(const_str_plain__authority_cert_serial_number);
    const_str_digest_1961eae2d00689b393091e3fc681acbe = UNSTREAM_STRING(&constant_bin[ 627886 ], 32, 0);
    const_str_digest_3611def0515b06c31df0f70307f767f3 = UNSTREAM_STRING(&constant_bin[ 627918 ], 83, 0);
    const_str_plain__usages = UNSTREAM_STRING(&constant_bin[ 628001 ], 7, 1);
    const_tuple_str_plain__indirect_crl_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_plain__indirect_crl_tuple, 0, const_str_plain__indirect_crl); Py_INCREF(const_str_plain__indirect_crl);
    const_tuple_str_plain_self_str_plain_extensions_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_extensions_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_extensions_tuple, 1, const_str_plain_extensions); Py_INCREF(const_str_plain_extensions);
    const_str_plain__signed_certificate_timestamps = UNSTREAM_STRING(&constant_bin[ 24962 ], 30, 1);
    const_tuple_str_plain_self_str_plain_oid_str_plain_ext_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_oid_str_plain_ext_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_oid_str_plain_ext_tuple, 1, const_str_plain_oid); Py_INCREF(const_str_plain_oid);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_oid_str_plain_ext_tuple, 2, const_str_plain_ext); Py_INCREF(const_str_plain_ext);
    const_tuple_str_plain__only_contains_user_certs_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_plain__only_contains_user_certs_tuple, 0, const_str_plain__only_contains_user_certs); Py_INCREF(const_str_plain__only_contains_user_certs);
    const_str_digest_42aaad2aaa6a1ee7d79f305ebfd1a58b = UNSTREAM_STRING(&constant_bin[ 628008 ], 173, 0);
    const_str_plain_from_issuer_subject_key_identifier = UNSTREAM_STRING(&constant_bin[ 628181 ], 34, 1);
    const_str_digest_56973e3a5f1a8b7f8ba81c36b603bcaa = UNSTREAM_STRING(&constant_bin[ 628215 ], 37, 0);
    const_tuple_str_plain__policy_identifier_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_plain__policy_identifier_tuple, 0, const_str_plain__policy_identifier); Py_INCREF(const_str_plain__policy_identifier);
    const_str_digest_e7bc751982d7cd4fe2e9c78dbf3e6347 = UNSTREAM_STRING(&constant_bin[ 628252 ], 125, 0);
    const_tuple_9d6859e57abe5ce2ca107f61cc5077a0_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_9d6859e57abe5ce2ca107f61cc5077a0_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_9d6859e57abe5ce2ca107f61cc5077a0_tuple, 1, const_str_plain_require_explicit_policy); Py_INCREF(const_str_plain_require_explicit_policy);
    PyTuple_SET_ITEM(const_tuple_9d6859e57abe5ce2ca107f61cc5077a0_tuple, 2, const_str_plain_inhibit_policy_mapping); Py_INCREF(const_str_plain_inhibit_policy_mapping);

    constants_created = true;
}

/* Function to verify module private constants for non-corruption. */
#ifndef __NUITKA_NO_ASSERT__
void checkModuleConstants_cryptography$x509$extensions(void) {
    // The module may not have been used at all, then ignore this.
    if (constants_created == false) return;


}
#endif

// The module code objects.
static PyCodeObject *codeobj_bd5a4ccd3526e581f6cff771453dcd80;
static PyCodeObject *codeobj_d5ecd660941aa92ad81b0960ed9952bd;
static PyCodeObject *codeobj_7b975eeb631ffb9fcaa0a37fa763716e;
static PyCodeObject *codeobj_6cc5423ab0acdb175d93b9726ccbd1a5;
static PyCodeObject *codeobj_08237a46621deda32827a6d1002f2896;
static PyCodeObject *codeobj_f6b8321b3a4026647bece9fcbe9c1464;
static PyCodeObject *codeobj_7d4fd4c587e255df3371241a48928f28;
static PyCodeObject *codeobj_6c990ee64c9c9599e422c207d851cbc9;
static PyCodeObject *codeobj_4121fcf894750f20ccf71bdfe3d19df2;
static PyCodeObject *codeobj_31212033882b18f22cff534424b54050;
static PyCodeObject *codeobj_976e58673ea1efbd2ac3a273b25c792e;
static PyCodeObject *codeobj_1e9868694a8772e0bc7d1c6993d99d35;
static PyCodeObject *codeobj_4a882b53e0e829bff518a8c7aacc9ae2;
static PyCodeObject *codeobj_85e574a0ea828b1296944aef7e1a45bc;
static PyCodeObject *codeobj_d4589269dd21e1af6cba113639e39aef;
static PyCodeObject *codeobj_9ed3c9ca3659a47dcc7d6a0adafc3ab6;
static PyCodeObject *codeobj_e842a3817de07d4676702c4ec5cd46ff;
static PyCodeObject *codeobj_be6d215d5ccf72c4dd20589bf484df13;
static PyCodeObject *codeobj_624e1fc6d94a612cab9b15afbf337091;
static PyCodeObject *codeobj_649d76a7830e746a0a26b7e9c621710f;
static PyCodeObject *codeobj_2e7cf4e83e69f15d24fde995cefd2a7c;
static PyCodeObject *codeobj_43c1c6d969ff6899544b1cfb272ea433;
static PyCodeObject *codeobj_888390ddbc4bf33f48bfeea2ec680910;
static PyCodeObject *codeobj_fdfe391b38b7f158ab41b6490db64d26;
static PyCodeObject *codeobj_8af375243c51a3b11b69e7c775faf530;
static PyCodeObject *codeobj_10cbbfd8fde45d6af5689d9068ecbd4d;
static PyCodeObject *codeobj_8cf535c0875cf42bdef61b5101de9850;
static PyCodeObject *codeobj_9c95e9ba0408147c3cfcb22e4b1c91c9;
static PyCodeObject *codeobj_f1fb71489cc684b7ee4d1e2902a82ad3;
static PyCodeObject *codeobj_d613475f4bc9b1ec8ed0abba919aa767;
static PyCodeObject *codeobj_6a2ac24867d838ebbfada582b800ac84;
static PyCodeObject *codeobj_c40257bc666664b368a90a2bb591b69e;
static PyCodeObject *codeobj_d9bb56bd96dd7fc707029f25f9b9879f;
static PyCodeObject *codeobj_d76b975938eb3793df08887e6a883dcc;
static PyCodeObject *codeobj_e04ffe5b900a4019b6788821593ab364;
static PyCodeObject *codeobj_8e8c1d14cc1f43c40fb686c3c332d970;
static PyCodeObject *codeobj_8be8c331db6797002bac5a779f59022d;
static PyCodeObject *codeobj_9cf8ad554dd9d3c4ef6ee538381ad390;
static PyCodeObject *codeobj_c1c2bb0918ddbcf5f075491c88a41e6d;
static PyCodeObject *codeobj_046f51f4b030997d90f3cee22939d406;
static PyCodeObject *codeobj_49473bcf3743b34fde0906127568439e;
static PyCodeObject *codeobj_083e1fa26f5ab300d67d5d5e3552df7c;
static PyCodeObject *codeobj_88f6f5c3c797c731ba74a50683fe2b42;
static PyCodeObject *codeobj_131acb86ad21685798bdc6a84a886dee;
static PyCodeObject *codeobj_14b4d327d26227dbeeaf8ac21d0eead5;
static PyCodeObject *codeobj_e1283683c51f59cb9a7eb7fe98cf8efa;
static PyCodeObject *codeobj_4db2c46a45695eb12bac9cef5aa0180e;
static PyCodeObject *codeobj_adabafe8c246c11f4a4c9f6f68213ae2;
static PyCodeObject *codeobj_5b0a6348dd417584c7f202513d6c4148;
static PyCodeObject *codeobj_34d3d5aa27da9c5dfcf667f6ff343fae;
static PyCodeObject *codeobj_52c7e053ce661cd35566c3bb41cd02bd;
static PyCodeObject *codeobj_0bc1f437e02225d59bf32cb2d7a199ed;
static PyCodeObject *codeobj_31b0147aee22ba20318b32af38dd79aa;
static PyCodeObject *codeobj_50a05b6f30ae622183421406fd266003;
static PyCodeObject *codeobj_284f196fc1cfe393c2e892de06b6804f;
static PyCodeObject *codeobj_5be6c71ea22dc937c8590e3714a0e70f;
static PyCodeObject *codeobj_ec606af4719e836adceac6092dca2c44;
static PyCodeObject *codeobj_3bb78211f559ebe4d881b75b546ffc0a;
static PyCodeObject *codeobj_ec6763a25cc283c8349cad2c66a21488;
static PyCodeObject *codeobj_b89be643f7a61f3d81c6671d6ad51b78;
static PyCodeObject *codeobj_bf509f0149490c9f7ccf380ab57d6798;
static PyCodeObject *codeobj_56e3c65f02e773e82d404aa393504dde;
static PyCodeObject *codeobj_401579719c1f990019f327b475e920c9;
static PyCodeObject *codeobj_bca7cfb63f34239fb1479c0362918cf5;
static PyCodeObject *codeobj_fd2f7ac83c7c2c75bf12c49dee786140;
static PyCodeObject *codeobj_37be6aa945e0555a84befbfd36f8ffc2;
static PyCodeObject *codeobj_7c03c4c0f3dcfa4c04cd5abaf3b9020a;
static PyCodeObject *codeobj_d85838fa42326f320c88255032c5fca7;
static PyCodeObject *codeobj_2321762013dc0ff29c834d130737aec5;
static PyCodeObject *codeobj_a4f75b426139664f5a0ed587effcf9e3;
static PyCodeObject *codeobj_49ab98a368a06f5b62e3090207811653;
static PyCodeObject *codeobj_24e7e599f7a9ff62dccfaaca7a767e34;
static PyCodeObject *codeobj_2907138fdb90eed1a368f2b6f66fa0e6;
static PyCodeObject *codeobj_9355c6ab964f8819c44a92cf3a8a7bc7;
static PyCodeObject *codeobj_36f675ca210741eafa6fdae589c7d341;
static PyCodeObject *codeobj_c27b0e8e5456bfa1ce1df12003e5c214;
static PyCodeObject *codeobj_377dfaf8031601d6b3bbe8ecaa46a6da;
static PyCodeObject *codeobj_4faa79e5001d77385bdc0e9fd35de12b;
static PyCodeObject *codeobj_65acb965719b8331ceb73cf60da5a34d;
static PyCodeObject *codeobj_763a08aeeae201c12ea113ce4cfc00d1;
static PyCodeObject *codeobj_a121d78d607dd566078ad638d3fd9345;
static PyCodeObject *codeobj_794acec4cbbb193c4d12f82b7f02da0c;
static PyCodeObject *codeobj_01367d6abaf9a9706fda30395db202db;
static PyCodeObject *codeobj_7028bdbd3fa71c0482994e203d0dd60c;
static PyCodeObject *codeobj_0baf7dc256d01cc71597fc9143b60403;
static PyCodeObject *codeobj_0072f7a0ccd296332a271d4a8e480c77;
static PyCodeObject *codeobj_60d2d44b2848d82367f482e630058a14;
static PyCodeObject *codeobj_a61d36331eed656537469cdb25841c38;
static PyCodeObject *codeobj_e1fa255798e8bef9d045790b180982af;
static PyCodeObject *codeobj_c4a263fab24d4b74487740f36bc3c59f;
static PyCodeObject *codeobj_91ef01aeefd39e14a3a497daec6f2d50;
static PyCodeObject *codeobj_4be51afc529a9d1699ae3aaaaf3cc631;
static PyCodeObject *codeobj_e80eadbccd9a352af4d1530cb82eabd0;
static PyCodeObject *codeobj_bc546761cdcfe97d2210ff9ffeb1d8d7;
static PyCodeObject *codeobj_50faf74e5ca2c4814bf1e56953546672;
static PyCodeObject *codeobj_e2014de1836f1bbfee700d36c26440be;
static PyCodeObject *codeobj_2cd7211ae0497207f8bc2f43f4d4f414;
static PyCodeObject *codeobj_dccf9a51dd0e5d88d3e5ed45b6d434bd;
static PyCodeObject *codeobj_7c6b59f6602706780fb2366013d7677d;
static PyCodeObject *codeobj_d4d5e0153429c0273ebb4e9160719179;
static PyCodeObject *codeobj_9e5fdab2f284d2dbd1ea4bcd02f4243a;
static PyCodeObject *codeobj_94ad4941638ca2d741d049b1fa5e9734;
static PyCodeObject *codeobj_24e6c32aa2722cf4ecaa3b16048d4738;
static PyCodeObject *codeobj_2ee369f8faadbdd2a80c9b8c92f1b573;
static PyCodeObject *codeobj_660db49e2668f19c95e04c246a6a5dd8;
static PyCodeObject *codeobj_0bf109aa3d44d653af2864e48ed4fe06;
static PyCodeObject *codeobj_54048dea6a948c37f34018f06d8c86ff;
static PyCodeObject *codeobj_9a7626d648d17d2d5ed8388969ae0bd5;
static PyCodeObject *codeobj_0c619b809dcf09b4a39bf5bdd60015b5;
static PyCodeObject *codeobj_307c2c80549b8830ab1bdc50cebac581;
static PyCodeObject *codeobj_630983a0bc3c12aec05d1c102c6f9427;
static PyCodeObject *codeobj_1915b0ec2af236e889c5e58dce17d01b;
static PyCodeObject *codeobj_4319d0fde202e8d91251639b1f99c86f;
static PyCodeObject *codeobj_6f49f5cfd885de7a42467f04151c4e4a;
static PyCodeObject *codeobj_7e8a46f19303bcd303c87268495b4873;
static PyCodeObject *codeobj_4e3af5c7e39f4d94e8e08cef824fb047;
static PyCodeObject *codeobj_b9940654b29bb9eed381a2ae1f642803;
static PyCodeObject *codeobj_617ec1273e01aa3bf39c7d8e1a305e70;
static PyCodeObject *codeobj_860103f2dcafc72031eb1f0cb95f4dfe;
static PyCodeObject *codeobj_ff20a1f819ea51d73291e30a17f7b7d5;
static PyCodeObject *codeobj_54cad17ac3bd5403abe61737684eaa45;
static PyCodeObject *codeobj_bbff8841f994d0861901167e26c77f21;
static PyCodeObject *codeobj_f2d176069a53125e7129d5de6997a323;
static PyCodeObject *codeobj_a404729c83b1ce7e50c89c3a34394158;
static PyCodeObject *codeobj_7b2b4c038ecf3dd78ddb14477ee2e367;
static PyCodeObject *codeobj_f20ef46fc2f13e0d2c1ca2898c462ef4;
static PyCodeObject *codeobj_0243f386a7ef791aa70475a164a2b63a;
static PyCodeObject *codeobj_f3eeb900b76619b4244a734caee1b5b1;
static PyCodeObject *codeobj_d82db69e835d9e68e136650ca07bce53;
static PyCodeObject *codeobj_fc83f25a35c64baf86fc9abec28579bf;
static PyCodeObject *codeobj_3e9816c5343a0a17dd4693ad9ed8aef1;
static PyCodeObject *codeobj_8947fe591337cc5a2cf6de779a4c5523;
static PyCodeObject *codeobj_2ac5cbbcb3461b660306ae84e4908ce0;
static PyCodeObject *codeobj_35d20cf5a412ee09604cd65c988906ca;
static PyCodeObject *codeobj_77c11ff9d369e4a1284f82ff18ea0eb6;
static PyCodeObject *codeobj_9dea707d642354d82eb245b14decc508;
static PyCodeObject *codeobj_f39e2c4ef794a49e891ba944e62753a1;
static PyCodeObject *codeobj_ccb81d58c538921fd6eadf0f5f9021bf;
static PyCodeObject *codeobj_15065a31e94060fc1e6f2be62d1bb441;
static PyCodeObject *codeobj_6b50228316171cb46aa5f942471d78c9;
static PyCodeObject *codeobj_168b828ef0bd5b03004b55cf5ee199a8;
static PyCodeObject *codeobj_0c8e1253c96407b45c539de5f50b8b44;
static PyCodeObject *codeobj_9fbea692e0648e29509653c9c860b09a;
static PyCodeObject *codeobj_ff0e042effc3afe7e319d9d9426d8281;
static PyCodeObject *codeobj_6b2b741db5b95eb288315358a396ca78;
static PyCodeObject *codeobj_de12b3c1eb89792f5ed199d2ecb02247;
static PyCodeObject *codeobj_a6ea834c6003bc7491321f01345f19da;
static PyCodeObject *codeobj_a639918ff9b53f9ac4ca97850d09e8b5;
static PyCodeObject *codeobj_060b6428f7e0298a84738a381d9a7335;
static PyCodeObject *codeobj_93c4a51e5d5a057df74d80318f8994b9;
static PyCodeObject *codeobj_bea296a7219ecd602eca25edc4652bad;
static PyCodeObject *codeobj_8b50f1443742e7df185a6bfdd7fc3d1f;
static PyCodeObject *codeobj_84a0291d7ab205891af2466b9e0377ec;
static PyCodeObject *codeobj_fcf5dbe695d0fd2e4622c11a67638dce;
static PyCodeObject *codeobj_15444db29e1e916a45d41f13f5c606ec;
static PyCodeObject *codeobj_2d8993bbcf695d23055ae2f7cb247a4b;
static PyCodeObject *codeobj_08aca7543267a89e2589b8bd1ffcee16;
static PyCodeObject *codeobj_6c658cb11fbcf33d94d501986e68c1ff;
static PyCodeObject *codeobj_8c74ccf08a9d69888a5bac51f8974a06;
static PyCodeObject *codeobj_5c40cf088e4ab97ee21bf262ce67d13d;
static PyCodeObject *codeobj_6ef664bce779bb8c807c67c1e9b5d169;
static PyCodeObject *codeobj_f3ae497e09b3bd3a162b69cd7a04cd91;
static PyCodeObject *codeobj_2a0bf5a2c89e7fa0fdc8aac5f0ceb989;
static PyCodeObject *codeobj_8abc18ccaef36115f2eefe103b30849a;
static PyCodeObject *codeobj_0cc8a86e0089204a5f1ba5499e750c59;
static PyCodeObject *codeobj_b916760a1adc6a39fbf1144eb6bf82c6;
static PyCodeObject *codeobj_cd33e2543397d1324358a2e61f8977a4;
static PyCodeObject *codeobj_c1b3c10743df6cec00e4bd32ad5436e8;
static PyCodeObject *codeobj_52ac52abb76c5766947a23493d41a735;
static PyCodeObject *codeobj_e3238b208fe2e5d2a45d1c96985f203f;
static PyCodeObject *codeobj_ae3e58b5effe48f6d27c07362c73d4d3;
static PyCodeObject *codeobj_1c9410bc25f1960eb621aefb650cc5ae;
static PyCodeObject *codeobj_6f3d7d0fdfecc3ad3243e2e88d74ced2;
static PyCodeObject *codeobj_d19dda71d3d42b410ec1cac06f83952c;
static PyCodeObject *codeobj_df6b91143147712a389f7e389566de10;
static PyCodeObject *codeobj_d617f84754084510e6e33c98f465dfab;
static PyCodeObject *codeobj_149307d85299be0e2bb512b521807433;
static PyCodeObject *codeobj_76098b86abab8a2ab9554e3939fdd518;
static PyCodeObject *codeobj_9dfb2f031074454e5d12da987d075118;
static PyCodeObject *codeobj_b1f676c1cba4b20ff4369028da50b101;
static PyCodeObject *codeobj_516022e569c9c2d4e801766d1e23a7a9;
static PyCodeObject *codeobj_8d9e40c8cfaba60d1272553c00ff35ed;
static PyCodeObject *codeobj_107c6fa6753a52c5be47fed9637674ab;
static PyCodeObject *codeobj_30f20714cec73f8af7aacc594b6386e4;
static PyCodeObject *codeobj_c17219ee1ea6d14faa2513ce9bfe056f;
static PyCodeObject *codeobj_538db483ab62c4241ff17d2733bb07d0;
static PyCodeObject *codeobj_e290bf4f69c1366e896d88d19cc6fb02;
static PyCodeObject *codeobj_9e02fda17edc241d52be17c732abc823;
static PyCodeObject *codeobj_2a76b8a7a0619e7e50369de1896fb82e;
static PyCodeObject *codeobj_bafa1748f4280a8d96a8ef0430df7fda;
static PyCodeObject *codeobj_0717dde802ff3bf828c32149b86f91c5;
static PyCodeObject *codeobj_b2624bbf7f2345dffc42b8356201f32c;
static PyCodeObject *codeobj_6eec4ed29d652d67297334df34b9efea;
static PyCodeObject *codeobj_a1d6f2aea8a4d49139a6df2ca29a43e4;
static PyCodeObject *codeobj_eec0c8b89a2742f11fc8c57f2f33ab22;
static PyCodeObject *codeobj_50bc9a59774bc50fc0ac2d1a07ffc38a;
static PyCodeObject *codeobj_1d077a2aa446b600dd44fa19b0fba0f2;
static PyCodeObject *codeobj_19f4c0df1d648fcd98396d2760645fff;
static PyCodeObject *codeobj_f02229ffaecf12b0bda4fcfc8980ff2f;
static PyCodeObject *codeobj_2572b3a6c05f0075fc8737e5fda0c78b;
static PyCodeObject *codeobj_2374d85031de4b81a17b991b72074603;
static PyCodeObject *codeobj_14de2d48cc6d86d7990ead778de5ef55;
static PyCodeObject *codeobj_45ed442e1506cc9b5cff022672c2bdc7;
static PyCodeObject *codeobj_56db8f3ad7ac017dddd0e01deae6912d;
static PyCodeObject *codeobj_57e36cbbce323c916e9e798bf8dbed90;
static PyCodeObject *codeobj_92c869c1bdf445f8c0f17651833850ef;
static PyCodeObject *codeobj_67946727c71fd992c6c0b992e68c9b62;
static PyCodeObject *codeobj_b5bbacf212743993a52b51355435ccb2;
static PyCodeObject *codeobj_fe1e7a1a7475b74c7d82a70b9b2a7b1c;
static PyCodeObject *codeobj_9f3b3e38c30463863dd51d0304783462;
static PyCodeObject *codeobj_ee82fcb5a179d6e83101dbacd640bb17;
static PyCodeObject *codeobj_9b60c539be2d599550e02a9e38767f40;
static PyCodeObject *codeobj_8df0a17a4cea47e2942cb3a703b1e430;
static PyCodeObject *codeobj_b1baa4b5a4f28808018d8437290cabf1;
static PyCodeObject *codeobj_2b9f0db2a0884ae0c464ed42cbe0ca77;
static PyCodeObject *codeobj_7573520d98579b7184ce117cbc63b138;
static PyCodeObject *codeobj_4db96353b2604ba4e009beb772a0e03c;
static PyCodeObject *codeobj_8405f2e69630444edfa5d22fe7c6076e;
static PyCodeObject *codeobj_5627fc3a583d3cb6bbb8c8b56cc5ee6e;
static PyCodeObject *codeobj_ab8c5a8b684c9fef58474266c7dffadb;
static PyCodeObject *codeobj_8fbc2a08b5ca5a8f7c260de621689a56;
static PyCodeObject *codeobj_aa37e82ac1bfe382d743f376673b24de;
static PyCodeObject *codeobj_cef83b92118b0cfd63adac31a6c2c4dd;
static PyCodeObject *codeobj_574e55e9b19a65578d5335f615e3ce1f;
static PyCodeObject *codeobj_149b439b28110db47c6d802c9ba60c85;
static PyCodeObject *codeobj_0e38c8c915cfa3f59056d06f346243bf;
static PyCodeObject *codeobj_3538b6f5a5b90a8f1ad1699f31158e85;
static PyCodeObject *codeobj_2b572ac717ef65df74ce99e5f8b136a9;
static PyCodeObject *codeobj_2e2a967d61caf9026b18b0e9c6006146;
static PyCodeObject *codeobj_7165db6d77156f077838a6ffb710eb7d;
static PyCodeObject *codeobj_c8ca74f375a5b66d21788a9c199bc810;
static PyCodeObject *codeobj_275913114fb9b83a1dbb762593bb7bc5;
static PyCodeObject *codeobj_55a2c931a1b128be07012db2099f9f07;
static PyCodeObject *codeobj_5e3e9860782562fdba9865949f9a1aad;
static PyCodeObject *codeobj_3e4f26f00524b986eaad778de10be378;
static PyCodeObject *codeobj_a40ae5465b1fee60f90d6ba7f74ac049;
static PyCodeObject *codeobj_c5572338dcd2f002feb76dcfbb9e1d18;
static PyCodeObject *codeobj_2032aff2dcfd5f708972757a2c967882;
static PyCodeObject *codeobj_efd34061bbe17d3f599acf52a0927a75;
static PyCodeObject *codeobj_ff22167bf97fbb91b6a1b6290ff782e8;
static PyCodeObject *codeobj_fadb2dc5d8bba71f9a8e9cfcaee28365;
static PyCodeObject *codeobj_993858ded2f3066e6cc14f93b879c724;
static PyCodeObject *codeobj_a5f1941815e6a4456d1d13832b07f311;
static PyCodeObject *codeobj_8188b9ec4ae4d8387eb82dac38e406e0;
static PyCodeObject *codeobj_cd9319f1e2a709da2e67b8939c90e219;
static PyCodeObject *codeobj_1492769ae6147f752f0b4b6f237cf894;
static PyCodeObject *codeobj_4ccea98cae174f5c67a2d51a294f6880;
static PyCodeObject *codeobj_53f581e08696ed1cb55d8d59dd2376ac;
static PyCodeObject *codeobj_de70240140ef9e6a0e5c1e2d00e223d2;
static PyCodeObject *codeobj_29760e1180446b273ed27a21f53c7d5b;
static PyCodeObject *codeobj_6e7680fc6f0882a572f93f3695c4ac8d;
static PyCodeObject *codeobj_b961bdee1fe305fdfe9be48d53ac2abd;
static PyCodeObject *codeobj_7aaeec7d13e2fa45c91143278c9384ed;
static PyCodeObject *codeobj_b2c6519047820697d77e44d8bdcfd13b;
static PyCodeObject *codeobj_a653d45da8baa6d488220c38863ffcf2;
static PyCodeObject *codeobj_3e69ec24bcd58b7600541c49b05642f9;
static PyCodeObject *codeobj_a3b7117cfaf5b59269aee17d1606e823;
static PyCodeObject *codeobj_44fcf979e33c233af5f80d7c35b13be4;
static PyCodeObject *codeobj_f68866006367fc4d498eabfdb2ce5eab;
static PyCodeObject *codeobj_38fda1c9e56fc83bd693815271a1967a;
static PyCodeObject *codeobj_54e466a14b6f5af1981cb3aaa414eccb;
static PyCodeObject *codeobj_be19316fadb8714fcba11591040e6359;
static PyCodeObject *codeobj_cfe41ce1eddc8e60170273ac53a9bcf1;

static void createModuleCodeObjects(void) {
    module_filename_obj = MAKE_RELATIVE_PATH(const_str_digest_520475ee9f753bee090d1ecadd4c727e);
    codeobj_bd5a4ccd3526e581f6cff771453dcd80 = MAKE_CODEOBJECT(module_filename_obj, 1191, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_angle_genexpr, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_i_tuple, 1, 0, 0);
    codeobj_d5ecd660941aa92ad81b0960ed9952bd = MAKE_CODEOBJECT(module_filename_obj, 1189, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_angle_genexpr, const_tuple_0249ced4da5e72f251db066d967b15dd_tuple, 1, 0, 0);
    codeobj_7b975eeb631ffb9fcaa0a37fa763716e = MAKE_CODEOBJECT(module_filename_obj, 1098, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_angle_genexpr, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_name_tuple, 1, 0, 0);
    codeobj_6cc5423ab0acdb175d93b9726ccbd1a5 = MAKE_CODEOBJECT(module_filename_obj, 1383, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_angle_genexpr, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_sct_tuple, 1, 0, 0);
    codeobj_08237a46621deda32827a6d1002f2896 = MAKE_CODEOBJECT(module_filename_obj, 162, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_angle_genexpr, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_x_tuple, 1, 0, 0);
    codeobj_f6b8321b3a4026647bece9fcbe9c1464 = MAKE_CODEOBJECT(module_filename_obj, 270, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_angle_genexpr, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_x_tuple, 1, 0, 0);
    codeobj_7d4fd4c587e255df3371241a48928f28 = MAKE_CODEOBJECT(module_filename_obj, 416, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_angle_genexpr, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_x_tuple, 1, 0, 0);
    codeobj_6c990ee64c9c9599e422c207d851cbc9 = MAKE_CODEOBJECT(module_filename_obj, 457, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_angle_genexpr, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_x_tuple, 1, 0, 0);
    codeobj_4121fcf894750f20ccf71bdfe3d19df2 = MAKE_CODEOBJECT(module_filename_obj, 501, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_angle_genexpr, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_x_tuple, 1, 0, 0);
    codeobj_31212033882b18f22cff534424b54050 = MAKE_CODEOBJECT(module_filename_obj, 514, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_angle_genexpr, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_x_tuple, 1, 0, 0);
    codeobj_976e58673ea1efbd2ac3a273b25c792e = MAKE_CODEOBJECT(module_filename_obj, 520, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_angle_genexpr, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_x_tuple, 1, 0, 0);
    codeobj_1e9868694a8772e0bc7d1c6993d99d35 = MAKE_CODEOBJECT(module_filename_obj, 664, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_angle_genexpr, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_x_tuple, 1, 0, 0);
    codeobj_4a882b53e0e829bff518a8c7aacc9ae2 = MAKE_CODEOBJECT(module_filename_obj, 707, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_angle_genexpr, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_x_tuple, 1, 0, 0);
    codeobj_85e574a0ea828b1296944aef7e1a45bc = MAKE_CODEOBJECT(module_filename_obj, 788, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_angle_genexpr, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_x_tuple, 1, 0, 0);
    codeobj_d4589269dd21e1af6cba113639e39aef = MAKE_CODEOBJECT(module_filename_obj, 826, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_angle_genexpr, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_x_tuple, 1, 0, 0);
    codeobj_9ed3c9ca3659a47dcc7d6a0adafc3ab6 = MAKE_CODEOBJECT(module_filename_obj, 872, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_angle_genexpr, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_x_tuple, 1, 0, 0);
    codeobj_e842a3817de07d4676702c4ec5cd46ff = MAKE_CODEOBJECT(module_filename_obj, 918, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_angle_genexpr, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_x_tuple, 1, 0, 0);
    codeobj_be6d215d5ccf72c4dd20589bf484df13 = MAKE_CODEOBJECT(module_filename_obj, 1055, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_angle_genexpr, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_x_tuple, 1, 0, 0);
    codeobj_624e1fc6d94a612cab9b15afbf337091 = MAKE_CODEOBJECT(module_filename_obj, 1067, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_angle_genexpr, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_x_tuple, 1, 0, 0);
    codeobj_649d76a7830e746a0a26b7e9c621710f = MAKE_CODEOBJECT(module_filename_obj, 1171, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_angle_genexpr, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_x_tuple, 1, 0, 0);
    codeobj_2e7cf4e83e69f15d24fde995cefd2a7c = MAKE_CODEOBJECT(module_filename_obj, 1462, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_angle_genexpr, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_x_tuple, 1, 0, 0);
    codeobj_43c1c6d969ff6899544b1cfb272ea433 = MAKE_CODEOBJECT(module_filename_obj, 1, CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_digest_56973e3a5f1a8b7f8ba81c36b603bcaa, const_tuple_empty, 0, 0, 0);
    codeobj_888390ddbc4bf33f48bfeea2ec680910 = MAKE_CODEOBJECT(module_filename_obj, 303, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_AccessDescription, const_tuple_empty, 0, 0, 0);
    codeobj_fdfe391b38b7f158ab41b6490db64d26 = MAKE_CODEOBJECT(module_filename_obj, 265, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_AuthorityInformationAccess, const_tuple_empty, 0, 0, 0);
    codeobj_8af375243c51a3b11b69e7c775faf530 = MAKE_CODEOBJECT(module_filename_obj, 146, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_AuthorityKeyIdentifier, const_tuple_empty, 0, 0, 0);
    codeobj_10cbbfd8fde45d6af5689d9068ecbd4d = MAKE_CODEOBJECT(module_filename_obj, 340, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_BasicConstraints, const_tuple_empty, 0, 0, 0);
    codeobj_8cf535c0875cf42bdef61b5101de9850 = MAKE_CODEOBJECT(module_filename_obj, 410, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_CRLDistributionPoints, const_tuple_empty, 0, 0, 0);
    codeobj_9c95e9ba0408147c3cfcb22e4b1c91c9 = MAKE_CODEOBJECT(module_filename_obj, 118, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_CRLNumber, const_tuple_empty, 0, 0, 0);
    codeobj_f1fb71489cc684b7ee4d1e2902a82ad3 = MAKE_CODEOBJECT(module_filename_obj, 1319, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_CRLReason, const_tuple_empty, 0, 0, 0);
    codeobj_d613475f4bc9b1ec8ed0abba919aa767 = MAKE_CODEOBJECT(module_filename_obj, 1284, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_CertificateIssuer, const_tuple_empty, 0, 0, 0);
    codeobj_6a2ac24867d838ebbfada582b800ac84 = MAKE_CODEOBJECT(module_filename_obj, 659, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_CertificatePolicies, const_tuple_empty, 0, 0, 0);
    codeobj_c40257bc666664b368a90a2bb591b69e = MAKE_CODEOBJECT(module_filename_obj, 382, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_DeltaCRLIndicator, const_tuple_empty, 0, 0, 0);
    codeobj_d9bb56bd96dd7fc707029f25f9b9879f = MAKE_CODEOBJECT(module_filename_obj, 491, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_DistributionPoint, const_tuple_empty, 0, 0, 0);
    codeobj_d76b975938eb3793df08887e6a883dcc = MAKE_CODEOBJECT(module_filename_obj, 821, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_ExtendedKeyUsage, const_tuple_empty, 0, 0, 0);
    codeobj_e04ffe5b900a4019b6788821593ab364 = MAKE_CODEOBJECT(module_filename_obj, 1129, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_Extension, const_tuple_empty, 0, 0, 0);
    codeobj_8e8c1d14cc1f43c40fb686c3c332d970 = MAKE_CODEOBJECT(module_filename_obj, 67, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_ExtensionType, const_tuple_empty, 0, 0, 0);
    codeobj_8be8c331db6797002bac5a779f59022d = MAKE_CODEOBJECT(module_filename_obj, 451, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_FreshestCRL, const_tuple_empty, 0, 0, 0);
    codeobj_9cf8ad554dd9d3c4ef6ee538381ad390 = MAKE_CODEOBJECT(module_filename_obj, 922, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_InhibitAnyPolicy, const_tuple_empty, 0, 0, 0);
    codeobj_c1c2bb0918ddbcf5f075491c88a41e6d = MAKE_CODEOBJECT(module_filename_obj, 1347, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_InvalidityDate, const_tuple_empty, 0, 0, 0);
    codeobj_046f51f4b030997d90f3cee22939d406 = MAKE_CODEOBJECT(module_filename_obj, 1249, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_IssuerAlternativeName, const_tuple_empty, 0, 0, 0);
    codeobj_49473bcf3743b34fde0906127568439e = MAKE_CODEOBJECT(module_filename_obj, 1453, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_IssuingDistributionPoint, const_tuple_empty, 0, 0, 0);
    codeobj_083e1fa26f5ab300d67d5d5e3552df7c = MAKE_CODEOBJECT(module_filename_obj, 953, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_KeyUsage, const_tuple_empty, 0, 0, 0);
    codeobj_88f6f5c3c797c731ba74a50683fe2b42 = MAKE_CODEOBJECT(module_filename_obj, 1048, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_NameConstraints, const_tuple_empty, 0, 0, 0);
    codeobj_131acb86ad21685798bdc6a84a886dee = MAKE_CODEOBJECT(module_filename_obj, 784, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_NoticeReference, const_tuple_empty, 0, 0, 0);
    codeobj_14b4d327d26227dbeeaf8ac21d0eead5 = MAKE_CODEOBJECT(module_filename_obj, 856, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_OCSPNoCheck, const_tuple_empty, 0, 0, 0);
    codeobj_e1283683c51f59cb9a7eb7fe98cf8efa = MAKE_CODEOBJECT(module_filename_obj, 1425, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_OCSPNonce, const_tuple_empty, 0, 0, 0);
    codeobj_4db2c46a45695eb12bac9cef5aa0180e = MAKE_CODEOBJECT(module_filename_obj, 598, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_PolicyConstraints, const_tuple_empty, 0, 0, 0);
    codeobj_adabafe8c246c11f4a4c9f6f68213ae2 = MAKE_CODEOBJECT(module_filename_obj, 697, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_PolicyInformation, const_tuple_empty, 0, 0, 0);
    codeobj_5b0a6348dd417584c7f202513d6c4148 = MAKE_CODEOBJECT(module_filename_obj, 861, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_PrecertPoison, const_tuple_empty, 0, 0, 0);
    codeobj_34d3d5aa27da9c5dfcf667f6ff343fae = MAKE_CODEOBJECT(module_filename_obj, 1377, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_digest_97ac982b098bfd0facb64df38773c335, const_tuple_empty, 0, 0, 0);
    codeobj_52c7e053ce661cd35566c3bb41cd02bd = MAKE_CODEOBJECT(module_filename_obj, 1214, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_SubjectAlternativeName, const_tuple_empty, 0, 0, 0);
    codeobj_0bc1f437e02225d59bf32cb2d7a199ed = MAKE_CODEOBJECT(module_filename_obj, 236, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_SubjectKeyIdentifier, const_tuple_empty, 0, 0, 0);
    codeobj_31b0147aee22ba20318b32af38dd79aa = MAKE_CODEOBJECT(module_filename_obj, 866, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_TLSFeature, const_tuple_empty, 0, 0, 0);
    codeobj_50a05b6f30ae622183421406fd266003 = MAKE_CODEOBJECT(module_filename_obj, 1583, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_UnrecognizedExtension, const_tuple_empty, 0, 0, 0);
    codeobj_284f196fc1cfe393c2e892de06b6804f = MAKE_CODEOBJECT(module_filename_obj, 747, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_UserNotice, const_tuple_empty, 0, 0, 0);
    codeobj_5be6c71ea22dc937c8590e3714a0e70f = MAKE_CODEOBJECT(module_filename_obj, 127, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___eq__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_ec606af4719e836adceac6092dca2c44 = MAKE_CODEOBJECT(module_filename_obj, 205, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___eq__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_3bb78211f559ebe4d881b75b546ffc0a = MAKE_CODEOBJECT(module_filename_obj, 251, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___eq__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_ec6763a25cc283c8349cad2c66a21488 = MAKE_CODEOBJECT(module_filename_obj, 287, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___eq__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_b89be643f7a61f3d81c6671d6ad51b78 = MAKE_CODEOBJECT(module_filename_obj, 320, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___eq__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_bf509f0149490c9f7ccf380ab57d6798 = MAKE_CODEOBJECT(module_filename_obj, 368, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___eq__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_56e3c65f02e773e82d404aa393504dde = MAKE_CODEOBJECT(module_filename_obj, 393, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___eq__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_401579719c1f990019f327b475e920c9 = MAKE_CODEOBJECT(module_filename_obj, 434, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___eq__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_bca7cfb63f34239fb1479c0362918cf5 = MAKE_CODEOBJECT(module_filename_obj, 475, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___eq__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_fd2f7ac83c7c2c75bf12c49dee786140 = MAKE_CODEOBJECT(module_filename_obj, 551, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___eq__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_37be6aa945e0555a84befbfd36f8ffc2 = MAKE_CODEOBJECT(module_filename_obj, 633, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___eq__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_7c03c4c0f3dcfa4c04cd5abaf3b9020a = MAKE_CODEOBJECT(module_filename_obj, 681, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___eq__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_d85838fa42326f320c88255032c5fca7 = MAKE_CODEOBJECT(module_filename_obj, 723, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___eq__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_2321762013dc0ff29c834d130737aec5 = MAKE_CODEOBJECT(module_filename_obj, 765, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___eq__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_a4f75b426139664f5a0ed587effcf9e3 = MAKE_CODEOBJECT(module_filename_obj, 801, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___eq__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_49ab98a368a06f5b62e3090207811653 = MAKE_CODEOBJECT(module_filename_obj, 842, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___eq__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_24e7e599f7a9ff62dccfaaca7a767e34 = MAKE_CODEOBJECT(module_filename_obj, 891, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___eq__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_2907138fdb90eed1a368f2b6f66fa0e6 = MAKE_CODEOBJECT(module_filename_obj, 937, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___eq__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_9355c6ab964f8819c44a92cf3a8a7bc7 = MAKE_CODEOBJECT(module_filename_obj, 1018, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___eq__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_36f675ca210741eafa6fdae589c7d341 = MAKE_CODEOBJECT(module_filename_obj, 1085, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___eq__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_c27b0e8e5456bfa1ce1df12003e5c214 = MAKE_CODEOBJECT(module_filename_obj, 1151, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___eq__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_377dfaf8031601d6b3bbe8ecaa46a6da = MAKE_CODEOBJECT(module_filename_obj, 1197, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___eq__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_4faa79e5001d77385bdc0e9fd35de12b = MAKE_CODEOBJECT(module_filename_obj, 1232, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___eq__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_65acb965719b8331ceb73cf60da5a34d = MAKE_CODEOBJECT(module_filename_obj, 1267, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___eq__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_763a08aeeae201c12ea113ce4cfc00d1 = MAKE_CODEOBJECT(module_filename_obj, 1302, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___eq__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_a121d78d607dd566078ad638d3fd9345 = MAKE_CODEOBJECT(module_filename_obj, 1331, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___eq__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_794acec4cbbb193c4d12f82b7f02da0c = MAKE_CODEOBJECT(module_filename_obj, 1361, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___eq__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_01367d6abaf9a9706fda30395db202db = MAKE_CODEOBJECT(module_filename_obj, 1411, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___eq__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_7028bdbd3fa71c0482994e203d0dd60c = MAKE_CODEOBJECT(module_filename_obj, 1434, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___eq__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_0baf7dc256d01cc71597fc9143b60403 = MAKE_CODEOBJECT(module_filename_obj, 1538, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___eq__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_0072f7a0ccd296332a271d4a8e480c77 = MAKE_CODEOBJECT(module_filename_obj, 1600, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___eq__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_60d2d44b2848d82367f482e630058a14 = MAKE_CODEOBJECT(module_filename_obj, 108, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___getitem__, const_tuple_str_plain_self_str_plain_idx_tuple, 2, 0, 0);
    codeobj_a61d36331eed656537469cdb25841c38 = MAKE_CODEOBJECT(module_filename_obj, 296, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___getitem__, const_tuple_str_plain_self_str_plain_idx_tuple, 2, 0, 0);
    codeobj_e1fa255798e8bef9d045790b180982af = MAKE_CODEOBJECT(module_filename_obj, 443, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___getitem__, const_tuple_str_plain_self_str_plain_idx_tuple, 2, 0, 0);
    codeobj_c4a263fab24d4b74487740f36bc3c59f = MAKE_CODEOBJECT(module_filename_obj, 484, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___getitem__, const_tuple_str_plain_self_str_plain_idx_tuple, 2, 0, 0);
    codeobj_91ef01aeefd39e14a3a497daec6f2d50 = MAKE_CODEOBJECT(module_filename_obj, 690, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___getitem__, const_tuple_str_plain_self_str_plain_idx_tuple, 2, 0, 0);
    codeobj_4be51afc529a9d1699ae3aaaaf3cc631 = MAKE_CODEOBJECT(module_filename_obj, 897, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___getitem__, const_tuple_str_plain_self_str_plain_idx_tuple, 2, 0, 0);
    codeobj_e80eadbccd9a352af4d1530cb82eabd0 = MAKE_CODEOBJECT(module_filename_obj, 1206, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___getitem__, const_tuple_str_plain_self_str_plain_idx_tuple, 2, 0, 0);
    codeobj_bc546761cdcfe97d2210ff9ffeb1d8d7 = MAKE_CODEOBJECT(module_filename_obj, 1238, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___getitem__, const_tuple_str_plain_self_str_plain_idx_tuple, 2, 0, 0);
    codeobj_50faf74e5ca2c4814bf1e56953546672 = MAKE_CODEOBJECT(module_filename_obj, 1276, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___getitem__, const_tuple_str_plain_self_str_plain_idx_tuple, 2, 0, 0);
    codeobj_e2014de1836f1bbfee700d36c26440be = MAKE_CODEOBJECT(module_filename_obj, 1311, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___getitem__, const_tuple_str_plain_self_str_plain_idx_tuple, 2, 0, 0);
    codeobj_2cd7211ae0497207f8bc2f43f4d4f414 = MAKE_CODEOBJECT(module_filename_obj, 1398, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___getitem__, const_tuple_str_plain_self_str_plain_idx_tuple, 2, 0, 0);
    codeobj_dccf9a51dd0e5d88d3e5ed45b6d434bd = MAKE_CODEOBJECT(module_filename_obj, 136, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___hash__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_7c6b59f6602706780fb2366013d7677d = MAKE_CODEOBJECT(module_filename_obj, 260, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___hash__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_d4d5e0153429c0273ebb4e9160719179 = MAKE_CODEOBJECT(module_filename_obj, 299, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___hash__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_9e5fdab2f284d2dbd1ea4bcd02f4243a = MAKE_CODEOBJECT(module_filename_obj, 332, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___hash__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_94ad4941638ca2d741d049b1fa5e9734 = MAKE_CODEOBJECT(module_filename_obj, 377, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___hash__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_24e6c32aa2722cf4ecaa3b16048d4738 = MAKE_CODEOBJECT(module_filename_obj, 402, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___hash__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_2ee369f8faadbdd2a80c9b8c92f1b573 = MAKE_CODEOBJECT(module_filename_obj, 446, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___hash__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_660db49e2668f19c95e04c246a6a5dd8 = MAKE_CODEOBJECT(module_filename_obj, 487, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___hash__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_0bf109aa3d44d653af2864e48ed4fe06 = MAKE_CODEOBJECT(module_filename_obj, 645, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___hash__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_54048dea6a948c37f34018f06d8c86ff = MAKE_CODEOBJECT(module_filename_obj, 693, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___hash__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_9a7626d648d17d2d5ed8388969ae0bd5 = MAKE_CODEOBJECT(module_filename_obj, 777, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___hash__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_0c619b809dcf09b4a39bf5bdd60015b5 = MAKE_CODEOBJECT(module_filename_obj, 813, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___hash__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_307c2c80549b8830ab1bdc50cebac581 = MAKE_CODEOBJECT(module_filename_obj, 851, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___hash__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_630983a0bc3c12aec05d1c102c6f9427 = MAKE_CODEOBJECT(module_filename_obj, 903, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___hash__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_1915b0ec2af236e889c5e58dce17d01b = MAKE_CODEOBJECT(module_filename_obj, 946, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___hash__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_4319d0fde202e8d91251639b1f99c86f = MAKE_CODEOBJECT(module_filename_obj, 1037, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___hash__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_6f49f5cfd885de7a42467f04151c4e4a = MAKE_CODEOBJECT(module_filename_obj, 1164, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___hash__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_7e8a46f19303bcd303c87268495b4873 = MAKE_CODEOBJECT(module_filename_obj, 1209, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___hash__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_4e3af5c7e39f4d94e8e08cef824fb047 = MAKE_CODEOBJECT(module_filename_obj, 1244, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___hash__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_b9940654b29bb9eed381a2ae1f642803 = MAKE_CODEOBJECT(module_filename_obj, 1279, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___hash__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_617ec1273e01aa3bf39c7d8e1a305e70 = MAKE_CODEOBJECT(module_filename_obj, 1314, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___hash__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_860103f2dcafc72031eb1f0cb95f4dfe = MAKE_CODEOBJECT(module_filename_obj, 1340, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___hash__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_ff20a1f819ea51d73291e30a17f7b7d5 = MAKE_CODEOBJECT(module_filename_obj, 1370, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___hash__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_54cad17ac3bd5403abe61737684eaa45 = MAKE_CODEOBJECT(module_filename_obj, 1408, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___hash__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_bbff8841f994d0861901167e26c77f21 = MAKE_CODEOBJECT(module_filename_obj, 1443, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___hash__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_f2d176069a53125e7129d5de6997a323 = MAKE_CODEOBJECT(module_filename_obj, 1556, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___hash__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_a404729c83b1ce7e50c89c3a34394158 = MAKE_CODEOBJECT(module_filename_obj, 1609, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___hash__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_7b2b4c038ecf3dd78ddb14477ee2e367 = MAKE_CODEOBJECT(module_filename_obj, 219, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___hash__, const_tuple_str_plain_self_str_plain_aci_tuple, 1, 0, 0);
    codeobj_f20ef46fc2f13e0d2c1ca2898c462ef4 = MAKE_CODEOBJECT(module_filename_obj, 565, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___hash__, const_tuple_str_plain_self_str_plain_crl_issuer_str_plain_fn_tuple, 1, 0, 0);
    codeobj_0243f386a7ef791aa70475a164a2b63a = MAKE_CODEOBJECT(module_filename_obj, 735, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___hash__, const_tuple_str_plain_self_str_plain_pq_tuple, 1, 0, 0);
    codeobj_f3eeb900b76619b4244a734caee1b5b1 = MAKE_CODEOBJECT(module_filename_obj, 1112, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___hash__, const_tuple_str_plain_self_str_plain_ps_str_plain_es_tuple, 1, 0, 0);
    codeobj_d82db69e835d9e68e136650ca07bce53 = MAKE_CODEOBJECT(module_filename_obj, 304, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___init__, const_tuple_9e442608387cffc806b1f25d569bdb89_tuple, 3, 0, 0);
    codeobj_fc83f25a35c64baf86fc9abec28579bf = MAKE_CODEOBJECT(module_filename_obj, 343, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___init__, const_tuple_str_plain_self_str_plain_ca_str_plain_path_length_tuple, 3, 0, 0);
    codeobj_3e9816c5343a0a17dd4693ad9ed8aef1 = MAKE_CODEOBJECT(module_filename_obj, 121, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___init__, const_tuple_str_plain_self_str_plain_crl_number_tuple, 2, 0, 0);
    codeobj_8947fe591337cc5a2cf6de779a4c5523 = MAKE_CODEOBJECT(module_filename_obj, 385, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___init__, const_tuple_str_plain_self_str_plain_crl_number_tuple, 2, 0, 0);
    codeobj_2ac5cbbcb3461b660306ae84e4908ce0 = MAKE_CODEOBJECT(module_filename_obj, 268, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___init__, const_tuple_str_plain_self_str_plain_descriptions_tuple, 2, 0, 0);
    codeobj_35d20cf5a412ee09604cd65c988906ca = MAKE_CODEOBJECT(module_filename_obj, 239, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___init__, const_tuple_str_plain_self_str_plain_digest_tuple, 2, 0, 0);
    codeobj_77c11ff9d369e4a1284f82ff18ea0eb6 = MAKE_CODEOBJECT(module_filename_obj, 956, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___init__, const_tuple_6d08159ea13672603ee689286b27f535_tuple, 10, 0, 0);
    codeobj_9dea707d642354d82eb245b14decc508 = MAKE_CODEOBJECT(module_filename_obj, 413, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___init__, const_tuple_str_plain_self_str_plain_distribution_points_tuple, 2, 0, 0);
    codeobj_f39e2c4ef794a49e891ba944e62753a1 = MAKE_CODEOBJECT(module_filename_obj, 454, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___init__, const_tuple_str_plain_self_str_plain_distribution_points_tuple, 2, 0, 0);
    codeobj_ccb81d58c538921fd6eadf0f5f9021bf = MAKE_CODEOBJECT(module_filename_obj, 76, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___init__, const_tuple_str_plain_self_str_plain_extensions_tuple, 2, 0, 0);
    codeobj_15065a31e94060fc1e6f2be62d1bb441 = MAKE_CODEOBJECT(module_filename_obj, 869, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___init__, const_tuple_str_plain_self_str_plain_features_tuple, 2, 0, 0);
    codeobj_6b50228316171cb46aa5f942471d78c9 = MAKE_CODEOBJECT(module_filename_obj, 1456, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___init__, const_tuple_c9093e158a1a3426ce5fb16319f2926f_tuple, 8, 0, 0);
    codeobj_168b828ef0bd5b03004b55cf5ee199a8 = MAKE_CODEOBJECT(module_filename_obj, 492, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___init__, const_tuple_35bfa5acc69c9c72494218df80b094f1_tuple, 5, 0, 0);
    codeobj_0c8e1253c96407b45c539de5f50b8b44 = MAKE_CODEOBJECT(module_filename_obj, 1169, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___init__, const_tuple_str_plain_self_str_plain_general_names_tuple, 2, 0, 0);
    codeobj_9fbea692e0648e29509653c9c860b09a = MAKE_CODEOBJECT(module_filename_obj, 1217, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___init__, const_tuple_str_plain_self_str_plain_general_names_tuple, 2, 0, 0);
    codeobj_ff0e042effc3afe7e319d9d9426d8281 = MAKE_CODEOBJECT(module_filename_obj, 1252, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___init__, const_tuple_str_plain_self_str_plain_general_names_tuple, 2, 0, 0);
    codeobj_6b2b741db5b95eb288315358a396ca78 = MAKE_CODEOBJECT(module_filename_obj, 1287, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___init__, const_tuple_str_plain_self_str_plain_general_names_tuple, 2, 0, 0);
    codeobj_de12b3c1eb89792f5ed199d2ecb02247 = MAKE_CODEOBJECT(module_filename_obj, 1350, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___init__, const_tuple_str_plain_self_str_plain_invalidity_date_tuple, 2, 0, 0);
    codeobj_a6ea834c6003bc7491321f01345f19da = MAKE_CODEOBJECT(module_filename_obj, 149, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___init__, const_tuple_02fac2eed0ac0dd060a0301d0bd9ba98_tuple, 4, 0, 0);
    codeobj_a639918ff9b53f9ac4ca97850d09e8b5 = MAKE_CODEOBJECT(module_filename_obj, 55, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___init__, const_tuple_str_plain_self_str_plain_msg_str_plain_oid_tuple, 3, 0, 0);
    codeobj_060b6428f7e0298a84738a381d9a7335 = MAKE_CODEOBJECT(module_filename_obj, 61, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___init__, const_tuple_str_plain_self_str_plain_msg_str_plain_oid_tuple, 3, 0, 0);
    codeobj_93c4a51e5d5a057df74d80318f8994b9 = MAKE_CODEOBJECT(module_filename_obj, 1428, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___init__, const_tuple_str_plain_self_str_plain_nonce_tuple, 2, 0, 0);
    codeobj_bea296a7219ecd602eca25edc4652bad = MAKE_CODEOBJECT(module_filename_obj, 748, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___init__, const_tuple_30cc927ede2fc9470dffcd81c25765bb_tuple, 3, 0, 0);
    codeobj_8b50f1443742e7df185a6bfdd7fc3d1f = MAKE_CODEOBJECT(module_filename_obj, 1130, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___init__, const_tuple_96332c2a391d63d358e15081c1debfb6_tuple, 4, 0, 0);
    codeobj_84a0291d7ab205891af2466b9e0377ec = MAKE_CODEOBJECT(module_filename_obj, 1584, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___init__, const_tuple_str_plain_self_str_plain_oid_str_plain_value_tuple, 3, 0, 0);
    codeobj_fcf5dbe695d0fd2e4622c11a67638dce = MAKE_CODEOBJECT(module_filename_obj, 785, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___init__, const_tuple_571ef8230a0f951e7e814a3a1b007a73_tuple, 3, 0, 0);
    codeobj_15444db29e1e916a45d41f13f5c606ec = MAKE_CODEOBJECT(module_filename_obj, 1051, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___init__, const_tuple_a73b8498e05ac6f54cfbc844a1aafead_tuple, 3, 0, 0);
    codeobj_2d8993bbcf695d23055ae2f7cb247a4b = MAKE_CODEOBJECT(module_filename_obj, 662, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___init__, const_tuple_str_plain_self_str_plain_policies_tuple, 2, 0, 0);
    codeobj_08aca7543267a89e2589b8bd1ffcee16 = MAKE_CODEOBJECT(module_filename_obj, 698, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___init__, const_tuple_79831141b0c54263bd4ba55a91ef27c4_tuple, 3, 0, 0);
    codeobj_6c658cb11fbcf33d94d501986e68c1ff = MAKE_CODEOBJECT(module_filename_obj, 1322, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___init__, const_tuple_str_plain_self_str_plain_reason_tuple, 2, 0, 0);
    codeobj_8c74ccf08a9d69888a5bac51f8974a06 = MAKE_CODEOBJECT(module_filename_obj, 601, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___init__, const_tuple_9d6859e57abe5ce2ca107f61cc5077a0_tuple, 3, 0, 0);
    codeobj_5c40cf088e4ab97ee21bf262ce67d13d = MAKE_CODEOBJECT(module_filename_obj, 1380, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___init__, const_tuple_str_plain_self_str_plain_signed_certificate_timestamps_tuple, 2, 0, 0);
    codeobj_6ef664bce779bb8c807c67c1e9b5d169 = MAKE_CODEOBJECT(module_filename_obj, 925, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___init__, const_tuple_str_plain_self_str_plain_skip_certs_tuple, 2, 0, 0);
    codeobj_f3ae497e09b3bd3a162b69cd7a04cd91 = MAKE_CODEOBJECT(module_filename_obj, 824, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___init__, const_tuple_str_plain_self_str_plain_usages_tuple, 2, 0, 0);
    codeobj_2a0bf5a2c89e7fa0fdc8aac5f0ceb989 = MAKE_CODEOBJECT(module_filename_obj, 102, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___iter__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_8abc18ccaef36115f2eefe103b30849a = MAKE_CODEOBJECT(module_filename_obj, 278, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___iter__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_0cc8a86e0089204a5f1ba5499e750c59 = MAKE_CODEOBJECT(module_filename_obj, 425, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___iter__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_b916760a1adc6a39fbf1144eb6bf82c6 = MAKE_CODEOBJECT(module_filename_obj, 466, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___iter__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_cd33e2543397d1324358a2e61f8977a4 = MAKE_CODEOBJECT(module_filename_obj, 672, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___iter__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_c1b3c10743df6cec00e4bd32ad5436e8 = MAKE_CODEOBJECT(module_filename_obj, 833, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___iter__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_52ac52abb76c5766947a23493d41a735 = MAKE_CODEOBJECT(module_filename_obj, 882, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___iter__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_e3238b208fe2e5d2a45d1c96985f203f = MAKE_CODEOBJECT(module_filename_obj, 1179, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___iter__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_ae3e58b5effe48f6d27c07362c73d4d3 = MAKE_CODEOBJECT(module_filename_obj, 1220, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___iter__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_1c9410bc25f1960eb621aefb650cc5ae = MAKE_CODEOBJECT(module_filename_obj, 1255, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___iter__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_6f3d7d0fdfecc3ad3243e2e88d74ced2 = MAKE_CODEOBJECT(module_filename_obj, 1290, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___iter__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_d19dda71d3d42b410ec1cac06f83952c = MAKE_CODEOBJECT(module_filename_obj, 1392, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___iter__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_df6b91143147712a389f7e389566de10 = MAKE_CODEOBJECT(module_filename_obj, 105, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___len__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_d617f84754084510e6e33c98f465dfab = MAKE_CODEOBJECT(module_filename_obj, 281, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___len__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_149307d85299be0e2bb512b521807433 = MAKE_CODEOBJECT(module_filename_obj, 428, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___len__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_76098b86abab8a2ab9554e3939fdd518 = MAKE_CODEOBJECT(module_filename_obj, 469, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___len__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_9dfb2f031074454e5d12da987d075118 = MAKE_CODEOBJECT(module_filename_obj, 675, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___len__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_b1f676c1cba4b20ff4369028da50b101 = MAKE_CODEOBJECT(module_filename_obj, 836, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___len__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_516022e569c9c2d4e801766d1e23a7a9 = MAKE_CODEOBJECT(module_filename_obj, 885, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___len__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_8d9e40c8cfaba60d1272553c00ff35ed = MAKE_CODEOBJECT(module_filename_obj, 1182, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___len__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_107c6fa6753a52c5be47fed9637674ab = MAKE_CODEOBJECT(module_filename_obj, 1223, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___len__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_30f20714cec73f8af7aacc594b6386e4 = MAKE_CODEOBJECT(module_filename_obj, 1258, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___len__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_c17219ee1ea6d14faa2513ce9bfe056f = MAKE_CODEOBJECT(module_filename_obj, 1293, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___len__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_538db483ab62c4241ff17d2733bb07d0 = MAKE_CODEOBJECT(module_filename_obj, 1395, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___len__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_e290bf4f69c1366e896d88d19cc6fb02 = MAKE_CODEOBJECT(module_filename_obj, 133, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___ne__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_9e02fda17edc241d52be17c732abc823 = MAKE_CODEOBJECT(module_filename_obj, 216, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___ne__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_2a76b8a7a0619e7e50369de1896fb82e = MAKE_CODEOBJECT(module_filename_obj, 257, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___ne__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_bafa1748f4280a8d96a8ef0430df7fda = MAKE_CODEOBJECT(module_filename_obj, 293, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___ne__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_0717dde802ff3bf828c32149b86f91c5 = MAKE_CODEOBJECT(module_filename_obj, 329, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___ne__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_b2624bbf7f2345dffc42b8356201f32c = MAKE_CODEOBJECT(module_filename_obj, 374, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___ne__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_6eec4ed29d652d67297334df34b9efea = MAKE_CODEOBJECT(module_filename_obj, 399, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___ne__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_a1d6f2aea8a4d49139a6df2ca29a43e4 = MAKE_CODEOBJECT(module_filename_obj, 440, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___ne__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_eec0c8b89a2742f11fc8c57f2f33ab22 = MAKE_CODEOBJECT(module_filename_obj, 481, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___ne__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_50bc9a59774bc50fc0ac2d1a07ffc38a = MAKE_CODEOBJECT(module_filename_obj, 562, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___ne__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_1d077a2aa446b600dd44fa19b0fba0f2 = MAKE_CODEOBJECT(module_filename_obj, 642, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___ne__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_19f4c0df1d648fcd98396d2760645fff = MAKE_CODEOBJECT(module_filename_obj, 687, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___ne__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_f02229ffaecf12b0bda4fcfc8980ff2f = MAKE_CODEOBJECT(module_filename_obj, 732, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___ne__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_2572b3a6c05f0075fc8737e5fda0c78b = MAKE_CODEOBJECT(module_filename_obj, 774, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___ne__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_2374d85031de4b81a17b991b72074603 = MAKE_CODEOBJECT(module_filename_obj, 810, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___ne__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_14de2d48cc6d86d7990ead778de5ef55 = MAKE_CODEOBJECT(module_filename_obj, 848, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___ne__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_45ed442e1506cc9b5cff022672c2bdc7 = MAKE_CODEOBJECT(module_filename_obj, 900, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___ne__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_56db8f3ad7ac017dddd0e01deae6912d = MAKE_CODEOBJECT(module_filename_obj, 943, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___ne__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_57e36cbbce323c916e9e798bf8dbed90 = MAKE_CODEOBJECT(module_filename_obj, 1034, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___ne__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_92c869c1bdf445f8c0f17651833850ef = MAKE_CODEOBJECT(module_filename_obj, 1094, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___ne__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_67946727c71fd992c6c0b992e68c9b62 = MAKE_CODEOBJECT(module_filename_obj, 1161, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___ne__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_b5bbacf212743993a52b51355435ccb2 = MAKE_CODEOBJECT(module_filename_obj, 1203, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___ne__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_fe1e7a1a7475b74c7d82a70b9b2a7b1c = MAKE_CODEOBJECT(module_filename_obj, 1241, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___ne__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_9f3b3e38c30463863dd51d0304783462 = MAKE_CODEOBJECT(module_filename_obj, 1273, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___ne__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_ee82fcb5a179d6e83101dbacd640bb17 = MAKE_CODEOBJECT(module_filename_obj, 1308, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___ne__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_9b60c539be2d599550e02a9e38767f40 = MAKE_CODEOBJECT(module_filename_obj, 1337, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___ne__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_8df0a17a4cea47e2942cb3a703b1e430 = MAKE_CODEOBJECT(module_filename_obj, 1367, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___ne__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_b1baa4b5a4f28808018d8437290cabf1 = MAKE_CODEOBJECT(module_filename_obj, 1420, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___ne__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_2b9f0db2a0884ae0c464ed42cbe0ca77 = MAKE_CODEOBJECT(module_filename_obj, 1440, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___ne__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_7573520d98579b7184ce117cbc63b138 = MAKE_CODEOBJECT(module_filename_obj, 1553, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___ne__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_4db96353b2604ba4e009beb772a0e03c = MAKE_CODEOBJECT(module_filename_obj, 1606, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___ne__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_8405f2e69630444edfa5d22fe7c6076e = MAKE_CODEOBJECT(module_filename_obj, 111, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___repr__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_5627fc3a583d3cb6bbb8c8b56cc5ee6e = MAKE_CODEOBJECT(module_filename_obj, 139, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___repr__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_ab8c5a8b684c9fef58474266c7dffadb = MAKE_CODEOBJECT(module_filename_obj, 197, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___repr__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_8fbc2a08b5ca5a8f7c260de621689a56 = MAKE_CODEOBJECT(module_filename_obj, 248, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___repr__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_aa37e82ac1bfe382d743f376673b24de = MAKE_CODEOBJECT(module_filename_obj, 284, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___repr__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_cef83b92118b0cfd63adac31a6c2c4dd = MAKE_CODEOBJECT(module_filename_obj, 314, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___repr__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_574e55e9b19a65578d5335f615e3ce1f = MAKE_CODEOBJECT(module_filename_obj, 364, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___repr__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_149b439b28110db47c6d802c9ba60c85 = MAKE_CODEOBJECT(module_filename_obj, 405, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___repr__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_0e38c8c915cfa3f59056d06f346243bf = MAKE_CODEOBJECT(module_filename_obj, 431, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___repr__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_3538b6f5a5b90a8f1ad1699f31158e85 = MAKE_CODEOBJECT(module_filename_obj, 472, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___repr__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_2b572ac717ef65df74ce99e5f8b136a9 = MAKE_CODEOBJECT(module_filename_obj, 544, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___repr__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_2e2a967d61caf9026b18b0e9c6006146 = MAKE_CODEOBJECT(module_filename_obj, 626, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___repr__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_7165db6d77156f077838a6ffb710eb7d = MAKE_CODEOBJECT(module_filename_obj, 678, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___repr__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_c8ca74f375a5b66d21788a9c199bc810 = MAKE_CODEOBJECT(module_filename_obj, 717, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___repr__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_275913114fb9b83a1dbb762593bb7bc5 = MAKE_CODEOBJECT(module_filename_obj, 759, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___repr__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_55a2c931a1b128be07012db2099f9f07 = MAKE_CODEOBJECT(module_filename_obj, 795, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___repr__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_5e3e9860782562fdba9865949f9a1aad = MAKE_CODEOBJECT(module_filename_obj, 839, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___repr__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_3e4f26f00524b986eaad778de10be378 = MAKE_CODEOBJECT(module_filename_obj, 888, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___repr__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_a40ae5465b1fee60f90d6ba7f74ac049 = MAKE_CODEOBJECT(module_filename_obj, 934, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___repr__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_c5572338dcd2f002feb76dcfbb9e1d18 = MAKE_CODEOBJECT(module_filename_obj, 1106, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___repr__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_2032aff2dcfd5f708972757a2c967882 = MAKE_CODEOBJECT(module_filename_obj, 1147, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___repr__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_efd34061bbe17d3f599acf52a0927a75 = MAKE_CODEOBJECT(module_filename_obj, 1194, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___repr__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_ff22167bf97fbb91b6a1b6290ff782e8 = MAKE_CODEOBJECT(module_filename_obj, 1229, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___repr__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_fadb2dc5d8bba71f9a8e9cfcaee28365 = MAKE_CODEOBJECT(module_filename_obj, 1264, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___repr__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_993858ded2f3066e6cc14f93b879c724 = MAKE_CODEOBJECT(module_filename_obj, 1299, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___repr__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_a5f1941815e6a4456d1d13832b07f311 = MAKE_CODEOBJECT(module_filename_obj, 1328, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___repr__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_8188b9ec4ae4d8387eb82dac38e406e0 = MAKE_CODEOBJECT(module_filename_obj, 1356, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___repr__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_cd9319f1e2a709da2e67b8939c90e219 = MAKE_CODEOBJECT(module_filename_obj, 1401, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___repr__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_1492769ae6147f752f0b4b6f237cf894 = MAKE_CODEOBJECT(module_filename_obj, 1446, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___repr__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_4ccea98cae174f5c67a2d51a294f6880 = MAKE_CODEOBJECT(module_filename_obj, 1526, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___repr__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_53f581e08696ed1cb55d8d59dd2376ac = MAKE_CODEOBJECT(module_filename_obj, 1593, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___repr__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_de70240140ef9e6a0e5c1e2d00e223d2 = MAKE_CODEOBJECT(module_filename_obj, 1001, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain___repr__, const_tuple_40c66ae610f06e095b8a28b392d109cb_tuple, 1, 0, 0);
    codeobj_29760e1180446b273ed27a21f53c7d5b = MAKE_CODEOBJECT(module_filename_obj, 31, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain__key_identifier_from_public_key, const_tuple_str_plain_public_key_str_plain_serialized_str_plain_data_tuple, 1, 0, 0);
    codeobj_6e7680fc6f0882a572f93f3695c4ac8d = MAKE_CODEOBJECT(module_filename_obj, 1097, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain__validate_ip_name, const_tuple_str_plain_self_str_plain_tree_tuple, 2, 0, 0);
    codeobj_b961bdee1fe305fdfe9be48d53ac2abd = MAKE_CODEOBJECT(module_filename_obj, 992, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_decipher_only, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_7aaeec7d13e2fa45c91143278c9384ed = MAKE_CODEOBJECT(module_filename_obj, 983, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_encipher_only, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_b2c6519047820697d77e44d8bdcfd13b = MAKE_CODEOBJECT(module_filename_obj, 180, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_from_issuer_public_key, const_tuple_str_plain_cls_str_plain_public_key_str_plain_digest_tuple, 2, 0, 0);
    codeobj_a653d45da8baa6d488220c38863ffcf2 = MAKE_CODEOBJECT(module_filename_obj, 189, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_from_issuer_subject_key_identifier, const_tuple_str_plain_cls_str_plain_ski_tuple, 2, 0, 0);
    codeobj_3e69ec24bcd58b7600541c49b05642f9 = MAKE_CODEOBJECT(module_filename_obj, 242, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_from_public_key, const_tuple_str_plain_cls_str_plain_public_key_tuple, 2, 0, 0);
    codeobj_a3b7117cfaf5b59269aee17d1606e823 = MAKE_CODEOBJECT(module_filename_obj, 86, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_get_extension_for_class, const_tuple_str_plain_self_str_plain_extclass_str_plain_ext_tuple, 2, 0, 0);
    codeobj_44fcf979e33c233af5f80d7c35b13be4 = MAKE_CODEOBJECT(module_filename_obj, 79, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_get_extension_for_oid, const_tuple_str_plain_self_str_plain_oid_str_plain_ext_tuple, 2, 0, 0);
    codeobj_f68866006367fc4d498eabfdb2ce5eab = MAKE_CODEOBJECT(module_filename_obj, 1226, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_get_values_for_type, const_tuple_str_plain_self_str_plain_type_tuple, 2, 0, 0);
    codeobj_38fda1c9e56fc83bd693815271a1967a = MAKE_CODEOBJECT(module_filename_obj, 1261, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_get_values_for_type, const_tuple_str_plain_self_str_plain_type_tuple, 2, 0, 0);
    codeobj_54e466a14b6f5af1981cb3aaa414eccb = MAKE_CODEOBJECT(module_filename_obj, 1296, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_get_values_for_type, const_tuple_str_plain_self_str_plain_type_tuple, 2, 0, 0);
    codeobj_be19316fadb8714fcba11591040e6359 = MAKE_CODEOBJECT(module_filename_obj, 1185, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_get_values_for_type, const_tuple_str_plain_self_str_plain_type_str_plain_objs_tuple, 2, 0, 0);
    codeobj_cfe41ce1eddc8e60170273ac53a9bcf1 = MAKE_CODEOBJECT(module_filename_obj, 68, CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION, const_str_plain_oid, const_tuple_str_plain_self_tuple, 1, 0, 0);
}

// The module function declarations.
static PyObject *cryptography$x509$extensions$$$function_17___init__$$$genexpr_1_genexpr_maker(void);


static PyObject *cryptography$x509$extensions$$$function_30___init__$$$genexpr_1_genexpr_maker(void);


static PyObject *cryptography$x509$extensions$$$function_53___init__$$$genexpr_1_genexpr_maker(void);


static PyObject *cryptography$x509$extensions$$$function_61___init__$$$genexpr_1_genexpr_maker(void);


static PyObject *cryptography$x509$extensions$$$function_69___init__$$$genexpr_1_genexpr_maker(void);


static PyObject *cryptography$x509$extensions$$$function_69___init__$$$genexpr_2_genexpr_maker(void);


static PyObject *cryptography$x509$extensions$$$function_69___init__$$$genexpr_3_genexpr_maker(void);


static PyObject *cryptography$x509$extensions$$$function_79___init__$$$genexpr_1_genexpr_maker(void);


static PyObject *cryptography$x509$extensions$$$function_87___init__$$$genexpr_1_genexpr_maker(void);


static PyObject *cryptography$x509$extensions$$$function_97___init__$$$genexpr_1_genexpr_maker(void);


static PyObject *cryptography$x509$extensions$$$function_102___init__$$$genexpr_1_genexpr_maker(void);


static PyObject *cryptography$x509$extensions$$$function_109___init__$$$genexpr_1_genexpr_maker(void);


static PyObject *cryptography$x509$extensions$$$genexpr_1_genexpr_maker(void);


static PyObject *cryptography$x509$extensions$$$function_129___init__$$$genexpr_1_genexpr_maker(void);


static PyObject *cryptography$x509$extensions$$$function_129___init__$$$genexpr_2_genexpr_maker(void);


static PyObject *cryptography$x509$extensions$$$function_132__validate_ip_name$$$genexpr_1_genexpr_maker(void);


static PyObject *cryptography$x509$extensions$$$function_140___init__$$$genexpr_1_genexpr_maker(void);


static PyObject *cryptography$x509$extensions$$$function_143_get_values_for_type$$$genexpr_1_genexpr_maker(void);


static PyObject *cryptography$x509$extensions$$$function_143_get_values_for_type$$$genexpr_2_genexpr_maker(void);


static PyObject *cryptography$x509$extensions$$$function_186___init__$$$genexpr_1_genexpr_maker(void);


static PyObject *cryptography$x509$extensions$$$function_199___init__$$$genexpr_1_genexpr_maker(void);


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_100___ne__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_101___hash__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_102___init__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_103___iter__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_104___len__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_105___repr__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_106___eq__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_107___ne__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_108___hash__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_109___init__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_10___getitem__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_110___iter__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_111___len__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_112___repr__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_113___eq__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_114___getitem__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_115___ne__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_116___hash__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_117___init__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_118___repr__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_119___eq__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_11___repr__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_120___ne__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_121___hash__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_122___init__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_123_encipher_only();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_124_decipher_only();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_125___repr__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_126___eq__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_127___ne__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_128___hash__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_129___init__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_12___init__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_130___eq__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_131___ne__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_132__validate_ip_name();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_133___repr__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_134___hash__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_135___init__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_136___repr__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_137___eq__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_138___ne__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_139___hash__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_13___eq__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_140___init__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_141___iter__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_142___len__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_143_get_values_for_type();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_144___repr__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_145___eq__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_146___ne__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_147___getitem__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_148___hash__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_149___init__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_14___ne__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_150___iter__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_151___len__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_152_get_values_for_type();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_153___repr__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_154___eq__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_155___getitem__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_156___ne__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_157___hash__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_158___init__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_159___iter__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_15___hash__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_160___len__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_161_get_values_for_type();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_162___repr__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_163___eq__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_164___ne__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_165___getitem__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_166___hash__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_167___init__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_168___iter__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_169___len__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_16___repr__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_170_get_values_for_type();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_171___repr__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_172___eq__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_173___ne__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_174___getitem__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_175___hash__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_176___init__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_177___repr__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_178___eq__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_179___ne__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_17___init__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_180___hash__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_181___init__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_182___repr__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_183___eq__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_184___ne__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_185___hash__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_186___init__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_187___iter__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_188___len__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_189___getitem__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_18_from_issuer_public_key();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_190___repr__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_191___hash__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_192___eq__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_193___ne__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_194___init__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_195___eq__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_196___ne__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_197___hash__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_198___repr__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_199___init__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_19_from_issuer_subject_key_identifier();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_1__key_identifier_from_public_key();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_200___repr__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_201___eq__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_202___ne__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_203___hash__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_204___init__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_205___repr__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_206___eq__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_207___ne__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_208___hash__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_20___repr__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_21___eq__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_22___ne__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_23___hash__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_24___init__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_25_from_public_key();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_26___repr__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_27___eq__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_28___ne__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_29___hash__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_2___init__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_30___init__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_31___iter__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_32___len__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_33___repr__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_34___eq__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_35___ne__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_36___getitem__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_37___hash__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_38___init__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_39___repr__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_3___init__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_40___eq__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_41___ne__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_42___hash__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_43___init__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_44___repr__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_45___eq__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_46___ne__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_47___hash__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_48___init__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_49___eq__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_4_oid();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_50___ne__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_51___hash__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_52___repr__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_53___init__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_54___iter__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_55___len__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_56___repr__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_57___eq__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_58___ne__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_59___getitem__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_5___init__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_60___hash__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_61___init__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_62___iter__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_63___len__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_64___repr__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_65___eq__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_66___ne__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_67___getitem__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_68___hash__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_69___init__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_6_get_extension_for_oid();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_70___repr__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_71___eq__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_72___ne__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_73___hash__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_74___init__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_75___repr__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_76___eq__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_77___ne__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_78___hash__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_79___init__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_7_get_extension_for_class();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_80___iter__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_81___len__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_82___repr__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_83___eq__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_84___ne__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_85___getitem__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_86___hash__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_87___init__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_88___repr__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_89___eq__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_8___iter__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_90___ne__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_91___hash__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_92___init__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_93___repr__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_94___eq__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_95___ne__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_96___hash__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_97___init__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_98___repr__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_99___eq__();


static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_9___len__();


// The module function definitions.
static PyObject *impl_cryptography$x509$extensions$$$function_1__key_identifier_from_public_key(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_public_key = python_pars[0];
    PyObject *var_serialized = NULL;
    PyObject *var_data = NULL;
    struct Nuitka_FrameObject *frame_29760e1180446b273ed27a21f53c7d5b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_29760e1180446b273ed27a21f53c7d5b = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_29760e1180446b273ed27a21f53c7d5b, codeobj_29760e1180446b273ed27a21f53c7d5b, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_29760e1180446b273ed27a21f53c7d5b = cache_frame_29760e1180446b273ed27a21f53c7d5b;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_29760e1180446b273ed27a21f53c7d5b);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_29760e1180446b273ed27a21f53c7d5b) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_public_key);
        tmp_isinstance_inst_1 = par_public_key;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_RSAPublicKey);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_RSAPublicKey);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 11987 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 32;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 32;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_called_name_1;
            PyObject *tmp_source_name_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_source_name_2;
            PyObject *tmp_source_name_3;
            PyObject *tmp_mvar_value_2;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_source_name_4;
            PyObject *tmp_source_name_5;
            PyObject *tmp_mvar_value_3;
            CHECK_OBJECT(par_public_key);
            tmp_source_name_1 = par_public_key;
            tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_public_bytes);
            if (tmp_called_name_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 33;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_serialization);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_serialization);
            }

            if (tmp_mvar_value_2 == NULL) {
                Py_DECREF(tmp_called_name_1);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21865 ], 42, 0);
                exception_tb = NULL;

                exception_lineno = 34;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_3 = tmp_mvar_value_2;
            tmp_source_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_Encoding);
            if (tmp_source_name_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_1);

                exception_lineno = 34;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_DER);
            Py_DECREF(tmp_source_name_2);
            if (tmp_args_element_name_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_1);

                exception_lineno = 34;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_serialization);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_serialization);
            }

            if (tmp_mvar_value_3 == NULL) {
                Py_DECREF(tmp_called_name_1);
                Py_DECREF(tmp_args_element_name_1);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21865 ], 42, 0);
                exception_tb = NULL;

                exception_lineno = 35;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_5 = tmp_mvar_value_3;
            tmp_source_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_PublicFormat);
            if (tmp_source_name_4 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_1);
                Py_DECREF(tmp_args_element_name_1);

                exception_lineno = 35;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_PKCS1);
            Py_DECREF(tmp_source_name_4);
            if (tmp_args_element_name_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_1);
                Py_DECREF(tmp_args_element_name_1);

                exception_lineno = 35;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            frame_29760e1180446b273ed27a21f53c7d5b->m_frame.f_lineno = 33;
            {
                PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
                tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
            }

            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_element_name_1);
            Py_DECREF(tmp_args_element_name_2);
            if (tmp_assign_source_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 33;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            assert(var_data == NULL);
            var_data = tmp_assign_source_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_isinstance_inst_2;
            PyObject *tmp_isinstance_cls_2;
            PyObject *tmp_mvar_value_4;
            CHECK_OBJECT(par_public_key);
            tmp_isinstance_inst_2 = par_public_key;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_EllipticCurvePublicKey);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_EllipticCurvePublicKey);
            }

            if (tmp_mvar_value_4 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 35960 ], 51, 0);
                exception_tb = NULL;

                exception_lineno = 37;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }

            tmp_isinstance_cls_2 = tmp_mvar_value_4;
            tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_2, tmp_isinstance_cls_2);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 37;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
                goto branch_yes_2;
            } else {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_assign_source_2;
                PyObject *tmp_called_name_2;
                PyObject *tmp_source_name_6;
                PyObject *tmp_args_element_name_3;
                PyObject *tmp_source_name_7;
                PyObject *tmp_source_name_8;
                PyObject *tmp_mvar_value_5;
                PyObject *tmp_args_element_name_4;
                PyObject *tmp_source_name_9;
                PyObject *tmp_source_name_10;
                PyObject *tmp_mvar_value_6;
                CHECK_OBJECT(par_public_key);
                tmp_source_name_6 = par_public_key;
                tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_public_bytes);
                if (tmp_called_name_2 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 38;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_serialization);

                if (unlikely(tmp_mvar_value_5 == NULL)) {
                    tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_serialization);
                }

                if (tmp_mvar_value_5 == NULL) {
                    Py_DECREF(tmp_called_name_2);
                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 21865 ], 42, 0);
                    exception_tb = NULL;

                    exception_lineno = 39;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_8 = tmp_mvar_value_5;
                tmp_source_name_7 = LOOKUP_ATTRIBUTE(tmp_source_name_8, const_str_plain_Encoding);
                if (tmp_source_name_7 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    Py_DECREF(tmp_called_name_2);

                    exception_lineno = 39;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                tmp_args_element_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain_X962);
                Py_DECREF(tmp_source_name_7);
                if (tmp_args_element_name_3 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    Py_DECREF(tmp_called_name_2);

                    exception_lineno = 39;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_serialization);

                if (unlikely(tmp_mvar_value_6 == NULL)) {
                    tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_serialization);
                }

                if (tmp_mvar_value_6 == NULL) {
                    Py_DECREF(tmp_called_name_2);
                    Py_DECREF(tmp_args_element_name_3);
                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 21865 ], 42, 0);
                    exception_tb = NULL;

                    exception_lineno = 40;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_10 = tmp_mvar_value_6;
                tmp_source_name_9 = LOOKUP_ATTRIBUTE(tmp_source_name_10, const_str_plain_PublicFormat);
                if (tmp_source_name_9 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    Py_DECREF(tmp_called_name_2);
                    Py_DECREF(tmp_args_element_name_3);

                    exception_lineno = 40;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                tmp_args_element_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_9, const_str_plain_UncompressedPoint);
                Py_DECREF(tmp_source_name_9);
                if (tmp_args_element_name_4 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    Py_DECREF(tmp_called_name_2);
                    Py_DECREF(tmp_args_element_name_3);

                    exception_lineno = 40;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                frame_29760e1180446b273ed27a21f53c7d5b->m_frame.f_lineno = 38;
                {
                    PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4};
                    tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
                }

                Py_DECREF(tmp_called_name_2);
                Py_DECREF(tmp_args_element_name_3);
                Py_DECREF(tmp_args_element_name_4);
                if (tmp_assign_source_2 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 38;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                assert(var_data == NULL);
                var_data = tmp_assign_source_2;
            }
            goto branch_end_2;
            branch_no_2:;
            {
                PyObject *tmp_assign_source_3;
                PyObject *tmp_called_name_3;
                PyObject *tmp_source_name_11;
                PyObject *tmp_args_element_name_5;
                PyObject *tmp_source_name_12;
                PyObject *tmp_source_name_13;
                PyObject *tmp_mvar_value_7;
                PyObject *tmp_args_element_name_6;
                PyObject *tmp_source_name_14;
                PyObject *tmp_source_name_15;
                PyObject *tmp_mvar_value_8;
                CHECK_OBJECT(par_public_key);
                tmp_source_name_11 = par_public_key;
                tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_11, const_str_plain_public_bytes);
                if (tmp_called_name_3 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 44;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_serialization);

                if (unlikely(tmp_mvar_value_7 == NULL)) {
                    tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_serialization);
                }

                if (tmp_mvar_value_7 == NULL) {
                    Py_DECREF(tmp_called_name_3);
                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 21865 ], 42, 0);
                    exception_tb = NULL;

                    exception_lineno = 45;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_13 = tmp_mvar_value_7;
                tmp_source_name_12 = LOOKUP_ATTRIBUTE(tmp_source_name_13, const_str_plain_Encoding);
                if (tmp_source_name_12 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    Py_DECREF(tmp_called_name_3);

                    exception_lineno = 45;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                tmp_args_element_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_12, const_str_plain_DER);
                Py_DECREF(tmp_source_name_12);
                if (tmp_args_element_name_5 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    Py_DECREF(tmp_called_name_3);

                    exception_lineno = 45;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_serialization);

                if (unlikely(tmp_mvar_value_8 == NULL)) {
                    tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_serialization);
                }

                if (tmp_mvar_value_8 == NULL) {
                    Py_DECREF(tmp_called_name_3);
                    Py_DECREF(tmp_args_element_name_5);
                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 21865 ], 42, 0);
                    exception_tb = NULL;

                    exception_lineno = 46;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_15 = tmp_mvar_value_8;
                tmp_source_name_14 = LOOKUP_ATTRIBUTE(tmp_source_name_15, const_str_plain_PublicFormat);
                if (tmp_source_name_14 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    Py_DECREF(tmp_called_name_3);
                    Py_DECREF(tmp_args_element_name_5);

                    exception_lineno = 46;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                tmp_args_element_name_6 = LOOKUP_ATTRIBUTE(tmp_source_name_14, const_str_plain_SubjectPublicKeyInfo);
                Py_DECREF(tmp_source_name_14);
                if (tmp_args_element_name_6 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    Py_DECREF(tmp_called_name_3);
                    Py_DECREF(tmp_args_element_name_5);

                    exception_lineno = 46;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                frame_29760e1180446b273ed27a21f53c7d5b->m_frame.f_lineno = 44;
                {
                    PyObject *call_args[] = {tmp_args_element_name_5, tmp_args_element_name_6};
                    tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_3, call_args);
                }

                Py_DECREF(tmp_called_name_3);
                Py_DECREF(tmp_args_element_name_5);
                Py_DECREF(tmp_args_element_name_6);
                if (tmp_assign_source_3 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 44;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                assert(var_serialized == NULL);
                var_serialized = tmp_assign_source_3;
            }
            {
                PyObject *tmp_assign_source_4;
                PyObject *tmp_str_arg_1;
                PyObject *tmp_subscribed_name_1;
                PyObject *tmp_called_instance_1;
                PyObject *tmp_mvar_value_9;
                PyObject *tmp_args_element_name_7;
                PyObject *tmp_subscript_name_1;
                tmp_mvar_value_9 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_PublicKeyInfo);

                if (unlikely(tmp_mvar_value_9 == NULL)) {
                    tmp_mvar_value_9 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_PublicKeyInfo);
                }

                if (tmp_mvar_value_9 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 12357 ], 42, 0);
                    exception_tb = NULL;

                    exception_lineno = 49;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_instance_1 = tmp_mvar_value_9;
                CHECK_OBJECT(var_serialized);
                tmp_args_element_name_7 = var_serialized;
                frame_29760e1180446b273ed27a21f53c7d5b->m_frame.f_lineno = 49;
                {
                    PyObject *call_args[] = {tmp_args_element_name_7};
                    tmp_subscribed_name_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_load, call_args);
                }

                if (tmp_subscribed_name_1 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 49;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                tmp_subscript_name_1 = const_str_plain_public_key;
                tmp_str_arg_1 = LOOKUP_SUBSCRIPT(tmp_subscribed_name_1, tmp_subscript_name_1);
                Py_DECREF(tmp_subscribed_name_1);
                if (tmp_str_arg_1 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 49;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                tmp_assign_source_4 = PyObject_Str(tmp_str_arg_1);
                Py_DECREF(tmp_str_arg_1);
                if (tmp_assign_source_4 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 49;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                assert(var_data == NULL);
                var_data = tmp_assign_source_4;
            }
            branch_end_2:;
        }
        branch_end_1:;
    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_16;
        PyObject *tmp_mvar_value_10;
        PyObject *tmp_args_element_name_8;
        tmp_mvar_value_10 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_hashlib);

        if (unlikely(tmp_mvar_value_10 == NULL)) {
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_hashlib);
        }

        if (tmp_mvar_value_10 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 12399 ], 36, 0);
            exception_tb = NULL;

            exception_lineno = 51;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_16 = tmp_mvar_value_10;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_16, const_str_plain_sha1);
        if (tmp_called_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 51;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        if (var_data == NULL) {
            Py_DECREF(tmp_called_name_4);
            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("local variable '%s' referenced before assignment", "data");
            exception_tb = NULL;

            exception_lineno = 51;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_8 = var_data;
        frame_29760e1180446b273ed27a21f53c7d5b->m_frame.f_lineno = 51;
        tmp_called_instance_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_4, tmp_args_element_name_8);
        Py_DECREF(tmp_called_name_4);
        if (tmp_called_instance_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 51;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_29760e1180446b273ed27a21f53c7d5b->m_frame.f_lineno = 51;
        tmp_return_value = CALL_METHOD_NO_ARGS(tmp_called_instance_2, const_str_plain_digest);
        Py_DECREF(tmp_called_instance_2);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 51;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_29760e1180446b273ed27a21f53c7d5b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_29760e1180446b273ed27a21f53c7d5b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_29760e1180446b273ed27a21f53c7d5b);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_29760e1180446b273ed27a21f53c7d5b, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_29760e1180446b273ed27a21f53c7d5b->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_29760e1180446b273ed27a21f53c7d5b, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_29760e1180446b273ed27a21f53c7d5b,
        type_description_1,
        par_public_key,
        var_serialized,
        var_data
    );


    // Release cached frame.
    if (frame_29760e1180446b273ed27a21f53c7d5b == cache_frame_29760e1180446b273ed27a21f53c7d5b) {
        Py_DECREF(frame_29760e1180446b273ed27a21f53c7d5b);
    }
    cache_frame_29760e1180446b273ed27a21f53c7d5b = NULL;

    assertFrameObject(frame_29760e1180446b273ed27a21f53c7d5b);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_1__key_identifier_from_public_key);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_serialized);
    var_serialized = NULL;

    Py_XDECREF(var_data);
    var_data = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_serialized);
    var_serialized = NULL;

    Py_XDECREF(var_data);
    var_data = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_1__key_identifier_from_public_key);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_public_key);
    Py_DECREF(par_public_key);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_public_key);
    Py_DECREF(par_public_key);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_2___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_msg = python_pars[1];
    PyObject *par_oid = python_pars[2];
    struct Nuitka_FrameObject *frame_a639918ff9b53f9ac4ca97850d09e8b5;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_a639918ff9b53f9ac4ca97850d09e8b5 = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_a639918ff9b53f9ac4ca97850d09e8b5, codeobj_a639918ff9b53f9ac4ca97850d09e8b5, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_a639918ff9b53f9ac4ca97850d09e8b5 = cache_frame_a639918ff9b53f9ac4ca97850d09e8b5;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_a639918ff9b53f9ac4ca97850d09e8b5);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_a639918ff9b53f9ac4ca97850d09e8b5) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_type_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_object_name_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_DuplicateExtension);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_DuplicateExtension);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 36011 ], 47, 0);
            exception_tb = NULL;

            exception_lineno = 56;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_type_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT(par_self);
        tmp_object_name_1 = par_self;
        tmp_called_instance_1 = BUILTIN_SUPER(tmp_type_name_1, tmp_object_name_1);
        if (tmp_called_instance_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 56;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_msg);
        tmp_args_element_name_1 = par_msg;
        frame_a639918ff9b53f9ac4ca97850d09e8b5->m_frame.f_lineno = 56;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain___init__, call_args);
        }

        Py_DECREF(tmp_called_instance_1);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 56;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_oid);
        tmp_assattr_name_1 = par_oid;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain_oid, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 57;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a639918ff9b53f9ac4ca97850d09e8b5);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a639918ff9b53f9ac4ca97850d09e8b5);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_a639918ff9b53f9ac4ca97850d09e8b5, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_a639918ff9b53f9ac4ca97850d09e8b5->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_a639918ff9b53f9ac4ca97850d09e8b5, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a639918ff9b53f9ac4ca97850d09e8b5,
        type_description_1,
        par_self,
        par_msg,
        par_oid
    );


    // Release cached frame.
    if (frame_a639918ff9b53f9ac4ca97850d09e8b5 == cache_frame_a639918ff9b53f9ac4ca97850d09e8b5) {
        Py_DECREF(frame_a639918ff9b53f9ac4ca97850d09e8b5);
    }
    cache_frame_a639918ff9b53f9ac4ca97850d09e8b5 = NULL;

    assertFrameObject(frame_a639918ff9b53f9ac4ca97850d09e8b5);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_2___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_msg);
    Py_DECREF(par_msg);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_oid);
    Py_DECREF(par_oid);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_msg);
    Py_DECREF(par_msg);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_oid);
    Py_DECREF(par_oid);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_3___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_msg = python_pars[1];
    PyObject *par_oid = python_pars[2];
    struct Nuitka_FrameObject *frame_060b6428f7e0298a84738a381d9a7335;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_060b6428f7e0298a84738a381d9a7335 = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_060b6428f7e0298a84738a381d9a7335, codeobj_060b6428f7e0298a84738a381d9a7335, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_060b6428f7e0298a84738a381d9a7335 = cache_frame_060b6428f7e0298a84738a381d9a7335;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_060b6428f7e0298a84738a381d9a7335);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_060b6428f7e0298a84738a381d9a7335) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_type_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_object_name_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionNotFound);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionNotFound);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 36058 ], 46, 0);
            exception_tb = NULL;

            exception_lineno = 62;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_type_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT(par_self);
        tmp_object_name_1 = par_self;
        tmp_called_instance_1 = BUILTIN_SUPER(tmp_type_name_1, tmp_object_name_1);
        if (tmp_called_instance_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 62;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_msg);
        tmp_args_element_name_1 = par_msg;
        frame_060b6428f7e0298a84738a381d9a7335->m_frame.f_lineno = 62;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain___init__, call_args);
        }

        Py_DECREF(tmp_called_instance_1);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 62;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_oid);
        tmp_assattr_name_1 = par_oid;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain_oid, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 63;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_060b6428f7e0298a84738a381d9a7335);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_060b6428f7e0298a84738a381d9a7335);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_060b6428f7e0298a84738a381d9a7335, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_060b6428f7e0298a84738a381d9a7335->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_060b6428f7e0298a84738a381d9a7335, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_060b6428f7e0298a84738a381d9a7335,
        type_description_1,
        par_self,
        par_msg,
        par_oid
    );


    // Release cached frame.
    if (frame_060b6428f7e0298a84738a381d9a7335 == cache_frame_060b6428f7e0298a84738a381d9a7335) {
        Py_DECREF(frame_060b6428f7e0298a84738a381d9a7335);
    }
    cache_frame_060b6428f7e0298a84738a381d9a7335 = NULL;

    assertFrameObject(frame_060b6428f7e0298a84738a381d9a7335);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_3___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_msg);
    Py_DECREF(par_msg);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_oid);
    Py_DECREF(par_oid);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_msg);
    Py_DECREF(par_msg);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_oid);
    Py_DECREF(par_oid);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_5___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_extensions = python_pars[1];
    struct Nuitka_FrameObject *frame_ccb81d58c538921fd6eadf0f5f9021bf;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_ccb81d58c538921fd6eadf0f5f9021bf = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_ccb81d58c538921fd6eadf0f5f9021bf, codeobj_ccb81d58c538921fd6eadf0f5f9021bf, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_ccb81d58c538921fd6eadf0f5f9021bf = cache_frame_ccb81d58c538921fd6eadf0f5f9021bf;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_ccb81d58c538921fd6eadf0f5f9021bf);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_ccb81d58c538921fd6eadf0f5f9021bf) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_extensions);
        tmp_assattr_name_1 = par_extensions;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__extensions, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 77;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ccb81d58c538921fd6eadf0f5f9021bf);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ccb81d58c538921fd6eadf0f5f9021bf);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_ccb81d58c538921fd6eadf0f5f9021bf, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_ccb81d58c538921fd6eadf0f5f9021bf->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_ccb81d58c538921fd6eadf0f5f9021bf, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ccb81d58c538921fd6eadf0f5f9021bf,
        type_description_1,
        par_self,
        par_extensions
    );


    // Release cached frame.
    if (frame_ccb81d58c538921fd6eadf0f5f9021bf == cache_frame_ccb81d58c538921fd6eadf0f5f9021bf) {
        Py_DECREF(frame_ccb81d58c538921fd6eadf0f5f9021bf);
    }
    cache_frame_ccb81d58c538921fd6eadf0f5f9021bf = NULL;

    assertFrameObject(frame_ccb81d58c538921fd6eadf0f5f9021bf);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_5___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_extensions);
    Py_DECREF(par_extensions);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_extensions);
    Py_DECREF(par_extensions);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_6_get_extension_for_oid(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_oid = python_pars[1];
    PyObject *var_ext = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_44fcf979e33c233af5f80d7c35b13be4;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_44fcf979e33c233af5f80d7c35b13be4 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_44fcf979e33c233af5f80d7c35b13be4, codeobj_44fcf979e33c233af5f80d7c35b13be4, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_44fcf979e33c233af5f80d7c35b13be4 = cache_frame_44fcf979e33c233af5f80d7c35b13be4;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_44fcf979e33c233af5f80d7c35b13be4);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_44fcf979e33c233af5f80d7c35b13be4) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_iter_arg_1;
        CHECK_OBJECT(par_self);
        tmp_iter_arg_1 = par_self;
        tmp_assign_source_1 = MAKE_ITERATOR(tmp_iter_arg_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 80;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(tmp_for_loop_1__for_iterator == NULL);
        tmp_for_loop_1__for_iterator = tmp_assign_source_1;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT(tmp_for_loop_1__for_iterator);
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_2 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_2 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "ooo";
                exception_lineno = 80;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_2;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_3;
        CHECK_OBJECT(tmp_for_loop_1__iter_value);
        tmp_assign_source_3 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_ext;
            var_ext = tmp_assign_source_3;
            Py_INCREF(var_ext);
            Py_XDECREF(old);
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(var_ext);
        tmp_source_name_1 = var_ext;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_oid);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 81;
            type_description_1 = "ooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT(par_oid);
        tmp_compexpr_right_1 = par_oid;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 81;
            type_description_1 = "ooo";
            goto try_except_handler_2;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        CHECK_OBJECT(var_ext);
        tmp_return_value = var_ext;
        Py_INCREF(tmp_return_value);
        goto try_return_handler_2;
        branch_no_1:;
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


        exception_lineno = 80;
        type_description_1 = "ooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT((PyObject *)tmp_for_loop_1__iter_value);
    Py_DECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    goto frame_return_exit_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    {
        PyObject *tmp_raise_type_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionNotFound);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionNotFound);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 36058 ], 46, 0);
            exception_tb = NULL;

            exception_lineno = 84;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        tmp_called_instance_1 = const_str_digest_6e39999ae9fa2f733baa4157c3ce7ef9;
        CHECK_OBJECT(par_oid);
        tmp_args_element_name_2 = par_oid;
        frame_44fcf979e33c233af5f80d7c35b13be4->m_frame.f_lineno = 84;
        {
            PyObject *call_args[] = {tmp_args_element_name_2};
            tmp_args_element_name_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_format, call_args);
        }

        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 84;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_oid);
        tmp_args_element_name_3 = par_oid;
        frame_44fcf979e33c233af5f80d7c35b13be4->m_frame.f_lineno = 84;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_3};
            tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_args_element_name_1);
        if (tmp_raise_type_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 84;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        exception_type = tmp_raise_type_1;
        exception_lineno = 84;
        RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_44fcf979e33c233af5f80d7c35b13be4);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_44fcf979e33c233af5f80d7c35b13be4);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_44fcf979e33c233af5f80d7c35b13be4);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_44fcf979e33c233af5f80d7c35b13be4, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_44fcf979e33c233af5f80d7c35b13be4->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_44fcf979e33c233af5f80d7c35b13be4, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_44fcf979e33c233af5f80d7c35b13be4,
        type_description_1,
        par_self,
        par_oid,
        var_ext
    );


    // Release cached frame.
    if (frame_44fcf979e33c233af5f80d7c35b13be4 == cache_frame_44fcf979e33c233af5f80d7c35b13be4) {
        Py_DECREF(frame_44fcf979e33c233af5f80d7c35b13be4);
    }
    cache_frame_44fcf979e33c233af5f80d7c35b13be4 = NULL;

    assertFrameObject(frame_44fcf979e33c233af5f80d7c35b13be4);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_6_get_extension_for_oid);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_ext);
    Py_DECREF(var_ext);
    var_ext = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_ext);
    var_ext = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_6_get_extension_for_oid);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_oid);
    Py_DECREF(par_oid);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_oid);
    Py_DECREF(par_oid);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_7_get_extension_for_class(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_extclass = python_pars[1];
    PyObject *var_ext = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_a3b7117cfaf5b59269aee17d1606e823;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_a3b7117cfaf5b59269aee17d1606e823 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_a3b7117cfaf5b59269aee17d1606e823, codeobj_a3b7117cfaf5b59269aee17d1606e823, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_a3b7117cfaf5b59269aee17d1606e823 = cache_frame_a3b7117cfaf5b59269aee17d1606e823;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_a3b7117cfaf5b59269aee17d1606e823);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_a3b7117cfaf5b59269aee17d1606e823) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_extclass);
        tmp_compexpr_left_1 = par_extclass;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_UnrecognizedExtension);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_UnrecognizedExtension);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 36104 ], 50, 0);
            exception_tb = NULL;

            exception_lineno = 87;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_f7d33cb69a7dc22294881ff5b1fe0ec9;
            frame_a3b7117cfaf5b59269aee17d1606e823->m_frame.f_lineno = 88;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 88;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_iter_arg_1;
        CHECK_OBJECT(par_self);
        tmp_iter_arg_1 = par_self;
        tmp_assign_source_1 = MAKE_ITERATOR(tmp_iter_arg_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 94;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(tmp_for_loop_1__for_iterator == NULL);
        tmp_for_loop_1__for_iterator = tmp_assign_source_1;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT(tmp_for_loop_1__for_iterator);
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_2 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_2 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "ooo";
                exception_lineno = 94;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_2;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_3;
        CHECK_OBJECT(tmp_for_loop_1__iter_value);
        tmp_assign_source_3 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_ext;
            var_ext = tmp_assign_source_3;
            Py_INCREF(var_ext);
            Py_XDECREF(old);
        }

    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(var_ext);
        tmp_source_name_1 = var_ext;
        tmp_isinstance_inst_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_value);
        if (tmp_isinstance_inst_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 95;
            type_description_1 = "ooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT(par_extclass);
        tmp_isinstance_cls_1 = par_extclass;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        Py_DECREF(tmp_isinstance_inst_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 95;
            type_description_1 = "ooo";
            goto try_except_handler_2;
        }
        tmp_condition_result_2 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        CHECK_OBJECT(var_ext);
        tmp_return_value = var_ext;
        Py_INCREF(tmp_return_value);
        goto try_return_handler_2;
        branch_no_2:;
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


        exception_lineno = 94;
        type_description_1 = "ooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT((PyObject *)tmp_for_loop_1__iter_value);
    Py_DECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    goto frame_return_exit_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    {
        PyObject *tmp_raise_type_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionNotFound);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionNotFound);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 36058 ], 46, 0);
            exception_tb = NULL;

            exception_lineno = 98;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_2;
        tmp_called_instance_1 = const_str_digest_6e39999ae9fa2f733baa4157c3ce7ef9;
        CHECK_OBJECT(par_extclass);
        tmp_args_element_name_2 = par_extclass;
        frame_a3b7117cfaf5b59269aee17d1606e823->m_frame.f_lineno = 99;
        {
            PyObject *call_args[] = {tmp_args_element_name_2};
            tmp_args_element_name_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_format, call_args);
        }

        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 99;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_extclass);
        tmp_source_name_2 = par_extclass;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_oid);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_args_element_name_1);

            exception_lineno = 99;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_a3b7117cfaf5b59269aee17d1606e823->m_frame.f_lineno = 98;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_3};
            tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_args_element_name_1);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_raise_type_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 98;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        exception_type = tmp_raise_type_2;
        exception_lineno = 98;
        RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a3b7117cfaf5b59269aee17d1606e823);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_a3b7117cfaf5b59269aee17d1606e823);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a3b7117cfaf5b59269aee17d1606e823);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_a3b7117cfaf5b59269aee17d1606e823, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_a3b7117cfaf5b59269aee17d1606e823->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_a3b7117cfaf5b59269aee17d1606e823, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a3b7117cfaf5b59269aee17d1606e823,
        type_description_1,
        par_self,
        par_extclass,
        var_ext
    );


    // Release cached frame.
    if (frame_a3b7117cfaf5b59269aee17d1606e823 == cache_frame_a3b7117cfaf5b59269aee17d1606e823) {
        Py_DECREF(frame_a3b7117cfaf5b59269aee17d1606e823);
    }
    cache_frame_a3b7117cfaf5b59269aee17d1606e823 = NULL;

    assertFrameObject(frame_a3b7117cfaf5b59269aee17d1606e823);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_7_get_extension_for_class);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_ext);
    Py_DECREF(var_ext);
    var_ext = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_ext);
    var_ext = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_7_get_extension_for_class);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_extclass);
    Py_DECREF(par_extclass);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_extclass);
    Py_DECREF(par_extclass);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_8___iter__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_2a0bf5a2c89e7fa0fdc8aac5f0ceb989;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_2a0bf5a2c89e7fa0fdc8aac5f0ceb989 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_2a0bf5a2c89e7fa0fdc8aac5f0ceb989, codeobj_2a0bf5a2c89e7fa0fdc8aac5f0ceb989, module_cryptography$x509$extensions, sizeof(void *));
    frame_2a0bf5a2c89e7fa0fdc8aac5f0ceb989 = cache_frame_2a0bf5a2c89e7fa0fdc8aac5f0ceb989;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_2a0bf5a2c89e7fa0fdc8aac5f0ceb989);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_2a0bf5a2c89e7fa0fdc8aac5f0ceb989) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_iter_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__extensions);
        if (tmp_iter_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 103;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = MAKE_ITERATOR(tmp_iter_arg_1);
        Py_DECREF(tmp_iter_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 103;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2a0bf5a2c89e7fa0fdc8aac5f0ceb989);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_2a0bf5a2c89e7fa0fdc8aac5f0ceb989);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2a0bf5a2c89e7fa0fdc8aac5f0ceb989);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_2a0bf5a2c89e7fa0fdc8aac5f0ceb989, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_2a0bf5a2c89e7fa0fdc8aac5f0ceb989->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_2a0bf5a2c89e7fa0fdc8aac5f0ceb989, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2a0bf5a2c89e7fa0fdc8aac5f0ceb989,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_2a0bf5a2c89e7fa0fdc8aac5f0ceb989 == cache_frame_2a0bf5a2c89e7fa0fdc8aac5f0ceb989) {
        Py_DECREF(frame_2a0bf5a2c89e7fa0fdc8aac5f0ceb989);
    }
    cache_frame_2a0bf5a2c89e7fa0fdc8aac5f0ceb989 = NULL;

    assertFrameObject(frame_2a0bf5a2c89e7fa0fdc8aac5f0ceb989);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_8___iter__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_9___len__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_df6b91143147712a389f7e389566de10;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_df6b91143147712a389f7e389566de10 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_df6b91143147712a389f7e389566de10, codeobj_df6b91143147712a389f7e389566de10, module_cryptography$x509$extensions, sizeof(void *));
    frame_df6b91143147712a389f7e389566de10 = cache_frame_df6b91143147712a389f7e389566de10;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_df6b91143147712a389f7e389566de10);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_df6b91143147712a389f7e389566de10) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_len_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_len_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__extensions);
        if (tmp_len_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 106;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = BUILTIN_LEN(tmp_len_arg_1);
        Py_DECREF(tmp_len_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 106;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_df6b91143147712a389f7e389566de10);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_df6b91143147712a389f7e389566de10);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_df6b91143147712a389f7e389566de10);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_df6b91143147712a389f7e389566de10, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_df6b91143147712a389f7e389566de10->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_df6b91143147712a389f7e389566de10, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_df6b91143147712a389f7e389566de10,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_df6b91143147712a389f7e389566de10 == cache_frame_df6b91143147712a389f7e389566de10) {
        Py_DECREF(frame_df6b91143147712a389f7e389566de10);
    }
    cache_frame_df6b91143147712a389f7e389566de10 = NULL;

    assertFrameObject(frame_df6b91143147712a389f7e389566de10);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_9___len__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_10___getitem__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_idx = python_pars[1];
    struct Nuitka_FrameObject *frame_60d2d44b2848d82367f482e630058a14;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_60d2d44b2848d82367f482e630058a14 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_60d2d44b2848d82367f482e630058a14, codeobj_60d2d44b2848d82367f482e630058a14, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_60d2d44b2848d82367f482e630058a14 = cache_frame_60d2d44b2848d82367f482e630058a14;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_60d2d44b2848d82367f482e630058a14);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_60d2d44b2848d82367f482e630058a14) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_subscript_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__extensions);
        if (tmp_subscribed_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 109;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_idx);
        tmp_subscript_name_1 = par_idx;
        tmp_return_value = LOOKUP_SUBSCRIPT(tmp_subscribed_name_1, tmp_subscript_name_1);
        Py_DECREF(tmp_subscribed_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 109;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_60d2d44b2848d82367f482e630058a14);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_60d2d44b2848d82367f482e630058a14);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_60d2d44b2848d82367f482e630058a14);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_60d2d44b2848d82367f482e630058a14, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_60d2d44b2848d82367f482e630058a14->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_60d2d44b2848d82367f482e630058a14, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_60d2d44b2848d82367f482e630058a14,
        type_description_1,
        par_self,
        par_idx
    );


    // Release cached frame.
    if (frame_60d2d44b2848d82367f482e630058a14 == cache_frame_60d2d44b2848d82367f482e630058a14) {
        Py_DECREF(frame_60d2d44b2848d82367f482e630058a14);
    }
    cache_frame_60d2d44b2848d82367f482e630058a14 = NULL;

    assertFrameObject(frame_60d2d44b2848d82367f482e630058a14);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_10___getitem__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_idx);
    Py_DECREF(par_idx);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_idx);
    Py_DECREF(par_idx);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_11___repr__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_8405f2e69630444edfa5d22fe7c6076e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_8405f2e69630444edfa5d22fe7c6076e = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_8405f2e69630444edfa5d22fe7c6076e, codeobj_8405f2e69630444edfa5d22fe7c6076e, module_cryptography$x509$extensions, sizeof(void *));
    frame_8405f2e69630444edfa5d22fe7c6076e = cache_frame_8405f2e69630444edfa5d22fe7c6076e;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_8405f2e69630444edfa5d22fe7c6076e);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_8405f2e69630444edfa5d22fe7c6076e) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_source_name_1 = const_str_digest_e29a6013213dd6497cd7c55bc7864351;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_format);
        assert(!(tmp_called_name_1 == NULL));
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__extensions);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 113;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_8405f2e69630444edfa5d22fe7c6076e->m_frame.f_lineno = 113;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 113;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8405f2e69630444edfa5d22fe7c6076e);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_8405f2e69630444edfa5d22fe7c6076e);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8405f2e69630444edfa5d22fe7c6076e);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_8405f2e69630444edfa5d22fe7c6076e, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_8405f2e69630444edfa5d22fe7c6076e->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_8405f2e69630444edfa5d22fe7c6076e, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8405f2e69630444edfa5d22fe7c6076e,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_8405f2e69630444edfa5d22fe7c6076e == cache_frame_8405f2e69630444edfa5d22fe7c6076e) {
        Py_DECREF(frame_8405f2e69630444edfa5d22fe7c6076e);
    }
    cache_frame_8405f2e69630444edfa5d22fe7c6076e = NULL;

    assertFrameObject(frame_8405f2e69630444edfa5d22fe7c6076e);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_11___repr__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_12___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_crl_number = python_pars[1];
    struct Nuitka_FrameObject *frame_3e9816c5343a0a17dd4693ad9ed8aef1;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_3e9816c5343a0a17dd4693ad9ed8aef1 = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_3e9816c5343a0a17dd4693ad9ed8aef1, codeobj_3e9816c5343a0a17dd4693ad9ed8aef1, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_3e9816c5343a0a17dd4693ad9ed8aef1 = cache_frame_3e9816c5343a0a17dd4693ad9ed8aef1;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_3e9816c5343a0a17dd4693ad9ed8aef1);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_3e9816c5343a0a17dd4693ad9ed8aef1) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_crl_number);
        tmp_isinstance_inst_1 = par_crl_number;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_six);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_six);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 19694 ], 32, 0);
            exception_tb = NULL;

            exception_lineno = 122;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_isinstance_cls_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_integer_types);
        if (tmp_isinstance_cls_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 122;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        Py_DECREF(tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 122;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 122;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_f7714799e19abc5d09ccbaf8366649ea;
            frame_3e9816c5343a0a17dd4693ad9ed8aef1->m_frame.f_lineno = 123;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 123;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_crl_number);
        tmp_assattr_name_1 = par_crl_number;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__crl_number, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 125;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3e9816c5343a0a17dd4693ad9ed8aef1);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3e9816c5343a0a17dd4693ad9ed8aef1);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_3e9816c5343a0a17dd4693ad9ed8aef1, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_3e9816c5343a0a17dd4693ad9ed8aef1->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_3e9816c5343a0a17dd4693ad9ed8aef1, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3e9816c5343a0a17dd4693ad9ed8aef1,
        type_description_1,
        par_self,
        par_crl_number
    );


    // Release cached frame.
    if (frame_3e9816c5343a0a17dd4693ad9ed8aef1 == cache_frame_3e9816c5343a0a17dd4693ad9ed8aef1) {
        Py_DECREF(frame_3e9816c5343a0a17dd4693ad9ed8aef1);
    }
    cache_frame_3e9816c5343a0a17dd4693ad9ed8aef1 = NULL;

    assertFrameObject(frame_3e9816c5343a0a17dd4693ad9ed8aef1);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_12___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_crl_number);
    Py_DECREF(par_crl_number);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_crl_number);
    Py_DECREF(par_crl_number);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_13___eq__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_5be6c71ea22dc937c8590e3714a0e70f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_5be6c71ea22dc937c8590e3714a0e70f = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_5be6c71ea22dc937c8590e3714a0e70f, codeobj_5be6c71ea22dc937c8590e3714a0e70f, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_5be6c71ea22dc937c8590e3714a0e70f = cache_frame_5be6c71ea22dc937c8590e3714a0e70f;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_5be6c71ea22dc937c8590e3714a0e70f);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_5be6c71ea22dc937c8590e3714a0e70f) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_other);
        tmp_isinstance_inst_1 = par_other;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_CRLNumber);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_CRLNumber);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 36154 ], 38, 0);
            exception_tb = NULL;

            exception_lineno = 128;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 128;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 128;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_crl_number);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 131;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_2 = par_other;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_crl_number);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_1);

            exception_lineno = 131;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 131;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5be6c71ea22dc937c8590e3714a0e70f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_5be6c71ea22dc937c8590e3714a0e70f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5be6c71ea22dc937c8590e3714a0e70f);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_5be6c71ea22dc937c8590e3714a0e70f, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_5be6c71ea22dc937c8590e3714a0e70f->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_5be6c71ea22dc937c8590e3714a0e70f, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5be6c71ea22dc937c8590e3714a0e70f,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_5be6c71ea22dc937c8590e3714a0e70f == cache_frame_5be6c71ea22dc937c8590e3714a0e70f) {
        Py_DECREF(frame_5be6c71ea22dc937c8590e3714a0e70f);
    }
    cache_frame_5be6c71ea22dc937c8590e3714a0e70f = NULL;

    assertFrameObject(frame_5be6c71ea22dc937c8590e3714a0e70f);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_13___eq__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_14___ne__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_e290bf4f69c1366e896d88d19cc6fb02;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_e290bf4f69c1366e896d88d19cc6fb02 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_e290bf4f69c1366e896d88d19cc6fb02, codeobj_e290bf4f69c1366e896d88d19cc6fb02, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_e290bf4f69c1366e896d88d19cc6fb02 = cache_frame_e290bf4f69c1366e896d88d19cc6fb02;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_e290bf4f69c1366e896d88d19cc6fb02);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_e290bf4f69c1366e896d88d19cc6fb02) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_self);
        tmp_compexpr_left_1 = par_self;
        CHECK_OBJECT(par_other);
        tmp_compexpr_right_1 = par_other;
        tmp_operand_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 134;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 134;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = (tmp_res == 0) ? Py_True : Py_False;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e290bf4f69c1366e896d88d19cc6fb02);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_e290bf4f69c1366e896d88d19cc6fb02);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e290bf4f69c1366e896d88d19cc6fb02);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_e290bf4f69c1366e896d88d19cc6fb02, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_e290bf4f69c1366e896d88d19cc6fb02->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_e290bf4f69c1366e896d88d19cc6fb02, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e290bf4f69c1366e896d88d19cc6fb02,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_e290bf4f69c1366e896d88d19cc6fb02 == cache_frame_e290bf4f69c1366e896d88d19cc6fb02) {
        Py_DECREF(frame_e290bf4f69c1366e896d88d19cc6fb02);
    }
    cache_frame_e290bf4f69c1366e896d88d19cc6fb02 = NULL;

    assertFrameObject(frame_e290bf4f69c1366e896d88d19cc6fb02);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_14___ne__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_15___hash__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_dccf9a51dd0e5d88d3e5ed45b6d434bd;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_dccf9a51dd0e5d88d3e5ed45b6d434bd = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_dccf9a51dd0e5d88d3e5ed45b6d434bd, codeobj_dccf9a51dd0e5d88d3e5ed45b6d434bd, module_cryptography$x509$extensions, sizeof(void *));
    frame_dccf9a51dd0e5d88d3e5ed45b6d434bd = cache_frame_dccf9a51dd0e5d88d3e5ed45b6d434bd;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_dccf9a51dd0e5d88d3e5ed45b6d434bd);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_dccf9a51dd0e5d88d3e5ed45b6d434bd) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_hash_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_hash_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_crl_number);
        if (tmp_hash_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 137;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = BUILTIN_HASH(tmp_hash_arg_1);
        Py_DECREF(tmp_hash_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 137;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_dccf9a51dd0e5d88d3e5ed45b6d434bd);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_dccf9a51dd0e5d88d3e5ed45b6d434bd);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_dccf9a51dd0e5d88d3e5ed45b6d434bd);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_dccf9a51dd0e5d88d3e5ed45b6d434bd, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_dccf9a51dd0e5d88d3e5ed45b6d434bd->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_dccf9a51dd0e5d88d3e5ed45b6d434bd, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_dccf9a51dd0e5d88d3e5ed45b6d434bd,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_dccf9a51dd0e5d88d3e5ed45b6d434bd == cache_frame_dccf9a51dd0e5d88d3e5ed45b6d434bd) {
        Py_DECREF(frame_dccf9a51dd0e5d88d3e5ed45b6d434bd);
    }
    cache_frame_dccf9a51dd0e5d88d3e5ed45b6d434bd = NULL;

    assertFrameObject(frame_dccf9a51dd0e5d88d3e5ed45b6d434bd);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_15___hash__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_16___repr__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_5627fc3a583d3cb6bbb8c8b56cc5ee6e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_5627fc3a583d3cb6bbb8c8b56cc5ee6e = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_5627fc3a583d3cb6bbb8c8b56cc5ee6e, codeobj_5627fc3a583d3cb6bbb8c8b56cc5ee6e, module_cryptography$x509$extensions, sizeof(void *));
    frame_5627fc3a583d3cb6bbb8c8b56cc5ee6e = cache_frame_5627fc3a583d3cb6bbb8c8b56cc5ee6e;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_5627fc3a583d3cb6bbb8c8b56cc5ee6e);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_5627fc3a583d3cb6bbb8c8b56cc5ee6e) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_source_name_1 = const_str_digest_de1714430c844d988a0d091fac0a73d4;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_format);
        assert(!(tmp_called_name_1 == NULL));
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_crl_number);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 140;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_5627fc3a583d3cb6bbb8c8b56cc5ee6e->m_frame.f_lineno = 140;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 140;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5627fc3a583d3cb6bbb8c8b56cc5ee6e);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_5627fc3a583d3cb6bbb8c8b56cc5ee6e);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5627fc3a583d3cb6bbb8c8b56cc5ee6e);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_5627fc3a583d3cb6bbb8c8b56cc5ee6e, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_5627fc3a583d3cb6bbb8c8b56cc5ee6e->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_5627fc3a583d3cb6bbb8c8b56cc5ee6e, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5627fc3a583d3cb6bbb8c8b56cc5ee6e,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_5627fc3a583d3cb6bbb8c8b56cc5ee6e == cache_frame_5627fc3a583d3cb6bbb8c8b56cc5ee6e) {
        Py_DECREF(frame_5627fc3a583d3cb6bbb8c8b56cc5ee6e);
    }
    cache_frame_5627fc3a583d3cb6bbb8c8b56cc5ee6e = NULL;

    assertFrameObject(frame_5627fc3a583d3cb6bbb8c8b56cc5ee6e);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_16___repr__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_17___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_key_identifier = python_pars[1];
    PyObject *par_authority_cert_issuer = python_pars[2];
    PyObject *par_authority_cert_serial_number = python_pars[3];
    PyObject *tmp_genexpr_1__$0 = NULL;
    struct Nuitka_FrameObject *frame_a6ea834c6003bc7491321f01345f19da;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_a6ea834c6003bc7491321f01345f19da = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_a6ea834c6003bc7491321f01345f19da, codeobj_a6ea834c6003bc7491321f01345f19da, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_a6ea834c6003bc7491321f01345f19da = cache_frame_a6ea834c6003bc7491321f01345f19da;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_a6ea834c6003bc7491321f01345f19da);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_a6ea834c6003bc7491321f01345f19da) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        CHECK_OBJECT(par_authority_cert_issuer);
        tmp_compexpr_left_2 = par_authority_cert_issuer;
        tmp_compexpr_right_2 = Py_None;
        tmp_compexpr_left_1 = (tmp_compexpr_left_2 == tmp_compexpr_right_2) ? Py_True : Py_False;
        CHECK_OBJECT(par_authority_cert_serial_number);
        tmp_compexpr_left_3 = par_authority_cert_serial_number;
        tmp_compexpr_right_3 = Py_None;
        tmp_compexpr_right_1 = (tmp_compexpr_left_3 == tmp_compexpr_right_3) ? Py_True : Py_False;
        tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        assert(!(tmp_res == -1));
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_da5560b5b28f3c84a1c556751340bb55;
            frame_a6ea834c6003bc7491321f01345f19da->m_frame.f_lineno = 154;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 154;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        CHECK_OBJECT(par_authority_cert_issuer);
        tmp_compexpr_left_4 = par_authority_cert_issuer;
        tmp_compexpr_right_4 = Py_None;
        tmp_condition_result_2 = (tmp_compexpr_left_4 != tmp_compexpr_right_4) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_list_arg_1;
            CHECK_OBJECT(par_authority_cert_issuer);
            tmp_list_arg_1 = par_authority_cert_issuer;
            tmp_assign_source_1 = PySequence_List(tmp_list_arg_1);
            if (tmp_assign_source_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 160;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_authority_cert_issuer;
                assert(old != NULL);
                par_authority_cert_issuer = tmp_assign_source_1;
                Py_DECREF(old);
            }

        }
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_operand_name_1;
            PyObject *tmp_all_arg_1;
            {
                PyObject *tmp_assign_source_2;
                PyObject *tmp_iter_arg_1;
                CHECK_OBJECT(par_authority_cert_issuer);
                tmp_iter_arg_1 = par_authority_cert_issuer;
                tmp_assign_source_2 = MAKE_ITERATOR(tmp_iter_arg_1);
                if (tmp_assign_source_2 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 162;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                assert(tmp_genexpr_1__$0 == NULL);
                tmp_genexpr_1__$0 = tmp_assign_source_2;
            }
            // Tried code:
            tmp_all_arg_1 = cryptography$x509$extensions$$$function_17___init__$$$genexpr_1_genexpr_maker();

            ((struct Nuitka_GeneratorObject *)tmp_all_arg_1)->m_closure[0] = PyCell_NEW0(tmp_genexpr_1__$0);


            goto try_return_handler_2;
            // tried codes exits in all cases
            NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_17___init__);
            return NULL;
            // Return handler code:
            try_return_handler_2:;
            CHECK_OBJECT((PyObject *)tmp_genexpr_1__$0);
            Py_DECREF(tmp_genexpr_1__$0);
            tmp_genexpr_1__$0 = NULL;

            goto outline_result_1;
            // End of try:
            CHECK_OBJECT((PyObject *)tmp_genexpr_1__$0);
            Py_DECREF(tmp_genexpr_1__$0);
            tmp_genexpr_1__$0 = NULL;

            // Return statement must have exited already.
            NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_17___init__);
            return NULL;
            outline_result_1:;
            tmp_operand_name_1 = BUILTIN_ALL(tmp_all_arg_1);
            Py_DECREF(tmp_all_arg_1);
            if (tmp_operand_name_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 161;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
            Py_DECREF(tmp_operand_name_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 161;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_3 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
                goto branch_yes_3;
            } else {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_raise_type_2;
                PyObject *tmp_make_exception_arg_2;
                tmp_make_exception_arg_2 = const_str_digest_e41e00d6ec327bc9d8187afd927a45a2;
                frame_a6ea834c6003bc7491321f01345f19da->m_frame.f_lineno = 164;
                tmp_raise_type_2 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_2);
                assert(!(tmp_raise_type_2 == NULL));
                exception_type = tmp_raise_type_2;
                exception_lineno = 164;
                RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            branch_no_3:;
        }
        branch_no_2:;
    }
    {
        nuitka_bool tmp_condition_result_4;
        int tmp_and_left_truth_1;
        nuitka_bool tmp_and_left_value_1;
        nuitka_bool tmp_and_right_value_1;
        PyObject *tmp_compexpr_left_5;
        PyObject *tmp_compexpr_right_5;
        PyObject *tmp_operand_name_2;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_authority_cert_serial_number);
        tmp_compexpr_left_5 = par_authority_cert_serial_number;
        tmp_compexpr_right_5 = Py_None;
        tmp_and_left_value_1 = (tmp_compexpr_left_5 != tmp_compexpr_right_5) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if (tmp_and_left_truth_1 == 1) {
            goto and_right_1;
        } else {
            goto and_left_1;
        }
        and_right_1:;
        CHECK_OBJECT(par_authority_cert_serial_number);
        tmp_isinstance_inst_1 = par_authority_cert_serial_number;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_six);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_six);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 19694 ], 32, 0);
            exception_tb = NULL;

            exception_lineno = 170;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_isinstance_cls_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_integer_types);
        if (tmp_isinstance_cls_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 170;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        Py_DECREF(tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 169;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_2 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 169;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_condition_result_4 = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_condition_result_4 = tmp_and_left_value_1;
        and_end_1:;
        if (tmp_condition_result_4 == NUITKA_BOOL_TRUE) {
            goto branch_yes_4;
        } else {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_raise_type_3;
            PyObject *tmp_make_exception_arg_3;
            tmp_make_exception_arg_3 = const_str_digest_024b912fa6151b94263fc1d09ce49af2;
            frame_a6ea834c6003bc7491321f01345f19da->m_frame.f_lineno = 172;
            tmp_raise_type_3 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_3);
            assert(!(tmp_raise_type_3 == NULL));
            exception_type = tmp_raise_type_3;
            exception_lineno = 172;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        branch_no_4:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_key_identifier);
        tmp_assattr_name_1 = par_key_identifier;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__key_identifier, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 176;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT(par_authority_cert_issuer);
        tmp_assattr_name_2 = par_authority_cert_issuer;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain__authority_cert_issuer, tmp_assattr_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 177;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_assattr_target_3;
        CHECK_OBJECT(par_authority_cert_serial_number);
        tmp_assattr_name_3 = par_authority_cert_serial_number;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_3 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_3, const_str_plain__authority_cert_serial_number, tmp_assattr_name_3);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 178;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a6ea834c6003bc7491321f01345f19da);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a6ea834c6003bc7491321f01345f19da);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_a6ea834c6003bc7491321f01345f19da, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_a6ea834c6003bc7491321f01345f19da->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_a6ea834c6003bc7491321f01345f19da, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a6ea834c6003bc7491321f01345f19da,
        type_description_1,
        par_self,
        par_key_identifier,
        par_authority_cert_issuer,
        par_authority_cert_serial_number
    );


    // Release cached frame.
    if (frame_a6ea834c6003bc7491321f01345f19da == cache_frame_a6ea834c6003bc7491321f01345f19da) {
        Py_DECREF(frame_a6ea834c6003bc7491321f01345f19da);
    }
    cache_frame_a6ea834c6003bc7491321f01345f19da = NULL;

    assertFrameObject(frame_a6ea834c6003bc7491321f01345f19da);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_17___init__);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)par_authority_cert_issuer);
    Py_DECREF(par_authority_cert_issuer);
    par_authority_cert_issuer = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(par_authority_cert_issuer);
    par_authority_cert_issuer = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_17___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_authority_cert_serial_number);
    Py_DECREF(par_authority_cert_serial_number);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_key_identifier);
    Py_DECREF(par_key_identifier);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_authority_cert_serial_number);
    Py_DECREF(par_authority_cert_serial_number);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_key_identifier);
    Py_DECREF(par_key_identifier);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}



struct cryptography$x509$extensions$$$function_17___init__$$$genexpr_1_genexpr_locals {
    PyObject *var_x;
    PyObject *tmp_iter_value_0;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    int tmp_res;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *cryptography$x509$extensions$$$function_17___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value ) {
    CHECK_OBJECT((PyObject *)generator);
    assert(Nuitka_Generator_Check( (PyObject *)generator ));

    // Heap access if used.
    struct cryptography$x509$extensions$$$function_17___init__$$$genexpr_1_genexpr_locals *generator_heap = (struct cryptography$x509$extensions$$$function_17___init__$$$genexpr_1_genexpr_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_x = NULL;
    generator_heap->tmp_iter_value_0 = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_m_frame, codeobj_08237a46621deda32827a6d1002f2896, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF(generator->m_frame);
    assert(Py_REFCNT(generator->m_frame) == 2); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR(generator->m_frame->m_frame.f_back);

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF(generator->m_frame->m_frame.f_back);

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF(generator->m_frame);

    Nuitka_Frame_MarkAsExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

        EXC_TYPE_F(generator) = EXC_TYPE(thread_state);
        if (EXC_TYPE_F(generator) == Py_None) EXC_TYPE_F(generator) = NULL;
        Py_XINCREF(EXC_TYPE_F(generator));
        EXC_VALUE_F(generator) = EXC_VALUE(thread_state);
        Py_XINCREF(EXC_VALUE_F(generator));
        EXC_TRACEBACK_F(generator) = EXC_TRACEBACK(thread_state);
        Py_XINCREF(EXC_TRACEBACK_F(generator));
    }

#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_1;
        CHECK_OBJECT(PyCell_GET(generator->m_closure[0]));
        tmp_next_source_1 = PyCell_GET(generator->m_closure[0]);
        tmp_assign_source_1 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_1 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);
                generator_heap->type_description_1 = "No";
                generator_heap->exception_lineno = 162;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_iter_value_0;
            generator_heap->tmp_iter_value_0 = tmp_assign_source_1;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT(generator_heap->tmp_iter_value_0);
        tmp_assign_source_2 = generator_heap->tmp_iter_value_0;
        {
            PyObject *old = generator_heap->var_x;
            generator_heap->var_x = tmp_assign_source_2;
            Py_INCREF(generator_heap->var_x);
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_expression_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        CHECK_OBJECT(generator_heap->var_x);
        tmp_isinstance_inst_1 = generator_heap->var_x;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_GeneralName);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_GeneralName);
        }

        if (tmp_mvar_value_1 == NULL) {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF(generator_heap->exception_type);
            generator_heap->exception_value = UNSTREAM_STRING(&constant_bin[ 36192 ], 40, 0);
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 162;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        generator_heap->tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (generator_heap->tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 162;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_expression_name_1 = (generator_heap->tmp_res != 0) ? Py_True : Py_False;
        Py_INCREF(tmp_expression_name_1);
        Nuitka_PreserveHeap(generator_heap->yield_tmps, &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), NULL);
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        Nuitka_RestoreHeap(generator_heap->yield_tmps, &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), NULL);
        if (yield_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 162;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


        generator_heap->exception_lineno = 162;
        generator_heap->type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    // Allow re-use of the frame again.
    Py_DECREF(generator->m_frame);
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if (!EXCEPTION_MATCH_GENERATOR(generator_heap->exception_type)) {
        if (generator_heap->exception_tb == NULL) {
            generator_heap->exception_tb = MAKE_TRACEBACK(generator->m_frame, generator_heap->exception_lineno);
        } else if (generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame) {
            generator_heap->exception_tb = ADD_TRACEBACK(generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno);
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            NULL,
            generator_heap->var_x
        );


        // Release cached frame.
        if (generator->m_frame == cache_m_frame) {
            Py_DECREF(generator->m_frame);
        }
        cache_m_frame = NULL;

        assertFrameObject(generator->m_frame);
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    Py_DECREF(generator->m_frame);

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->var_x);
    generator_heap->var_x = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    Py_XDECREF(generator_heap->var_x);
    generator_heap->var_x = NULL;



    return NULL;

    function_exception_exit:
    assert(generator_heap->exception_type);
    RESTORE_ERROR_OCCURRED(generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb);

    return NULL;

}

static PyObject *cryptography$x509$extensions$$$function_17___init__$$$genexpr_1_genexpr_maker(void) {
    return Nuitka_Generator_New(
        cryptography$x509$extensions$$$function_17___init__$$$genexpr_1_genexpr_context,
        module_cryptography$x509$extensions,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_08237a46621deda32827a6d1002f2896,
        1,
        sizeof(struct cryptography$x509$extensions$$$function_17___init__$$$genexpr_1_genexpr_locals)
    );
}


static PyObject *impl_cryptography$x509$extensions$$$function_18_from_issuer_public_key(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_public_key = python_pars[1];
    PyObject *var_digest = NULL;
    struct Nuitka_FrameObject *frame_b2c6519047820697d77e44d8bdcfd13b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_b2c6519047820697d77e44d8bdcfd13b = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_b2c6519047820697d77e44d8bdcfd13b, codeobj_b2c6519047820697d77e44d8bdcfd13b, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_b2c6519047820697d77e44d8bdcfd13b = cache_frame_b2c6519047820697d77e44d8bdcfd13b;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_b2c6519047820697d77e44d8bdcfd13b);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_b2c6519047820697d77e44d8bdcfd13b) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain__key_identifier_from_public_key);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__key_identifier_from_public_key);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 36232 ], 60, 0);
            exception_tb = NULL;

            exception_lineno = 182;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT(par_public_key);
        tmp_args_element_name_1 = par_public_key;
        frame_b2c6519047820697d77e44d8bdcfd13b->m_frame.f_lineno = 182;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 182;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_digest == NULL);
        var_digest = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        PyObject *tmp_dict_key_3;
        PyObject *tmp_dict_value_3;
        CHECK_OBJECT(par_cls);
        tmp_called_name_2 = par_cls;
        CHECK_OBJECT(var_digest);
        tmp_dict_value_1 = var_digest;
        tmp_dict_key_1 = const_str_plain_key_identifier;
        tmp_kw_name_1 = _PyDict_NewPresized( 3 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        assert(!(tmp_res != 0));
        tmp_dict_value_2 = Py_None;
        tmp_dict_key_2 = const_str_plain_authority_cert_issuer;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2);
        assert(!(tmp_res != 0));
        tmp_dict_value_3 = Py_None;
        tmp_dict_key_3 = const_str_plain_authority_cert_serial_number;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3);
        assert(!(tmp_res != 0));
        frame_b2c6519047820697d77e44d8bdcfd13b->m_frame.f_lineno = 183;
        tmp_return_value = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_2, tmp_kw_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 183;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b2c6519047820697d77e44d8bdcfd13b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_b2c6519047820697d77e44d8bdcfd13b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b2c6519047820697d77e44d8bdcfd13b);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_b2c6519047820697d77e44d8bdcfd13b, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_b2c6519047820697d77e44d8bdcfd13b->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_b2c6519047820697d77e44d8bdcfd13b, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b2c6519047820697d77e44d8bdcfd13b,
        type_description_1,
        par_cls,
        par_public_key,
        var_digest
    );


    // Release cached frame.
    if (frame_b2c6519047820697d77e44d8bdcfd13b == cache_frame_b2c6519047820697d77e44d8bdcfd13b) {
        Py_DECREF(frame_b2c6519047820697d77e44d8bdcfd13b);
    }
    cache_frame_b2c6519047820697d77e44d8bdcfd13b = NULL;

    assertFrameObject(frame_b2c6519047820697d77e44d8bdcfd13b);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_18_from_issuer_public_key);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_digest);
    Py_DECREF(var_digest);
    var_digest = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_digest);
    var_digest = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_18_from_issuer_public_key);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_public_key);
    Py_DECREF(par_public_key);
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_public_key);
    Py_DECREF(par_public_key);
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_19_from_issuer_subject_key_identifier(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_ski = python_pars[1];
    struct Nuitka_FrameObject *frame_a653d45da8baa6d488220c38863ffcf2;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_a653d45da8baa6d488220c38863ffcf2 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_a653d45da8baa6d488220c38863ffcf2, codeobj_a653d45da8baa6d488220c38863ffcf2, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_a653d45da8baa6d488220c38863ffcf2 = cache_frame_a653d45da8baa6d488220c38863ffcf2;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_a653d45da8baa6d488220c38863ffcf2);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_a653d45da8baa6d488220c38863ffcf2) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        PyObject *tmp_dict_key_3;
        PyObject *tmp_dict_value_3;
        CHECK_OBJECT(par_cls);
        tmp_called_name_1 = par_cls;
        CHECK_OBJECT(par_ski);
        tmp_source_name_2 = par_ski;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_value);
        if (tmp_source_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 192;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_dict_value_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_digest);
        Py_DECREF(tmp_source_name_1);
        if (tmp_dict_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 192;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_dict_key_1 = const_str_plain_key_identifier;
        tmp_kw_name_1 = _PyDict_NewPresized( 3 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        Py_DECREF(tmp_dict_value_1);
        assert(!(tmp_res != 0));
        tmp_dict_value_2 = Py_None;
        tmp_dict_key_2 = const_str_plain_authority_cert_issuer;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2);
        assert(!(tmp_res != 0));
        tmp_dict_value_3 = Py_None;
        tmp_dict_key_3 = const_str_plain_authority_cert_serial_number;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3);
        assert(!(tmp_res != 0));
        frame_a653d45da8baa6d488220c38863ffcf2->m_frame.f_lineno = 191;
        tmp_return_value = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 191;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a653d45da8baa6d488220c38863ffcf2);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_a653d45da8baa6d488220c38863ffcf2);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a653d45da8baa6d488220c38863ffcf2);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_a653d45da8baa6d488220c38863ffcf2, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_a653d45da8baa6d488220c38863ffcf2->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_a653d45da8baa6d488220c38863ffcf2, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a653d45da8baa6d488220c38863ffcf2,
        type_description_1,
        par_cls,
        par_ski
    );


    // Release cached frame.
    if (frame_a653d45da8baa6d488220c38863ffcf2 == cache_frame_a653d45da8baa6d488220c38863ffcf2) {
        Py_DECREF(frame_a653d45da8baa6d488220c38863ffcf2);
    }
    cache_frame_a653d45da8baa6d488220c38863ffcf2 = NULL;

    assertFrameObject(frame_a653d45da8baa6d488220c38863ffcf2);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_19_from_issuer_subject_key_identifier);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_ski);
    Py_DECREF(par_ski);
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_ski);
    Py_DECREF(par_ski);
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_20___repr__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_ab8c5a8b684c9fef58474266c7dffadb;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_ab8c5a8b684c9fef58474266c7dffadb = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_ab8c5a8b684c9fef58474266c7dffadb, codeobj_ab8c5a8b684c9fef58474266c7dffadb, module_cryptography$x509$extensions, sizeof(void *));
    frame_ab8c5a8b684c9fef58474266c7dffadb = cache_frame_ab8c5a8b684c9fef58474266c7dffadb;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_ab8c5a8b684c9fef58474266c7dffadb);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_ab8c5a8b684c9fef58474266c7dffadb) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        tmp_called_instance_1 = const_str_digest_42aaad2aaa6a1ee7d79f305ebfd1a58b;
        CHECK_OBJECT(par_self);
        tmp_args_element_name_1 = par_self;
        frame_ab8c5a8b684c9fef58474266c7dffadb->m_frame.f_lineno = 199;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_format, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 199;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ab8c5a8b684c9fef58474266c7dffadb);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_ab8c5a8b684c9fef58474266c7dffadb);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ab8c5a8b684c9fef58474266c7dffadb);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_ab8c5a8b684c9fef58474266c7dffadb, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_ab8c5a8b684c9fef58474266c7dffadb->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_ab8c5a8b684c9fef58474266c7dffadb, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ab8c5a8b684c9fef58474266c7dffadb,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_ab8c5a8b684c9fef58474266c7dffadb == cache_frame_ab8c5a8b684c9fef58474266c7dffadb) {
        Py_DECREF(frame_ab8c5a8b684c9fef58474266c7dffadb);
    }
    cache_frame_ab8c5a8b684c9fef58474266c7dffadb = NULL;

    assertFrameObject(frame_ab8c5a8b684c9fef58474266c7dffadb);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_20___repr__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_21___eq__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_ec606af4719e836adceac6092dca2c44;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_ec606af4719e836adceac6092dca2c44 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_ec606af4719e836adceac6092dca2c44, codeobj_ec606af4719e836adceac6092dca2c44, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_ec606af4719e836adceac6092dca2c44 = cache_frame_ec606af4719e836adceac6092dca2c44;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_ec606af4719e836adceac6092dca2c44);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_ec606af4719e836adceac6092dca2c44) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_other);
        tmp_isinstance_inst_1 = par_other;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_AuthorityKeyIdentifier);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_AuthorityKeyIdentifier);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 36292 ], 51, 0);
            exception_tb = NULL;

            exception_lineno = 206;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 206;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 206;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        int tmp_and_left_truth_1;
        PyObject *tmp_and_left_value_1;
        PyObject *tmp_and_right_value_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        int tmp_and_left_truth_2;
        PyObject *tmp_and_left_value_2;
        PyObject *tmp_and_right_value_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_source_name_4;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_source_name_5;
        PyObject *tmp_source_name_6;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_key_identifier);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 210;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_2 = par_other;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_key_identifier);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_1);

            exception_lineno = 210;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_and_left_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 210;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_truth_1 = CHECK_IF_TRUE(tmp_and_left_value_1);
        if (tmp_and_left_truth_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_and_left_value_1);

            exception_lineno = 212;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        if (tmp_and_left_truth_1 == 1) {
            goto and_right_1;
        } else {
            goto and_left_1;
        }
        and_right_1:;
        Py_DECREF(tmp_and_left_value_1);
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_authority_cert_issuer);
        if (tmp_compexpr_left_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 211;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_4 = par_other;
        tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_authority_cert_issuer);
        if (tmp_compexpr_right_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_2);

            exception_lineno = 211;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_2 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
        Py_DECREF(tmp_compexpr_left_2);
        Py_DECREF(tmp_compexpr_right_2);
        if (tmp_and_left_value_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 211;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_truth_2 = CHECK_IF_TRUE(tmp_and_left_value_2);
        if (tmp_and_left_truth_2 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_and_left_value_2);

            exception_lineno = 212;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        if (tmp_and_left_truth_2 == 1) {
            goto and_right_2;
        } else {
            goto and_left_2;
        }
        and_right_2:;
        Py_DECREF(tmp_and_left_value_2);
        CHECK_OBJECT(par_self);
        tmp_source_name_5 = par_self;
        tmp_compexpr_left_3 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_authority_cert_serial_number);
        if (tmp_compexpr_left_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 212;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_6 = par_other;
        tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_authority_cert_serial_number);
        if (tmp_compexpr_right_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_3);

            exception_lineno = 213;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_2 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_3, tmp_compexpr_right_3);
        Py_DECREF(tmp_compexpr_left_3);
        Py_DECREF(tmp_compexpr_right_3);
        if (tmp_and_right_value_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 212;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = tmp_and_right_value_2;
        goto and_end_2;
        and_left_2:;
        tmp_and_right_value_1 = tmp_and_left_value_2;
        and_end_2:;
        tmp_return_value = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_return_value = tmp_and_left_value_1;
        and_end_1:;
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ec606af4719e836adceac6092dca2c44);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_ec606af4719e836adceac6092dca2c44);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ec606af4719e836adceac6092dca2c44);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_ec606af4719e836adceac6092dca2c44, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_ec606af4719e836adceac6092dca2c44->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_ec606af4719e836adceac6092dca2c44, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ec606af4719e836adceac6092dca2c44,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_ec606af4719e836adceac6092dca2c44 == cache_frame_ec606af4719e836adceac6092dca2c44) {
        Py_DECREF(frame_ec606af4719e836adceac6092dca2c44);
    }
    cache_frame_ec606af4719e836adceac6092dca2c44 = NULL;

    assertFrameObject(frame_ec606af4719e836adceac6092dca2c44);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_21___eq__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_22___ne__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_9e02fda17edc241d52be17c732abc823;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_9e02fda17edc241d52be17c732abc823 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_9e02fda17edc241d52be17c732abc823, codeobj_9e02fda17edc241d52be17c732abc823, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_9e02fda17edc241d52be17c732abc823 = cache_frame_9e02fda17edc241d52be17c732abc823;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_9e02fda17edc241d52be17c732abc823);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_9e02fda17edc241d52be17c732abc823) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_self);
        tmp_compexpr_left_1 = par_self;
        CHECK_OBJECT(par_other);
        tmp_compexpr_right_1 = par_other;
        tmp_operand_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 217;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 217;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = (tmp_res == 0) ? Py_True : Py_False;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9e02fda17edc241d52be17c732abc823);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_9e02fda17edc241d52be17c732abc823);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9e02fda17edc241d52be17c732abc823);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_9e02fda17edc241d52be17c732abc823, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_9e02fda17edc241d52be17c732abc823->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_9e02fda17edc241d52be17c732abc823, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9e02fda17edc241d52be17c732abc823,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_9e02fda17edc241d52be17c732abc823 == cache_frame_9e02fda17edc241d52be17c732abc823) {
        Py_DECREF(frame_9e02fda17edc241d52be17c732abc823);
    }
    cache_frame_9e02fda17edc241d52be17c732abc823 = NULL;

    assertFrameObject(frame_9e02fda17edc241d52be17c732abc823);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_22___ne__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_23___hash__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_aci = NULL;
    struct Nuitka_FrameObject *frame_7b2b4c038ecf3dd78ddb14477ee2e367;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_7b2b4c038ecf3dd78ddb14477ee2e367 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_7b2b4c038ecf3dd78ddb14477ee2e367, codeobj_7b2b4c038ecf3dd78ddb14477ee2e367, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_7b2b4c038ecf3dd78ddb14477ee2e367 = cache_frame_7b2b4c038ecf3dd78ddb14477ee2e367;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_7b2b4c038ecf3dd78ddb14477ee2e367);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_7b2b4c038ecf3dd78ddb14477ee2e367) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_authority_cert_issuer);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 220;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_compexpr_left_1);
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            tmp_assign_source_1 = Py_None;
            assert(var_aci == NULL);
            Py_INCREF(tmp_assign_source_1);
            var_aci = tmp_assign_source_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_tuple_arg_1;
            PyObject *tmp_source_name_2;
            CHECK_OBJECT(par_self);
            tmp_source_name_2 = par_self;
            tmp_tuple_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_authority_cert_issuer);
            if (tmp_tuple_arg_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 223;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_assign_source_2 = PySequence_Tuple(tmp_tuple_arg_1);
            Py_DECREF(tmp_tuple_arg_1);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 223;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            assert(var_aci == NULL);
            var_aci = tmp_assign_source_2;
        }
        branch_end_1:;
    }
    {
        PyObject *tmp_hash_arg_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_source_name_4;
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_key_identifier);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 225;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_hash_arg_1 = PyTuple_New(3);
        PyTuple_SET_ITEM(tmp_hash_arg_1, 0, tmp_tuple_element_1);
        CHECK_OBJECT(var_aci);
        tmp_tuple_element_1 = var_aci;
        Py_INCREF(tmp_tuple_element_1);
        PyTuple_SET_ITEM(tmp_hash_arg_1, 1, tmp_tuple_element_1);
        CHECK_OBJECT(par_self);
        tmp_source_name_4 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_authority_cert_serial_number);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_hash_arg_1);

            exception_lineno = 225;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM(tmp_hash_arg_1, 2, tmp_tuple_element_1);
        tmp_return_value = BUILTIN_HASH(tmp_hash_arg_1);
        Py_DECREF(tmp_hash_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 224;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_7b2b4c038ecf3dd78ddb14477ee2e367);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_7b2b4c038ecf3dd78ddb14477ee2e367);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_7b2b4c038ecf3dd78ddb14477ee2e367);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_7b2b4c038ecf3dd78ddb14477ee2e367, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_7b2b4c038ecf3dd78ddb14477ee2e367->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_7b2b4c038ecf3dd78ddb14477ee2e367, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7b2b4c038ecf3dd78ddb14477ee2e367,
        type_description_1,
        par_self,
        var_aci
    );


    // Release cached frame.
    if (frame_7b2b4c038ecf3dd78ddb14477ee2e367 == cache_frame_7b2b4c038ecf3dd78ddb14477ee2e367) {
        Py_DECREF(frame_7b2b4c038ecf3dd78ddb14477ee2e367);
    }
    cache_frame_7b2b4c038ecf3dd78ddb14477ee2e367 = NULL;

    assertFrameObject(frame_7b2b4c038ecf3dd78ddb14477ee2e367);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_23___hash__);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_aci);
    Py_DECREF(var_aci);
    var_aci = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_aci);
    var_aci = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_23___hash__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_24___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_digest = python_pars[1];
    struct Nuitka_FrameObject *frame_35d20cf5a412ee09604cd65c988906ca;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_35d20cf5a412ee09604cd65c988906ca = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_35d20cf5a412ee09604cd65c988906ca, codeobj_35d20cf5a412ee09604cd65c988906ca, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_35d20cf5a412ee09604cd65c988906ca = cache_frame_35d20cf5a412ee09604cd65c988906ca;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_35d20cf5a412ee09604cd65c988906ca);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_35d20cf5a412ee09604cd65c988906ca) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_digest);
        tmp_assattr_name_1 = par_digest;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__digest, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 240;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_35d20cf5a412ee09604cd65c988906ca);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_35d20cf5a412ee09604cd65c988906ca);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_35d20cf5a412ee09604cd65c988906ca, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_35d20cf5a412ee09604cd65c988906ca->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_35d20cf5a412ee09604cd65c988906ca, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_35d20cf5a412ee09604cd65c988906ca,
        type_description_1,
        par_self,
        par_digest
    );


    // Release cached frame.
    if (frame_35d20cf5a412ee09604cd65c988906ca == cache_frame_35d20cf5a412ee09604cd65c988906ca) {
        Py_DECREF(frame_35d20cf5a412ee09604cd65c988906ca);
    }
    cache_frame_35d20cf5a412ee09604cd65c988906ca = NULL;

    assertFrameObject(frame_35d20cf5a412ee09604cd65c988906ca);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_24___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_digest);
    Py_DECREF(par_digest);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_digest);
    Py_DECREF(par_digest);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_25_from_public_key(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_public_key = python_pars[1];
    struct Nuitka_FrameObject *frame_3e69ec24bcd58b7600541c49b05642f9;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_3e69ec24bcd58b7600541c49b05642f9 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_3e69ec24bcd58b7600541c49b05642f9, codeobj_3e69ec24bcd58b7600541c49b05642f9, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_3e69ec24bcd58b7600541c49b05642f9 = cache_frame_3e69ec24bcd58b7600541c49b05642f9;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_3e69ec24bcd58b7600541c49b05642f9);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_3e69ec24bcd58b7600541c49b05642f9) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT(par_cls);
        tmp_called_name_1 = par_cls;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain__key_identifier_from_public_key);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__key_identifier_from_public_key);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 36232 ], 60, 0);
            exception_tb = NULL;

            exception_lineno = 244;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_1;
        CHECK_OBJECT(par_public_key);
        tmp_args_element_name_2 = par_public_key;
        frame_3e69ec24bcd58b7600541c49b05642f9->m_frame.f_lineno = 244;
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_2);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 244;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_3e69ec24bcd58b7600541c49b05642f9->m_frame.f_lineno = 244;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 244;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3e69ec24bcd58b7600541c49b05642f9);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_3e69ec24bcd58b7600541c49b05642f9);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3e69ec24bcd58b7600541c49b05642f9);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_3e69ec24bcd58b7600541c49b05642f9, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_3e69ec24bcd58b7600541c49b05642f9->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_3e69ec24bcd58b7600541c49b05642f9, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3e69ec24bcd58b7600541c49b05642f9,
        type_description_1,
        par_cls,
        par_public_key
    );


    // Release cached frame.
    if (frame_3e69ec24bcd58b7600541c49b05642f9 == cache_frame_3e69ec24bcd58b7600541c49b05642f9) {
        Py_DECREF(frame_3e69ec24bcd58b7600541c49b05642f9);
    }
    cache_frame_3e69ec24bcd58b7600541c49b05642f9 = NULL;

    assertFrameObject(frame_3e69ec24bcd58b7600541c49b05642f9);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_25_from_public_key);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_public_key);
    Py_DECREF(par_public_key);
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_public_key);
    Py_DECREF(par_public_key);
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_26___repr__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_8fbc2a08b5ca5a8f7c260de621689a56;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_8fbc2a08b5ca5a8f7c260de621689a56 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_8fbc2a08b5ca5a8f7c260de621689a56, codeobj_8fbc2a08b5ca5a8f7c260de621689a56, module_cryptography$x509$extensions, sizeof(void *));
    frame_8fbc2a08b5ca5a8f7c260de621689a56 = cache_frame_8fbc2a08b5ca5a8f7c260de621689a56;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_8fbc2a08b5ca5a8f7c260de621689a56);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_8fbc2a08b5ca5a8f7c260de621689a56) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_source_name_1 = const_str_digest_2fedee8d2e8553cc3a2acd1bc300acd1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_format);
        assert(!(tmp_called_name_1 == NULL));
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_digest);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 249;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_8fbc2a08b5ca5a8f7c260de621689a56->m_frame.f_lineno = 249;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 249;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8fbc2a08b5ca5a8f7c260de621689a56);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_8fbc2a08b5ca5a8f7c260de621689a56);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8fbc2a08b5ca5a8f7c260de621689a56);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_8fbc2a08b5ca5a8f7c260de621689a56, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_8fbc2a08b5ca5a8f7c260de621689a56->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_8fbc2a08b5ca5a8f7c260de621689a56, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8fbc2a08b5ca5a8f7c260de621689a56,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_8fbc2a08b5ca5a8f7c260de621689a56 == cache_frame_8fbc2a08b5ca5a8f7c260de621689a56) {
        Py_DECREF(frame_8fbc2a08b5ca5a8f7c260de621689a56);
    }
    cache_frame_8fbc2a08b5ca5a8f7c260de621689a56 = NULL;

    assertFrameObject(frame_8fbc2a08b5ca5a8f7c260de621689a56);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_26___repr__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_27___eq__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_3bb78211f559ebe4d881b75b546ffc0a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_3bb78211f559ebe4d881b75b546ffc0a = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_3bb78211f559ebe4d881b75b546ffc0a, codeobj_3bb78211f559ebe4d881b75b546ffc0a, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_3bb78211f559ebe4d881b75b546ffc0a = cache_frame_3bb78211f559ebe4d881b75b546ffc0a;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_3bb78211f559ebe4d881b75b546ffc0a);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_3bb78211f559ebe4d881b75b546ffc0a) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_other);
        tmp_isinstance_inst_1 = par_other;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_SubjectKeyIdentifier);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_SubjectKeyIdentifier);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 36343 ], 49, 0);
            exception_tb = NULL;

            exception_lineno = 252;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 252;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 252;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_constant_time);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_constant_time);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 22833 ], 42, 0);
            exception_tb = NULL;

            exception_lineno = 255;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_bytes_eq);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 255;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_digest);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 255;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_3 = par_other;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_digest);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_element_name_1);

            exception_lineno = 255;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_3bb78211f559ebe4d881b75b546ffc0a->m_frame.f_lineno = 255;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 255;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3bb78211f559ebe4d881b75b546ffc0a);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_3bb78211f559ebe4d881b75b546ffc0a);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3bb78211f559ebe4d881b75b546ffc0a);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_3bb78211f559ebe4d881b75b546ffc0a, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_3bb78211f559ebe4d881b75b546ffc0a->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_3bb78211f559ebe4d881b75b546ffc0a, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3bb78211f559ebe4d881b75b546ffc0a,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_3bb78211f559ebe4d881b75b546ffc0a == cache_frame_3bb78211f559ebe4d881b75b546ffc0a) {
        Py_DECREF(frame_3bb78211f559ebe4d881b75b546ffc0a);
    }
    cache_frame_3bb78211f559ebe4d881b75b546ffc0a = NULL;

    assertFrameObject(frame_3bb78211f559ebe4d881b75b546ffc0a);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_27___eq__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_28___ne__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_2a76b8a7a0619e7e50369de1896fb82e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_2a76b8a7a0619e7e50369de1896fb82e = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_2a76b8a7a0619e7e50369de1896fb82e, codeobj_2a76b8a7a0619e7e50369de1896fb82e, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_2a76b8a7a0619e7e50369de1896fb82e = cache_frame_2a76b8a7a0619e7e50369de1896fb82e;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_2a76b8a7a0619e7e50369de1896fb82e);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_2a76b8a7a0619e7e50369de1896fb82e) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_self);
        tmp_compexpr_left_1 = par_self;
        CHECK_OBJECT(par_other);
        tmp_compexpr_right_1 = par_other;
        tmp_operand_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 258;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 258;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = (tmp_res == 0) ? Py_True : Py_False;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2a76b8a7a0619e7e50369de1896fb82e);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_2a76b8a7a0619e7e50369de1896fb82e);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2a76b8a7a0619e7e50369de1896fb82e);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_2a76b8a7a0619e7e50369de1896fb82e, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_2a76b8a7a0619e7e50369de1896fb82e->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_2a76b8a7a0619e7e50369de1896fb82e, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2a76b8a7a0619e7e50369de1896fb82e,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_2a76b8a7a0619e7e50369de1896fb82e == cache_frame_2a76b8a7a0619e7e50369de1896fb82e) {
        Py_DECREF(frame_2a76b8a7a0619e7e50369de1896fb82e);
    }
    cache_frame_2a76b8a7a0619e7e50369de1896fb82e = NULL;

    assertFrameObject(frame_2a76b8a7a0619e7e50369de1896fb82e);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_28___ne__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_29___hash__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_7c6b59f6602706780fb2366013d7677d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_7c6b59f6602706780fb2366013d7677d = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_7c6b59f6602706780fb2366013d7677d, codeobj_7c6b59f6602706780fb2366013d7677d, module_cryptography$x509$extensions, sizeof(void *));
    frame_7c6b59f6602706780fb2366013d7677d = cache_frame_7c6b59f6602706780fb2366013d7677d;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_7c6b59f6602706780fb2366013d7677d);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_7c6b59f6602706780fb2366013d7677d) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_hash_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_hash_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_digest);
        if (tmp_hash_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 261;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = BUILTIN_HASH(tmp_hash_arg_1);
        Py_DECREF(tmp_hash_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 261;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_7c6b59f6602706780fb2366013d7677d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_7c6b59f6602706780fb2366013d7677d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_7c6b59f6602706780fb2366013d7677d);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_7c6b59f6602706780fb2366013d7677d, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_7c6b59f6602706780fb2366013d7677d->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_7c6b59f6602706780fb2366013d7677d, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7c6b59f6602706780fb2366013d7677d,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_7c6b59f6602706780fb2366013d7677d == cache_frame_7c6b59f6602706780fb2366013d7677d) {
        Py_DECREF(frame_7c6b59f6602706780fb2366013d7677d);
    }
    cache_frame_7c6b59f6602706780fb2366013d7677d = NULL;

    assertFrameObject(frame_7c6b59f6602706780fb2366013d7677d);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_29___hash__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_30___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_descriptions = python_pars[1];
    PyObject *tmp_genexpr_1__$0 = NULL;
    struct Nuitka_FrameObject *frame_2ac5cbbcb3461b660306ae84e4908ce0;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_2ac5cbbcb3461b660306ae84e4908ce0 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_2ac5cbbcb3461b660306ae84e4908ce0, codeobj_2ac5cbbcb3461b660306ae84e4908ce0, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_2ac5cbbcb3461b660306ae84e4908ce0 = cache_frame_2ac5cbbcb3461b660306ae84e4908ce0;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_2ac5cbbcb3461b660306ae84e4908ce0);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_2ac5cbbcb3461b660306ae84e4908ce0) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_list_arg_1;
        CHECK_OBJECT(par_descriptions);
        tmp_list_arg_1 = par_descriptions;
        tmp_assign_source_1 = PySequence_List(tmp_list_arg_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 269;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = par_descriptions;
            assert(old != NULL);
            par_descriptions = tmp_assign_source_1;
            Py_DECREF(old);
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_all_arg_1;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT(par_descriptions);
            tmp_iter_arg_1 = par_descriptions;
            tmp_assign_source_2 = MAKE_ITERATOR(tmp_iter_arg_1);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 270;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            assert(tmp_genexpr_1__$0 == NULL);
            tmp_genexpr_1__$0 = tmp_assign_source_2;
        }
        // Tried code:
        tmp_all_arg_1 = cryptography$x509$extensions$$$function_30___init__$$$genexpr_1_genexpr_maker();

        ((struct Nuitka_GeneratorObject *)tmp_all_arg_1)->m_closure[0] = PyCell_NEW0(tmp_genexpr_1__$0);


        goto try_return_handler_2;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_30___init__);
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        CHECK_OBJECT((PyObject *)tmp_genexpr_1__$0);
        Py_DECREF(tmp_genexpr_1__$0);
        tmp_genexpr_1__$0 = NULL;

        goto outline_result_1;
        // End of try:
        CHECK_OBJECT((PyObject *)tmp_genexpr_1__$0);
        Py_DECREF(tmp_genexpr_1__$0);
        tmp_genexpr_1__$0 = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_30___init__);
        return NULL;
        outline_result_1:;
        tmp_operand_name_1 = BUILTIN_ALL(tmp_all_arg_1);
        Py_DECREF(tmp_all_arg_1);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 270;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 270;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_52903da339eb426b3d703a3f30ce3e10;
            frame_2ac5cbbcb3461b660306ae84e4908ce0->m_frame.f_lineno = 271;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 271;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_descriptions);
        tmp_assattr_name_1 = par_descriptions;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__descriptions, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 276;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2ac5cbbcb3461b660306ae84e4908ce0);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2ac5cbbcb3461b660306ae84e4908ce0);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_2ac5cbbcb3461b660306ae84e4908ce0, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_2ac5cbbcb3461b660306ae84e4908ce0->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_2ac5cbbcb3461b660306ae84e4908ce0, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2ac5cbbcb3461b660306ae84e4908ce0,
        type_description_1,
        par_self,
        par_descriptions
    );


    // Release cached frame.
    if (frame_2ac5cbbcb3461b660306ae84e4908ce0 == cache_frame_2ac5cbbcb3461b660306ae84e4908ce0) {
        Py_DECREF(frame_2ac5cbbcb3461b660306ae84e4908ce0);
    }
    cache_frame_2ac5cbbcb3461b660306ae84e4908ce0 = NULL;

    assertFrameObject(frame_2ac5cbbcb3461b660306ae84e4908ce0);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_30___init__);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)par_descriptions);
    Py_DECREF(par_descriptions);
    par_descriptions = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)par_descriptions);
    Py_DECREF(par_descriptions);
    par_descriptions = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_30___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}



struct cryptography$x509$extensions$$$function_30___init__$$$genexpr_1_genexpr_locals {
    PyObject *var_x;
    PyObject *tmp_iter_value_0;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    int tmp_res;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *cryptography$x509$extensions$$$function_30___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value ) {
    CHECK_OBJECT((PyObject *)generator);
    assert(Nuitka_Generator_Check( (PyObject *)generator ));

    // Heap access if used.
    struct cryptography$x509$extensions$$$function_30___init__$$$genexpr_1_genexpr_locals *generator_heap = (struct cryptography$x509$extensions$$$function_30___init__$$$genexpr_1_genexpr_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_x = NULL;
    generator_heap->tmp_iter_value_0 = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_m_frame, codeobj_f6b8321b3a4026647bece9fcbe9c1464, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF(generator->m_frame);
    assert(Py_REFCNT(generator->m_frame) == 2); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR(generator->m_frame->m_frame.f_back);

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF(generator->m_frame->m_frame.f_back);

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF(generator->m_frame);

    Nuitka_Frame_MarkAsExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

        EXC_TYPE_F(generator) = EXC_TYPE(thread_state);
        if (EXC_TYPE_F(generator) == Py_None) EXC_TYPE_F(generator) = NULL;
        Py_XINCREF(EXC_TYPE_F(generator));
        EXC_VALUE_F(generator) = EXC_VALUE(thread_state);
        Py_XINCREF(EXC_VALUE_F(generator));
        EXC_TRACEBACK_F(generator) = EXC_TRACEBACK(thread_state);
        Py_XINCREF(EXC_TRACEBACK_F(generator));
    }

#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_1;
        CHECK_OBJECT(PyCell_GET(generator->m_closure[0]));
        tmp_next_source_1 = PyCell_GET(generator->m_closure[0]);
        tmp_assign_source_1 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_1 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);
                generator_heap->type_description_1 = "No";
                generator_heap->exception_lineno = 270;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_iter_value_0;
            generator_heap->tmp_iter_value_0 = tmp_assign_source_1;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT(generator_heap->tmp_iter_value_0);
        tmp_assign_source_2 = generator_heap->tmp_iter_value_0;
        {
            PyObject *old = generator_heap->var_x;
            generator_heap->var_x = tmp_assign_source_2;
            Py_INCREF(generator_heap->var_x);
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_expression_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        CHECK_OBJECT(generator_heap->var_x);
        tmp_isinstance_inst_1 = generator_heap->var_x;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_AccessDescription);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_AccessDescription);
        }

        if (tmp_mvar_value_1 == NULL) {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF(generator_heap->exception_type);
            generator_heap->exception_value = UNSTREAM_STRING(&constant_bin[ 36392 ], 46, 0);
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 270;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        generator_heap->tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (generator_heap->tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 270;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_expression_name_1 = (generator_heap->tmp_res != 0) ? Py_True : Py_False;
        Py_INCREF(tmp_expression_name_1);
        Nuitka_PreserveHeap(generator_heap->yield_tmps, &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), NULL);
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        Nuitka_RestoreHeap(generator_heap->yield_tmps, &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), NULL);
        if (yield_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 270;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


        generator_heap->exception_lineno = 270;
        generator_heap->type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    // Allow re-use of the frame again.
    Py_DECREF(generator->m_frame);
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if (!EXCEPTION_MATCH_GENERATOR(generator_heap->exception_type)) {
        if (generator_heap->exception_tb == NULL) {
            generator_heap->exception_tb = MAKE_TRACEBACK(generator->m_frame, generator_heap->exception_lineno);
        } else if (generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame) {
            generator_heap->exception_tb = ADD_TRACEBACK(generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno);
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            NULL,
            generator_heap->var_x
        );


        // Release cached frame.
        if (generator->m_frame == cache_m_frame) {
            Py_DECREF(generator->m_frame);
        }
        cache_m_frame = NULL;

        assertFrameObject(generator->m_frame);
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    Py_DECREF(generator->m_frame);

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->var_x);
    generator_heap->var_x = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    Py_XDECREF(generator_heap->var_x);
    generator_heap->var_x = NULL;



    return NULL;

    function_exception_exit:
    assert(generator_heap->exception_type);
    RESTORE_ERROR_OCCURRED(generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb);

    return NULL;

}

static PyObject *cryptography$x509$extensions$$$function_30___init__$$$genexpr_1_genexpr_maker(void) {
    return Nuitka_Generator_New(
        cryptography$x509$extensions$$$function_30___init__$$$genexpr_1_genexpr_context,
        module_cryptography$x509$extensions,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_f6b8321b3a4026647bece9fcbe9c1464,
        1,
        sizeof(struct cryptography$x509$extensions$$$function_30___init__$$$genexpr_1_genexpr_locals)
    );
}


static PyObject *impl_cryptography$x509$extensions$$$function_31___iter__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_8abc18ccaef36115f2eefe103b30849a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_8abc18ccaef36115f2eefe103b30849a = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_8abc18ccaef36115f2eefe103b30849a, codeobj_8abc18ccaef36115f2eefe103b30849a, module_cryptography$x509$extensions, sizeof(void *));
    frame_8abc18ccaef36115f2eefe103b30849a = cache_frame_8abc18ccaef36115f2eefe103b30849a;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_8abc18ccaef36115f2eefe103b30849a);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_8abc18ccaef36115f2eefe103b30849a) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_iter_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__descriptions);
        if (tmp_iter_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 279;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = MAKE_ITERATOR(tmp_iter_arg_1);
        Py_DECREF(tmp_iter_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 279;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8abc18ccaef36115f2eefe103b30849a);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_8abc18ccaef36115f2eefe103b30849a);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8abc18ccaef36115f2eefe103b30849a);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_8abc18ccaef36115f2eefe103b30849a, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_8abc18ccaef36115f2eefe103b30849a->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_8abc18ccaef36115f2eefe103b30849a, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8abc18ccaef36115f2eefe103b30849a,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_8abc18ccaef36115f2eefe103b30849a == cache_frame_8abc18ccaef36115f2eefe103b30849a) {
        Py_DECREF(frame_8abc18ccaef36115f2eefe103b30849a);
    }
    cache_frame_8abc18ccaef36115f2eefe103b30849a = NULL;

    assertFrameObject(frame_8abc18ccaef36115f2eefe103b30849a);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_31___iter__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_32___len__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_d617f84754084510e6e33c98f465dfab;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_d617f84754084510e6e33c98f465dfab = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_d617f84754084510e6e33c98f465dfab, codeobj_d617f84754084510e6e33c98f465dfab, module_cryptography$x509$extensions, sizeof(void *));
    frame_d617f84754084510e6e33c98f465dfab = cache_frame_d617f84754084510e6e33c98f465dfab;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_d617f84754084510e6e33c98f465dfab);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_d617f84754084510e6e33c98f465dfab) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_len_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_len_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__descriptions);
        if (tmp_len_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 282;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = BUILTIN_LEN(tmp_len_arg_1);
        Py_DECREF(tmp_len_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 282;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_d617f84754084510e6e33c98f465dfab);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_d617f84754084510e6e33c98f465dfab);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_d617f84754084510e6e33c98f465dfab);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_d617f84754084510e6e33c98f465dfab, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_d617f84754084510e6e33c98f465dfab->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_d617f84754084510e6e33c98f465dfab, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d617f84754084510e6e33c98f465dfab,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_d617f84754084510e6e33c98f465dfab == cache_frame_d617f84754084510e6e33c98f465dfab) {
        Py_DECREF(frame_d617f84754084510e6e33c98f465dfab);
    }
    cache_frame_d617f84754084510e6e33c98f465dfab = NULL;

    assertFrameObject(frame_d617f84754084510e6e33c98f465dfab);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_32___len__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_33___repr__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_aa37e82ac1bfe382d743f376673b24de;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_aa37e82ac1bfe382d743f376673b24de = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_aa37e82ac1bfe382d743f376673b24de, codeobj_aa37e82ac1bfe382d743f376673b24de, module_cryptography$x509$extensions, sizeof(void *));
    frame_aa37e82ac1bfe382d743f376673b24de = cache_frame_aa37e82ac1bfe382d743f376673b24de;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_aa37e82ac1bfe382d743f376673b24de);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_aa37e82ac1bfe382d743f376673b24de) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_source_name_1 = const_str_digest_26a75172f55108334b01cdc8efcbab38;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_format);
        assert(!(tmp_called_name_1 == NULL));
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__descriptions);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 285;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_aa37e82ac1bfe382d743f376673b24de->m_frame.f_lineno = 285;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 285;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_aa37e82ac1bfe382d743f376673b24de);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_aa37e82ac1bfe382d743f376673b24de);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_aa37e82ac1bfe382d743f376673b24de);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_aa37e82ac1bfe382d743f376673b24de, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_aa37e82ac1bfe382d743f376673b24de->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_aa37e82ac1bfe382d743f376673b24de, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_aa37e82ac1bfe382d743f376673b24de,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_aa37e82ac1bfe382d743f376673b24de == cache_frame_aa37e82ac1bfe382d743f376673b24de) {
        Py_DECREF(frame_aa37e82ac1bfe382d743f376673b24de);
    }
    cache_frame_aa37e82ac1bfe382d743f376673b24de = NULL;

    assertFrameObject(frame_aa37e82ac1bfe382d743f376673b24de);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_33___repr__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_34___eq__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_ec6763a25cc283c8349cad2c66a21488;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_ec6763a25cc283c8349cad2c66a21488 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_ec6763a25cc283c8349cad2c66a21488, codeobj_ec6763a25cc283c8349cad2c66a21488, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_ec6763a25cc283c8349cad2c66a21488 = cache_frame_ec6763a25cc283c8349cad2c66a21488;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_ec6763a25cc283c8349cad2c66a21488);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_ec6763a25cc283c8349cad2c66a21488) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_other);
        tmp_isinstance_inst_1 = par_other;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_AuthorityInformationAccess);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_AuthorityInformationAccess);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 36438 ], 55, 0);
            exception_tb = NULL;

            exception_lineno = 288;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 288;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 288;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__descriptions);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 291;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_2 = par_other;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__descriptions);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_1);

            exception_lineno = 291;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 291;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ec6763a25cc283c8349cad2c66a21488);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_ec6763a25cc283c8349cad2c66a21488);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ec6763a25cc283c8349cad2c66a21488);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_ec6763a25cc283c8349cad2c66a21488, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_ec6763a25cc283c8349cad2c66a21488->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_ec6763a25cc283c8349cad2c66a21488, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ec6763a25cc283c8349cad2c66a21488,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_ec6763a25cc283c8349cad2c66a21488 == cache_frame_ec6763a25cc283c8349cad2c66a21488) {
        Py_DECREF(frame_ec6763a25cc283c8349cad2c66a21488);
    }
    cache_frame_ec6763a25cc283c8349cad2c66a21488 = NULL;

    assertFrameObject(frame_ec6763a25cc283c8349cad2c66a21488);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_34___eq__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_35___ne__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_bafa1748f4280a8d96a8ef0430df7fda;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_bafa1748f4280a8d96a8ef0430df7fda = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_bafa1748f4280a8d96a8ef0430df7fda, codeobj_bafa1748f4280a8d96a8ef0430df7fda, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_bafa1748f4280a8d96a8ef0430df7fda = cache_frame_bafa1748f4280a8d96a8ef0430df7fda;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_bafa1748f4280a8d96a8ef0430df7fda);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_bafa1748f4280a8d96a8ef0430df7fda) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_self);
        tmp_compexpr_left_1 = par_self;
        CHECK_OBJECT(par_other);
        tmp_compexpr_right_1 = par_other;
        tmp_operand_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 294;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 294;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = (tmp_res == 0) ? Py_True : Py_False;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_bafa1748f4280a8d96a8ef0430df7fda);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_bafa1748f4280a8d96a8ef0430df7fda);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_bafa1748f4280a8d96a8ef0430df7fda);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_bafa1748f4280a8d96a8ef0430df7fda, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_bafa1748f4280a8d96a8ef0430df7fda->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_bafa1748f4280a8d96a8ef0430df7fda, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_bafa1748f4280a8d96a8ef0430df7fda,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_bafa1748f4280a8d96a8ef0430df7fda == cache_frame_bafa1748f4280a8d96a8ef0430df7fda) {
        Py_DECREF(frame_bafa1748f4280a8d96a8ef0430df7fda);
    }
    cache_frame_bafa1748f4280a8d96a8ef0430df7fda = NULL;

    assertFrameObject(frame_bafa1748f4280a8d96a8ef0430df7fda);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_35___ne__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_36___getitem__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_idx = python_pars[1];
    struct Nuitka_FrameObject *frame_a61d36331eed656537469cdb25841c38;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_a61d36331eed656537469cdb25841c38 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_a61d36331eed656537469cdb25841c38, codeobj_a61d36331eed656537469cdb25841c38, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_a61d36331eed656537469cdb25841c38 = cache_frame_a61d36331eed656537469cdb25841c38;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_a61d36331eed656537469cdb25841c38);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_a61d36331eed656537469cdb25841c38) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_subscript_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__descriptions);
        if (tmp_subscribed_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 297;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_idx);
        tmp_subscript_name_1 = par_idx;
        tmp_return_value = LOOKUP_SUBSCRIPT(tmp_subscribed_name_1, tmp_subscript_name_1);
        Py_DECREF(tmp_subscribed_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 297;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a61d36331eed656537469cdb25841c38);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_a61d36331eed656537469cdb25841c38);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a61d36331eed656537469cdb25841c38);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_a61d36331eed656537469cdb25841c38, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_a61d36331eed656537469cdb25841c38->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_a61d36331eed656537469cdb25841c38, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a61d36331eed656537469cdb25841c38,
        type_description_1,
        par_self,
        par_idx
    );


    // Release cached frame.
    if (frame_a61d36331eed656537469cdb25841c38 == cache_frame_a61d36331eed656537469cdb25841c38) {
        Py_DECREF(frame_a61d36331eed656537469cdb25841c38);
    }
    cache_frame_a61d36331eed656537469cdb25841c38 = NULL;

    assertFrameObject(frame_a61d36331eed656537469cdb25841c38);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_36___getitem__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_idx);
    Py_DECREF(par_idx);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_idx);
    Py_DECREF(par_idx);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_37___hash__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_d4d5e0153429c0273ebb4e9160719179;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_d4d5e0153429c0273ebb4e9160719179 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_d4d5e0153429c0273ebb4e9160719179, codeobj_d4d5e0153429c0273ebb4e9160719179, module_cryptography$x509$extensions, sizeof(void *));
    frame_d4d5e0153429c0273ebb4e9160719179 = cache_frame_d4d5e0153429c0273ebb4e9160719179;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_d4d5e0153429c0273ebb4e9160719179);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_d4d5e0153429c0273ebb4e9160719179) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_hash_arg_1;
        PyObject *tmp_tuple_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_tuple_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__descriptions);
        if (tmp_tuple_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 300;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_hash_arg_1 = PySequence_Tuple(tmp_tuple_arg_1);
        Py_DECREF(tmp_tuple_arg_1);
        if (tmp_hash_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 300;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = BUILTIN_HASH(tmp_hash_arg_1);
        Py_DECREF(tmp_hash_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 300;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_d4d5e0153429c0273ebb4e9160719179);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_d4d5e0153429c0273ebb4e9160719179);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_d4d5e0153429c0273ebb4e9160719179);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_d4d5e0153429c0273ebb4e9160719179, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_d4d5e0153429c0273ebb4e9160719179->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_d4d5e0153429c0273ebb4e9160719179, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d4d5e0153429c0273ebb4e9160719179,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_d4d5e0153429c0273ebb4e9160719179 == cache_frame_d4d5e0153429c0273ebb4e9160719179) {
        Py_DECREF(frame_d4d5e0153429c0273ebb4e9160719179);
    }
    cache_frame_d4d5e0153429c0273ebb4e9160719179 = NULL;

    assertFrameObject(frame_d4d5e0153429c0273ebb4e9160719179);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_37___hash__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_38___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_access_method = python_pars[1];
    PyObject *par_access_location = python_pars[2];
    struct Nuitka_FrameObject *frame_d82db69e835d9e68e136650ca07bce53;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_d82db69e835d9e68e136650ca07bce53 = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_d82db69e835d9e68e136650ca07bce53, codeobj_d82db69e835d9e68e136650ca07bce53, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_d82db69e835d9e68e136650ca07bce53 = cache_frame_d82db69e835d9e68e136650ca07bce53;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_d82db69e835d9e68e136650ca07bce53);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_d82db69e835d9e68e136650ca07bce53) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_access_method);
        tmp_isinstance_inst_1 = par_access_method;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ObjectIdentifier);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ObjectIdentifier);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 18374 ], 45, 0);
            exception_tb = NULL;

            exception_lineno = 305;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 305;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 305;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_b436a97f38724e3583df19a1d449e278;
            frame_d82db69e835d9e68e136650ca07bce53->m_frame.f_lineno = 306;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 306;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_2;
        PyObject *tmp_isinstance_inst_2;
        PyObject *tmp_isinstance_cls_2;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT(par_access_location);
        tmp_isinstance_inst_2 = par_access_location;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_GeneralName);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_GeneralName);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 36192 ], 40, 0);
            exception_tb = NULL;

            exception_lineno = 308;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_2 = tmp_mvar_value_2;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_2, tmp_isinstance_cls_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 308;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_2 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 308;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            tmp_make_exception_arg_2 = const_str_digest_1dfb7a6265a6e9db387c1d41869616b8;
            frame_d82db69e835d9e68e136650ca07bce53->m_frame.f_lineno = 309;
            tmp_raise_type_2 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_2);
            assert(!(tmp_raise_type_2 == NULL));
            exception_type = tmp_raise_type_2;
            exception_lineno = 309;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_access_method);
        tmp_assattr_name_1 = par_access_method;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__access_method, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 311;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT(par_access_location);
        tmp_assattr_name_2 = par_access_location;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain__access_location, tmp_assattr_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 312;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_d82db69e835d9e68e136650ca07bce53);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_d82db69e835d9e68e136650ca07bce53);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_d82db69e835d9e68e136650ca07bce53, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_d82db69e835d9e68e136650ca07bce53->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_d82db69e835d9e68e136650ca07bce53, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d82db69e835d9e68e136650ca07bce53,
        type_description_1,
        par_self,
        par_access_method,
        par_access_location
    );


    // Release cached frame.
    if (frame_d82db69e835d9e68e136650ca07bce53 == cache_frame_d82db69e835d9e68e136650ca07bce53) {
        Py_DECREF(frame_d82db69e835d9e68e136650ca07bce53);
    }
    cache_frame_d82db69e835d9e68e136650ca07bce53 = NULL;

    assertFrameObject(frame_d82db69e835d9e68e136650ca07bce53);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_38___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_access_location);
    Py_DECREF(par_access_location);
    CHECK_OBJECT(par_access_method);
    Py_DECREF(par_access_method);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_access_location);
    Py_DECREF(par_access_location);
    CHECK_OBJECT(par_access_method);
    Py_DECREF(par_access_method);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_39___repr__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_cef83b92118b0cfd63adac31a6c2c4dd;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_cef83b92118b0cfd63adac31a6c2c4dd = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_cef83b92118b0cfd63adac31a6c2c4dd, codeobj_cef83b92118b0cfd63adac31a6c2c4dd, module_cryptography$x509$extensions, sizeof(void *));
    frame_cef83b92118b0cfd63adac31a6c2c4dd = cache_frame_cef83b92118b0cfd63adac31a6c2c4dd;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_cef83b92118b0cfd63adac31a6c2c4dd);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_cef83b92118b0cfd63adac31a6c2c4dd) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        tmp_called_instance_1 = const_str_digest_5576b3ba482b3c884e20c0f0f9889daf;
        CHECK_OBJECT(par_self);
        tmp_args_element_name_1 = par_self;
        frame_cef83b92118b0cfd63adac31a6c2c4dd->m_frame.f_lineno = 316;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_format, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 316;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_cef83b92118b0cfd63adac31a6c2c4dd);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_cef83b92118b0cfd63adac31a6c2c4dd);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_cef83b92118b0cfd63adac31a6c2c4dd);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_cef83b92118b0cfd63adac31a6c2c4dd, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_cef83b92118b0cfd63adac31a6c2c4dd->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_cef83b92118b0cfd63adac31a6c2c4dd, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_cef83b92118b0cfd63adac31a6c2c4dd,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_cef83b92118b0cfd63adac31a6c2c4dd == cache_frame_cef83b92118b0cfd63adac31a6c2c4dd) {
        Py_DECREF(frame_cef83b92118b0cfd63adac31a6c2c4dd);
    }
    cache_frame_cef83b92118b0cfd63adac31a6c2c4dd = NULL;

    assertFrameObject(frame_cef83b92118b0cfd63adac31a6c2c4dd);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_39___repr__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_40___eq__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_b89be643f7a61f3d81c6671d6ad51b78;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_b89be643f7a61f3d81c6671d6ad51b78 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_b89be643f7a61f3d81c6671d6ad51b78, codeobj_b89be643f7a61f3d81c6671d6ad51b78, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_b89be643f7a61f3d81c6671d6ad51b78 = cache_frame_b89be643f7a61f3d81c6671d6ad51b78;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_b89be643f7a61f3d81c6671d6ad51b78);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_b89be643f7a61f3d81c6671d6ad51b78) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_other);
        tmp_isinstance_inst_1 = par_other;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_AccessDescription);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_AccessDescription);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 36392 ], 46, 0);
            exception_tb = NULL;

            exception_lineno = 321;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 321;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 321;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        int tmp_and_left_truth_1;
        PyObject *tmp_and_left_value_1;
        PyObject *tmp_and_right_value_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_source_name_4;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_access_method);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 325;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_2 = par_other;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_access_method);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_1);

            exception_lineno = 325;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_and_left_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 325;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_truth_1 = CHECK_IF_TRUE(tmp_and_left_value_1);
        if (tmp_and_left_truth_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_and_left_value_1);

            exception_lineno = 326;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        if (tmp_and_left_truth_1 == 1) {
            goto and_right_1;
        } else {
            goto and_left_1;
        }
        and_right_1:;
        Py_DECREF(tmp_and_left_value_1);
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_access_location);
        if (tmp_compexpr_left_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 326;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_4 = par_other;
        tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_access_location);
        if (tmp_compexpr_right_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_2);

            exception_lineno = 326;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
        Py_DECREF(tmp_compexpr_left_2);
        Py_DECREF(tmp_compexpr_right_2);
        if (tmp_and_right_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 326;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_return_value = tmp_and_left_value_1;
        and_end_1:;
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b89be643f7a61f3d81c6671d6ad51b78);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_b89be643f7a61f3d81c6671d6ad51b78);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b89be643f7a61f3d81c6671d6ad51b78);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_b89be643f7a61f3d81c6671d6ad51b78, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_b89be643f7a61f3d81c6671d6ad51b78->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_b89be643f7a61f3d81c6671d6ad51b78, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b89be643f7a61f3d81c6671d6ad51b78,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_b89be643f7a61f3d81c6671d6ad51b78 == cache_frame_b89be643f7a61f3d81c6671d6ad51b78) {
        Py_DECREF(frame_b89be643f7a61f3d81c6671d6ad51b78);
    }
    cache_frame_b89be643f7a61f3d81c6671d6ad51b78 = NULL;

    assertFrameObject(frame_b89be643f7a61f3d81c6671d6ad51b78);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_40___eq__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_41___ne__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_0717dde802ff3bf828c32149b86f91c5;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_0717dde802ff3bf828c32149b86f91c5 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_0717dde802ff3bf828c32149b86f91c5, codeobj_0717dde802ff3bf828c32149b86f91c5, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_0717dde802ff3bf828c32149b86f91c5 = cache_frame_0717dde802ff3bf828c32149b86f91c5;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_0717dde802ff3bf828c32149b86f91c5);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_0717dde802ff3bf828c32149b86f91c5) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_self);
        tmp_compexpr_left_1 = par_self;
        CHECK_OBJECT(par_other);
        tmp_compexpr_right_1 = par_other;
        tmp_operand_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 330;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 330;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = (tmp_res == 0) ? Py_True : Py_False;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0717dde802ff3bf828c32149b86f91c5);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_0717dde802ff3bf828c32149b86f91c5);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0717dde802ff3bf828c32149b86f91c5);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_0717dde802ff3bf828c32149b86f91c5, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_0717dde802ff3bf828c32149b86f91c5->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_0717dde802ff3bf828c32149b86f91c5, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0717dde802ff3bf828c32149b86f91c5,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_0717dde802ff3bf828c32149b86f91c5 == cache_frame_0717dde802ff3bf828c32149b86f91c5) {
        Py_DECREF(frame_0717dde802ff3bf828c32149b86f91c5);
    }
    cache_frame_0717dde802ff3bf828c32149b86f91c5 = NULL;

    assertFrameObject(frame_0717dde802ff3bf828c32149b86f91c5);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_41___ne__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_42___hash__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_9e5fdab2f284d2dbd1ea4bcd02f4243a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_9e5fdab2f284d2dbd1ea4bcd02f4243a = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_9e5fdab2f284d2dbd1ea4bcd02f4243a, codeobj_9e5fdab2f284d2dbd1ea4bcd02f4243a, module_cryptography$x509$extensions, sizeof(void *));
    frame_9e5fdab2f284d2dbd1ea4bcd02f4243a = cache_frame_9e5fdab2f284d2dbd1ea4bcd02f4243a;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_9e5fdab2f284d2dbd1ea4bcd02f4243a);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_9e5fdab2f284d2dbd1ea4bcd02f4243a) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_hash_arg_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_access_method);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 333;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_hash_arg_1 = PyTuple_New(2);
        PyTuple_SET_ITEM(tmp_hash_arg_1, 0, tmp_tuple_element_1);
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_access_location);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_hash_arg_1);

            exception_lineno = 333;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM(tmp_hash_arg_1, 1, tmp_tuple_element_1);
        tmp_return_value = BUILTIN_HASH(tmp_hash_arg_1);
        Py_DECREF(tmp_hash_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 333;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9e5fdab2f284d2dbd1ea4bcd02f4243a);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_9e5fdab2f284d2dbd1ea4bcd02f4243a);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9e5fdab2f284d2dbd1ea4bcd02f4243a);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_9e5fdab2f284d2dbd1ea4bcd02f4243a, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_9e5fdab2f284d2dbd1ea4bcd02f4243a->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_9e5fdab2f284d2dbd1ea4bcd02f4243a, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9e5fdab2f284d2dbd1ea4bcd02f4243a,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_9e5fdab2f284d2dbd1ea4bcd02f4243a == cache_frame_9e5fdab2f284d2dbd1ea4bcd02f4243a) {
        Py_DECREF(frame_9e5fdab2f284d2dbd1ea4bcd02f4243a);
    }
    cache_frame_9e5fdab2f284d2dbd1ea4bcd02f4243a = NULL;

    assertFrameObject(frame_9e5fdab2f284d2dbd1ea4bcd02f4243a);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_42___hash__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_43___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_ca = python_pars[1];
    PyObject *par_path_length = python_pars[2];
    struct Nuitka_FrameObject *frame_fc83f25a35c64baf86fc9abec28579bf;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_fc83f25a35c64baf86fc9abec28579bf = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_fc83f25a35c64baf86fc9abec28579bf, codeobj_fc83f25a35c64baf86fc9abec28579bf, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_fc83f25a35c64baf86fc9abec28579bf = cache_frame_fc83f25a35c64baf86fc9abec28579bf;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_fc83f25a35c64baf86fc9abec28579bf);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_fc83f25a35c64baf86fc9abec28579bf) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        CHECK_OBJECT(par_ca);
        tmp_isinstance_inst_1 = par_ca;
        tmp_isinstance_cls_1 = (PyObject *)&PyBool_Type;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 344;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 344;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_421b43a5ec9f9f0f5f30b5a50ec3db96;
            frame_fc83f25a35c64baf86fc9abec28579bf->m_frame.f_lineno = 345;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 345;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        int tmp_and_left_truth_1;
        nuitka_bool tmp_and_left_value_1;
        nuitka_bool tmp_and_right_value_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_operand_name_2;
        CHECK_OBJECT(par_path_length);
        tmp_compexpr_left_1 = par_path_length;
        tmp_compexpr_right_1 = Py_None;
        tmp_and_left_value_1 = (tmp_compexpr_left_1 != tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if (tmp_and_left_truth_1 == 1) {
            goto and_right_1;
        } else {
            goto and_left_1;
        }
        and_right_1:;
        CHECK_OBJECT(par_ca);
        tmp_operand_name_2 = par_ca;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 347;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_condition_result_2 = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_condition_result_2 = tmp_and_left_value_1;
        and_end_1:;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            tmp_make_exception_arg_2 = const_str_digest_ba0ace4d3ab5fb435146fa7a7a8c5e76;
            frame_fc83f25a35c64baf86fc9abec28579bf->m_frame.f_lineno = 348;
            tmp_raise_type_2 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_2);
            assert(!(tmp_raise_type_2 == NULL));
            exception_type = tmp_raise_type_2;
            exception_lineno = 348;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        int tmp_and_left_truth_2;
        nuitka_bool tmp_and_left_value_2;
        nuitka_bool tmp_and_right_value_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        int tmp_or_left_truth_1;
        nuitka_bool tmp_or_left_value_1;
        nuitka_bool tmp_or_right_value_1;
        PyObject *tmp_operand_name_3;
        PyObject *tmp_isinstance_inst_2;
        PyObject *tmp_isinstance_cls_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        CHECK_OBJECT(par_path_length);
        tmp_compexpr_left_2 = par_path_length;
        tmp_compexpr_right_2 = Py_None;
        tmp_and_left_value_2 = (tmp_compexpr_left_2 != tmp_compexpr_right_2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_2 = tmp_and_left_value_2 == NUITKA_BOOL_TRUE ? 1 : 0;
        if (tmp_and_left_truth_2 == 1) {
            goto and_right_2;
        } else {
            goto and_left_2;
        }
        and_right_2:;
        CHECK_OBJECT(par_path_length);
        tmp_isinstance_inst_2 = par_path_length;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_six);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_six);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 19694 ], 32, 0);
            exception_tb = NULL;

            exception_lineno = 352;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_isinstance_cls_2 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_integer_types);
        if (tmp_isinstance_cls_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 352;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_2, tmp_isinstance_cls_2);
        Py_DECREF(tmp_isinstance_cls_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 352;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_3 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_3);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 352;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_or_left_value_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_or_left_truth_1 = tmp_or_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if (tmp_or_left_truth_1 == 1) {
            goto or_left_1;
        } else {
            goto or_right_1;
        }
        or_right_1:;
        CHECK_OBJECT(par_path_length);
        tmp_compexpr_left_3 = par_path_length;
        tmp_compexpr_right_3 = const_int_0;
        tmp_res = RICH_COMPARE_BOOL_LT_OBJECT_INT(tmp_compexpr_left_3, tmp_compexpr_right_3);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 352;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_or_right_value_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_right_value_2 = tmp_or_right_value_1;
        goto or_end_1;
        or_left_1:;
        tmp_and_right_value_2 = tmp_or_left_value_1;
        or_end_1:;
        tmp_condition_result_3 = tmp_and_right_value_2;
        goto and_end_2;
        and_left_2:;
        tmp_condition_result_3 = tmp_and_left_value_2;
        and_end_2:;
        if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
            goto branch_yes_3;
        } else {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_raise_type_3;
            PyObject *tmp_make_exception_arg_3;
            tmp_make_exception_arg_3 = const_str_digest_350fb76bfa2c81c3db35fe4ad0c5cc28;
            frame_fc83f25a35c64baf86fc9abec28579bf->m_frame.f_lineno = 354;
            tmp_raise_type_3 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_3);
            assert(!(tmp_raise_type_3 == NULL));
            exception_type = tmp_raise_type_3;
            exception_lineno = 354;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_3:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_ca);
        tmp_assattr_name_1 = par_ca;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__ca, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 358;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT(par_path_length);
        tmp_assattr_name_2 = par_path_length;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain__path_length, tmp_assattr_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 359;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_fc83f25a35c64baf86fc9abec28579bf);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_fc83f25a35c64baf86fc9abec28579bf);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_fc83f25a35c64baf86fc9abec28579bf, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_fc83f25a35c64baf86fc9abec28579bf->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_fc83f25a35c64baf86fc9abec28579bf, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_fc83f25a35c64baf86fc9abec28579bf,
        type_description_1,
        par_self,
        par_ca,
        par_path_length
    );


    // Release cached frame.
    if (frame_fc83f25a35c64baf86fc9abec28579bf == cache_frame_fc83f25a35c64baf86fc9abec28579bf) {
        Py_DECREF(frame_fc83f25a35c64baf86fc9abec28579bf);
    }
    cache_frame_fc83f25a35c64baf86fc9abec28579bf = NULL;

    assertFrameObject(frame_fc83f25a35c64baf86fc9abec28579bf);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_43___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_ca);
    Py_DECREF(par_ca);
    CHECK_OBJECT(par_path_length);
    Py_DECREF(par_path_length);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_ca);
    Py_DECREF(par_ca);
    CHECK_OBJECT(par_path_length);
    Py_DECREF(par_path_length);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_44___repr__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_574e55e9b19a65578d5335f615e3ce1f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_574e55e9b19a65578d5335f615e3ce1f = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_574e55e9b19a65578d5335f615e3ce1f, codeobj_574e55e9b19a65578d5335f615e3ce1f, module_cryptography$x509$extensions, sizeof(void *));
    frame_574e55e9b19a65578d5335f615e3ce1f = cache_frame_574e55e9b19a65578d5335f615e3ce1f;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_574e55e9b19a65578d5335f615e3ce1f);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_574e55e9b19a65578d5335f615e3ce1f) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        tmp_called_instance_1 = const_str_digest_d0363a16b2327897c21c9e61fd2edb1e;
        CHECK_OBJECT(par_self);
        tmp_args_element_name_1 = par_self;
        frame_574e55e9b19a65578d5335f615e3ce1f->m_frame.f_lineno = 365;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_format, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 365;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_574e55e9b19a65578d5335f615e3ce1f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_574e55e9b19a65578d5335f615e3ce1f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_574e55e9b19a65578d5335f615e3ce1f);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_574e55e9b19a65578d5335f615e3ce1f, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_574e55e9b19a65578d5335f615e3ce1f->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_574e55e9b19a65578d5335f615e3ce1f, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_574e55e9b19a65578d5335f615e3ce1f,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_574e55e9b19a65578d5335f615e3ce1f == cache_frame_574e55e9b19a65578d5335f615e3ce1f) {
        Py_DECREF(frame_574e55e9b19a65578d5335f615e3ce1f);
    }
    cache_frame_574e55e9b19a65578d5335f615e3ce1f = NULL;

    assertFrameObject(frame_574e55e9b19a65578d5335f615e3ce1f);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_44___repr__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_45___eq__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_bf509f0149490c9f7ccf380ab57d6798;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_bf509f0149490c9f7ccf380ab57d6798 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_bf509f0149490c9f7ccf380ab57d6798, codeobj_bf509f0149490c9f7ccf380ab57d6798, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_bf509f0149490c9f7ccf380ab57d6798 = cache_frame_bf509f0149490c9f7ccf380ab57d6798;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_bf509f0149490c9f7ccf380ab57d6798);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_bf509f0149490c9f7ccf380ab57d6798) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_other);
        tmp_isinstance_inst_1 = par_other;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_BasicConstraints);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_BasicConstraints);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 36493 ], 45, 0);
            exception_tb = NULL;

            exception_lineno = 369;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 369;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 369;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        int tmp_and_left_truth_1;
        PyObject *tmp_and_left_value_1;
        PyObject *tmp_and_right_value_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_source_name_4;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_ca);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 372;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_2 = par_other;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_ca);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_1);

            exception_lineno = 372;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_and_left_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 372;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_truth_1 = CHECK_IF_TRUE(tmp_and_left_value_1);
        if (tmp_and_left_truth_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_and_left_value_1);

            exception_lineno = 372;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        if (tmp_and_left_truth_1 == 1) {
            goto and_right_1;
        } else {
            goto and_left_1;
        }
        and_right_1:;
        Py_DECREF(tmp_and_left_value_1);
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_path_length);
        if (tmp_compexpr_left_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 372;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_4 = par_other;
        tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_path_length);
        if (tmp_compexpr_right_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_2);

            exception_lineno = 372;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
        Py_DECREF(tmp_compexpr_left_2);
        Py_DECREF(tmp_compexpr_right_2);
        if (tmp_and_right_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 372;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_return_value = tmp_and_left_value_1;
        and_end_1:;
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_bf509f0149490c9f7ccf380ab57d6798);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_bf509f0149490c9f7ccf380ab57d6798);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_bf509f0149490c9f7ccf380ab57d6798);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_bf509f0149490c9f7ccf380ab57d6798, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_bf509f0149490c9f7ccf380ab57d6798->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_bf509f0149490c9f7ccf380ab57d6798, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_bf509f0149490c9f7ccf380ab57d6798,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_bf509f0149490c9f7ccf380ab57d6798 == cache_frame_bf509f0149490c9f7ccf380ab57d6798) {
        Py_DECREF(frame_bf509f0149490c9f7ccf380ab57d6798);
    }
    cache_frame_bf509f0149490c9f7ccf380ab57d6798 = NULL;

    assertFrameObject(frame_bf509f0149490c9f7ccf380ab57d6798);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_45___eq__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_46___ne__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_b2624bbf7f2345dffc42b8356201f32c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_b2624bbf7f2345dffc42b8356201f32c = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_b2624bbf7f2345dffc42b8356201f32c, codeobj_b2624bbf7f2345dffc42b8356201f32c, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_b2624bbf7f2345dffc42b8356201f32c = cache_frame_b2624bbf7f2345dffc42b8356201f32c;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_b2624bbf7f2345dffc42b8356201f32c);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_b2624bbf7f2345dffc42b8356201f32c) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_self);
        tmp_compexpr_left_1 = par_self;
        CHECK_OBJECT(par_other);
        tmp_compexpr_right_1 = par_other;
        tmp_operand_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 375;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 375;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = (tmp_res == 0) ? Py_True : Py_False;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b2624bbf7f2345dffc42b8356201f32c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_b2624bbf7f2345dffc42b8356201f32c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b2624bbf7f2345dffc42b8356201f32c);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_b2624bbf7f2345dffc42b8356201f32c, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_b2624bbf7f2345dffc42b8356201f32c->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_b2624bbf7f2345dffc42b8356201f32c, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b2624bbf7f2345dffc42b8356201f32c,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_b2624bbf7f2345dffc42b8356201f32c == cache_frame_b2624bbf7f2345dffc42b8356201f32c) {
        Py_DECREF(frame_b2624bbf7f2345dffc42b8356201f32c);
    }
    cache_frame_b2624bbf7f2345dffc42b8356201f32c = NULL;

    assertFrameObject(frame_b2624bbf7f2345dffc42b8356201f32c);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_46___ne__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_47___hash__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_94ad4941638ca2d741d049b1fa5e9734;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_94ad4941638ca2d741d049b1fa5e9734 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_94ad4941638ca2d741d049b1fa5e9734, codeobj_94ad4941638ca2d741d049b1fa5e9734, module_cryptography$x509$extensions, sizeof(void *));
    frame_94ad4941638ca2d741d049b1fa5e9734 = cache_frame_94ad4941638ca2d741d049b1fa5e9734;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_94ad4941638ca2d741d049b1fa5e9734);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_94ad4941638ca2d741d049b1fa5e9734) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_hash_arg_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_ca);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 378;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_hash_arg_1 = PyTuple_New(2);
        PyTuple_SET_ITEM(tmp_hash_arg_1, 0, tmp_tuple_element_1);
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_path_length);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_hash_arg_1);

            exception_lineno = 378;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM(tmp_hash_arg_1, 1, tmp_tuple_element_1);
        tmp_return_value = BUILTIN_HASH(tmp_hash_arg_1);
        Py_DECREF(tmp_hash_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 378;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_94ad4941638ca2d741d049b1fa5e9734);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_94ad4941638ca2d741d049b1fa5e9734);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_94ad4941638ca2d741d049b1fa5e9734);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_94ad4941638ca2d741d049b1fa5e9734, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_94ad4941638ca2d741d049b1fa5e9734->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_94ad4941638ca2d741d049b1fa5e9734, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_94ad4941638ca2d741d049b1fa5e9734,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_94ad4941638ca2d741d049b1fa5e9734 == cache_frame_94ad4941638ca2d741d049b1fa5e9734) {
        Py_DECREF(frame_94ad4941638ca2d741d049b1fa5e9734);
    }
    cache_frame_94ad4941638ca2d741d049b1fa5e9734 = NULL;

    assertFrameObject(frame_94ad4941638ca2d741d049b1fa5e9734);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_47___hash__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_48___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_crl_number = python_pars[1];
    struct Nuitka_FrameObject *frame_8947fe591337cc5a2cf6de779a4c5523;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_8947fe591337cc5a2cf6de779a4c5523 = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_8947fe591337cc5a2cf6de779a4c5523, codeobj_8947fe591337cc5a2cf6de779a4c5523, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_8947fe591337cc5a2cf6de779a4c5523 = cache_frame_8947fe591337cc5a2cf6de779a4c5523;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_8947fe591337cc5a2cf6de779a4c5523);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_8947fe591337cc5a2cf6de779a4c5523) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_crl_number);
        tmp_isinstance_inst_1 = par_crl_number;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_six);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_six);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 19694 ], 32, 0);
            exception_tb = NULL;

            exception_lineno = 386;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_isinstance_cls_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_integer_types);
        if (tmp_isinstance_cls_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 386;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        Py_DECREF(tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 386;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 386;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_f7714799e19abc5d09ccbaf8366649ea;
            frame_8947fe591337cc5a2cf6de779a4c5523->m_frame.f_lineno = 387;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 387;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_crl_number);
        tmp_assattr_name_1 = par_crl_number;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__crl_number, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 389;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8947fe591337cc5a2cf6de779a4c5523);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8947fe591337cc5a2cf6de779a4c5523);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_8947fe591337cc5a2cf6de779a4c5523, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_8947fe591337cc5a2cf6de779a4c5523->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_8947fe591337cc5a2cf6de779a4c5523, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8947fe591337cc5a2cf6de779a4c5523,
        type_description_1,
        par_self,
        par_crl_number
    );


    // Release cached frame.
    if (frame_8947fe591337cc5a2cf6de779a4c5523 == cache_frame_8947fe591337cc5a2cf6de779a4c5523) {
        Py_DECREF(frame_8947fe591337cc5a2cf6de779a4c5523);
    }
    cache_frame_8947fe591337cc5a2cf6de779a4c5523 = NULL;

    assertFrameObject(frame_8947fe591337cc5a2cf6de779a4c5523);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_48___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_crl_number);
    Py_DECREF(par_crl_number);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_crl_number);
    Py_DECREF(par_crl_number);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_49___eq__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_56e3c65f02e773e82d404aa393504dde;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_56e3c65f02e773e82d404aa393504dde = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_56e3c65f02e773e82d404aa393504dde, codeobj_56e3c65f02e773e82d404aa393504dde, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_56e3c65f02e773e82d404aa393504dde = cache_frame_56e3c65f02e773e82d404aa393504dde;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_56e3c65f02e773e82d404aa393504dde);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_56e3c65f02e773e82d404aa393504dde) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_other);
        tmp_isinstance_inst_1 = par_other;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_DeltaCRLIndicator);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_DeltaCRLIndicator);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 36538 ], 46, 0);
            exception_tb = NULL;

            exception_lineno = 394;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 394;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 394;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_crl_number);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 397;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_2 = par_other;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_crl_number);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_1);

            exception_lineno = 397;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 397;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_56e3c65f02e773e82d404aa393504dde);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_56e3c65f02e773e82d404aa393504dde);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_56e3c65f02e773e82d404aa393504dde);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_56e3c65f02e773e82d404aa393504dde, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_56e3c65f02e773e82d404aa393504dde->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_56e3c65f02e773e82d404aa393504dde, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_56e3c65f02e773e82d404aa393504dde,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_56e3c65f02e773e82d404aa393504dde == cache_frame_56e3c65f02e773e82d404aa393504dde) {
        Py_DECREF(frame_56e3c65f02e773e82d404aa393504dde);
    }
    cache_frame_56e3c65f02e773e82d404aa393504dde = NULL;

    assertFrameObject(frame_56e3c65f02e773e82d404aa393504dde);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_49___eq__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_50___ne__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_6eec4ed29d652d67297334df34b9efea;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_6eec4ed29d652d67297334df34b9efea = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_6eec4ed29d652d67297334df34b9efea, codeobj_6eec4ed29d652d67297334df34b9efea, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_6eec4ed29d652d67297334df34b9efea = cache_frame_6eec4ed29d652d67297334df34b9efea;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_6eec4ed29d652d67297334df34b9efea);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_6eec4ed29d652d67297334df34b9efea) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_self);
        tmp_compexpr_left_1 = par_self;
        CHECK_OBJECT(par_other);
        tmp_compexpr_right_1 = par_other;
        tmp_operand_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 400;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 400;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = (tmp_res == 0) ? Py_True : Py_False;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_6eec4ed29d652d67297334df34b9efea);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_6eec4ed29d652d67297334df34b9efea);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_6eec4ed29d652d67297334df34b9efea);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_6eec4ed29d652d67297334df34b9efea, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_6eec4ed29d652d67297334df34b9efea->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_6eec4ed29d652d67297334df34b9efea, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6eec4ed29d652d67297334df34b9efea,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_6eec4ed29d652d67297334df34b9efea == cache_frame_6eec4ed29d652d67297334df34b9efea) {
        Py_DECREF(frame_6eec4ed29d652d67297334df34b9efea);
    }
    cache_frame_6eec4ed29d652d67297334df34b9efea = NULL;

    assertFrameObject(frame_6eec4ed29d652d67297334df34b9efea);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_50___ne__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_51___hash__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_24e6c32aa2722cf4ecaa3b16048d4738;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_24e6c32aa2722cf4ecaa3b16048d4738 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_24e6c32aa2722cf4ecaa3b16048d4738, codeobj_24e6c32aa2722cf4ecaa3b16048d4738, module_cryptography$x509$extensions, sizeof(void *));
    frame_24e6c32aa2722cf4ecaa3b16048d4738 = cache_frame_24e6c32aa2722cf4ecaa3b16048d4738;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_24e6c32aa2722cf4ecaa3b16048d4738);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_24e6c32aa2722cf4ecaa3b16048d4738) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_hash_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_hash_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_crl_number);
        if (tmp_hash_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 403;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = BUILTIN_HASH(tmp_hash_arg_1);
        Py_DECREF(tmp_hash_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 403;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_24e6c32aa2722cf4ecaa3b16048d4738);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_24e6c32aa2722cf4ecaa3b16048d4738);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_24e6c32aa2722cf4ecaa3b16048d4738);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_24e6c32aa2722cf4ecaa3b16048d4738, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_24e6c32aa2722cf4ecaa3b16048d4738->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_24e6c32aa2722cf4ecaa3b16048d4738, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_24e6c32aa2722cf4ecaa3b16048d4738,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_24e6c32aa2722cf4ecaa3b16048d4738 == cache_frame_24e6c32aa2722cf4ecaa3b16048d4738) {
        Py_DECREF(frame_24e6c32aa2722cf4ecaa3b16048d4738);
    }
    cache_frame_24e6c32aa2722cf4ecaa3b16048d4738 = NULL;

    assertFrameObject(frame_24e6c32aa2722cf4ecaa3b16048d4738);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_51___hash__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_52___repr__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_149b439b28110db47c6d802c9ba60c85;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_149b439b28110db47c6d802c9ba60c85 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_149b439b28110db47c6d802c9ba60c85, codeobj_149b439b28110db47c6d802c9ba60c85, module_cryptography$x509$extensions, sizeof(void *));
    frame_149b439b28110db47c6d802c9ba60c85 = cache_frame_149b439b28110db47c6d802c9ba60c85;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_149b439b28110db47c6d802c9ba60c85);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_149b439b28110db47c6d802c9ba60c85) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        tmp_called_instance_1 = const_str_digest_009ff6af115398b3dfb26f0926fdbea2;
        CHECK_OBJECT(par_self);
        tmp_args_element_name_1 = par_self;
        frame_149b439b28110db47c6d802c9ba60c85->m_frame.f_lineno = 406;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_format, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 406;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_149b439b28110db47c6d802c9ba60c85);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_149b439b28110db47c6d802c9ba60c85);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_149b439b28110db47c6d802c9ba60c85);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_149b439b28110db47c6d802c9ba60c85, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_149b439b28110db47c6d802c9ba60c85->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_149b439b28110db47c6d802c9ba60c85, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_149b439b28110db47c6d802c9ba60c85,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_149b439b28110db47c6d802c9ba60c85 == cache_frame_149b439b28110db47c6d802c9ba60c85) {
        Py_DECREF(frame_149b439b28110db47c6d802c9ba60c85);
    }
    cache_frame_149b439b28110db47c6d802c9ba60c85 = NULL;

    assertFrameObject(frame_149b439b28110db47c6d802c9ba60c85);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_52___repr__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_53___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_distribution_points = python_pars[1];
    PyObject *tmp_genexpr_1__$0 = NULL;
    struct Nuitka_FrameObject *frame_9dea707d642354d82eb245b14decc508;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_9dea707d642354d82eb245b14decc508 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_9dea707d642354d82eb245b14decc508, codeobj_9dea707d642354d82eb245b14decc508, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_9dea707d642354d82eb245b14decc508 = cache_frame_9dea707d642354d82eb245b14decc508;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_9dea707d642354d82eb245b14decc508);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_9dea707d642354d82eb245b14decc508) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_list_arg_1;
        CHECK_OBJECT(par_distribution_points);
        tmp_list_arg_1 = par_distribution_points;
        tmp_assign_source_1 = PySequence_List(tmp_list_arg_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 414;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = par_distribution_points;
            assert(old != NULL);
            par_distribution_points = tmp_assign_source_1;
            Py_DECREF(old);
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_all_arg_1;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT(par_distribution_points);
            tmp_iter_arg_1 = par_distribution_points;
            tmp_assign_source_2 = MAKE_ITERATOR(tmp_iter_arg_1);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 416;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            assert(tmp_genexpr_1__$0 == NULL);
            tmp_genexpr_1__$0 = tmp_assign_source_2;
        }
        // Tried code:
        tmp_all_arg_1 = cryptography$x509$extensions$$$function_53___init__$$$genexpr_1_genexpr_maker();

        ((struct Nuitka_GeneratorObject *)tmp_all_arg_1)->m_closure[0] = PyCell_NEW0(tmp_genexpr_1__$0);


        goto try_return_handler_2;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_53___init__);
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        CHECK_OBJECT((PyObject *)tmp_genexpr_1__$0);
        Py_DECREF(tmp_genexpr_1__$0);
        tmp_genexpr_1__$0 = NULL;

        goto outline_result_1;
        // End of try:
        CHECK_OBJECT((PyObject *)tmp_genexpr_1__$0);
        Py_DECREF(tmp_genexpr_1__$0);
        tmp_genexpr_1__$0 = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_53___init__);
        return NULL;
        outline_result_1:;
        tmp_operand_name_1 = BUILTIN_ALL(tmp_all_arg_1);
        Py_DECREF(tmp_all_arg_1);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 415;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 415;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_37a5813a8df88d549fa10cdd6f24a9b9;
            frame_9dea707d642354d82eb245b14decc508->m_frame.f_lineno = 418;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 418;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_distribution_points);
        tmp_assattr_name_1 = par_distribution_points;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__distribution_points, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 423;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9dea707d642354d82eb245b14decc508);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9dea707d642354d82eb245b14decc508);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_9dea707d642354d82eb245b14decc508, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_9dea707d642354d82eb245b14decc508->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_9dea707d642354d82eb245b14decc508, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9dea707d642354d82eb245b14decc508,
        type_description_1,
        par_self,
        par_distribution_points
    );


    // Release cached frame.
    if (frame_9dea707d642354d82eb245b14decc508 == cache_frame_9dea707d642354d82eb245b14decc508) {
        Py_DECREF(frame_9dea707d642354d82eb245b14decc508);
    }
    cache_frame_9dea707d642354d82eb245b14decc508 = NULL;

    assertFrameObject(frame_9dea707d642354d82eb245b14decc508);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_53___init__);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)par_distribution_points);
    Py_DECREF(par_distribution_points);
    par_distribution_points = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)par_distribution_points);
    Py_DECREF(par_distribution_points);
    par_distribution_points = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_53___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}



struct cryptography$x509$extensions$$$function_53___init__$$$genexpr_1_genexpr_locals {
    PyObject *var_x;
    PyObject *tmp_iter_value_0;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    int tmp_res;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *cryptography$x509$extensions$$$function_53___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value ) {
    CHECK_OBJECT((PyObject *)generator);
    assert(Nuitka_Generator_Check( (PyObject *)generator ));

    // Heap access if used.
    struct cryptography$x509$extensions$$$function_53___init__$$$genexpr_1_genexpr_locals *generator_heap = (struct cryptography$x509$extensions$$$function_53___init__$$$genexpr_1_genexpr_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_x = NULL;
    generator_heap->tmp_iter_value_0 = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_m_frame, codeobj_7d4fd4c587e255df3371241a48928f28, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF(generator->m_frame);
    assert(Py_REFCNT(generator->m_frame) == 2); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR(generator->m_frame->m_frame.f_back);

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF(generator->m_frame->m_frame.f_back);

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF(generator->m_frame);

    Nuitka_Frame_MarkAsExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

        EXC_TYPE_F(generator) = EXC_TYPE(thread_state);
        if (EXC_TYPE_F(generator) == Py_None) EXC_TYPE_F(generator) = NULL;
        Py_XINCREF(EXC_TYPE_F(generator));
        EXC_VALUE_F(generator) = EXC_VALUE(thread_state);
        Py_XINCREF(EXC_VALUE_F(generator));
        EXC_TRACEBACK_F(generator) = EXC_TRACEBACK(thread_state);
        Py_XINCREF(EXC_TRACEBACK_F(generator));
    }

#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_1;
        CHECK_OBJECT(PyCell_GET(generator->m_closure[0]));
        tmp_next_source_1 = PyCell_GET(generator->m_closure[0]);
        tmp_assign_source_1 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_1 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);
                generator_heap->type_description_1 = "No";
                generator_heap->exception_lineno = 416;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_iter_value_0;
            generator_heap->tmp_iter_value_0 = tmp_assign_source_1;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT(generator_heap->tmp_iter_value_0);
        tmp_assign_source_2 = generator_heap->tmp_iter_value_0;
        {
            PyObject *old = generator_heap->var_x;
            generator_heap->var_x = tmp_assign_source_2;
            Py_INCREF(generator_heap->var_x);
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_expression_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        CHECK_OBJECT(generator_heap->var_x);
        tmp_isinstance_inst_1 = generator_heap->var_x;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_DistributionPoint);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_DistributionPoint);
        }

        if (tmp_mvar_value_1 == NULL) {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF(generator_heap->exception_type);
            generator_heap->exception_value = UNSTREAM_STRING(&constant_bin[ 36584 ], 46, 0);
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 416;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        generator_heap->tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (generator_heap->tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 416;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_expression_name_1 = (generator_heap->tmp_res != 0) ? Py_True : Py_False;
        Py_INCREF(tmp_expression_name_1);
        Nuitka_PreserveHeap(generator_heap->yield_tmps, &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), NULL);
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        Nuitka_RestoreHeap(generator_heap->yield_tmps, &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), NULL);
        if (yield_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 416;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


        generator_heap->exception_lineno = 416;
        generator_heap->type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    // Allow re-use of the frame again.
    Py_DECREF(generator->m_frame);
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if (!EXCEPTION_MATCH_GENERATOR(generator_heap->exception_type)) {
        if (generator_heap->exception_tb == NULL) {
            generator_heap->exception_tb = MAKE_TRACEBACK(generator->m_frame, generator_heap->exception_lineno);
        } else if (generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame) {
            generator_heap->exception_tb = ADD_TRACEBACK(generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno);
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            NULL,
            generator_heap->var_x
        );


        // Release cached frame.
        if (generator->m_frame == cache_m_frame) {
            Py_DECREF(generator->m_frame);
        }
        cache_m_frame = NULL;

        assertFrameObject(generator->m_frame);
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    Py_DECREF(generator->m_frame);

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->var_x);
    generator_heap->var_x = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    Py_XDECREF(generator_heap->var_x);
    generator_heap->var_x = NULL;



    return NULL;

    function_exception_exit:
    assert(generator_heap->exception_type);
    RESTORE_ERROR_OCCURRED(generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb);

    return NULL;

}

static PyObject *cryptography$x509$extensions$$$function_53___init__$$$genexpr_1_genexpr_maker(void) {
    return Nuitka_Generator_New(
        cryptography$x509$extensions$$$function_53___init__$$$genexpr_1_genexpr_context,
        module_cryptography$x509$extensions,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_7d4fd4c587e255df3371241a48928f28,
        1,
        sizeof(struct cryptography$x509$extensions$$$function_53___init__$$$genexpr_1_genexpr_locals)
    );
}


static PyObject *impl_cryptography$x509$extensions$$$function_54___iter__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_0cc8a86e0089204a5f1ba5499e750c59;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_0cc8a86e0089204a5f1ba5499e750c59 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_0cc8a86e0089204a5f1ba5499e750c59, codeobj_0cc8a86e0089204a5f1ba5499e750c59, module_cryptography$x509$extensions, sizeof(void *));
    frame_0cc8a86e0089204a5f1ba5499e750c59 = cache_frame_0cc8a86e0089204a5f1ba5499e750c59;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_0cc8a86e0089204a5f1ba5499e750c59);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_0cc8a86e0089204a5f1ba5499e750c59) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_iter_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__distribution_points);
        if (tmp_iter_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 426;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = MAKE_ITERATOR(tmp_iter_arg_1);
        Py_DECREF(tmp_iter_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 426;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0cc8a86e0089204a5f1ba5499e750c59);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_0cc8a86e0089204a5f1ba5499e750c59);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0cc8a86e0089204a5f1ba5499e750c59);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_0cc8a86e0089204a5f1ba5499e750c59, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_0cc8a86e0089204a5f1ba5499e750c59->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_0cc8a86e0089204a5f1ba5499e750c59, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0cc8a86e0089204a5f1ba5499e750c59,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_0cc8a86e0089204a5f1ba5499e750c59 == cache_frame_0cc8a86e0089204a5f1ba5499e750c59) {
        Py_DECREF(frame_0cc8a86e0089204a5f1ba5499e750c59);
    }
    cache_frame_0cc8a86e0089204a5f1ba5499e750c59 = NULL;

    assertFrameObject(frame_0cc8a86e0089204a5f1ba5499e750c59);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_54___iter__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_55___len__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_149307d85299be0e2bb512b521807433;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_149307d85299be0e2bb512b521807433 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_149307d85299be0e2bb512b521807433, codeobj_149307d85299be0e2bb512b521807433, module_cryptography$x509$extensions, sizeof(void *));
    frame_149307d85299be0e2bb512b521807433 = cache_frame_149307d85299be0e2bb512b521807433;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_149307d85299be0e2bb512b521807433);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_149307d85299be0e2bb512b521807433) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_len_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_len_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__distribution_points);
        if (tmp_len_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 429;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = BUILTIN_LEN(tmp_len_arg_1);
        Py_DECREF(tmp_len_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 429;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_149307d85299be0e2bb512b521807433);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_149307d85299be0e2bb512b521807433);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_149307d85299be0e2bb512b521807433);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_149307d85299be0e2bb512b521807433, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_149307d85299be0e2bb512b521807433->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_149307d85299be0e2bb512b521807433, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_149307d85299be0e2bb512b521807433,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_149307d85299be0e2bb512b521807433 == cache_frame_149307d85299be0e2bb512b521807433) {
        Py_DECREF(frame_149307d85299be0e2bb512b521807433);
    }
    cache_frame_149307d85299be0e2bb512b521807433 = NULL;

    assertFrameObject(frame_149307d85299be0e2bb512b521807433);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_55___len__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_56___repr__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_0e38c8c915cfa3f59056d06f346243bf;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_0e38c8c915cfa3f59056d06f346243bf = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_0e38c8c915cfa3f59056d06f346243bf, codeobj_0e38c8c915cfa3f59056d06f346243bf, module_cryptography$x509$extensions, sizeof(void *));
    frame_0e38c8c915cfa3f59056d06f346243bf = cache_frame_0e38c8c915cfa3f59056d06f346243bf;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_0e38c8c915cfa3f59056d06f346243bf);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_0e38c8c915cfa3f59056d06f346243bf) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_source_name_1 = const_str_digest_d0cacbb4febc1bdb60a26b048c7bb9b6;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_format);
        assert(!(tmp_called_name_1 == NULL));
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__distribution_points);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 432;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_0e38c8c915cfa3f59056d06f346243bf->m_frame.f_lineno = 432;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 432;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0e38c8c915cfa3f59056d06f346243bf);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_0e38c8c915cfa3f59056d06f346243bf);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0e38c8c915cfa3f59056d06f346243bf);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_0e38c8c915cfa3f59056d06f346243bf, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_0e38c8c915cfa3f59056d06f346243bf->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_0e38c8c915cfa3f59056d06f346243bf, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0e38c8c915cfa3f59056d06f346243bf,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_0e38c8c915cfa3f59056d06f346243bf == cache_frame_0e38c8c915cfa3f59056d06f346243bf) {
        Py_DECREF(frame_0e38c8c915cfa3f59056d06f346243bf);
    }
    cache_frame_0e38c8c915cfa3f59056d06f346243bf = NULL;

    assertFrameObject(frame_0e38c8c915cfa3f59056d06f346243bf);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_56___repr__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_57___eq__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_401579719c1f990019f327b475e920c9;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_401579719c1f990019f327b475e920c9 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_401579719c1f990019f327b475e920c9, codeobj_401579719c1f990019f327b475e920c9, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_401579719c1f990019f327b475e920c9 = cache_frame_401579719c1f990019f327b475e920c9;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_401579719c1f990019f327b475e920c9);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_401579719c1f990019f327b475e920c9) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_other);
        tmp_isinstance_inst_1 = par_other;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_CRLDistributionPoints);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_CRLDistributionPoints);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 36630 ], 50, 0);
            exception_tb = NULL;

            exception_lineno = 435;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 435;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 435;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__distribution_points);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 438;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_2 = par_other;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__distribution_points);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_1);

            exception_lineno = 438;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 438;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_401579719c1f990019f327b475e920c9);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_401579719c1f990019f327b475e920c9);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_401579719c1f990019f327b475e920c9);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_401579719c1f990019f327b475e920c9, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_401579719c1f990019f327b475e920c9->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_401579719c1f990019f327b475e920c9, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_401579719c1f990019f327b475e920c9,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_401579719c1f990019f327b475e920c9 == cache_frame_401579719c1f990019f327b475e920c9) {
        Py_DECREF(frame_401579719c1f990019f327b475e920c9);
    }
    cache_frame_401579719c1f990019f327b475e920c9 = NULL;

    assertFrameObject(frame_401579719c1f990019f327b475e920c9);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_57___eq__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_58___ne__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_a1d6f2aea8a4d49139a6df2ca29a43e4;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_a1d6f2aea8a4d49139a6df2ca29a43e4 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_a1d6f2aea8a4d49139a6df2ca29a43e4, codeobj_a1d6f2aea8a4d49139a6df2ca29a43e4, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_a1d6f2aea8a4d49139a6df2ca29a43e4 = cache_frame_a1d6f2aea8a4d49139a6df2ca29a43e4;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_a1d6f2aea8a4d49139a6df2ca29a43e4);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_a1d6f2aea8a4d49139a6df2ca29a43e4) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_self);
        tmp_compexpr_left_1 = par_self;
        CHECK_OBJECT(par_other);
        tmp_compexpr_right_1 = par_other;
        tmp_operand_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 441;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 441;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = (tmp_res == 0) ? Py_True : Py_False;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a1d6f2aea8a4d49139a6df2ca29a43e4);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_a1d6f2aea8a4d49139a6df2ca29a43e4);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a1d6f2aea8a4d49139a6df2ca29a43e4);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_a1d6f2aea8a4d49139a6df2ca29a43e4, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_a1d6f2aea8a4d49139a6df2ca29a43e4->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_a1d6f2aea8a4d49139a6df2ca29a43e4, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a1d6f2aea8a4d49139a6df2ca29a43e4,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_a1d6f2aea8a4d49139a6df2ca29a43e4 == cache_frame_a1d6f2aea8a4d49139a6df2ca29a43e4) {
        Py_DECREF(frame_a1d6f2aea8a4d49139a6df2ca29a43e4);
    }
    cache_frame_a1d6f2aea8a4d49139a6df2ca29a43e4 = NULL;

    assertFrameObject(frame_a1d6f2aea8a4d49139a6df2ca29a43e4);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_58___ne__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_59___getitem__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_idx = python_pars[1];
    struct Nuitka_FrameObject *frame_e1fa255798e8bef9d045790b180982af;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_e1fa255798e8bef9d045790b180982af = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_e1fa255798e8bef9d045790b180982af, codeobj_e1fa255798e8bef9d045790b180982af, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_e1fa255798e8bef9d045790b180982af = cache_frame_e1fa255798e8bef9d045790b180982af;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_e1fa255798e8bef9d045790b180982af);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_e1fa255798e8bef9d045790b180982af) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_subscript_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__distribution_points);
        if (tmp_subscribed_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 444;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_idx);
        tmp_subscript_name_1 = par_idx;
        tmp_return_value = LOOKUP_SUBSCRIPT(tmp_subscribed_name_1, tmp_subscript_name_1);
        Py_DECREF(tmp_subscribed_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 444;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e1fa255798e8bef9d045790b180982af);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_e1fa255798e8bef9d045790b180982af);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e1fa255798e8bef9d045790b180982af);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_e1fa255798e8bef9d045790b180982af, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_e1fa255798e8bef9d045790b180982af->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_e1fa255798e8bef9d045790b180982af, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e1fa255798e8bef9d045790b180982af,
        type_description_1,
        par_self,
        par_idx
    );


    // Release cached frame.
    if (frame_e1fa255798e8bef9d045790b180982af == cache_frame_e1fa255798e8bef9d045790b180982af) {
        Py_DECREF(frame_e1fa255798e8bef9d045790b180982af);
    }
    cache_frame_e1fa255798e8bef9d045790b180982af = NULL;

    assertFrameObject(frame_e1fa255798e8bef9d045790b180982af);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_59___getitem__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_idx);
    Py_DECREF(par_idx);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_idx);
    Py_DECREF(par_idx);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_60___hash__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_2ee369f8faadbdd2a80c9b8c92f1b573;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_2ee369f8faadbdd2a80c9b8c92f1b573 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_2ee369f8faadbdd2a80c9b8c92f1b573, codeobj_2ee369f8faadbdd2a80c9b8c92f1b573, module_cryptography$x509$extensions, sizeof(void *));
    frame_2ee369f8faadbdd2a80c9b8c92f1b573 = cache_frame_2ee369f8faadbdd2a80c9b8c92f1b573;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_2ee369f8faadbdd2a80c9b8c92f1b573);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_2ee369f8faadbdd2a80c9b8c92f1b573) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_hash_arg_1;
        PyObject *tmp_tuple_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_tuple_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__distribution_points);
        if (tmp_tuple_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 447;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_hash_arg_1 = PySequence_Tuple(tmp_tuple_arg_1);
        Py_DECREF(tmp_tuple_arg_1);
        if (tmp_hash_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 447;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = BUILTIN_HASH(tmp_hash_arg_1);
        Py_DECREF(tmp_hash_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 447;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2ee369f8faadbdd2a80c9b8c92f1b573);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_2ee369f8faadbdd2a80c9b8c92f1b573);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2ee369f8faadbdd2a80c9b8c92f1b573);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_2ee369f8faadbdd2a80c9b8c92f1b573, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_2ee369f8faadbdd2a80c9b8c92f1b573->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_2ee369f8faadbdd2a80c9b8c92f1b573, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2ee369f8faadbdd2a80c9b8c92f1b573,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_2ee369f8faadbdd2a80c9b8c92f1b573 == cache_frame_2ee369f8faadbdd2a80c9b8c92f1b573) {
        Py_DECREF(frame_2ee369f8faadbdd2a80c9b8c92f1b573);
    }
    cache_frame_2ee369f8faadbdd2a80c9b8c92f1b573 = NULL;

    assertFrameObject(frame_2ee369f8faadbdd2a80c9b8c92f1b573);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_60___hash__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_61___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_distribution_points = python_pars[1];
    PyObject *tmp_genexpr_1__$0 = NULL;
    struct Nuitka_FrameObject *frame_f39e2c4ef794a49e891ba944e62753a1;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_f39e2c4ef794a49e891ba944e62753a1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_f39e2c4ef794a49e891ba944e62753a1, codeobj_f39e2c4ef794a49e891ba944e62753a1, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_f39e2c4ef794a49e891ba944e62753a1 = cache_frame_f39e2c4ef794a49e891ba944e62753a1;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_f39e2c4ef794a49e891ba944e62753a1);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_f39e2c4ef794a49e891ba944e62753a1) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_list_arg_1;
        CHECK_OBJECT(par_distribution_points);
        tmp_list_arg_1 = par_distribution_points;
        tmp_assign_source_1 = PySequence_List(tmp_list_arg_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 455;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = par_distribution_points;
            assert(old != NULL);
            par_distribution_points = tmp_assign_source_1;
            Py_DECREF(old);
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_all_arg_1;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT(par_distribution_points);
            tmp_iter_arg_1 = par_distribution_points;
            tmp_assign_source_2 = MAKE_ITERATOR(tmp_iter_arg_1);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 457;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            assert(tmp_genexpr_1__$0 == NULL);
            tmp_genexpr_1__$0 = tmp_assign_source_2;
        }
        // Tried code:
        tmp_all_arg_1 = cryptography$x509$extensions$$$function_61___init__$$$genexpr_1_genexpr_maker();

        ((struct Nuitka_GeneratorObject *)tmp_all_arg_1)->m_closure[0] = PyCell_NEW0(tmp_genexpr_1__$0);


        goto try_return_handler_2;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_61___init__);
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        CHECK_OBJECT((PyObject *)tmp_genexpr_1__$0);
        Py_DECREF(tmp_genexpr_1__$0);
        tmp_genexpr_1__$0 = NULL;

        goto outline_result_1;
        // End of try:
        CHECK_OBJECT((PyObject *)tmp_genexpr_1__$0);
        Py_DECREF(tmp_genexpr_1__$0);
        tmp_genexpr_1__$0 = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_61___init__);
        return NULL;
        outline_result_1:;
        tmp_operand_name_1 = BUILTIN_ALL(tmp_all_arg_1);
        Py_DECREF(tmp_all_arg_1);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 456;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 456;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_37a5813a8df88d549fa10cdd6f24a9b9;
            frame_f39e2c4ef794a49e891ba944e62753a1->m_frame.f_lineno = 459;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 459;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_distribution_points);
        tmp_assattr_name_1 = par_distribution_points;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__distribution_points, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 464;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_f39e2c4ef794a49e891ba944e62753a1);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_f39e2c4ef794a49e891ba944e62753a1);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_f39e2c4ef794a49e891ba944e62753a1, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_f39e2c4ef794a49e891ba944e62753a1->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_f39e2c4ef794a49e891ba944e62753a1, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f39e2c4ef794a49e891ba944e62753a1,
        type_description_1,
        par_self,
        par_distribution_points
    );


    // Release cached frame.
    if (frame_f39e2c4ef794a49e891ba944e62753a1 == cache_frame_f39e2c4ef794a49e891ba944e62753a1) {
        Py_DECREF(frame_f39e2c4ef794a49e891ba944e62753a1);
    }
    cache_frame_f39e2c4ef794a49e891ba944e62753a1 = NULL;

    assertFrameObject(frame_f39e2c4ef794a49e891ba944e62753a1);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_61___init__);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)par_distribution_points);
    Py_DECREF(par_distribution_points);
    par_distribution_points = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)par_distribution_points);
    Py_DECREF(par_distribution_points);
    par_distribution_points = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_61___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}



struct cryptography$x509$extensions$$$function_61___init__$$$genexpr_1_genexpr_locals {
    PyObject *var_x;
    PyObject *tmp_iter_value_0;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    int tmp_res;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *cryptography$x509$extensions$$$function_61___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value ) {
    CHECK_OBJECT((PyObject *)generator);
    assert(Nuitka_Generator_Check( (PyObject *)generator ));

    // Heap access if used.
    struct cryptography$x509$extensions$$$function_61___init__$$$genexpr_1_genexpr_locals *generator_heap = (struct cryptography$x509$extensions$$$function_61___init__$$$genexpr_1_genexpr_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_x = NULL;
    generator_heap->tmp_iter_value_0 = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_m_frame, codeobj_6c990ee64c9c9599e422c207d851cbc9, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF(generator->m_frame);
    assert(Py_REFCNT(generator->m_frame) == 2); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR(generator->m_frame->m_frame.f_back);

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF(generator->m_frame->m_frame.f_back);

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF(generator->m_frame);

    Nuitka_Frame_MarkAsExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

        EXC_TYPE_F(generator) = EXC_TYPE(thread_state);
        if (EXC_TYPE_F(generator) == Py_None) EXC_TYPE_F(generator) = NULL;
        Py_XINCREF(EXC_TYPE_F(generator));
        EXC_VALUE_F(generator) = EXC_VALUE(thread_state);
        Py_XINCREF(EXC_VALUE_F(generator));
        EXC_TRACEBACK_F(generator) = EXC_TRACEBACK(thread_state);
        Py_XINCREF(EXC_TRACEBACK_F(generator));
    }

#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_1;
        CHECK_OBJECT(PyCell_GET(generator->m_closure[0]));
        tmp_next_source_1 = PyCell_GET(generator->m_closure[0]);
        tmp_assign_source_1 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_1 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);
                generator_heap->type_description_1 = "No";
                generator_heap->exception_lineno = 457;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_iter_value_0;
            generator_heap->tmp_iter_value_0 = tmp_assign_source_1;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT(generator_heap->tmp_iter_value_0);
        tmp_assign_source_2 = generator_heap->tmp_iter_value_0;
        {
            PyObject *old = generator_heap->var_x;
            generator_heap->var_x = tmp_assign_source_2;
            Py_INCREF(generator_heap->var_x);
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_expression_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        CHECK_OBJECT(generator_heap->var_x);
        tmp_isinstance_inst_1 = generator_heap->var_x;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_DistributionPoint);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_DistributionPoint);
        }

        if (tmp_mvar_value_1 == NULL) {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF(generator_heap->exception_type);
            generator_heap->exception_value = UNSTREAM_STRING(&constant_bin[ 36584 ], 46, 0);
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 457;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        generator_heap->tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (generator_heap->tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 457;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_expression_name_1 = (generator_heap->tmp_res != 0) ? Py_True : Py_False;
        Py_INCREF(tmp_expression_name_1);
        Nuitka_PreserveHeap(generator_heap->yield_tmps, &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), NULL);
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        Nuitka_RestoreHeap(generator_heap->yield_tmps, &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), NULL);
        if (yield_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 457;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


        generator_heap->exception_lineno = 457;
        generator_heap->type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    // Allow re-use of the frame again.
    Py_DECREF(generator->m_frame);
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if (!EXCEPTION_MATCH_GENERATOR(generator_heap->exception_type)) {
        if (generator_heap->exception_tb == NULL) {
            generator_heap->exception_tb = MAKE_TRACEBACK(generator->m_frame, generator_heap->exception_lineno);
        } else if (generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame) {
            generator_heap->exception_tb = ADD_TRACEBACK(generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno);
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            NULL,
            generator_heap->var_x
        );


        // Release cached frame.
        if (generator->m_frame == cache_m_frame) {
            Py_DECREF(generator->m_frame);
        }
        cache_m_frame = NULL;

        assertFrameObject(generator->m_frame);
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    Py_DECREF(generator->m_frame);

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->var_x);
    generator_heap->var_x = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    Py_XDECREF(generator_heap->var_x);
    generator_heap->var_x = NULL;



    return NULL;

    function_exception_exit:
    assert(generator_heap->exception_type);
    RESTORE_ERROR_OCCURRED(generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb);

    return NULL;

}

static PyObject *cryptography$x509$extensions$$$function_61___init__$$$genexpr_1_genexpr_maker(void) {
    return Nuitka_Generator_New(
        cryptography$x509$extensions$$$function_61___init__$$$genexpr_1_genexpr_context,
        module_cryptography$x509$extensions,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_6c990ee64c9c9599e422c207d851cbc9,
        1,
        sizeof(struct cryptography$x509$extensions$$$function_61___init__$$$genexpr_1_genexpr_locals)
    );
}


static PyObject *impl_cryptography$x509$extensions$$$function_62___iter__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_b916760a1adc6a39fbf1144eb6bf82c6;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_b916760a1adc6a39fbf1144eb6bf82c6 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_b916760a1adc6a39fbf1144eb6bf82c6, codeobj_b916760a1adc6a39fbf1144eb6bf82c6, module_cryptography$x509$extensions, sizeof(void *));
    frame_b916760a1adc6a39fbf1144eb6bf82c6 = cache_frame_b916760a1adc6a39fbf1144eb6bf82c6;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_b916760a1adc6a39fbf1144eb6bf82c6);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_b916760a1adc6a39fbf1144eb6bf82c6) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_iter_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__distribution_points);
        if (tmp_iter_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 467;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = MAKE_ITERATOR(tmp_iter_arg_1);
        Py_DECREF(tmp_iter_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 467;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b916760a1adc6a39fbf1144eb6bf82c6);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_b916760a1adc6a39fbf1144eb6bf82c6);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b916760a1adc6a39fbf1144eb6bf82c6);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_b916760a1adc6a39fbf1144eb6bf82c6, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_b916760a1adc6a39fbf1144eb6bf82c6->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_b916760a1adc6a39fbf1144eb6bf82c6, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b916760a1adc6a39fbf1144eb6bf82c6,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_b916760a1adc6a39fbf1144eb6bf82c6 == cache_frame_b916760a1adc6a39fbf1144eb6bf82c6) {
        Py_DECREF(frame_b916760a1adc6a39fbf1144eb6bf82c6);
    }
    cache_frame_b916760a1adc6a39fbf1144eb6bf82c6 = NULL;

    assertFrameObject(frame_b916760a1adc6a39fbf1144eb6bf82c6);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_62___iter__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_63___len__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_76098b86abab8a2ab9554e3939fdd518;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_76098b86abab8a2ab9554e3939fdd518 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_76098b86abab8a2ab9554e3939fdd518, codeobj_76098b86abab8a2ab9554e3939fdd518, module_cryptography$x509$extensions, sizeof(void *));
    frame_76098b86abab8a2ab9554e3939fdd518 = cache_frame_76098b86abab8a2ab9554e3939fdd518;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_76098b86abab8a2ab9554e3939fdd518);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_76098b86abab8a2ab9554e3939fdd518) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_len_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_len_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__distribution_points);
        if (tmp_len_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 470;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = BUILTIN_LEN(tmp_len_arg_1);
        Py_DECREF(tmp_len_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 470;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_76098b86abab8a2ab9554e3939fdd518);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_76098b86abab8a2ab9554e3939fdd518);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_76098b86abab8a2ab9554e3939fdd518);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_76098b86abab8a2ab9554e3939fdd518, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_76098b86abab8a2ab9554e3939fdd518->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_76098b86abab8a2ab9554e3939fdd518, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_76098b86abab8a2ab9554e3939fdd518,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_76098b86abab8a2ab9554e3939fdd518 == cache_frame_76098b86abab8a2ab9554e3939fdd518) {
        Py_DECREF(frame_76098b86abab8a2ab9554e3939fdd518);
    }
    cache_frame_76098b86abab8a2ab9554e3939fdd518 = NULL;

    assertFrameObject(frame_76098b86abab8a2ab9554e3939fdd518);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_63___len__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_64___repr__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_3538b6f5a5b90a8f1ad1699f31158e85;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_3538b6f5a5b90a8f1ad1699f31158e85 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_3538b6f5a5b90a8f1ad1699f31158e85, codeobj_3538b6f5a5b90a8f1ad1699f31158e85, module_cryptography$x509$extensions, sizeof(void *));
    frame_3538b6f5a5b90a8f1ad1699f31158e85 = cache_frame_3538b6f5a5b90a8f1ad1699f31158e85;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_3538b6f5a5b90a8f1ad1699f31158e85);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_3538b6f5a5b90a8f1ad1699f31158e85) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_source_name_1 = const_str_digest_aedab8e33f4a55e03d8255716673252f;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_format);
        assert(!(tmp_called_name_1 == NULL));
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__distribution_points);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 473;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_3538b6f5a5b90a8f1ad1699f31158e85->m_frame.f_lineno = 473;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 473;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3538b6f5a5b90a8f1ad1699f31158e85);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_3538b6f5a5b90a8f1ad1699f31158e85);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3538b6f5a5b90a8f1ad1699f31158e85);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_3538b6f5a5b90a8f1ad1699f31158e85, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_3538b6f5a5b90a8f1ad1699f31158e85->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_3538b6f5a5b90a8f1ad1699f31158e85, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3538b6f5a5b90a8f1ad1699f31158e85,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_3538b6f5a5b90a8f1ad1699f31158e85 == cache_frame_3538b6f5a5b90a8f1ad1699f31158e85) {
        Py_DECREF(frame_3538b6f5a5b90a8f1ad1699f31158e85);
    }
    cache_frame_3538b6f5a5b90a8f1ad1699f31158e85 = NULL;

    assertFrameObject(frame_3538b6f5a5b90a8f1ad1699f31158e85);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_64___repr__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_65___eq__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_bca7cfb63f34239fb1479c0362918cf5;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_bca7cfb63f34239fb1479c0362918cf5 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_bca7cfb63f34239fb1479c0362918cf5, codeobj_bca7cfb63f34239fb1479c0362918cf5, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_bca7cfb63f34239fb1479c0362918cf5 = cache_frame_bca7cfb63f34239fb1479c0362918cf5;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_bca7cfb63f34239fb1479c0362918cf5);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_bca7cfb63f34239fb1479c0362918cf5) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_other);
        tmp_isinstance_inst_1 = par_other;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_FreshestCRL);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_FreshestCRL);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 36680 ], 40, 0);
            exception_tb = NULL;

            exception_lineno = 476;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 476;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 476;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__distribution_points);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 479;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_2 = par_other;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__distribution_points);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_1);

            exception_lineno = 479;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 479;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_bca7cfb63f34239fb1479c0362918cf5);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_bca7cfb63f34239fb1479c0362918cf5);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_bca7cfb63f34239fb1479c0362918cf5);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_bca7cfb63f34239fb1479c0362918cf5, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_bca7cfb63f34239fb1479c0362918cf5->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_bca7cfb63f34239fb1479c0362918cf5, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_bca7cfb63f34239fb1479c0362918cf5,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_bca7cfb63f34239fb1479c0362918cf5 == cache_frame_bca7cfb63f34239fb1479c0362918cf5) {
        Py_DECREF(frame_bca7cfb63f34239fb1479c0362918cf5);
    }
    cache_frame_bca7cfb63f34239fb1479c0362918cf5 = NULL;

    assertFrameObject(frame_bca7cfb63f34239fb1479c0362918cf5);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_65___eq__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_66___ne__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_eec0c8b89a2742f11fc8c57f2f33ab22;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_eec0c8b89a2742f11fc8c57f2f33ab22 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_eec0c8b89a2742f11fc8c57f2f33ab22, codeobj_eec0c8b89a2742f11fc8c57f2f33ab22, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_eec0c8b89a2742f11fc8c57f2f33ab22 = cache_frame_eec0c8b89a2742f11fc8c57f2f33ab22;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_eec0c8b89a2742f11fc8c57f2f33ab22);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_eec0c8b89a2742f11fc8c57f2f33ab22) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_self);
        tmp_compexpr_left_1 = par_self;
        CHECK_OBJECT(par_other);
        tmp_compexpr_right_1 = par_other;
        tmp_operand_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 482;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 482;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = (tmp_res == 0) ? Py_True : Py_False;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_eec0c8b89a2742f11fc8c57f2f33ab22);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_eec0c8b89a2742f11fc8c57f2f33ab22);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_eec0c8b89a2742f11fc8c57f2f33ab22);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_eec0c8b89a2742f11fc8c57f2f33ab22, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_eec0c8b89a2742f11fc8c57f2f33ab22->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_eec0c8b89a2742f11fc8c57f2f33ab22, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_eec0c8b89a2742f11fc8c57f2f33ab22,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_eec0c8b89a2742f11fc8c57f2f33ab22 == cache_frame_eec0c8b89a2742f11fc8c57f2f33ab22) {
        Py_DECREF(frame_eec0c8b89a2742f11fc8c57f2f33ab22);
    }
    cache_frame_eec0c8b89a2742f11fc8c57f2f33ab22 = NULL;

    assertFrameObject(frame_eec0c8b89a2742f11fc8c57f2f33ab22);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_66___ne__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_67___getitem__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_idx = python_pars[1];
    struct Nuitka_FrameObject *frame_c4a263fab24d4b74487740f36bc3c59f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_c4a263fab24d4b74487740f36bc3c59f = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_c4a263fab24d4b74487740f36bc3c59f, codeobj_c4a263fab24d4b74487740f36bc3c59f, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_c4a263fab24d4b74487740f36bc3c59f = cache_frame_c4a263fab24d4b74487740f36bc3c59f;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_c4a263fab24d4b74487740f36bc3c59f);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_c4a263fab24d4b74487740f36bc3c59f) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_subscript_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__distribution_points);
        if (tmp_subscribed_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 485;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_idx);
        tmp_subscript_name_1 = par_idx;
        tmp_return_value = LOOKUP_SUBSCRIPT(tmp_subscribed_name_1, tmp_subscript_name_1);
        Py_DECREF(tmp_subscribed_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 485;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c4a263fab24d4b74487740f36bc3c59f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_c4a263fab24d4b74487740f36bc3c59f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c4a263fab24d4b74487740f36bc3c59f);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_c4a263fab24d4b74487740f36bc3c59f, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_c4a263fab24d4b74487740f36bc3c59f->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_c4a263fab24d4b74487740f36bc3c59f, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c4a263fab24d4b74487740f36bc3c59f,
        type_description_1,
        par_self,
        par_idx
    );


    // Release cached frame.
    if (frame_c4a263fab24d4b74487740f36bc3c59f == cache_frame_c4a263fab24d4b74487740f36bc3c59f) {
        Py_DECREF(frame_c4a263fab24d4b74487740f36bc3c59f);
    }
    cache_frame_c4a263fab24d4b74487740f36bc3c59f = NULL;

    assertFrameObject(frame_c4a263fab24d4b74487740f36bc3c59f);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_67___getitem__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_idx);
    Py_DECREF(par_idx);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_idx);
    Py_DECREF(par_idx);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_68___hash__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_660db49e2668f19c95e04c246a6a5dd8;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_660db49e2668f19c95e04c246a6a5dd8 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_660db49e2668f19c95e04c246a6a5dd8, codeobj_660db49e2668f19c95e04c246a6a5dd8, module_cryptography$x509$extensions, sizeof(void *));
    frame_660db49e2668f19c95e04c246a6a5dd8 = cache_frame_660db49e2668f19c95e04c246a6a5dd8;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_660db49e2668f19c95e04c246a6a5dd8);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_660db49e2668f19c95e04c246a6a5dd8) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_hash_arg_1;
        PyObject *tmp_tuple_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_tuple_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__distribution_points);
        if (tmp_tuple_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 488;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_hash_arg_1 = PySequence_Tuple(tmp_tuple_arg_1);
        Py_DECREF(tmp_tuple_arg_1);
        if (tmp_hash_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 488;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = BUILTIN_HASH(tmp_hash_arg_1);
        Py_DECREF(tmp_hash_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 488;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_660db49e2668f19c95e04c246a6a5dd8);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_660db49e2668f19c95e04c246a6a5dd8);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_660db49e2668f19c95e04c246a6a5dd8);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_660db49e2668f19c95e04c246a6a5dd8, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_660db49e2668f19c95e04c246a6a5dd8->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_660db49e2668f19c95e04c246a6a5dd8, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_660db49e2668f19c95e04c246a6a5dd8,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_660db49e2668f19c95e04c246a6a5dd8 == cache_frame_660db49e2668f19c95e04c246a6a5dd8) {
        Py_DECREF(frame_660db49e2668f19c95e04c246a6a5dd8);
    }
    cache_frame_660db49e2668f19c95e04c246a6a5dd8 = NULL;

    assertFrameObject(frame_660db49e2668f19c95e04c246a6a5dd8);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_68___hash__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_69___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_full_name = python_pars[1];
    PyObject *par_relative_name = python_pars[2];
    PyObject *par_reasons = python_pars[3];
    PyObject *par_crl_issuer = python_pars[4];
    PyObject *tmp_genexpr_1__$0 = NULL;
    PyObject *tmp_genexpr_2__$0 = NULL;
    PyObject *tmp_genexpr_3__$0 = NULL;
    struct Nuitka_FrameObject *frame_168b828ef0bd5b03004b55cf5ee199a8;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_168b828ef0bd5b03004b55cf5ee199a8 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_168b828ef0bd5b03004b55cf5ee199a8, codeobj_168b828ef0bd5b03004b55cf5ee199a8, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_168b828ef0bd5b03004b55cf5ee199a8 = cache_frame_168b828ef0bd5b03004b55cf5ee199a8;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_168b828ef0bd5b03004b55cf5ee199a8);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_168b828ef0bd5b03004b55cf5ee199a8) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_and_left_truth_1;
        nuitka_bool tmp_and_left_value_1;
        nuitka_bool tmp_and_right_value_1;
        int tmp_truth_name_1;
        int tmp_truth_name_2;
        CHECK_OBJECT(par_full_name);
        tmp_truth_name_1 = CHECK_IF_TRUE(par_full_name);
        if (tmp_truth_name_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 493;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if (tmp_and_left_truth_1 == 1) {
            goto and_right_1;
        } else {
            goto and_left_1;
        }
        and_right_1:;
        CHECK_OBJECT(par_relative_name);
        tmp_truth_name_2 = CHECK_IF_TRUE(par_relative_name);
        if (tmp_truth_name_2 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 493;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = tmp_truth_name_2 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_condition_result_1 = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_condition_result_1 = tmp_and_left_value_1;
        and_end_1:;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_11b049dd960f5e8f8d4550cdd9caf427;
            frame_168b828ef0bd5b03004b55cf5ee199a8->m_frame.f_lineno = 494;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 494;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        int tmp_truth_name_3;
        CHECK_OBJECT(par_full_name);
        tmp_truth_name_3 = CHECK_IF_TRUE(par_full_name);
        if (tmp_truth_name_3 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 499;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = tmp_truth_name_3 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_list_arg_1;
            CHECK_OBJECT(par_full_name);
            tmp_list_arg_1 = par_full_name;
            tmp_assign_source_1 = PySequence_List(tmp_list_arg_1);
            if (tmp_assign_source_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 500;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_full_name;
                assert(old != NULL);
                par_full_name = tmp_assign_source_1;
                Py_DECREF(old);
            }

        }
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_operand_name_1;
            PyObject *tmp_all_arg_1;
            {
                PyObject *tmp_assign_source_2;
                PyObject *tmp_iter_arg_1;
                CHECK_OBJECT(par_full_name);
                tmp_iter_arg_1 = par_full_name;
                tmp_assign_source_2 = MAKE_ITERATOR(tmp_iter_arg_1);
                if (tmp_assign_source_2 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 501;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                assert(tmp_genexpr_1__$0 == NULL);
                tmp_genexpr_1__$0 = tmp_assign_source_2;
            }
            // Tried code:
            tmp_all_arg_1 = cryptography$x509$extensions$$$function_69___init__$$$genexpr_1_genexpr_maker();

            ((struct Nuitka_GeneratorObject *)tmp_all_arg_1)->m_closure[0] = PyCell_NEW0(tmp_genexpr_1__$0);


            goto try_return_handler_2;
            // tried codes exits in all cases
            NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_69___init__);
            return NULL;
            // Return handler code:
            try_return_handler_2:;
            CHECK_OBJECT((PyObject *)tmp_genexpr_1__$0);
            Py_DECREF(tmp_genexpr_1__$0);
            tmp_genexpr_1__$0 = NULL;

            goto outline_result_1;
            // End of try:
            CHECK_OBJECT((PyObject *)tmp_genexpr_1__$0);
            Py_DECREF(tmp_genexpr_1__$0);
            tmp_genexpr_1__$0 = NULL;

            // Return statement must have exited already.
            NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_69___init__);
            return NULL;
            outline_result_1:;
            tmp_operand_name_1 = BUILTIN_ALL(tmp_all_arg_1);
            Py_DECREF(tmp_all_arg_1);
            if (tmp_operand_name_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 501;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
            Py_DECREF(tmp_operand_name_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 501;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_3 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
                goto branch_yes_3;
            } else {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_raise_type_2;
                PyObject *tmp_make_exception_arg_2;
                tmp_make_exception_arg_2 = const_str_digest_449ea3887ada75d14dab0f566d0a778c;
                frame_168b828ef0bd5b03004b55cf5ee199a8->m_frame.f_lineno = 502;
                tmp_raise_type_2 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_2);
                assert(!(tmp_raise_type_2 == NULL));
                exception_type = tmp_raise_type_2;
                exception_lineno = 502;
                RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            branch_no_3:;
        }
        branch_no_2:;
    }
    {
        nuitka_bool tmp_condition_result_4;
        int tmp_truth_name_4;
        CHECK_OBJECT(par_relative_name);
        tmp_truth_name_4 = CHECK_IF_TRUE(par_relative_name);
        if (tmp_truth_name_4 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 506;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_4 = tmp_truth_name_4 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_4 == NUITKA_BOOL_TRUE) {
            goto branch_yes_4;
        } else {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            nuitka_bool tmp_condition_result_5;
            PyObject *tmp_operand_name_2;
            PyObject *tmp_isinstance_inst_1;
            PyObject *tmp_isinstance_cls_1;
            PyObject *tmp_mvar_value_1;
            CHECK_OBJECT(par_relative_name);
            tmp_isinstance_inst_1 = par_relative_name;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_RelativeDistinguishedName);

            if (unlikely(tmp_mvar_value_1 == NULL)) {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_RelativeDistinguishedName);
            }

            if (tmp_mvar_value_1 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 36720 ], 54, 0);
                exception_tb = NULL;

                exception_lineno = 507;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_isinstance_cls_1 = tmp_mvar_value_1;
            tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 507;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_operand_name_2 = (tmp_res != 0) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE(tmp_operand_name_2);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 507;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_5 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_5 == NUITKA_BOOL_TRUE) {
                goto branch_yes_5;
            } else {
                goto branch_no_5;
            }
            branch_yes_5:;
            {
                PyObject *tmp_raise_type_3;
                PyObject *tmp_make_exception_arg_3;
                tmp_make_exception_arg_3 = const_str_digest_0c5b9c1eebf18567ca6eef13eba8418b;
                frame_168b828ef0bd5b03004b55cf5ee199a8->m_frame.f_lineno = 508;
                tmp_raise_type_3 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_3);
                assert(!(tmp_raise_type_3 == NULL));
                exception_type = tmp_raise_type_3;
                exception_lineno = 508;
                RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            branch_no_5:;
        }
        branch_no_4:;
    }
    {
        nuitka_bool tmp_condition_result_6;
        int tmp_truth_name_5;
        CHECK_OBJECT(par_crl_issuer);
        tmp_truth_name_5 = CHECK_IF_TRUE(par_crl_issuer);
        if (tmp_truth_name_5 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 512;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_6 = tmp_truth_name_5 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_6 == NUITKA_BOOL_TRUE) {
            goto branch_yes_6;
        } else {
            goto branch_no_6;
        }
        branch_yes_6:;
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_list_arg_2;
            CHECK_OBJECT(par_crl_issuer);
            tmp_list_arg_2 = par_crl_issuer;
            tmp_assign_source_3 = PySequence_List(tmp_list_arg_2);
            if (tmp_assign_source_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 513;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_crl_issuer;
                assert(old != NULL);
                par_crl_issuer = tmp_assign_source_3;
                Py_DECREF(old);
            }

        }
        {
            nuitka_bool tmp_condition_result_7;
            PyObject *tmp_operand_name_3;
            PyObject *tmp_all_arg_2;
            {
                PyObject *tmp_assign_source_4;
                PyObject *tmp_iter_arg_2;
                CHECK_OBJECT(par_crl_issuer);
                tmp_iter_arg_2 = par_crl_issuer;
                tmp_assign_source_4 = MAKE_ITERATOR(tmp_iter_arg_2);
                if (tmp_assign_source_4 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 514;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                assert(tmp_genexpr_2__$0 == NULL);
                tmp_genexpr_2__$0 = tmp_assign_source_4;
            }
            // Tried code:
            tmp_all_arg_2 = cryptography$x509$extensions$$$function_69___init__$$$genexpr_2_genexpr_maker();

            ((struct Nuitka_GeneratorObject *)tmp_all_arg_2)->m_closure[0] = PyCell_NEW0(tmp_genexpr_2__$0);


            goto try_return_handler_3;
            // tried codes exits in all cases
            NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_69___init__);
            return NULL;
            // Return handler code:
            try_return_handler_3:;
            CHECK_OBJECT((PyObject *)tmp_genexpr_2__$0);
            Py_DECREF(tmp_genexpr_2__$0);
            tmp_genexpr_2__$0 = NULL;

            goto outline_result_2;
            // End of try:
            CHECK_OBJECT((PyObject *)tmp_genexpr_2__$0);
            Py_DECREF(tmp_genexpr_2__$0);
            tmp_genexpr_2__$0 = NULL;

            // Return statement must have exited already.
            NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_69___init__);
            return NULL;
            outline_result_2:;
            tmp_operand_name_3 = BUILTIN_ALL(tmp_all_arg_2);
            Py_DECREF(tmp_all_arg_2);
            if (tmp_operand_name_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 514;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_res = CHECK_IF_TRUE(tmp_operand_name_3);
            Py_DECREF(tmp_operand_name_3);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 514;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_7 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_7 == NUITKA_BOOL_TRUE) {
                goto branch_yes_7;
            } else {
                goto branch_no_7;
            }
            branch_yes_7:;
            {
                PyObject *tmp_raise_type_4;
                PyObject *tmp_make_exception_arg_4;
                tmp_make_exception_arg_4 = const_str_digest_837e2310df6009dd1b110accad73bb42;
                frame_168b828ef0bd5b03004b55cf5ee199a8->m_frame.f_lineno = 515;
                tmp_raise_type_4 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_4);
                assert(!(tmp_raise_type_4 == NULL));
                exception_type = tmp_raise_type_4;
                exception_lineno = 515;
                RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            branch_no_7:;
        }
        branch_no_6:;
    }
    {
        nuitka_bool tmp_condition_result_8;
        int tmp_and_left_truth_2;
        nuitka_bool tmp_and_left_value_2;
        nuitka_bool tmp_and_right_value_2;
        int tmp_truth_name_6;
        int tmp_or_left_truth_1;
        nuitka_bool tmp_or_left_value_1;
        nuitka_bool tmp_or_right_value_1;
        PyObject *tmp_operand_name_4;
        PyObject *tmp_isinstance_inst_2;
        PyObject *tmp_isinstance_cls_2;
        PyObject *tmp_operand_name_5;
        PyObject *tmp_all_arg_3;
        CHECK_OBJECT(par_reasons);
        tmp_truth_name_6 = CHECK_IF_TRUE(par_reasons);
        if (tmp_truth_name_6 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 519;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_2 = tmp_truth_name_6 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_2 = tmp_and_left_value_2 == NUITKA_BOOL_TRUE ? 1 : 0;
        if (tmp_and_left_truth_2 == 1) {
            goto and_right_2;
        } else {
            goto and_left_2;
        }
        and_right_2:;
        CHECK_OBJECT(par_reasons);
        tmp_isinstance_inst_2 = par_reasons;
        tmp_isinstance_cls_2 = (PyObject *)&PyFrozenSet_Type;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_2, tmp_isinstance_cls_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 519;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_4 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_4);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 519;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_or_left_value_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_or_left_truth_1 = tmp_or_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if (tmp_or_left_truth_1 == 1) {
            goto or_left_1;
        } else {
            goto or_right_1;
        }
        or_right_1:;
        {
            PyObject *tmp_assign_source_5;
            PyObject *tmp_iter_arg_3;
            CHECK_OBJECT(par_reasons);
            tmp_iter_arg_3 = par_reasons;
            tmp_assign_source_5 = MAKE_ITERATOR(tmp_iter_arg_3);
            if (tmp_assign_source_5 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 520;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            assert(tmp_genexpr_3__$0 == NULL);
            tmp_genexpr_3__$0 = tmp_assign_source_5;
        }
        // Tried code:
        tmp_all_arg_3 = cryptography$x509$extensions$$$function_69___init__$$$genexpr_3_genexpr_maker();

        ((struct Nuitka_GeneratorObject *)tmp_all_arg_3)->m_closure[0] = PyCell_NEW0(tmp_genexpr_3__$0);


        goto try_return_handler_4;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_69___init__);
        return NULL;
        // Return handler code:
        try_return_handler_4:;
        CHECK_OBJECT((PyObject *)tmp_genexpr_3__$0);
        Py_DECREF(tmp_genexpr_3__$0);
        tmp_genexpr_3__$0 = NULL;

        goto outline_result_3;
        // End of try:
        CHECK_OBJECT((PyObject *)tmp_genexpr_3__$0);
        Py_DECREF(tmp_genexpr_3__$0);
        tmp_genexpr_3__$0 = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_69___init__);
        return NULL;
        outline_result_3:;
        tmp_operand_name_5 = BUILTIN_ALL(tmp_all_arg_3);
        Py_DECREF(tmp_all_arg_3);
        if (tmp_operand_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 519;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_5);
        Py_DECREF(tmp_operand_name_5);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 519;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_or_right_value_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_right_value_2 = tmp_or_right_value_1;
        goto or_end_1;
        or_left_1:;
        tmp_and_right_value_2 = tmp_or_left_value_1;
        or_end_1:;
        tmp_condition_result_8 = tmp_and_right_value_2;
        goto and_end_2;
        and_left_2:;
        tmp_condition_result_8 = tmp_and_left_value_2;
        and_end_2:;
        if (tmp_condition_result_8 == NUITKA_BOOL_TRUE) {
            goto branch_yes_8;
        } else {
            goto branch_no_8;
        }
        branch_yes_8:;
        {
            PyObject *tmp_raise_type_5;
            PyObject *tmp_make_exception_arg_5;
            tmp_make_exception_arg_5 = const_str_digest_2615a61b30c6d1612864004a5b3409b1;
            frame_168b828ef0bd5b03004b55cf5ee199a8->m_frame.f_lineno = 522;
            tmp_raise_type_5 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_5);
            assert(!(tmp_raise_type_5 == NULL));
            exception_type = tmp_raise_type_5;
            exception_lineno = 522;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        branch_no_8:;
    }
    {
        nuitka_bool tmp_condition_result_9;
        int tmp_and_left_truth_3;
        nuitka_bool tmp_and_left_value_3;
        nuitka_bool tmp_and_right_value_3;
        int tmp_truth_name_7;
        int tmp_or_left_truth_2;
        nuitka_bool tmp_or_left_value_2;
        nuitka_bool tmp_or_right_value_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        CHECK_OBJECT(par_reasons);
        tmp_truth_name_7 = CHECK_IF_TRUE(par_reasons);
        if (tmp_truth_name_7 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 524;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_3 = tmp_truth_name_7 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_3 = tmp_and_left_value_3 == NUITKA_BOOL_TRUE ? 1 : 0;
        if (tmp_and_left_truth_3 == 1) {
            goto and_right_3;
        } else {
            goto and_left_3;
        }
        and_right_3:;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ReasonFlags);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ReasonFlags);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 36774 ], 40, 0);
            exception_tb = NULL;

            exception_lineno = 525;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_unspecified);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 525;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_reasons);
        tmp_compexpr_right_1 = par_reasons;
        tmp_res = PySequence_Contains(tmp_compexpr_right_1, tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_left_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 525;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_or_left_value_2 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_or_left_truth_2 = tmp_or_left_value_2 == NUITKA_BOOL_TRUE ? 1 : 0;
        if (tmp_or_left_truth_2 == 1) {
            goto or_left_2;
        } else {
            goto or_right_2;
        }
        or_right_2:;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ReasonFlags);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ReasonFlags);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 36774 ], 40, 0);
            exception_tb = NULL;

            exception_lineno = 526;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_remove_from_crl);
        if (tmp_compexpr_left_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 526;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_reasons);
        tmp_compexpr_right_2 = par_reasons;
        tmp_res = PySequence_Contains(tmp_compexpr_right_2, tmp_compexpr_left_2);
        Py_DECREF(tmp_compexpr_left_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 526;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_or_right_value_2 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_right_value_3 = tmp_or_right_value_2;
        goto or_end_2;
        or_left_2:;
        tmp_and_right_value_3 = tmp_or_left_value_2;
        or_end_2:;
        tmp_condition_result_9 = tmp_and_right_value_3;
        goto and_end_3;
        and_left_3:;
        tmp_condition_result_9 = tmp_and_left_value_3;
        and_end_3:;
        if (tmp_condition_result_9 == NUITKA_BOOL_TRUE) {
            goto branch_yes_9;
        } else {
            goto branch_no_9;
        }
        branch_yes_9:;
        {
            PyObject *tmp_raise_type_6;
            PyObject *tmp_make_exception_arg_6;
            tmp_make_exception_arg_6 = const_str_digest_3a0a1109b8c268ad95ea7f220c74ef61;
            frame_168b828ef0bd5b03004b55cf5ee199a8->m_frame.f_lineno = 528;
            tmp_raise_type_6 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_6);
            assert(!(tmp_raise_type_6 == NULL));
            exception_type = tmp_raise_type_6;
            exception_lineno = 528;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        branch_no_9:;
    }
    {
        nuitka_bool tmp_condition_result_10;
        int tmp_and_left_truth_4;
        nuitka_bool tmp_and_left_value_4;
        nuitka_bool tmp_and_right_value_4;
        int tmp_truth_name_8;
        int tmp_and_left_truth_5;
        nuitka_bool tmp_and_left_value_5;
        nuitka_bool tmp_and_right_value_5;
        PyObject *tmp_operand_name_6;
        PyObject *tmp_operand_name_7;
        int tmp_or_left_truth_3;
        PyObject *tmp_or_left_value_3;
        PyObject *tmp_or_right_value_3;
        CHECK_OBJECT(par_reasons);
        tmp_truth_name_8 = CHECK_IF_TRUE(par_reasons);
        if (tmp_truth_name_8 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 533;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_4 = tmp_truth_name_8 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_4 = tmp_and_left_value_4 == NUITKA_BOOL_TRUE ? 1 : 0;
        if (tmp_and_left_truth_4 == 1) {
            goto and_right_4;
        } else {
            goto and_left_4;
        }
        and_right_4:;
        CHECK_OBJECT(par_crl_issuer);
        tmp_operand_name_6 = par_crl_issuer;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_6);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 533;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_5 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_5 = tmp_and_left_value_5 == NUITKA_BOOL_TRUE ? 1 : 0;
        if (tmp_and_left_truth_5 == 1) {
            goto and_right_5;
        } else {
            goto and_left_5;
        }
        and_right_5:;
        CHECK_OBJECT(par_full_name);
        tmp_or_left_value_3 = par_full_name;
        tmp_or_left_truth_3 = CHECK_IF_TRUE(tmp_or_left_value_3);
        if (tmp_or_left_truth_3 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 533;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        if (tmp_or_left_truth_3 == 1) {
            goto or_left_3;
        } else {
            goto or_right_3;
        }
        or_right_3:;
        CHECK_OBJECT(par_relative_name);
        tmp_or_right_value_3 = par_relative_name;
        tmp_operand_name_7 = tmp_or_right_value_3;
        goto or_end_3;
        or_left_3:;
        tmp_operand_name_7 = tmp_or_left_value_3;
        or_end_3:;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_7);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 533;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_5 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_right_value_4 = tmp_and_right_value_5;
        goto and_end_5;
        and_left_5:;
        tmp_and_right_value_4 = tmp_and_left_value_5;
        and_end_5:;
        tmp_condition_result_10 = tmp_and_right_value_4;
        goto and_end_4;
        and_left_4:;
        tmp_condition_result_10 = tmp_and_left_value_4;
        and_end_4:;
        if (tmp_condition_result_10 == NUITKA_BOOL_TRUE) {
            goto branch_yes_10;
        } else {
            goto branch_no_10;
        }
        branch_yes_10:;
        {
            PyObject *tmp_raise_type_7;
            PyObject *tmp_make_exception_arg_7;
            tmp_make_exception_arg_7 = const_str_digest_198893d8157c272d69767f46f86316c2;
            frame_168b828ef0bd5b03004b55cf5ee199a8->m_frame.f_lineno = 534;
            tmp_raise_type_7 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_7);
            assert(!(tmp_raise_type_7 == NULL));
            exception_type = tmp_raise_type_7;
            exception_lineno = 534;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        branch_no_10:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_full_name);
        tmp_assattr_name_1 = par_full_name;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__full_name, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 539;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT(par_relative_name);
        tmp_assattr_name_2 = par_relative_name;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain__relative_name, tmp_assattr_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 540;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_assattr_target_3;
        CHECK_OBJECT(par_reasons);
        tmp_assattr_name_3 = par_reasons;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_3 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_3, const_str_plain__reasons, tmp_assattr_name_3);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 541;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_4;
        PyObject *tmp_assattr_target_4;
        CHECK_OBJECT(par_crl_issuer);
        tmp_assattr_name_4 = par_crl_issuer;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_4 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_4, const_str_plain__crl_issuer, tmp_assattr_name_4);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 542;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_168b828ef0bd5b03004b55cf5ee199a8);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_168b828ef0bd5b03004b55cf5ee199a8);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_168b828ef0bd5b03004b55cf5ee199a8, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_168b828ef0bd5b03004b55cf5ee199a8->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_168b828ef0bd5b03004b55cf5ee199a8, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_168b828ef0bd5b03004b55cf5ee199a8,
        type_description_1,
        par_self,
        par_full_name,
        par_relative_name,
        par_reasons,
        par_crl_issuer
    );


    // Release cached frame.
    if (frame_168b828ef0bd5b03004b55cf5ee199a8 == cache_frame_168b828ef0bd5b03004b55cf5ee199a8) {
        Py_DECREF(frame_168b828ef0bd5b03004b55cf5ee199a8);
    }
    cache_frame_168b828ef0bd5b03004b55cf5ee199a8 = NULL;

    assertFrameObject(frame_168b828ef0bd5b03004b55cf5ee199a8);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_69___init__);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)par_crl_issuer);
    Py_DECREF(par_crl_issuer);
    par_crl_issuer = NULL;

    CHECK_OBJECT((PyObject *)par_full_name);
    Py_DECREF(par_full_name);
    par_full_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(par_crl_issuer);
    par_crl_issuer = NULL;

    Py_XDECREF(par_full_name);
    par_full_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_69___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_reasons);
    Py_DECREF(par_reasons);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_relative_name);
    Py_DECREF(par_relative_name);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_reasons);
    Py_DECREF(par_reasons);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_relative_name);
    Py_DECREF(par_relative_name);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}



struct cryptography$x509$extensions$$$function_69___init__$$$genexpr_1_genexpr_locals {
    PyObject *var_x;
    PyObject *tmp_iter_value_0;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    int tmp_res;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *cryptography$x509$extensions$$$function_69___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value ) {
    CHECK_OBJECT((PyObject *)generator);
    assert(Nuitka_Generator_Check( (PyObject *)generator ));

    // Heap access if used.
    struct cryptography$x509$extensions$$$function_69___init__$$$genexpr_1_genexpr_locals *generator_heap = (struct cryptography$x509$extensions$$$function_69___init__$$$genexpr_1_genexpr_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_x = NULL;
    generator_heap->tmp_iter_value_0 = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_m_frame, codeobj_4121fcf894750f20ccf71bdfe3d19df2, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF(generator->m_frame);
    assert(Py_REFCNT(generator->m_frame) == 2); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR(generator->m_frame->m_frame.f_back);

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF(generator->m_frame->m_frame.f_back);

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF(generator->m_frame);

    Nuitka_Frame_MarkAsExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

        EXC_TYPE_F(generator) = EXC_TYPE(thread_state);
        if (EXC_TYPE_F(generator) == Py_None) EXC_TYPE_F(generator) = NULL;
        Py_XINCREF(EXC_TYPE_F(generator));
        EXC_VALUE_F(generator) = EXC_VALUE(thread_state);
        Py_XINCREF(EXC_VALUE_F(generator));
        EXC_TRACEBACK_F(generator) = EXC_TRACEBACK(thread_state);
        Py_XINCREF(EXC_TRACEBACK_F(generator));
    }

#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_1;
        CHECK_OBJECT(PyCell_GET(generator->m_closure[0]));
        tmp_next_source_1 = PyCell_GET(generator->m_closure[0]);
        tmp_assign_source_1 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_1 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);
                generator_heap->type_description_1 = "No";
                generator_heap->exception_lineno = 501;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_iter_value_0;
            generator_heap->tmp_iter_value_0 = tmp_assign_source_1;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT(generator_heap->tmp_iter_value_0);
        tmp_assign_source_2 = generator_heap->tmp_iter_value_0;
        {
            PyObject *old = generator_heap->var_x;
            generator_heap->var_x = tmp_assign_source_2;
            Py_INCREF(generator_heap->var_x);
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_expression_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        CHECK_OBJECT(generator_heap->var_x);
        tmp_isinstance_inst_1 = generator_heap->var_x;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_GeneralName);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_GeneralName);
        }

        if (tmp_mvar_value_1 == NULL) {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF(generator_heap->exception_type);
            generator_heap->exception_value = UNSTREAM_STRING(&constant_bin[ 36192 ], 40, 0);
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 501;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        generator_heap->tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (generator_heap->tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 501;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_expression_name_1 = (generator_heap->tmp_res != 0) ? Py_True : Py_False;
        Py_INCREF(tmp_expression_name_1);
        Nuitka_PreserveHeap(generator_heap->yield_tmps, &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), NULL);
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        Nuitka_RestoreHeap(generator_heap->yield_tmps, &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), NULL);
        if (yield_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 501;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


        generator_heap->exception_lineno = 501;
        generator_heap->type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    // Allow re-use of the frame again.
    Py_DECREF(generator->m_frame);
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if (!EXCEPTION_MATCH_GENERATOR(generator_heap->exception_type)) {
        if (generator_heap->exception_tb == NULL) {
            generator_heap->exception_tb = MAKE_TRACEBACK(generator->m_frame, generator_heap->exception_lineno);
        } else if (generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame) {
            generator_heap->exception_tb = ADD_TRACEBACK(generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno);
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            NULL,
            generator_heap->var_x
        );


        // Release cached frame.
        if (generator->m_frame == cache_m_frame) {
            Py_DECREF(generator->m_frame);
        }
        cache_m_frame = NULL;

        assertFrameObject(generator->m_frame);
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    Py_DECREF(generator->m_frame);

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->var_x);
    generator_heap->var_x = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    Py_XDECREF(generator_heap->var_x);
    generator_heap->var_x = NULL;



    return NULL;

    function_exception_exit:
    assert(generator_heap->exception_type);
    RESTORE_ERROR_OCCURRED(generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb);

    return NULL;

}

static PyObject *cryptography$x509$extensions$$$function_69___init__$$$genexpr_1_genexpr_maker(void) {
    return Nuitka_Generator_New(
        cryptography$x509$extensions$$$function_69___init__$$$genexpr_1_genexpr_context,
        module_cryptography$x509$extensions,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_4121fcf894750f20ccf71bdfe3d19df2,
        1,
        sizeof(struct cryptography$x509$extensions$$$function_69___init__$$$genexpr_1_genexpr_locals)
    );
}



struct cryptography$x509$extensions$$$function_69___init__$$$genexpr_2_genexpr_locals {
    PyObject *var_x;
    PyObject *tmp_iter_value_0;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    int tmp_res;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *cryptography$x509$extensions$$$function_69___init__$$$genexpr_2_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value ) {
    CHECK_OBJECT((PyObject *)generator);
    assert(Nuitka_Generator_Check( (PyObject *)generator ));

    // Heap access if used.
    struct cryptography$x509$extensions$$$function_69___init__$$$genexpr_2_genexpr_locals *generator_heap = (struct cryptography$x509$extensions$$$function_69___init__$$$genexpr_2_genexpr_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_x = NULL;
    generator_heap->tmp_iter_value_0 = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_m_frame, codeobj_31212033882b18f22cff534424b54050, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF(generator->m_frame);
    assert(Py_REFCNT(generator->m_frame) == 2); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR(generator->m_frame->m_frame.f_back);

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF(generator->m_frame->m_frame.f_back);

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF(generator->m_frame);

    Nuitka_Frame_MarkAsExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

        EXC_TYPE_F(generator) = EXC_TYPE(thread_state);
        if (EXC_TYPE_F(generator) == Py_None) EXC_TYPE_F(generator) = NULL;
        Py_XINCREF(EXC_TYPE_F(generator));
        EXC_VALUE_F(generator) = EXC_VALUE(thread_state);
        Py_XINCREF(EXC_VALUE_F(generator));
        EXC_TRACEBACK_F(generator) = EXC_TRACEBACK(thread_state);
        Py_XINCREF(EXC_TRACEBACK_F(generator));
    }

#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_1;
        CHECK_OBJECT(PyCell_GET(generator->m_closure[0]));
        tmp_next_source_1 = PyCell_GET(generator->m_closure[0]);
        tmp_assign_source_1 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_1 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);
                generator_heap->type_description_1 = "No";
                generator_heap->exception_lineno = 514;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_iter_value_0;
            generator_heap->tmp_iter_value_0 = tmp_assign_source_1;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT(generator_heap->tmp_iter_value_0);
        tmp_assign_source_2 = generator_heap->tmp_iter_value_0;
        {
            PyObject *old = generator_heap->var_x;
            generator_heap->var_x = tmp_assign_source_2;
            Py_INCREF(generator_heap->var_x);
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_expression_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        CHECK_OBJECT(generator_heap->var_x);
        tmp_isinstance_inst_1 = generator_heap->var_x;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_GeneralName);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_GeneralName);
        }

        if (tmp_mvar_value_1 == NULL) {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF(generator_heap->exception_type);
            generator_heap->exception_value = UNSTREAM_STRING(&constant_bin[ 36192 ], 40, 0);
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 514;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        generator_heap->tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (generator_heap->tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 514;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_expression_name_1 = (generator_heap->tmp_res != 0) ? Py_True : Py_False;
        Py_INCREF(tmp_expression_name_1);
        Nuitka_PreserveHeap(generator_heap->yield_tmps, &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), NULL);
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        Nuitka_RestoreHeap(generator_heap->yield_tmps, &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), NULL);
        if (yield_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 514;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


        generator_heap->exception_lineno = 514;
        generator_heap->type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    // Allow re-use of the frame again.
    Py_DECREF(generator->m_frame);
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if (!EXCEPTION_MATCH_GENERATOR(generator_heap->exception_type)) {
        if (generator_heap->exception_tb == NULL) {
            generator_heap->exception_tb = MAKE_TRACEBACK(generator->m_frame, generator_heap->exception_lineno);
        } else if (generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame) {
            generator_heap->exception_tb = ADD_TRACEBACK(generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno);
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            NULL,
            generator_heap->var_x
        );


        // Release cached frame.
        if (generator->m_frame == cache_m_frame) {
            Py_DECREF(generator->m_frame);
        }
        cache_m_frame = NULL;

        assertFrameObject(generator->m_frame);
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    Py_DECREF(generator->m_frame);

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->var_x);
    generator_heap->var_x = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    Py_XDECREF(generator_heap->var_x);
    generator_heap->var_x = NULL;



    return NULL;

    function_exception_exit:
    assert(generator_heap->exception_type);
    RESTORE_ERROR_OCCURRED(generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb);

    return NULL;

}

static PyObject *cryptography$x509$extensions$$$function_69___init__$$$genexpr_2_genexpr_maker(void) {
    return Nuitka_Generator_New(
        cryptography$x509$extensions$$$function_69___init__$$$genexpr_2_genexpr_context,
        module_cryptography$x509$extensions,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_31212033882b18f22cff534424b54050,
        1,
        sizeof(struct cryptography$x509$extensions$$$function_69___init__$$$genexpr_2_genexpr_locals)
    );
}



struct cryptography$x509$extensions$$$function_69___init__$$$genexpr_3_genexpr_locals {
    PyObject *var_x;
    PyObject *tmp_iter_value_0;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    int tmp_res;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *cryptography$x509$extensions$$$function_69___init__$$$genexpr_3_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value ) {
    CHECK_OBJECT((PyObject *)generator);
    assert(Nuitka_Generator_Check( (PyObject *)generator ));

    // Heap access if used.
    struct cryptography$x509$extensions$$$function_69___init__$$$genexpr_3_genexpr_locals *generator_heap = (struct cryptography$x509$extensions$$$function_69___init__$$$genexpr_3_genexpr_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_x = NULL;
    generator_heap->tmp_iter_value_0 = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_m_frame, codeobj_976e58673ea1efbd2ac3a273b25c792e, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF(generator->m_frame);
    assert(Py_REFCNT(generator->m_frame) == 2); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR(generator->m_frame->m_frame.f_back);

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF(generator->m_frame->m_frame.f_back);

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF(generator->m_frame);

    Nuitka_Frame_MarkAsExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

        EXC_TYPE_F(generator) = EXC_TYPE(thread_state);
        if (EXC_TYPE_F(generator) == Py_None) EXC_TYPE_F(generator) = NULL;
        Py_XINCREF(EXC_TYPE_F(generator));
        EXC_VALUE_F(generator) = EXC_VALUE(thread_state);
        Py_XINCREF(EXC_VALUE_F(generator));
        EXC_TRACEBACK_F(generator) = EXC_TRACEBACK(thread_state);
        Py_XINCREF(EXC_TRACEBACK_F(generator));
    }

#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_1;
        CHECK_OBJECT(PyCell_GET(generator->m_closure[0]));
        tmp_next_source_1 = PyCell_GET(generator->m_closure[0]);
        tmp_assign_source_1 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_1 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);
                generator_heap->type_description_1 = "No";
                generator_heap->exception_lineno = 520;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_iter_value_0;
            generator_heap->tmp_iter_value_0 = tmp_assign_source_1;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT(generator_heap->tmp_iter_value_0);
        tmp_assign_source_2 = generator_heap->tmp_iter_value_0;
        {
            PyObject *old = generator_heap->var_x;
            generator_heap->var_x = tmp_assign_source_2;
            Py_INCREF(generator_heap->var_x);
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_expression_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        CHECK_OBJECT(generator_heap->var_x);
        tmp_isinstance_inst_1 = generator_heap->var_x;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ReasonFlags);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ReasonFlags);
        }

        if (tmp_mvar_value_1 == NULL) {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF(generator_heap->exception_type);
            generator_heap->exception_value = UNSTREAM_STRING(&constant_bin[ 36774 ], 40, 0);
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 520;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        generator_heap->tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (generator_heap->tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 520;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_expression_name_1 = (generator_heap->tmp_res != 0) ? Py_True : Py_False;
        Py_INCREF(tmp_expression_name_1);
        Nuitka_PreserveHeap(generator_heap->yield_tmps, &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), NULL);
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        Nuitka_RestoreHeap(generator_heap->yield_tmps, &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), NULL);
        if (yield_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 520;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


        generator_heap->exception_lineno = 520;
        generator_heap->type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    // Allow re-use of the frame again.
    Py_DECREF(generator->m_frame);
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if (!EXCEPTION_MATCH_GENERATOR(generator_heap->exception_type)) {
        if (generator_heap->exception_tb == NULL) {
            generator_heap->exception_tb = MAKE_TRACEBACK(generator->m_frame, generator_heap->exception_lineno);
        } else if (generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame) {
            generator_heap->exception_tb = ADD_TRACEBACK(generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno);
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            NULL,
            generator_heap->var_x
        );


        // Release cached frame.
        if (generator->m_frame == cache_m_frame) {
            Py_DECREF(generator->m_frame);
        }
        cache_m_frame = NULL;

        assertFrameObject(generator->m_frame);
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    Py_DECREF(generator->m_frame);

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->var_x);
    generator_heap->var_x = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    Py_XDECREF(generator_heap->var_x);
    generator_heap->var_x = NULL;



    return NULL;

    function_exception_exit:
    assert(generator_heap->exception_type);
    RESTORE_ERROR_OCCURRED(generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb);

    return NULL;

}

static PyObject *cryptography$x509$extensions$$$function_69___init__$$$genexpr_3_genexpr_maker(void) {
    return Nuitka_Generator_New(
        cryptography$x509$extensions$$$function_69___init__$$$genexpr_3_genexpr_context,
        module_cryptography$x509$extensions,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_976e58673ea1efbd2ac3a273b25c792e,
        1,
        sizeof(struct cryptography$x509$extensions$$$function_69___init__$$$genexpr_3_genexpr_locals)
    );
}


static PyObject *impl_cryptography$x509$extensions$$$function_70___repr__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_2b572ac717ef65df74ce99e5f8b136a9;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_2b572ac717ef65df74ce99e5f8b136a9 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_2b572ac717ef65df74ce99e5f8b136a9, codeobj_2b572ac717ef65df74ce99e5f8b136a9, module_cryptography$x509$extensions, sizeof(void *));
    frame_2b572ac717ef65df74ce99e5f8b136a9 = cache_frame_2b572ac717ef65df74ce99e5f8b136a9;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_2b572ac717ef65df74ce99e5f8b136a9);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_2b572ac717ef65df74ce99e5f8b136a9) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        tmp_called_instance_1 = const_str_digest_e7bc751982d7cd4fe2e9c78dbf3e6347;
        CHECK_OBJECT(par_self);
        tmp_args_element_name_1 = par_self;
        frame_2b572ac717ef65df74ce99e5f8b136a9->m_frame.f_lineno = 546;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_format, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 546;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2b572ac717ef65df74ce99e5f8b136a9);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_2b572ac717ef65df74ce99e5f8b136a9);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2b572ac717ef65df74ce99e5f8b136a9);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_2b572ac717ef65df74ce99e5f8b136a9, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_2b572ac717ef65df74ce99e5f8b136a9->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_2b572ac717ef65df74ce99e5f8b136a9, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2b572ac717ef65df74ce99e5f8b136a9,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_2b572ac717ef65df74ce99e5f8b136a9 == cache_frame_2b572ac717ef65df74ce99e5f8b136a9) {
        Py_DECREF(frame_2b572ac717ef65df74ce99e5f8b136a9);
    }
    cache_frame_2b572ac717ef65df74ce99e5f8b136a9 = NULL;

    assertFrameObject(frame_2b572ac717ef65df74ce99e5f8b136a9);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_70___repr__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_71___eq__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_fd2f7ac83c7c2c75bf12c49dee786140;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_fd2f7ac83c7c2c75bf12c49dee786140 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_fd2f7ac83c7c2c75bf12c49dee786140, codeobj_fd2f7ac83c7c2c75bf12c49dee786140, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_fd2f7ac83c7c2c75bf12c49dee786140 = cache_frame_fd2f7ac83c7c2c75bf12c49dee786140;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_fd2f7ac83c7c2c75bf12c49dee786140);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_fd2f7ac83c7c2c75bf12c49dee786140) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_other);
        tmp_isinstance_inst_1 = par_other;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_DistributionPoint);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_DistributionPoint);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 36584 ], 46, 0);
            exception_tb = NULL;

            exception_lineno = 552;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 552;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 552;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        int tmp_and_left_truth_1;
        PyObject *tmp_and_left_value_1;
        PyObject *tmp_and_right_value_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        int tmp_and_left_truth_2;
        PyObject *tmp_and_left_value_2;
        PyObject *tmp_and_right_value_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_source_name_4;
        int tmp_and_left_truth_3;
        PyObject *tmp_and_left_value_3;
        PyObject *tmp_and_right_value_3;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_source_name_5;
        PyObject *tmp_source_name_6;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        PyObject *tmp_source_name_7;
        PyObject *tmp_source_name_8;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_full_name);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 556;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_2 = par_other;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_full_name);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_1);

            exception_lineno = 556;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_and_left_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 556;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_truth_1 = CHECK_IF_TRUE(tmp_and_left_value_1);
        if (tmp_and_left_truth_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_and_left_value_1);

            exception_lineno = 559;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        if (tmp_and_left_truth_1 == 1) {
            goto and_right_1;
        } else {
            goto and_left_1;
        }
        and_right_1:;
        Py_DECREF(tmp_and_left_value_1);
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_relative_name);
        if (tmp_compexpr_left_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 557;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_4 = par_other;
        tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_relative_name);
        if (tmp_compexpr_right_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_2);

            exception_lineno = 557;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_2 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
        Py_DECREF(tmp_compexpr_left_2);
        Py_DECREF(tmp_compexpr_right_2);
        if (tmp_and_left_value_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 557;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_truth_2 = CHECK_IF_TRUE(tmp_and_left_value_2);
        if (tmp_and_left_truth_2 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_and_left_value_2);

            exception_lineno = 559;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        if (tmp_and_left_truth_2 == 1) {
            goto and_right_2;
        } else {
            goto and_left_2;
        }
        and_right_2:;
        Py_DECREF(tmp_and_left_value_2);
        CHECK_OBJECT(par_self);
        tmp_source_name_5 = par_self;
        tmp_compexpr_left_3 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_reasons);
        if (tmp_compexpr_left_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 558;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_6 = par_other;
        tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_reasons);
        if (tmp_compexpr_right_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_3);

            exception_lineno = 558;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_3 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_3, tmp_compexpr_right_3);
        Py_DECREF(tmp_compexpr_left_3);
        Py_DECREF(tmp_compexpr_right_3);
        if (tmp_and_left_value_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 558;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_truth_3 = CHECK_IF_TRUE(tmp_and_left_value_3);
        if (tmp_and_left_truth_3 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_and_left_value_3);

            exception_lineno = 559;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        if (tmp_and_left_truth_3 == 1) {
            goto and_right_3;
        } else {
            goto and_left_3;
        }
        and_right_3:;
        Py_DECREF(tmp_and_left_value_3);
        CHECK_OBJECT(par_self);
        tmp_source_name_7 = par_self;
        tmp_compexpr_left_4 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain_crl_issuer);
        if (tmp_compexpr_left_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 559;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_8 = par_other;
        tmp_compexpr_right_4 = LOOKUP_ATTRIBUTE(tmp_source_name_8, const_str_plain_crl_issuer);
        if (tmp_compexpr_right_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_4);

            exception_lineno = 559;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_3 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_4, tmp_compexpr_right_4);
        Py_DECREF(tmp_compexpr_left_4);
        Py_DECREF(tmp_compexpr_right_4);
        if (tmp_and_right_value_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 559;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_2 = tmp_and_right_value_3;
        goto and_end_3;
        and_left_3:;
        tmp_and_right_value_2 = tmp_and_left_value_3;
        and_end_3:;
        tmp_and_right_value_1 = tmp_and_right_value_2;
        goto and_end_2;
        and_left_2:;
        tmp_and_right_value_1 = tmp_and_left_value_2;
        and_end_2:;
        tmp_return_value = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_return_value = tmp_and_left_value_1;
        and_end_1:;
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_fd2f7ac83c7c2c75bf12c49dee786140);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_fd2f7ac83c7c2c75bf12c49dee786140);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_fd2f7ac83c7c2c75bf12c49dee786140);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_fd2f7ac83c7c2c75bf12c49dee786140, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_fd2f7ac83c7c2c75bf12c49dee786140->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_fd2f7ac83c7c2c75bf12c49dee786140, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_fd2f7ac83c7c2c75bf12c49dee786140,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_fd2f7ac83c7c2c75bf12c49dee786140 == cache_frame_fd2f7ac83c7c2c75bf12c49dee786140) {
        Py_DECREF(frame_fd2f7ac83c7c2c75bf12c49dee786140);
    }
    cache_frame_fd2f7ac83c7c2c75bf12c49dee786140 = NULL;

    assertFrameObject(frame_fd2f7ac83c7c2c75bf12c49dee786140);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_71___eq__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_72___ne__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_50bc9a59774bc50fc0ac2d1a07ffc38a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_50bc9a59774bc50fc0ac2d1a07ffc38a = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_50bc9a59774bc50fc0ac2d1a07ffc38a, codeobj_50bc9a59774bc50fc0ac2d1a07ffc38a, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_50bc9a59774bc50fc0ac2d1a07ffc38a = cache_frame_50bc9a59774bc50fc0ac2d1a07ffc38a;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_50bc9a59774bc50fc0ac2d1a07ffc38a);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_50bc9a59774bc50fc0ac2d1a07ffc38a) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_self);
        tmp_compexpr_left_1 = par_self;
        CHECK_OBJECT(par_other);
        tmp_compexpr_right_1 = par_other;
        tmp_operand_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 563;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 563;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = (tmp_res == 0) ? Py_True : Py_False;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_50bc9a59774bc50fc0ac2d1a07ffc38a);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_50bc9a59774bc50fc0ac2d1a07ffc38a);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_50bc9a59774bc50fc0ac2d1a07ffc38a);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_50bc9a59774bc50fc0ac2d1a07ffc38a, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_50bc9a59774bc50fc0ac2d1a07ffc38a->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_50bc9a59774bc50fc0ac2d1a07ffc38a, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_50bc9a59774bc50fc0ac2d1a07ffc38a,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_50bc9a59774bc50fc0ac2d1a07ffc38a == cache_frame_50bc9a59774bc50fc0ac2d1a07ffc38a) {
        Py_DECREF(frame_50bc9a59774bc50fc0ac2d1a07ffc38a);
    }
    cache_frame_50bc9a59774bc50fc0ac2d1a07ffc38a = NULL;

    assertFrameObject(frame_50bc9a59774bc50fc0ac2d1a07ffc38a);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_72___ne__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_73___hash__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_crl_issuer = NULL;
    PyObject *var_fn = NULL;
    struct Nuitka_FrameObject *frame_f20ef46fc2f13e0d2c1ca2898c462ef4;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_f20ef46fc2f13e0d2c1ca2898c462ef4 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_f20ef46fc2f13e0d2c1ca2898c462ef4, codeobj_f20ef46fc2f13e0d2c1ca2898c462ef4, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_f20ef46fc2f13e0d2c1ca2898c462ef4 = cache_frame_f20ef46fc2f13e0d2c1ca2898c462ef4;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_f20ef46fc2f13e0d2c1ca2898c462ef4);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_f20ef46fc2f13e0d2c1ca2898c462ef4) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_full_name);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 566;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 != tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_compexpr_left_1);
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_tuple_arg_1;
            PyObject *tmp_source_name_2;
            CHECK_OBJECT(par_self);
            tmp_source_name_2 = par_self;
            tmp_tuple_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_full_name);
            if (tmp_tuple_arg_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 567;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_assign_source_1 = PySequence_Tuple(tmp_tuple_arg_1);
            Py_DECREF(tmp_tuple_arg_1);
            if (tmp_assign_source_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 567;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            assert(var_fn == NULL);
            var_fn = tmp_assign_source_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_2;
            tmp_assign_source_2 = Py_None;
            assert(var_fn == NULL);
            Py_INCREF(tmp_assign_source_2);
            var_fn = tmp_assign_source_2;
        }
        branch_end_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_3;
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_crl_issuer);
        if (tmp_compexpr_left_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 571;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_2 = Py_None;
        tmp_condition_result_2 = (tmp_compexpr_left_2 != tmp_compexpr_right_2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_compexpr_left_2);
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_tuple_arg_2;
            PyObject *tmp_source_name_4;
            CHECK_OBJECT(par_self);
            tmp_source_name_4 = par_self;
            tmp_tuple_arg_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_crl_issuer);
            if (tmp_tuple_arg_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 572;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_assign_source_3 = PySequence_Tuple(tmp_tuple_arg_2);
            Py_DECREF(tmp_tuple_arg_2);
            if (tmp_assign_source_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 572;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            assert(var_crl_issuer == NULL);
            var_crl_issuer = tmp_assign_source_3;
        }
        goto branch_end_2;
        branch_no_2:;
        {
            PyObject *tmp_assign_source_4;
            tmp_assign_source_4 = Py_None;
            assert(var_crl_issuer == NULL);
            Py_INCREF(tmp_assign_source_4);
            var_crl_issuer = tmp_assign_source_4;
        }
        branch_end_2:;
    }
    {
        PyObject *tmp_hash_arg_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_5;
        PyObject *tmp_source_name_6;
        CHECK_OBJECT(var_fn);
        tmp_tuple_element_1 = var_fn;
        tmp_hash_arg_1 = PyTuple_New(4);
        Py_INCREF(tmp_tuple_element_1);
        PyTuple_SET_ITEM(tmp_hash_arg_1, 0, tmp_tuple_element_1);
        CHECK_OBJECT(par_self);
        tmp_source_name_5 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_relative_name);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_hash_arg_1);

            exception_lineno = 576;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM(tmp_hash_arg_1, 1, tmp_tuple_element_1);
        CHECK_OBJECT(par_self);
        tmp_source_name_6 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_reasons);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_hash_arg_1);

            exception_lineno = 576;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM(tmp_hash_arg_1, 2, tmp_tuple_element_1);
        CHECK_OBJECT(var_crl_issuer);
        tmp_tuple_element_1 = var_crl_issuer;
        Py_INCREF(tmp_tuple_element_1);
        PyTuple_SET_ITEM(tmp_hash_arg_1, 3, tmp_tuple_element_1);
        tmp_return_value = BUILTIN_HASH(tmp_hash_arg_1);
        Py_DECREF(tmp_hash_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 576;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_f20ef46fc2f13e0d2c1ca2898c462ef4);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_f20ef46fc2f13e0d2c1ca2898c462ef4);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_f20ef46fc2f13e0d2c1ca2898c462ef4);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_f20ef46fc2f13e0d2c1ca2898c462ef4, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_f20ef46fc2f13e0d2c1ca2898c462ef4->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_f20ef46fc2f13e0d2c1ca2898c462ef4, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f20ef46fc2f13e0d2c1ca2898c462ef4,
        type_description_1,
        par_self,
        var_crl_issuer,
        var_fn
    );


    // Release cached frame.
    if (frame_f20ef46fc2f13e0d2c1ca2898c462ef4 == cache_frame_f20ef46fc2f13e0d2c1ca2898c462ef4) {
        Py_DECREF(frame_f20ef46fc2f13e0d2c1ca2898c462ef4);
    }
    cache_frame_f20ef46fc2f13e0d2c1ca2898c462ef4 = NULL;

    assertFrameObject(frame_f20ef46fc2f13e0d2c1ca2898c462ef4);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_73___hash__);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_crl_issuer);
    Py_DECREF(var_crl_issuer);
    var_crl_issuer = NULL;

    CHECK_OBJECT((PyObject *)var_fn);
    Py_DECREF(var_fn);
    var_fn = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_crl_issuer);
    var_crl_issuer = NULL;

    Py_XDECREF(var_fn);
    var_fn = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_73___hash__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_74___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_require_explicit_policy = python_pars[1];
    PyObject *par_inhibit_policy_mapping = python_pars[2];
    struct Nuitka_FrameObject *frame_8c74ccf08a9d69888a5bac51f8974a06;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_8c74ccf08a9d69888a5bac51f8974a06 = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_8c74ccf08a9d69888a5bac51f8974a06, codeobj_8c74ccf08a9d69888a5bac51f8974a06, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_8c74ccf08a9d69888a5bac51f8974a06 = cache_frame_8c74ccf08a9d69888a5bac51f8974a06;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_8c74ccf08a9d69888a5bac51f8974a06);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_8c74ccf08a9d69888a5bac51f8974a06) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_and_left_truth_1;
        nuitka_bool tmp_and_left_value_1;
        nuitka_bool tmp_and_right_value_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_require_explicit_policy);
        tmp_compexpr_left_1 = par_require_explicit_policy;
        tmp_compexpr_right_1 = Py_None;
        tmp_and_left_value_1 = (tmp_compexpr_left_1 != tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if (tmp_and_left_truth_1 == 1) {
            goto and_right_1;
        } else {
            goto and_left_1;
        }
        and_right_1:;
        CHECK_OBJECT(par_require_explicit_policy);
        tmp_isinstance_inst_1 = par_require_explicit_policy;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_six);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_six);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 19694 ], 32, 0);
            exception_tb = NULL;

            exception_lineno = 603;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_isinstance_cls_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_integer_types);
        if (tmp_isinstance_cls_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 603;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        Py_DECREF(tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 602;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 602;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_condition_result_1 = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_condition_result_1 = tmp_and_left_value_1;
        and_end_1:;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_ac8667798ba70bb109d3e3236473ab02;
            frame_8c74ccf08a9d69888a5bac51f8974a06->m_frame.f_lineno = 605;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 605;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        int tmp_and_left_truth_2;
        nuitka_bool tmp_and_left_value_2;
        nuitka_bool tmp_and_right_value_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_operand_name_2;
        PyObject *tmp_isinstance_inst_2;
        PyObject *tmp_isinstance_cls_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT(par_inhibit_policy_mapping);
        tmp_compexpr_left_2 = par_inhibit_policy_mapping;
        tmp_compexpr_right_2 = Py_None;
        tmp_and_left_value_2 = (tmp_compexpr_left_2 != tmp_compexpr_right_2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_2 = tmp_and_left_value_2 == NUITKA_BOOL_TRUE ? 1 : 0;
        if (tmp_and_left_truth_2 == 1) {
            goto and_right_2;
        } else {
            goto and_left_2;
        }
        and_right_2:;
        CHECK_OBJECT(par_inhibit_policy_mapping);
        tmp_isinstance_inst_2 = par_inhibit_policy_mapping;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_six);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_six);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 19694 ], 32, 0);
            exception_tb = NULL;

            exception_lineno = 611;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_isinstance_cls_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_integer_types);
        if (tmp_isinstance_cls_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 611;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_2, tmp_isinstance_cls_2);
        Py_DECREF(tmp_isinstance_cls_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 610;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_2 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 610;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_2 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_condition_result_2 = tmp_and_right_value_2;
        goto and_end_2;
        and_left_2:;
        tmp_condition_result_2 = tmp_and_left_value_2;
        and_end_2:;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            tmp_make_exception_arg_2 = const_str_digest_acc45e336b0d5f3376f4867fb94a18e6;
            frame_8c74ccf08a9d69888a5bac51f8974a06->m_frame.f_lineno = 613;
            tmp_raise_type_2 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_2);
            assert(!(tmp_raise_type_2 == NULL));
            exception_type = tmp_raise_type_2;
            exception_lineno = 613;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        int tmp_and_left_truth_3;
        nuitka_bool tmp_and_left_value_3;
        nuitka_bool tmp_and_right_value_3;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        CHECK_OBJECT(par_inhibit_policy_mapping);
        tmp_compexpr_left_3 = par_inhibit_policy_mapping;
        tmp_compexpr_right_3 = Py_None;
        tmp_and_left_value_3 = (tmp_compexpr_left_3 == tmp_compexpr_right_3) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_3 = tmp_and_left_value_3 == NUITKA_BOOL_TRUE ? 1 : 0;
        if (tmp_and_left_truth_3 == 1) {
            goto and_right_3;
        } else {
            goto and_left_3;
        }
        and_right_3:;
        CHECK_OBJECT(par_require_explicit_policy);
        tmp_compexpr_left_4 = par_require_explicit_policy;
        tmp_compexpr_right_4 = Py_None;
        tmp_and_right_value_3 = (tmp_compexpr_left_4 == tmp_compexpr_right_4) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_condition_result_3 = tmp_and_right_value_3;
        goto and_end_3;
        and_left_3:;
        tmp_condition_result_3 = tmp_and_left_value_3;
        and_end_3:;
        if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
            goto branch_yes_3;
        } else {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_raise_type_3;
            PyObject *tmp_make_exception_arg_3;
            tmp_make_exception_arg_3 = const_str_digest_3611def0515b06c31df0f70307f767f3;
            frame_8c74ccf08a9d69888a5bac51f8974a06->m_frame.f_lineno = 618;
            tmp_raise_type_3 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_3);
            assert(!(tmp_raise_type_3 == NULL));
            exception_type = tmp_raise_type_3;
            exception_lineno = 618;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_3:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_require_explicit_policy);
        tmp_assattr_name_1 = par_require_explicit_policy;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__require_explicit_policy, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 623;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT(par_inhibit_policy_mapping);
        tmp_assattr_name_2 = par_inhibit_policy_mapping;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain__inhibit_policy_mapping, tmp_assattr_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 624;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8c74ccf08a9d69888a5bac51f8974a06);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8c74ccf08a9d69888a5bac51f8974a06);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_8c74ccf08a9d69888a5bac51f8974a06, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_8c74ccf08a9d69888a5bac51f8974a06->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_8c74ccf08a9d69888a5bac51f8974a06, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8c74ccf08a9d69888a5bac51f8974a06,
        type_description_1,
        par_self,
        par_require_explicit_policy,
        par_inhibit_policy_mapping
    );


    // Release cached frame.
    if (frame_8c74ccf08a9d69888a5bac51f8974a06 == cache_frame_8c74ccf08a9d69888a5bac51f8974a06) {
        Py_DECREF(frame_8c74ccf08a9d69888a5bac51f8974a06);
    }
    cache_frame_8c74ccf08a9d69888a5bac51f8974a06 = NULL;

    assertFrameObject(frame_8c74ccf08a9d69888a5bac51f8974a06);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_74___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_require_explicit_policy);
    Py_DECREF(par_require_explicit_policy);
    CHECK_OBJECT(par_inhibit_policy_mapping);
    Py_DECREF(par_inhibit_policy_mapping);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_require_explicit_policy);
    Py_DECREF(par_require_explicit_policy);
    CHECK_OBJECT(par_inhibit_policy_mapping);
    Py_DECREF(par_inhibit_policy_mapping);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_75___repr__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_2e2a967d61caf9026b18b0e9c6006146;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_2e2a967d61caf9026b18b0e9c6006146 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_2e2a967d61caf9026b18b0e9c6006146, codeobj_2e2a967d61caf9026b18b0e9c6006146, module_cryptography$x509$extensions, sizeof(void *));
    frame_2e2a967d61caf9026b18b0e9c6006146 = cache_frame_2e2a967d61caf9026b18b0e9c6006146;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_2e2a967d61caf9026b18b0e9c6006146);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_2e2a967d61caf9026b18b0e9c6006146) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        tmp_called_instance_1 = const_unicode_digest_71b136bb2c4e9e2ce7c90a48ee86f246;
        CHECK_OBJECT(par_self);
        tmp_args_element_name_1 = par_self;
        frame_2e2a967d61caf9026b18b0e9c6006146->m_frame.f_lineno = 628;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_format, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 628;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2e2a967d61caf9026b18b0e9c6006146);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_2e2a967d61caf9026b18b0e9c6006146);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2e2a967d61caf9026b18b0e9c6006146);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_2e2a967d61caf9026b18b0e9c6006146, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_2e2a967d61caf9026b18b0e9c6006146->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_2e2a967d61caf9026b18b0e9c6006146, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2e2a967d61caf9026b18b0e9c6006146,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_2e2a967d61caf9026b18b0e9c6006146 == cache_frame_2e2a967d61caf9026b18b0e9c6006146) {
        Py_DECREF(frame_2e2a967d61caf9026b18b0e9c6006146);
    }
    cache_frame_2e2a967d61caf9026b18b0e9c6006146 = NULL;

    assertFrameObject(frame_2e2a967d61caf9026b18b0e9c6006146);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_75___repr__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_76___eq__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_37be6aa945e0555a84befbfd36f8ffc2;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_37be6aa945e0555a84befbfd36f8ffc2 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_37be6aa945e0555a84befbfd36f8ffc2, codeobj_37be6aa945e0555a84befbfd36f8ffc2, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_37be6aa945e0555a84befbfd36f8ffc2 = cache_frame_37be6aa945e0555a84befbfd36f8ffc2;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_37be6aa945e0555a84befbfd36f8ffc2);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_37be6aa945e0555a84befbfd36f8ffc2) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_other);
        tmp_isinstance_inst_1 = par_other;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_PolicyConstraints);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_PolicyConstraints);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 36814 ], 46, 0);
            exception_tb = NULL;

            exception_lineno = 634;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 634;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 634;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        int tmp_and_left_truth_1;
        PyObject *tmp_and_left_value_1;
        PyObject *tmp_and_right_value_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_source_name_4;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_require_explicit_policy);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 638;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_2 = par_other;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_require_explicit_policy);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_1);

            exception_lineno = 638;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_and_left_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 638;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_truth_1 = CHECK_IF_TRUE(tmp_and_left_value_1);
        if (tmp_and_left_truth_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_and_left_value_1);

            exception_lineno = 639;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        if (tmp_and_left_truth_1 == 1) {
            goto and_right_1;
        } else {
            goto and_left_1;
        }
        and_right_1:;
        Py_DECREF(tmp_and_left_value_1);
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_inhibit_policy_mapping);
        if (tmp_compexpr_left_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 639;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_4 = par_other;
        tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_inhibit_policy_mapping);
        if (tmp_compexpr_right_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_2);

            exception_lineno = 639;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
        Py_DECREF(tmp_compexpr_left_2);
        Py_DECREF(tmp_compexpr_right_2);
        if (tmp_and_right_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 639;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_return_value = tmp_and_left_value_1;
        and_end_1:;
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_37be6aa945e0555a84befbfd36f8ffc2);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_37be6aa945e0555a84befbfd36f8ffc2);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_37be6aa945e0555a84befbfd36f8ffc2);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_37be6aa945e0555a84befbfd36f8ffc2, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_37be6aa945e0555a84befbfd36f8ffc2->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_37be6aa945e0555a84befbfd36f8ffc2, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_37be6aa945e0555a84befbfd36f8ffc2,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_37be6aa945e0555a84befbfd36f8ffc2 == cache_frame_37be6aa945e0555a84befbfd36f8ffc2) {
        Py_DECREF(frame_37be6aa945e0555a84befbfd36f8ffc2);
    }
    cache_frame_37be6aa945e0555a84befbfd36f8ffc2 = NULL;

    assertFrameObject(frame_37be6aa945e0555a84befbfd36f8ffc2);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_76___eq__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_77___ne__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_1d077a2aa446b600dd44fa19b0fba0f2;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_1d077a2aa446b600dd44fa19b0fba0f2 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_1d077a2aa446b600dd44fa19b0fba0f2, codeobj_1d077a2aa446b600dd44fa19b0fba0f2, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_1d077a2aa446b600dd44fa19b0fba0f2 = cache_frame_1d077a2aa446b600dd44fa19b0fba0f2;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_1d077a2aa446b600dd44fa19b0fba0f2);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_1d077a2aa446b600dd44fa19b0fba0f2) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_self);
        tmp_compexpr_left_1 = par_self;
        CHECK_OBJECT(par_other);
        tmp_compexpr_right_1 = par_other;
        tmp_operand_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 643;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 643;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = (tmp_res == 0) ? Py_True : Py_False;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_1d077a2aa446b600dd44fa19b0fba0f2);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_1d077a2aa446b600dd44fa19b0fba0f2);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_1d077a2aa446b600dd44fa19b0fba0f2);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_1d077a2aa446b600dd44fa19b0fba0f2, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_1d077a2aa446b600dd44fa19b0fba0f2->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_1d077a2aa446b600dd44fa19b0fba0f2, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1d077a2aa446b600dd44fa19b0fba0f2,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_1d077a2aa446b600dd44fa19b0fba0f2 == cache_frame_1d077a2aa446b600dd44fa19b0fba0f2) {
        Py_DECREF(frame_1d077a2aa446b600dd44fa19b0fba0f2);
    }
    cache_frame_1d077a2aa446b600dd44fa19b0fba0f2 = NULL;

    assertFrameObject(frame_1d077a2aa446b600dd44fa19b0fba0f2);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_77___ne__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_78___hash__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_0bf109aa3d44d653af2864e48ed4fe06;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_0bf109aa3d44d653af2864e48ed4fe06 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_0bf109aa3d44d653af2864e48ed4fe06, codeobj_0bf109aa3d44d653af2864e48ed4fe06, module_cryptography$x509$extensions, sizeof(void *));
    frame_0bf109aa3d44d653af2864e48ed4fe06 = cache_frame_0bf109aa3d44d653af2864e48ed4fe06;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_0bf109aa3d44d653af2864e48ed4fe06);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_0bf109aa3d44d653af2864e48ed4fe06) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_hash_arg_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_require_explicit_policy);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 647;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_hash_arg_1 = PyTuple_New(2);
        PyTuple_SET_ITEM(tmp_hash_arg_1, 0, tmp_tuple_element_1);
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_inhibit_policy_mapping);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_hash_arg_1);

            exception_lineno = 647;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM(tmp_hash_arg_1, 1, tmp_tuple_element_1);
        tmp_return_value = BUILTIN_HASH(tmp_hash_arg_1);
        Py_DECREF(tmp_hash_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 646;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0bf109aa3d44d653af2864e48ed4fe06);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_0bf109aa3d44d653af2864e48ed4fe06);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0bf109aa3d44d653af2864e48ed4fe06);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_0bf109aa3d44d653af2864e48ed4fe06, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_0bf109aa3d44d653af2864e48ed4fe06->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_0bf109aa3d44d653af2864e48ed4fe06, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0bf109aa3d44d653af2864e48ed4fe06,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_0bf109aa3d44d653af2864e48ed4fe06 == cache_frame_0bf109aa3d44d653af2864e48ed4fe06) {
        Py_DECREF(frame_0bf109aa3d44d653af2864e48ed4fe06);
    }
    cache_frame_0bf109aa3d44d653af2864e48ed4fe06 = NULL;

    assertFrameObject(frame_0bf109aa3d44d653af2864e48ed4fe06);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_78___hash__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_79___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_policies = python_pars[1];
    PyObject *tmp_genexpr_1__$0 = NULL;
    struct Nuitka_FrameObject *frame_2d8993bbcf695d23055ae2f7cb247a4b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_2d8993bbcf695d23055ae2f7cb247a4b = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_2d8993bbcf695d23055ae2f7cb247a4b, codeobj_2d8993bbcf695d23055ae2f7cb247a4b, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_2d8993bbcf695d23055ae2f7cb247a4b = cache_frame_2d8993bbcf695d23055ae2f7cb247a4b;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_2d8993bbcf695d23055ae2f7cb247a4b);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_2d8993bbcf695d23055ae2f7cb247a4b) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_list_arg_1;
        CHECK_OBJECT(par_policies);
        tmp_list_arg_1 = par_policies;
        tmp_assign_source_1 = PySequence_List(tmp_list_arg_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 663;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = par_policies;
            assert(old != NULL);
            par_policies = tmp_assign_source_1;
            Py_DECREF(old);
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_all_arg_1;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT(par_policies);
            tmp_iter_arg_1 = par_policies;
            tmp_assign_source_2 = MAKE_ITERATOR(tmp_iter_arg_1);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 664;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            assert(tmp_genexpr_1__$0 == NULL);
            tmp_genexpr_1__$0 = tmp_assign_source_2;
        }
        // Tried code:
        tmp_all_arg_1 = cryptography$x509$extensions$$$function_79___init__$$$genexpr_1_genexpr_maker();

        ((struct Nuitka_GeneratorObject *)tmp_all_arg_1)->m_closure[0] = PyCell_NEW0(tmp_genexpr_1__$0);


        goto try_return_handler_2;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_79___init__);
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        CHECK_OBJECT((PyObject *)tmp_genexpr_1__$0);
        Py_DECREF(tmp_genexpr_1__$0);
        tmp_genexpr_1__$0 = NULL;

        goto outline_result_1;
        // End of try:
        CHECK_OBJECT((PyObject *)tmp_genexpr_1__$0);
        Py_DECREF(tmp_genexpr_1__$0);
        tmp_genexpr_1__$0 = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_79___init__);
        return NULL;
        outline_result_1:;
        tmp_operand_name_1 = BUILTIN_ALL(tmp_all_arg_1);
        Py_DECREF(tmp_all_arg_1);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 664;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 664;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_a4add4111fbe02d06da1613741f3d5ca;
            frame_2d8993bbcf695d23055ae2f7cb247a4b->m_frame.f_lineno = 665;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 665;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_policies);
        tmp_assattr_name_1 = par_policies;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__policies, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 670;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2d8993bbcf695d23055ae2f7cb247a4b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2d8993bbcf695d23055ae2f7cb247a4b);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_2d8993bbcf695d23055ae2f7cb247a4b, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_2d8993bbcf695d23055ae2f7cb247a4b->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_2d8993bbcf695d23055ae2f7cb247a4b, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2d8993bbcf695d23055ae2f7cb247a4b,
        type_description_1,
        par_self,
        par_policies
    );


    // Release cached frame.
    if (frame_2d8993bbcf695d23055ae2f7cb247a4b == cache_frame_2d8993bbcf695d23055ae2f7cb247a4b) {
        Py_DECREF(frame_2d8993bbcf695d23055ae2f7cb247a4b);
    }
    cache_frame_2d8993bbcf695d23055ae2f7cb247a4b = NULL;

    assertFrameObject(frame_2d8993bbcf695d23055ae2f7cb247a4b);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_79___init__);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)par_policies);
    Py_DECREF(par_policies);
    par_policies = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)par_policies);
    Py_DECREF(par_policies);
    par_policies = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_79___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}



struct cryptography$x509$extensions$$$function_79___init__$$$genexpr_1_genexpr_locals {
    PyObject *var_x;
    PyObject *tmp_iter_value_0;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    int tmp_res;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *cryptography$x509$extensions$$$function_79___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value ) {
    CHECK_OBJECT((PyObject *)generator);
    assert(Nuitka_Generator_Check( (PyObject *)generator ));

    // Heap access if used.
    struct cryptography$x509$extensions$$$function_79___init__$$$genexpr_1_genexpr_locals *generator_heap = (struct cryptography$x509$extensions$$$function_79___init__$$$genexpr_1_genexpr_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_x = NULL;
    generator_heap->tmp_iter_value_0 = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_m_frame, codeobj_1e9868694a8772e0bc7d1c6993d99d35, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF(generator->m_frame);
    assert(Py_REFCNT(generator->m_frame) == 2); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR(generator->m_frame->m_frame.f_back);

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF(generator->m_frame->m_frame.f_back);

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF(generator->m_frame);

    Nuitka_Frame_MarkAsExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

        EXC_TYPE_F(generator) = EXC_TYPE(thread_state);
        if (EXC_TYPE_F(generator) == Py_None) EXC_TYPE_F(generator) = NULL;
        Py_XINCREF(EXC_TYPE_F(generator));
        EXC_VALUE_F(generator) = EXC_VALUE(thread_state);
        Py_XINCREF(EXC_VALUE_F(generator));
        EXC_TRACEBACK_F(generator) = EXC_TRACEBACK(thread_state);
        Py_XINCREF(EXC_TRACEBACK_F(generator));
    }

#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_1;
        CHECK_OBJECT(PyCell_GET(generator->m_closure[0]));
        tmp_next_source_1 = PyCell_GET(generator->m_closure[0]);
        tmp_assign_source_1 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_1 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);
                generator_heap->type_description_1 = "No";
                generator_heap->exception_lineno = 664;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_iter_value_0;
            generator_heap->tmp_iter_value_0 = tmp_assign_source_1;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT(generator_heap->tmp_iter_value_0);
        tmp_assign_source_2 = generator_heap->tmp_iter_value_0;
        {
            PyObject *old = generator_heap->var_x;
            generator_heap->var_x = tmp_assign_source_2;
            Py_INCREF(generator_heap->var_x);
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_expression_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        CHECK_OBJECT(generator_heap->var_x);
        tmp_isinstance_inst_1 = generator_heap->var_x;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_PolicyInformation);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_PolicyInformation);
        }

        if (tmp_mvar_value_1 == NULL) {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF(generator_heap->exception_type);
            generator_heap->exception_value = UNSTREAM_STRING(&constant_bin[ 36860 ], 46, 0);
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 664;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        generator_heap->tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (generator_heap->tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 664;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_expression_name_1 = (generator_heap->tmp_res != 0) ? Py_True : Py_False;
        Py_INCREF(tmp_expression_name_1);
        Nuitka_PreserveHeap(generator_heap->yield_tmps, &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), NULL);
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        Nuitka_RestoreHeap(generator_heap->yield_tmps, &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), NULL);
        if (yield_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 664;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


        generator_heap->exception_lineno = 664;
        generator_heap->type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    // Allow re-use of the frame again.
    Py_DECREF(generator->m_frame);
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if (!EXCEPTION_MATCH_GENERATOR(generator_heap->exception_type)) {
        if (generator_heap->exception_tb == NULL) {
            generator_heap->exception_tb = MAKE_TRACEBACK(generator->m_frame, generator_heap->exception_lineno);
        } else if (generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame) {
            generator_heap->exception_tb = ADD_TRACEBACK(generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno);
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            NULL,
            generator_heap->var_x
        );


        // Release cached frame.
        if (generator->m_frame == cache_m_frame) {
            Py_DECREF(generator->m_frame);
        }
        cache_m_frame = NULL;

        assertFrameObject(generator->m_frame);
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    Py_DECREF(generator->m_frame);

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->var_x);
    generator_heap->var_x = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    Py_XDECREF(generator_heap->var_x);
    generator_heap->var_x = NULL;



    return NULL;

    function_exception_exit:
    assert(generator_heap->exception_type);
    RESTORE_ERROR_OCCURRED(generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb);

    return NULL;

}

static PyObject *cryptography$x509$extensions$$$function_79___init__$$$genexpr_1_genexpr_maker(void) {
    return Nuitka_Generator_New(
        cryptography$x509$extensions$$$function_79___init__$$$genexpr_1_genexpr_context,
        module_cryptography$x509$extensions,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_1e9868694a8772e0bc7d1c6993d99d35,
        1,
        sizeof(struct cryptography$x509$extensions$$$function_79___init__$$$genexpr_1_genexpr_locals)
    );
}


static PyObject *impl_cryptography$x509$extensions$$$function_80___iter__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_cd33e2543397d1324358a2e61f8977a4;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_cd33e2543397d1324358a2e61f8977a4 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_cd33e2543397d1324358a2e61f8977a4, codeobj_cd33e2543397d1324358a2e61f8977a4, module_cryptography$x509$extensions, sizeof(void *));
    frame_cd33e2543397d1324358a2e61f8977a4 = cache_frame_cd33e2543397d1324358a2e61f8977a4;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_cd33e2543397d1324358a2e61f8977a4);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_cd33e2543397d1324358a2e61f8977a4) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_iter_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__policies);
        if (tmp_iter_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 673;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = MAKE_ITERATOR(tmp_iter_arg_1);
        Py_DECREF(tmp_iter_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 673;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_cd33e2543397d1324358a2e61f8977a4);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_cd33e2543397d1324358a2e61f8977a4);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_cd33e2543397d1324358a2e61f8977a4);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_cd33e2543397d1324358a2e61f8977a4, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_cd33e2543397d1324358a2e61f8977a4->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_cd33e2543397d1324358a2e61f8977a4, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_cd33e2543397d1324358a2e61f8977a4,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_cd33e2543397d1324358a2e61f8977a4 == cache_frame_cd33e2543397d1324358a2e61f8977a4) {
        Py_DECREF(frame_cd33e2543397d1324358a2e61f8977a4);
    }
    cache_frame_cd33e2543397d1324358a2e61f8977a4 = NULL;

    assertFrameObject(frame_cd33e2543397d1324358a2e61f8977a4);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_80___iter__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_81___len__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_9dfb2f031074454e5d12da987d075118;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_9dfb2f031074454e5d12da987d075118 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_9dfb2f031074454e5d12da987d075118, codeobj_9dfb2f031074454e5d12da987d075118, module_cryptography$x509$extensions, sizeof(void *));
    frame_9dfb2f031074454e5d12da987d075118 = cache_frame_9dfb2f031074454e5d12da987d075118;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_9dfb2f031074454e5d12da987d075118);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_9dfb2f031074454e5d12da987d075118) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_len_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_len_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__policies);
        if (tmp_len_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 676;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = BUILTIN_LEN(tmp_len_arg_1);
        Py_DECREF(tmp_len_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 676;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9dfb2f031074454e5d12da987d075118);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_9dfb2f031074454e5d12da987d075118);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9dfb2f031074454e5d12da987d075118);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_9dfb2f031074454e5d12da987d075118, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_9dfb2f031074454e5d12da987d075118->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_9dfb2f031074454e5d12da987d075118, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9dfb2f031074454e5d12da987d075118,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_9dfb2f031074454e5d12da987d075118 == cache_frame_9dfb2f031074454e5d12da987d075118) {
        Py_DECREF(frame_9dfb2f031074454e5d12da987d075118);
    }
    cache_frame_9dfb2f031074454e5d12da987d075118 = NULL;

    assertFrameObject(frame_9dfb2f031074454e5d12da987d075118);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_81___len__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_82___repr__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_7165db6d77156f077838a6ffb710eb7d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_7165db6d77156f077838a6ffb710eb7d = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_7165db6d77156f077838a6ffb710eb7d, codeobj_7165db6d77156f077838a6ffb710eb7d, module_cryptography$x509$extensions, sizeof(void *));
    frame_7165db6d77156f077838a6ffb710eb7d = cache_frame_7165db6d77156f077838a6ffb710eb7d;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_7165db6d77156f077838a6ffb710eb7d);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_7165db6d77156f077838a6ffb710eb7d) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_source_name_1 = const_str_digest_98ddab5a38618a53af9688f12b4a5b05;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_format);
        assert(!(tmp_called_name_1 == NULL));
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__policies);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 679;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_7165db6d77156f077838a6ffb710eb7d->m_frame.f_lineno = 679;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 679;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_7165db6d77156f077838a6ffb710eb7d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_7165db6d77156f077838a6ffb710eb7d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_7165db6d77156f077838a6ffb710eb7d);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_7165db6d77156f077838a6ffb710eb7d, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_7165db6d77156f077838a6ffb710eb7d->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_7165db6d77156f077838a6ffb710eb7d, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7165db6d77156f077838a6ffb710eb7d,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_7165db6d77156f077838a6ffb710eb7d == cache_frame_7165db6d77156f077838a6ffb710eb7d) {
        Py_DECREF(frame_7165db6d77156f077838a6ffb710eb7d);
    }
    cache_frame_7165db6d77156f077838a6ffb710eb7d = NULL;

    assertFrameObject(frame_7165db6d77156f077838a6ffb710eb7d);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_82___repr__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_83___eq__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_7c03c4c0f3dcfa4c04cd5abaf3b9020a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_7c03c4c0f3dcfa4c04cd5abaf3b9020a = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_7c03c4c0f3dcfa4c04cd5abaf3b9020a, codeobj_7c03c4c0f3dcfa4c04cd5abaf3b9020a, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_7c03c4c0f3dcfa4c04cd5abaf3b9020a = cache_frame_7c03c4c0f3dcfa4c04cd5abaf3b9020a;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_7c03c4c0f3dcfa4c04cd5abaf3b9020a);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_7c03c4c0f3dcfa4c04cd5abaf3b9020a) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_other);
        tmp_isinstance_inst_1 = par_other;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_CertificatePolicies);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_CertificatePolicies);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 36906 ], 48, 0);
            exception_tb = NULL;

            exception_lineno = 682;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 682;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 682;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__policies);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 685;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_2 = par_other;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__policies);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_1);

            exception_lineno = 685;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 685;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_7c03c4c0f3dcfa4c04cd5abaf3b9020a);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_7c03c4c0f3dcfa4c04cd5abaf3b9020a);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_7c03c4c0f3dcfa4c04cd5abaf3b9020a);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_7c03c4c0f3dcfa4c04cd5abaf3b9020a, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_7c03c4c0f3dcfa4c04cd5abaf3b9020a->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_7c03c4c0f3dcfa4c04cd5abaf3b9020a, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7c03c4c0f3dcfa4c04cd5abaf3b9020a,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_7c03c4c0f3dcfa4c04cd5abaf3b9020a == cache_frame_7c03c4c0f3dcfa4c04cd5abaf3b9020a) {
        Py_DECREF(frame_7c03c4c0f3dcfa4c04cd5abaf3b9020a);
    }
    cache_frame_7c03c4c0f3dcfa4c04cd5abaf3b9020a = NULL;

    assertFrameObject(frame_7c03c4c0f3dcfa4c04cd5abaf3b9020a);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_83___eq__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_84___ne__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_19f4c0df1d648fcd98396d2760645fff;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_19f4c0df1d648fcd98396d2760645fff = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_19f4c0df1d648fcd98396d2760645fff, codeobj_19f4c0df1d648fcd98396d2760645fff, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_19f4c0df1d648fcd98396d2760645fff = cache_frame_19f4c0df1d648fcd98396d2760645fff;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_19f4c0df1d648fcd98396d2760645fff);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_19f4c0df1d648fcd98396d2760645fff) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_self);
        tmp_compexpr_left_1 = par_self;
        CHECK_OBJECT(par_other);
        tmp_compexpr_right_1 = par_other;
        tmp_operand_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 688;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 688;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = (tmp_res == 0) ? Py_True : Py_False;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_19f4c0df1d648fcd98396d2760645fff);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_19f4c0df1d648fcd98396d2760645fff);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_19f4c0df1d648fcd98396d2760645fff);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_19f4c0df1d648fcd98396d2760645fff, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_19f4c0df1d648fcd98396d2760645fff->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_19f4c0df1d648fcd98396d2760645fff, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_19f4c0df1d648fcd98396d2760645fff,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_19f4c0df1d648fcd98396d2760645fff == cache_frame_19f4c0df1d648fcd98396d2760645fff) {
        Py_DECREF(frame_19f4c0df1d648fcd98396d2760645fff);
    }
    cache_frame_19f4c0df1d648fcd98396d2760645fff = NULL;

    assertFrameObject(frame_19f4c0df1d648fcd98396d2760645fff);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_84___ne__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_85___getitem__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_idx = python_pars[1];
    struct Nuitka_FrameObject *frame_91ef01aeefd39e14a3a497daec6f2d50;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_91ef01aeefd39e14a3a497daec6f2d50 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_91ef01aeefd39e14a3a497daec6f2d50, codeobj_91ef01aeefd39e14a3a497daec6f2d50, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_91ef01aeefd39e14a3a497daec6f2d50 = cache_frame_91ef01aeefd39e14a3a497daec6f2d50;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_91ef01aeefd39e14a3a497daec6f2d50);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_91ef01aeefd39e14a3a497daec6f2d50) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_subscript_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__policies);
        if (tmp_subscribed_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 691;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_idx);
        tmp_subscript_name_1 = par_idx;
        tmp_return_value = LOOKUP_SUBSCRIPT(tmp_subscribed_name_1, tmp_subscript_name_1);
        Py_DECREF(tmp_subscribed_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 691;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_91ef01aeefd39e14a3a497daec6f2d50);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_91ef01aeefd39e14a3a497daec6f2d50);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_91ef01aeefd39e14a3a497daec6f2d50);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_91ef01aeefd39e14a3a497daec6f2d50, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_91ef01aeefd39e14a3a497daec6f2d50->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_91ef01aeefd39e14a3a497daec6f2d50, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_91ef01aeefd39e14a3a497daec6f2d50,
        type_description_1,
        par_self,
        par_idx
    );


    // Release cached frame.
    if (frame_91ef01aeefd39e14a3a497daec6f2d50 == cache_frame_91ef01aeefd39e14a3a497daec6f2d50) {
        Py_DECREF(frame_91ef01aeefd39e14a3a497daec6f2d50);
    }
    cache_frame_91ef01aeefd39e14a3a497daec6f2d50 = NULL;

    assertFrameObject(frame_91ef01aeefd39e14a3a497daec6f2d50);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_85___getitem__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_idx);
    Py_DECREF(par_idx);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_idx);
    Py_DECREF(par_idx);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_86___hash__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_54048dea6a948c37f34018f06d8c86ff;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_54048dea6a948c37f34018f06d8c86ff = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_54048dea6a948c37f34018f06d8c86ff, codeobj_54048dea6a948c37f34018f06d8c86ff, module_cryptography$x509$extensions, sizeof(void *));
    frame_54048dea6a948c37f34018f06d8c86ff = cache_frame_54048dea6a948c37f34018f06d8c86ff;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_54048dea6a948c37f34018f06d8c86ff);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_54048dea6a948c37f34018f06d8c86ff) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_hash_arg_1;
        PyObject *tmp_tuple_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_tuple_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__policies);
        if (tmp_tuple_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 694;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_hash_arg_1 = PySequence_Tuple(tmp_tuple_arg_1);
        Py_DECREF(tmp_tuple_arg_1);
        if (tmp_hash_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 694;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = BUILTIN_HASH(tmp_hash_arg_1);
        Py_DECREF(tmp_hash_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 694;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_54048dea6a948c37f34018f06d8c86ff);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_54048dea6a948c37f34018f06d8c86ff);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_54048dea6a948c37f34018f06d8c86ff);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_54048dea6a948c37f34018f06d8c86ff, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_54048dea6a948c37f34018f06d8c86ff->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_54048dea6a948c37f34018f06d8c86ff, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_54048dea6a948c37f34018f06d8c86ff,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_54048dea6a948c37f34018f06d8c86ff == cache_frame_54048dea6a948c37f34018f06d8c86ff) {
        Py_DECREF(frame_54048dea6a948c37f34018f06d8c86ff);
    }
    cache_frame_54048dea6a948c37f34018f06d8c86ff = NULL;

    assertFrameObject(frame_54048dea6a948c37f34018f06d8c86ff);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_86___hash__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_87___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_policy_identifier = python_pars[1];
    PyObject *par_policy_qualifiers = python_pars[2];
    PyObject *tmp_genexpr_1__$0 = NULL;
    struct Nuitka_FrameObject *frame_08aca7543267a89e2589b8bd1ffcee16;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_08aca7543267a89e2589b8bd1ffcee16 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_08aca7543267a89e2589b8bd1ffcee16, codeobj_08aca7543267a89e2589b8bd1ffcee16, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_08aca7543267a89e2589b8bd1ffcee16 = cache_frame_08aca7543267a89e2589b8bd1ffcee16;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_08aca7543267a89e2589b8bd1ffcee16);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_08aca7543267a89e2589b8bd1ffcee16) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_policy_identifier);
        tmp_isinstance_inst_1 = par_policy_identifier;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ObjectIdentifier);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ObjectIdentifier);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 18374 ], 45, 0);
            exception_tb = NULL;

            exception_lineno = 699;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 699;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 699;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_ad140184cf2507dc997c5c6a9d0f3e94;
            frame_08aca7543267a89e2589b8bd1ffcee16->m_frame.f_lineno = 700;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 700;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_policy_identifier);
        tmp_assattr_name_1 = par_policy_identifier;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__policy_identifier, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 702;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }
    {
        nuitka_bool tmp_condition_result_2;
        int tmp_truth_name_1;
        CHECK_OBJECT(par_policy_qualifiers);
        tmp_truth_name_1 = CHECK_IF_TRUE(par_policy_qualifiers);
        if (tmp_truth_name_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 704;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_list_arg_1;
            CHECK_OBJECT(par_policy_qualifiers);
            tmp_list_arg_1 = par_policy_qualifiers;
            tmp_assign_source_1 = PySequence_List(tmp_list_arg_1);
            if (tmp_assign_source_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 705;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_policy_qualifiers;
                assert(old != NULL);
                par_policy_qualifiers = tmp_assign_source_1;
                Py_DECREF(old);
            }

        }
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_operand_name_2;
            PyObject *tmp_all_arg_1;
            {
                PyObject *tmp_assign_source_2;
                PyObject *tmp_iter_arg_1;
                CHECK_OBJECT(par_policy_qualifiers);
                tmp_iter_arg_1 = par_policy_qualifiers;
                tmp_assign_source_2 = MAKE_ITERATOR(tmp_iter_arg_1);
                if (tmp_assign_source_2 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 707;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                assert(tmp_genexpr_1__$0 == NULL);
                tmp_genexpr_1__$0 = tmp_assign_source_2;
            }
            // Tried code:
            tmp_all_arg_1 = cryptography$x509$extensions$$$function_87___init__$$$genexpr_1_genexpr_maker();

            ((struct Nuitka_GeneratorObject *)tmp_all_arg_1)->m_closure[0] = PyCell_NEW0(tmp_genexpr_1__$0);


            goto try_return_handler_2;
            // tried codes exits in all cases
            NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_87___init__);
            return NULL;
            // Return handler code:
            try_return_handler_2:;
            CHECK_OBJECT((PyObject *)tmp_genexpr_1__$0);
            Py_DECREF(tmp_genexpr_1__$0);
            tmp_genexpr_1__$0 = NULL;

            goto outline_result_1;
            // End of try:
            CHECK_OBJECT((PyObject *)tmp_genexpr_1__$0);
            Py_DECREF(tmp_genexpr_1__$0);
            tmp_genexpr_1__$0 = NULL;

            // Return statement must have exited already.
            NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_87___init__);
            return NULL;
            outline_result_1:;
            tmp_operand_name_2 = BUILTIN_ALL(tmp_all_arg_1);
            Py_DECREF(tmp_all_arg_1);
            if (tmp_operand_name_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 706;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_res = CHECK_IF_TRUE(tmp_operand_name_2);
            Py_DECREF(tmp_operand_name_2);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 706;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_3 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
                goto branch_yes_3;
            } else {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_raise_type_2;
                PyObject *tmp_make_exception_arg_2;
                tmp_make_exception_arg_2 = const_str_digest_cb90e2fbaafbf44b381aafdbc54043e2;
                frame_08aca7543267a89e2589b8bd1ffcee16->m_frame.f_lineno = 710;
                tmp_raise_type_2 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_2);
                assert(!(tmp_raise_type_2 == NULL));
                exception_type = tmp_raise_type_2;
                exception_lineno = 710;
                RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            branch_no_3:;
        }
        branch_no_2:;
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT(par_policy_qualifiers);
        tmp_assattr_name_2 = par_policy_qualifiers;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain__policy_qualifiers, tmp_assattr_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 715;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_08aca7543267a89e2589b8bd1ffcee16);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_08aca7543267a89e2589b8bd1ffcee16);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_08aca7543267a89e2589b8bd1ffcee16, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_08aca7543267a89e2589b8bd1ffcee16->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_08aca7543267a89e2589b8bd1ffcee16, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_08aca7543267a89e2589b8bd1ffcee16,
        type_description_1,
        par_self,
        par_policy_identifier,
        par_policy_qualifiers
    );


    // Release cached frame.
    if (frame_08aca7543267a89e2589b8bd1ffcee16 == cache_frame_08aca7543267a89e2589b8bd1ffcee16) {
        Py_DECREF(frame_08aca7543267a89e2589b8bd1ffcee16);
    }
    cache_frame_08aca7543267a89e2589b8bd1ffcee16 = NULL;

    assertFrameObject(frame_08aca7543267a89e2589b8bd1ffcee16);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_87___init__);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)par_policy_qualifiers);
    Py_DECREF(par_policy_qualifiers);
    par_policy_qualifiers = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(par_policy_qualifiers);
    par_policy_qualifiers = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_87___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_policy_identifier);
    Py_DECREF(par_policy_identifier);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_policy_identifier);
    Py_DECREF(par_policy_identifier);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}



struct cryptography$x509$extensions$$$function_87___init__$$$genexpr_1_genexpr_locals {
    PyObject *var_x;
    PyObject *tmp_iter_value_0;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    int tmp_res;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *cryptography$x509$extensions$$$function_87___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value ) {
    CHECK_OBJECT((PyObject *)generator);
    assert(Nuitka_Generator_Check( (PyObject *)generator ));

    // Heap access if used.
    struct cryptography$x509$extensions$$$function_87___init__$$$genexpr_1_genexpr_locals *generator_heap = (struct cryptography$x509$extensions$$$function_87___init__$$$genexpr_1_genexpr_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_x = NULL;
    generator_heap->tmp_iter_value_0 = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_m_frame, codeobj_4a882b53e0e829bff518a8c7aacc9ae2, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF(generator->m_frame);
    assert(Py_REFCNT(generator->m_frame) == 2); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR(generator->m_frame->m_frame.f_back);

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF(generator->m_frame->m_frame.f_back);

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF(generator->m_frame);

    Nuitka_Frame_MarkAsExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

        EXC_TYPE_F(generator) = EXC_TYPE(thread_state);
        if (EXC_TYPE_F(generator) == Py_None) EXC_TYPE_F(generator) = NULL;
        Py_XINCREF(EXC_TYPE_F(generator));
        EXC_VALUE_F(generator) = EXC_VALUE(thread_state);
        Py_XINCREF(EXC_VALUE_F(generator));
        EXC_TRACEBACK_F(generator) = EXC_TRACEBACK(thread_state);
        Py_XINCREF(EXC_TRACEBACK_F(generator));
    }

#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_1;
        CHECK_OBJECT(PyCell_GET(generator->m_closure[0]));
        tmp_next_source_1 = PyCell_GET(generator->m_closure[0]);
        tmp_assign_source_1 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_1 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);
                generator_heap->type_description_1 = "No";
                generator_heap->exception_lineno = 707;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_iter_value_0;
            generator_heap->tmp_iter_value_0 = tmp_assign_source_1;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT(generator_heap->tmp_iter_value_0);
        tmp_assign_source_2 = generator_heap->tmp_iter_value_0;
        {
            PyObject *old = generator_heap->var_x;
            generator_heap->var_x = tmp_assign_source_2;
            Py_INCREF(generator_heap->var_x);
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_expression_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_mvar_value_2;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        CHECK_OBJECT(generator_heap->var_x);
        tmp_isinstance_inst_1 = generator_heap->var_x;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_six);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_six);
        }

        if (tmp_mvar_value_1 == NULL) {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF(generator_heap->exception_type);
            generator_heap->exception_value = UNSTREAM_STRING(&constant_bin[ 19694 ], 32, 0);
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 707;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_text_type);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 707;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_isinstance_cls_1 = PyTuple_New(2);
        PyTuple_SET_ITEM(tmp_isinstance_cls_1, 0, tmp_tuple_element_1);
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_UserNotice);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_UserNotice);
        }

        if (tmp_mvar_value_2 == NULL) {
            Py_DECREF(tmp_isinstance_cls_1);
            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF(generator_heap->exception_type);
            generator_heap->exception_value = UNSTREAM_STRING(&constant_bin[ 36954 ], 39, 0);
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 707;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }

        tmp_tuple_element_1 = tmp_mvar_value_2;
        Py_INCREF(tmp_tuple_element_1);
        PyTuple_SET_ITEM(tmp_isinstance_cls_1, 1, tmp_tuple_element_1);
        generator_heap->tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        Py_DECREF(tmp_isinstance_cls_1);
        if (generator_heap->tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 707;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_expression_name_1 = (generator_heap->tmp_res != 0) ? Py_True : Py_False;
        Py_INCREF(tmp_expression_name_1);
        Nuitka_PreserveHeap(generator_heap->yield_tmps, &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), &tmp_tuple_element_1, sizeof(PyObject *), &tmp_source_name_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), &tmp_mvar_value_2, sizeof(PyObject *), NULL);
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        Nuitka_RestoreHeap(generator_heap->yield_tmps, &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), &tmp_tuple_element_1, sizeof(PyObject *), &tmp_source_name_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), &tmp_mvar_value_2, sizeof(PyObject *), NULL);
        if (yield_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 707;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


        generator_heap->exception_lineno = 707;
        generator_heap->type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    // Allow re-use of the frame again.
    Py_DECREF(generator->m_frame);
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if (!EXCEPTION_MATCH_GENERATOR(generator_heap->exception_type)) {
        if (generator_heap->exception_tb == NULL) {
            generator_heap->exception_tb = MAKE_TRACEBACK(generator->m_frame, generator_heap->exception_lineno);
        } else if (generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame) {
            generator_heap->exception_tb = ADD_TRACEBACK(generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno);
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            NULL,
            generator_heap->var_x
        );


        // Release cached frame.
        if (generator->m_frame == cache_m_frame) {
            Py_DECREF(generator->m_frame);
        }
        cache_m_frame = NULL;

        assertFrameObject(generator->m_frame);
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    Py_DECREF(generator->m_frame);

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->var_x);
    generator_heap->var_x = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    Py_XDECREF(generator_heap->var_x);
    generator_heap->var_x = NULL;



    return NULL;

    function_exception_exit:
    assert(generator_heap->exception_type);
    RESTORE_ERROR_OCCURRED(generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb);

    return NULL;

}

static PyObject *cryptography$x509$extensions$$$function_87___init__$$$genexpr_1_genexpr_maker(void) {
    return Nuitka_Generator_New(
        cryptography$x509$extensions$$$function_87___init__$$$genexpr_1_genexpr_context,
        module_cryptography$x509$extensions,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_4a882b53e0e829bff518a8c7aacc9ae2,
        1,
        sizeof(struct cryptography$x509$extensions$$$function_87___init__$$$genexpr_1_genexpr_locals)
    );
}


static PyObject *impl_cryptography$x509$extensions$$$function_88___repr__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_c8ca74f375a5b66d21788a9c199bc810;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_c8ca74f375a5b66d21788a9c199bc810 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_c8ca74f375a5b66d21788a9c199bc810, codeobj_c8ca74f375a5b66d21788a9c199bc810, module_cryptography$x509$extensions, sizeof(void *));
    frame_c8ca74f375a5b66d21788a9c199bc810 = cache_frame_c8ca74f375a5b66d21788a9c199bc810;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_c8ca74f375a5b66d21788a9c199bc810);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_c8ca74f375a5b66d21788a9c199bc810) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        tmp_called_instance_1 = const_str_digest_9cc2c8377ce78bc1b198ac0906717d7f;
        CHECK_OBJECT(par_self);
        tmp_args_element_name_1 = par_self;
        frame_c8ca74f375a5b66d21788a9c199bc810->m_frame.f_lineno = 719;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_format, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 719;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c8ca74f375a5b66d21788a9c199bc810);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_c8ca74f375a5b66d21788a9c199bc810);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c8ca74f375a5b66d21788a9c199bc810);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_c8ca74f375a5b66d21788a9c199bc810, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_c8ca74f375a5b66d21788a9c199bc810->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_c8ca74f375a5b66d21788a9c199bc810, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c8ca74f375a5b66d21788a9c199bc810,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_c8ca74f375a5b66d21788a9c199bc810 == cache_frame_c8ca74f375a5b66d21788a9c199bc810) {
        Py_DECREF(frame_c8ca74f375a5b66d21788a9c199bc810);
    }
    cache_frame_c8ca74f375a5b66d21788a9c199bc810 = NULL;

    assertFrameObject(frame_c8ca74f375a5b66d21788a9c199bc810);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_88___repr__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_89___eq__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_d85838fa42326f320c88255032c5fca7;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_d85838fa42326f320c88255032c5fca7 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_d85838fa42326f320c88255032c5fca7, codeobj_d85838fa42326f320c88255032c5fca7, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_d85838fa42326f320c88255032c5fca7 = cache_frame_d85838fa42326f320c88255032c5fca7;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_d85838fa42326f320c88255032c5fca7);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_d85838fa42326f320c88255032c5fca7) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_other);
        tmp_isinstance_inst_1 = par_other;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_PolicyInformation);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_PolicyInformation);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 36860 ], 46, 0);
            exception_tb = NULL;

            exception_lineno = 724;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 724;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 724;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        int tmp_and_left_truth_1;
        PyObject *tmp_and_left_value_1;
        PyObject *tmp_and_right_value_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_source_name_4;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_policy_identifier);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 728;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_2 = par_other;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_policy_identifier);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_1);

            exception_lineno = 728;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_and_left_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 728;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_truth_1 = CHECK_IF_TRUE(tmp_and_left_value_1);
        if (tmp_and_left_truth_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_and_left_value_1);

            exception_lineno = 729;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        if (tmp_and_left_truth_1 == 1) {
            goto and_right_1;
        } else {
            goto and_left_1;
        }
        and_right_1:;
        Py_DECREF(tmp_and_left_value_1);
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_policy_qualifiers);
        if (tmp_compexpr_left_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 729;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_4 = par_other;
        tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_policy_qualifiers);
        if (tmp_compexpr_right_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_2);

            exception_lineno = 729;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
        Py_DECREF(tmp_compexpr_left_2);
        Py_DECREF(tmp_compexpr_right_2);
        if (tmp_and_right_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 729;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_return_value = tmp_and_left_value_1;
        and_end_1:;
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_d85838fa42326f320c88255032c5fca7);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_d85838fa42326f320c88255032c5fca7);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_d85838fa42326f320c88255032c5fca7);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_d85838fa42326f320c88255032c5fca7, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_d85838fa42326f320c88255032c5fca7->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_d85838fa42326f320c88255032c5fca7, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d85838fa42326f320c88255032c5fca7,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_d85838fa42326f320c88255032c5fca7 == cache_frame_d85838fa42326f320c88255032c5fca7) {
        Py_DECREF(frame_d85838fa42326f320c88255032c5fca7);
    }
    cache_frame_d85838fa42326f320c88255032c5fca7 = NULL;

    assertFrameObject(frame_d85838fa42326f320c88255032c5fca7);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_89___eq__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_90___ne__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_f02229ffaecf12b0bda4fcfc8980ff2f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_f02229ffaecf12b0bda4fcfc8980ff2f = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_f02229ffaecf12b0bda4fcfc8980ff2f, codeobj_f02229ffaecf12b0bda4fcfc8980ff2f, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_f02229ffaecf12b0bda4fcfc8980ff2f = cache_frame_f02229ffaecf12b0bda4fcfc8980ff2f;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_f02229ffaecf12b0bda4fcfc8980ff2f);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_f02229ffaecf12b0bda4fcfc8980ff2f) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_self);
        tmp_compexpr_left_1 = par_self;
        CHECK_OBJECT(par_other);
        tmp_compexpr_right_1 = par_other;
        tmp_operand_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 733;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 733;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = (tmp_res == 0) ? Py_True : Py_False;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_f02229ffaecf12b0bda4fcfc8980ff2f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_f02229ffaecf12b0bda4fcfc8980ff2f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_f02229ffaecf12b0bda4fcfc8980ff2f);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_f02229ffaecf12b0bda4fcfc8980ff2f, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_f02229ffaecf12b0bda4fcfc8980ff2f->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_f02229ffaecf12b0bda4fcfc8980ff2f, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f02229ffaecf12b0bda4fcfc8980ff2f,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_f02229ffaecf12b0bda4fcfc8980ff2f == cache_frame_f02229ffaecf12b0bda4fcfc8980ff2f) {
        Py_DECREF(frame_f02229ffaecf12b0bda4fcfc8980ff2f);
    }
    cache_frame_f02229ffaecf12b0bda4fcfc8980ff2f = NULL;

    assertFrameObject(frame_f02229ffaecf12b0bda4fcfc8980ff2f);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_90___ne__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_91___hash__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_pq = NULL;
    struct Nuitka_FrameObject *frame_0243f386a7ef791aa70475a164a2b63a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_0243f386a7ef791aa70475a164a2b63a = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_0243f386a7ef791aa70475a164a2b63a, codeobj_0243f386a7ef791aa70475a164a2b63a, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_0243f386a7ef791aa70475a164a2b63a = cache_frame_0243f386a7ef791aa70475a164a2b63a;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_0243f386a7ef791aa70475a164a2b63a);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_0243f386a7ef791aa70475a164a2b63a) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_policy_qualifiers);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 736;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 != tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_compexpr_left_1);
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_tuple_arg_1;
            PyObject *tmp_source_name_2;
            CHECK_OBJECT(par_self);
            tmp_source_name_2 = par_self;
            tmp_tuple_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_policy_qualifiers);
            if (tmp_tuple_arg_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 737;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_assign_source_1 = PySequence_Tuple(tmp_tuple_arg_1);
            Py_DECREF(tmp_tuple_arg_1);
            if (tmp_assign_source_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 737;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            assert(var_pq == NULL);
            var_pq = tmp_assign_source_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_2;
            tmp_assign_source_2 = Py_None;
            assert(var_pq == NULL);
            Py_INCREF(tmp_assign_source_2);
            var_pq = tmp_assign_source_2;
        }
        branch_end_1:;
    }
    {
        PyObject *tmp_hash_arg_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_3;
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_policy_identifier);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 741;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_hash_arg_1 = PyTuple_New(2);
        PyTuple_SET_ITEM(tmp_hash_arg_1, 0, tmp_tuple_element_1);
        CHECK_OBJECT(var_pq);
        tmp_tuple_element_1 = var_pq;
        Py_INCREF(tmp_tuple_element_1);
        PyTuple_SET_ITEM(tmp_hash_arg_1, 1, tmp_tuple_element_1);
        tmp_return_value = BUILTIN_HASH(tmp_hash_arg_1);
        Py_DECREF(tmp_hash_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 741;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0243f386a7ef791aa70475a164a2b63a);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_0243f386a7ef791aa70475a164a2b63a);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0243f386a7ef791aa70475a164a2b63a);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_0243f386a7ef791aa70475a164a2b63a, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_0243f386a7ef791aa70475a164a2b63a->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_0243f386a7ef791aa70475a164a2b63a, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0243f386a7ef791aa70475a164a2b63a,
        type_description_1,
        par_self,
        var_pq
    );


    // Release cached frame.
    if (frame_0243f386a7ef791aa70475a164a2b63a == cache_frame_0243f386a7ef791aa70475a164a2b63a) {
        Py_DECREF(frame_0243f386a7ef791aa70475a164a2b63a);
    }
    cache_frame_0243f386a7ef791aa70475a164a2b63a = NULL;

    assertFrameObject(frame_0243f386a7ef791aa70475a164a2b63a);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_91___hash__);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_pq);
    Py_DECREF(var_pq);
    var_pq = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_pq);
    var_pq = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_91___hash__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_92___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_notice_reference = python_pars[1];
    PyObject *par_explicit_text = python_pars[2];
    struct Nuitka_FrameObject *frame_bea296a7219ecd602eca25edc4652bad;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_bea296a7219ecd602eca25edc4652bad = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_bea296a7219ecd602eca25edc4652bad, codeobj_bea296a7219ecd602eca25edc4652bad, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_bea296a7219ecd602eca25edc4652bad = cache_frame_bea296a7219ecd602eca25edc4652bad;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_bea296a7219ecd602eca25edc4652bad);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_bea296a7219ecd602eca25edc4652bad) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_and_left_truth_1;
        nuitka_bool tmp_and_left_value_1;
        nuitka_bool tmp_and_right_value_1;
        int tmp_truth_name_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_notice_reference);
        tmp_truth_name_1 = CHECK_IF_TRUE(par_notice_reference);
        if (tmp_truth_name_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 749;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if (tmp_and_left_truth_1 == 1) {
            goto and_right_1;
        } else {
            goto and_left_1;
        }
        and_right_1:;
        CHECK_OBJECT(par_notice_reference);
        tmp_isinstance_inst_1 = par_notice_reference;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_NoticeReference);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_NoticeReference);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 36993 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 750;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 749;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 749;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_condition_result_1 = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_condition_result_1 = tmp_and_left_value_1;
        and_end_1:;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_7689dc38f9edab5e0154168296ac4aa7;
            frame_bea296a7219ecd602eca25edc4652bad->m_frame.f_lineno = 752;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 752;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_notice_reference);
        tmp_assattr_name_1 = par_notice_reference;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__notice_reference, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 756;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT(par_explicit_text);
        tmp_assattr_name_2 = par_explicit_text;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain__explicit_text, tmp_assattr_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 757;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_bea296a7219ecd602eca25edc4652bad);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_bea296a7219ecd602eca25edc4652bad);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_bea296a7219ecd602eca25edc4652bad, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_bea296a7219ecd602eca25edc4652bad->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_bea296a7219ecd602eca25edc4652bad, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_bea296a7219ecd602eca25edc4652bad,
        type_description_1,
        par_self,
        par_notice_reference,
        par_explicit_text
    );


    // Release cached frame.
    if (frame_bea296a7219ecd602eca25edc4652bad == cache_frame_bea296a7219ecd602eca25edc4652bad) {
        Py_DECREF(frame_bea296a7219ecd602eca25edc4652bad);
    }
    cache_frame_bea296a7219ecd602eca25edc4652bad = NULL;

    assertFrameObject(frame_bea296a7219ecd602eca25edc4652bad);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_92___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_explicit_text);
    Py_DECREF(par_explicit_text);
    CHECK_OBJECT(par_notice_reference);
    Py_DECREF(par_notice_reference);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_explicit_text);
    Py_DECREF(par_explicit_text);
    CHECK_OBJECT(par_notice_reference);
    Py_DECREF(par_notice_reference);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_93___repr__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_275913114fb9b83a1dbb762593bb7bc5;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_275913114fb9b83a1dbb762593bb7bc5 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_275913114fb9b83a1dbb762593bb7bc5, codeobj_275913114fb9b83a1dbb762593bb7bc5, module_cryptography$x509$extensions, sizeof(void *));
    frame_275913114fb9b83a1dbb762593bb7bc5 = cache_frame_275913114fb9b83a1dbb762593bb7bc5;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_275913114fb9b83a1dbb762593bb7bc5);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_275913114fb9b83a1dbb762593bb7bc5) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        tmp_called_instance_1 = const_str_digest_76d9dc3b971abafb272069e298f2eb0c;
        CHECK_OBJECT(par_self);
        tmp_args_element_name_1 = par_self;
        frame_275913114fb9b83a1dbb762593bb7bc5->m_frame.f_lineno = 761;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_format, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 761;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_275913114fb9b83a1dbb762593bb7bc5);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_275913114fb9b83a1dbb762593bb7bc5);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_275913114fb9b83a1dbb762593bb7bc5);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_275913114fb9b83a1dbb762593bb7bc5, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_275913114fb9b83a1dbb762593bb7bc5->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_275913114fb9b83a1dbb762593bb7bc5, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_275913114fb9b83a1dbb762593bb7bc5,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_275913114fb9b83a1dbb762593bb7bc5 == cache_frame_275913114fb9b83a1dbb762593bb7bc5) {
        Py_DECREF(frame_275913114fb9b83a1dbb762593bb7bc5);
    }
    cache_frame_275913114fb9b83a1dbb762593bb7bc5 = NULL;

    assertFrameObject(frame_275913114fb9b83a1dbb762593bb7bc5);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_93___repr__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_94___eq__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_2321762013dc0ff29c834d130737aec5;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_2321762013dc0ff29c834d130737aec5 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_2321762013dc0ff29c834d130737aec5, codeobj_2321762013dc0ff29c834d130737aec5, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_2321762013dc0ff29c834d130737aec5 = cache_frame_2321762013dc0ff29c834d130737aec5;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_2321762013dc0ff29c834d130737aec5);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_2321762013dc0ff29c834d130737aec5) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_other);
        tmp_isinstance_inst_1 = par_other;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_UserNotice);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_UserNotice);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 36954 ], 39, 0);
            exception_tb = NULL;

            exception_lineno = 766;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 766;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 766;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        int tmp_and_left_truth_1;
        PyObject *tmp_and_left_value_1;
        PyObject *tmp_and_right_value_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_source_name_4;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_notice_reference);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 770;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_2 = par_other;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_notice_reference);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_1);

            exception_lineno = 770;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_and_left_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 770;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_truth_1 = CHECK_IF_TRUE(tmp_and_left_value_1);
        if (tmp_and_left_truth_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_and_left_value_1);

            exception_lineno = 771;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        if (tmp_and_left_truth_1 == 1) {
            goto and_right_1;
        } else {
            goto and_left_1;
        }
        and_right_1:;
        Py_DECREF(tmp_and_left_value_1);
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_explicit_text);
        if (tmp_compexpr_left_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 771;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_4 = par_other;
        tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_explicit_text);
        if (tmp_compexpr_right_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_2);

            exception_lineno = 771;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
        Py_DECREF(tmp_compexpr_left_2);
        Py_DECREF(tmp_compexpr_right_2);
        if (tmp_and_right_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 771;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_return_value = tmp_and_left_value_1;
        and_end_1:;
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2321762013dc0ff29c834d130737aec5);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_2321762013dc0ff29c834d130737aec5);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2321762013dc0ff29c834d130737aec5);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_2321762013dc0ff29c834d130737aec5, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_2321762013dc0ff29c834d130737aec5->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_2321762013dc0ff29c834d130737aec5, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2321762013dc0ff29c834d130737aec5,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_2321762013dc0ff29c834d130737aec5 == cache_frame_2321762013dc0ff29c834d130737aec5) {
        Py_DECREF(frame_2321762013dc0ff29c834d130737aec5);
    }
    cache_frame_2321762013dc0ff29c834d130737aec5 = NULL;

    assertFrameObject(frame_2321762013dc0ff29c834d130737aec5);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_94___eq__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_95___ne__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_2572b3a6c05f0075fc8737e5fda0c78b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_2572b3a6c05f0075fc8737e5fda0c78b = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_2572b3a6c05f0075fc8737e5fda0c78b, codeobj_2572b3a6c05f0075fc8737e5fda0c78b, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_2572b3a6c05f0075fc8737e5fda0c78b = cache_frame_2572b3a6c05f0075fc8737e5fda0c78b;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_2572b3a6c05f0075fc8737e5fda0c78b);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_2572b3a6c05f0075fc8737e5fda0c78b) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_self);
        tmp_compexpr_left_1 = par_self;
        CHECK_OBJECT(par_other);
        tmp_compexpr_right_1 = par_other;
        tmp_operand_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 775;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 775;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = (tmp_res == 0) ? Py_True : Py_False;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2572b3a6c05f0075fc8737e5fda0c78b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_2572b3a6c05f0075fc8737e5fda0c78b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2572b3a6c05f0075fc8737e5fda0c78b);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_2572b3a6c05f0075fc8737e5fda0c78b, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_2572b3a6c05f0075fc8737e5fda0c78b->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_2572b3a6c05f0075fc8737e5fda0c78b, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2572b3a6c05f0075fc8737e5fda0c78b,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_2572b3a6c05f0075fc8737e5fda0c78b == cache_frame_2572b3a6c05f0075fc8737e5fda0c78b) {
        Py_DECREF(frame_2572b3a6c05f0075fc8737e5fda0c78b);
    }
    cache_frame_2572b3a6c05f0075fc8737e5fda0c78b = NULL;

    assertFrameObject(frame_2572b3a6c05f0075fc8737e5fda0c78b);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_95___ne__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_96___hash__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_9a7626d648d17d2d5ed8388969ae0bd5;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_9a7626d648d17d2d5ed8388969ae0bd5 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_9a7626d648d17d2d5ed8388969ae0bd5, codeobj_9a7626d648d17d2d5ed8388969ae0bd5, module_cryptography$x509$extensions, sizeof(void *));
    frame_9a7626d648d17d2d5ed8388969ae0bd5 = cache_frame_9a7626d648d17d2d5ed8388969ae0bd5;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_9a7626d648d17d2d5ed8388969ae0bd5);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_9a7626d648d17d2d5ed8388969ae0bd5) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_hash_arg_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_notice_reference);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 778;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_hash_arg_1 = PyTuple_New(2);
        PyTuple_SET_ITEM(tmp_hash_arg_1, 0, tmp_tuple_element_1);
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_explicit_text);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_hash_arg_1);

            exception_lineno = 778;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM(tmp_hash_arg_1, 1, tmp_tuple_element_1);
        tmp_return_value = BUILTIN_HASH(tmp_hash_arg_1);
        Py_DECREF(tmp_hash_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 778;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9a7626d648d17d2d5ed8388969ae0bd5);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_9a7626d648d17d2d5ed8388969ae0bd5);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9a7626d648d17d2d5ed8388969ae0bd5);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_9a7626d648d17d2d5ed8388969ae0bd5, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_9a7626d648d17d2d5ed8388969ae0bd5->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_9a7626d648d17d2d5ed8388969ae0bd5, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9a7626d648d17d2d5ed8388969ae0bd5,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_9a7626d648d17d2d5ed8388969ae0bd5 == cache_frame_9a7626d648d17d2d5ed8388969ae0bd5) {
        Py_DECREF(frame_9a7626d648d17d2d5ed8388969ae0bd5);
    }
    cache_frame_9a7626d648d17d2d5ed8388969ae0bd5 = NULL;

    assertFrameObject(frame_9a7626d648d17d2d5ed8388969ae0bd5);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_96___hash__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_97___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_organization = python_pars[1];
    PyObject *par_notice_numbers = python_pars[2];
    PyObject *tmp_genexpr_1__$0 = NULL;
    struct Nuitka_FrameObject *frame_fcf5dbe695d0fd2e4622c11a67638dce;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_fcf5dbe695d0fd2e4622c11a67638dce = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_fcf5dbe695d0fd2e4622c11a67638dce, codeobj_fcf5dbe695d0fd2e4622c11a67638dce, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_fcf5dbe695d0fd2e4622c11a67638dce = cache_frame_fcf5dbe695d0fd2e4622c11a67638dce;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_fcf5dbe695d0fd2e4622c11a67638dce);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_fcf5dbe695d0fd2e4622c11a67638dce) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_organization);
        tmp_assattr_name_1 = par_organization;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__organization, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 786;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_list_arg_1;
        CHECK_OBJECT(par_notice_numbers);
        tmp_list_arg_1 = par_notice_numbers;
        tmp_assign_source_1 = PySequence_List(tmp_list_arg_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 787;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = par_notice_numbers;
            assert(old != NULL);
            par_notice_numbers = tmp_assign_source_1;
            Py_DECREF(old);
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_all_arg_1;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT(par_notice_numbers);
            tmp_iter_arg_1 = par_notice_numbers;
            tmp_assign_source_2 = MAKE_ITERATOR(tmp_iter_arg_1);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 788;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            assert(tmp_genexpr_1__$0 == NULL);
            tmp_genexpr_1__$0 = tmp_assign_source_2;
        }
        // Tried code:
        tmp_all_arg_1 = cryptography$x509$extensions$$$function_97___init__$$$genexpr_1_genexpr_maker();

        ((struct Nuitka_GeneratorObject *)tmp_all_arg_1)->m_closure[0] = PyCell_NEW0(tmp_genexpr_1__$0);


        goto try_return_handler_2;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_97___init__);
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        CHECK_OBJECT((PyObject *)tmp_genexpr_1__$0);
        Py_DECREF(tmp_genexpr_1__$0);
        tmp_genexpr_1__$0 = NULL;

        goto outline_result_1;
        // End of try:
        CHECK_OBJECT((PyObject *)tmp_genexpr_1__$0);
        Py_DECREF(tmp_genexpr_1__$0);
        tmp_genexpr_1__$0 = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_97___init__);
        return NULL;
        outline_result_1:;
        tmp_operand_name_1 = BUILTIN_ALL(tmp_all_arg_1);
        Py_DECREF(tmp_all_arg_1);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 788;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 788;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_d2a030963ea7fa46a452128daffceb24;
            frame_fcf5dbe695d0fd2e4622c11a67638dce->m_frame.f_lineno = 789;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 789;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT(par_notice_numbers);
        tmp_assattr_name_2 = par_notice_numbers;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain__notice_numbers, tmp_assattr_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 793;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_fcf5dbe695d0fd2e4622c11a67638dce);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_fcf5dbe695d0fd2e4622c11a67638dce);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_fcf5dbe695d0fd2e4622c11a67638dce, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_fcf5dbe695d0fd2e4622c11a67638dce->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_fcf5dbe695d0fd2e4622c11a67638dce, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_fcf5dbe695d0fd2e4622c11a67638dce,
        type_description_1,
        par_self,
        par_organization,
        par_notice_numbers
    );


    // Release cached frame.
    if (frame_fcf5dbe695d0fd2e4622c11a67638dce == cache_frame_fcf5dbe695d0fd2e4622c11a67638dce) {
        Py_DECREF(frame_fcf5dbe695d0fd2e4622c11a67638dce);
    }
    cache_frame_fcf5dbe695d0fd2e4622c11a67638dce = NULL;

    assertFrameObject(frame_fcf5dbe695d0fd2e4622c11a67638dce);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_97___init__);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)par_notice_numbers);
    Py_DECREF(par_notice_numbers);
    par_notice_numbers = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)par_notice_numbers);
    Py_DECREF(par_notice_numbers);
    par_notice_numbers = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_97___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_organization);
    Py_DECREF(par_organization);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_organization);
    Py_DECREF(par_organization);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}



struct cryptography$x509$extensions$$$function_97___init__$$$genexpr_1_genexpr_locals {
    PyObject *var_x;
    PyObject *tmp_iter_value_0;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    int tmp_res;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *cryptography$x509$extensions$$$function_97___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value ) {
    CHECK_OBJECT((PyObject *)generator);
    assert(Nuitka_Generator_Check( (PyObject *)generator ));

    // Heap access if used.
    struct cryptography$x509$extensions$$$function_97___init__$$$genexpr_1_genexpr_locals *generator_heap = (struct cryptography$x509$extensions$$$function_97___init__$$$genexpr_1_genexpr_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_x = NULL;
    generator_heap->tmp_iter_value_0 = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_m_frame, codeobj_85e574a0ea828b1296944aef7e1a45bc, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF(generator->m_frame);
    assert(Py_REFCNT(generator->m_frame) == 2); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR(generator->m_frame->m_frame.f_back);

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF(generator->m_frame->m_frame.f_back);

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF(generator->m_frame);

    Nuitka_Frame_MarkAsExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

        EXC_TYPE_F(generator) = EXC_TYPE(thread_state);
        if (EXC_TYPE_F(generator) == Py_None) EXC_TYPE_F(generator) = NULL;
        Py_XINCREF(EXC_TYPE_F(generator));
        EXC_VALUE_F(generator) = EXC_VALUE(thread_state);
        Py_XINCREF(EXC_VALUE_F(generator));
        EXC_TRACEBACK_F(generator) = EXC_TRACEBACK(thread_state);
        Py_XINCREF(EXC_TRACEBACK_F(generator));
    }

#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_1;
        CHECK_OBJECT(PyCell_GET(generator->m_closure[0]));
        tmp_next_source_1 = PyCell_GET(generator->m_closure[0]);
        tmp_assign_source_1 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_1 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);
                generator_heap->type_description_1 = "No";
                generator_heap->exception_lineno = 788;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_iter_value_0;
            generator_heap->tmp_iter_value_0 = tmp_assign_source_1;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT(generator_heap->tmp_iter_value_0);
        tmp_assign_source_2 = generator_heap->tmp_iter_value_0;
        {
            PyObject *old = generator_heap->var_x;
            generator_heap->var_x = tmp_assign_source_2;
            Py_INCREF(generator_heap->var_x);
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_expression_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        CHECK_OBJECT(generator_heap->var_x);
        tmp_isinstance_inst_1 = generator_heap->var_x;
        tmp_isinstance_cls_1 = (PyObject *)&PyInt_Type;
        generator_heap->tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (generator_heap->tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 788;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_expression_name_1 = (generator_heap->tmp_res != 0) ? Py_True : Py_False;
        Py_INCREF(tmp_expression_name_1);
        Nuitka_PreserveHeap(generator_heap->yield_tmps, &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), NULL);
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        Nuitka_RestoreHeap(generator_heap->yield_tmps, &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), NULL);
        if (yield_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 788;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


        generator_heap->exception_lineno = 788;
        generator_heap->type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    // Allow re-use of the frame again.
    Py_DECREF(generator->m_frame);
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if (!EXCEPTION_MATCH_GENERATOR(generator_heap->exception_type)) {
        if (generator_heap->exception_tb == NULL) {
            generator_heap->exception_tb = MAKE_TRACEBACK(generator->m_frame, generator_heap->exception_lineno);
        } else if (generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame) {
            generator_heap->exception_tb = ADD_TRACEBACK(generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno);
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            NULL,
            generator_heap->var_x
        );


        // Release cached frame.
        if (generator->m_frame == cache_m_frame) {
            Py_DECREF(generator->m_frame);
        }
        cache_m_frame = NULL;

        assertFrameObject(generator->m_frame);
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    Py_DECREF(generator->m_frame);

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->var_x);
    generator_heap->var_x = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    Py_XDECREF(generator_heap->var_x);
    generator_heap->var_x = NULL;



    return NULL;

    function_exception_exit:
    assert(generator_heap->exception_type);
    RESTORE_ERROR_OCCURRED(generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb);

    return NULL;

}

static PyObject *cryptography$x509$extensions$$$function_97___init__$$$genexpr_1_genexpr_maker(void) {
    return Nuitka_Generator_New(
        cryptography$x509$extensions$$$function_97___init__$$$genexpr_1_genexpr_context,
        module_cryptography$x509$extensions,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_85e574a0ea828b1296944aef7e1a45bc,
        1,
        sizeof(struct cryptography$x509$extensions$$$function_97___init__$$$genexpr_1_genexpr_locals)
    );
}


static PyObject *impl_cryptography$x509$extensions$$$function_98___repr__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_55a2c931a1b128be07012db2099f9f07;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_55a2c931a1b128be07012db2099f9f07 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_55a2c931a1b128be07012db2099f9f07, codeobj_55a2c931a1b128be07012db2099f9f07, module_cryptography$x509$extensions, sizeof(void *));
    frame_55a2c931a1b128be07012db2099f9f07 = cache_frame_55a2c931a1b128be07012db2099f9f07;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_55a2c931a1b128be07012db2099f9f07);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_55a2c931a1b128be07012db2099f9f07) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        tmp_called_instance_1 = const_str_digest_114372ae17a491041cc1a4b677269f5b;
        CHECK_OBJECT(par_self);
        tmp_args_element_name_1 = par_self;
        frame_55a2c931a1b128be07012db2099f9f07->m_frame.f_lineno = 797;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_format, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 797;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_55a2c931a1b128be07012db2099f9f07);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_55a2c931a1b128be07012db2099f9f07);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_55a2c931a1b128be07012db2099f9f07);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_55a2c931a1b128be07012db2099f9f07, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_55a2c931a1b128be07012db2099f9f07->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_55a2c931a1b128be07012db2099f9f07, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_55a2c931a1b128be07012db2099f9f07,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_55a2c931a1b128be07012db2099f9f07 == cache_frame_55a2c931a1b128be07012db2099f9f07) {
        Py_DECREF(frame_55a2c931a1b128be07012db2099f9f07);
    }
    cache_frame_55a2c931a1b128be07012db2099f9f07 = NULL;

    assertFrameObject(frame_55a2c931a1b128be07012db2099f9f07);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_98___repr__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_99___eq__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_a4f75b426139664f5a0ed587effcf9e3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_a4f75b426139664f5a0ed587effcf9e3 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_a4f75b426139664f5a0ed587effcf9e3, codeobj_a4f75b426139664f5a0ed587effcf9e3, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_a4f75b426139664f5a0ed587effcf9e3 = cache_frame_a4f75b426139664f5a0ed587effcf9e3;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_a4f75b426139664f5a0ed587effcf9e3);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_a4f75b426139664f5a0ed587effcf9e3) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_other);
        tmp_isinstance_inst_1 = par_other;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_NoticeReference);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_NoticeReference);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 36993 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 802;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 802;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 802;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        int tmp_and_left_truth_1;
        PyObject *tmp_and_left_value_1;
        PyObject *tmp_and_right_value_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_source_name_4;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_organization);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 806;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_2 = par_other;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_organization);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_1);

            exception_lineno = 806;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_and_left_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 806;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_truth_1 = CHECK_IF_TRUE(tmp_and_left_value_1);
        if (tmp_and_left_truth_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_and_left_value_1);

            exception_lineno = 807;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        if (tmp_and_left_truth_1 == 1) {
            goto and_right_1;
        } else {
            goto and_left_1;
        }
        and_right_1:;
        Py_DECREF(tmp_and_left_value_1);
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_notice_numbers);
        if (tmp_compexpr_left_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 807;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_4 = par_other;
        tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_notice_numbers);
        if (tmp_compexpr_right_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_2);

            exception_lineno = 807;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
        Py_DECREF(tmp_compexpr_left_2);
        Py_DECREF(tmp_compexpr_right_2);
        if (tmp_and_right_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 807;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_return_value = tmp_and_left_value_1;
        and_end_1:;
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a4f75b426139664f5a0ed587effcf9e3);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_a4f75b426139664f5a0ed587effcf9e3);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a4f75b426139664f5a0ed587effcf9e3);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_a4f75b426139664f5a0ed587effcf9e3, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_a4f75b426139664f5a0ed587effcf9e3->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_a4f75b426139664f5a0ed587effcf9e3, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a4f75b426139664f5a0ed587effcf9e3,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_a4f75b426139664f5a0ed587effcf9e3 == cache_frame_a4f75b426139664f5a0ed587effcf9e3) {
        Py_DECREF(frame_a4f75b426139664f5a0ed587effcf9e3);
    }
    cache_frame_a4f75b426139664f5a0ed587effcf9e3 = NULL;

    assertFrameObject(frame_a4f75b426139664f5a0ed587effcf9e3);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_99___eq__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_100___ne__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_2374d85031de4b81a17b991b72074603;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_2374d85031de4b81a17b991b72074603 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_2374d85031de4b81a17b991b72074603, codeobj_2374d85031de4b81a17b991b72074603, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_2374d85031de4b81a17b991b72074603 = cache_frame_2374d85031de4b81a17b991b72074603;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_2374d85031de4b81a17b991b72074603);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_2374d85031de4b81a17b991b72074603) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_self);
        tmp_compexpr_left_1 = par_self;
        CHECK_OBJECT(par_other);
        tmp_compexpr_right_1 = par_other;
        tmp_operand_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 811;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 811;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = (tmp_res == 0) ? Py_True : Py_False;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2374d85031de4b81a17b991b72074603);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_2374d85031de4b81a17b991b72074603);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2374d85031de4b81a17b991b72074603);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_2374d85031de4b81a17b991b72074603, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_2374d85031de4b81a17b991b72074603->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_2374d85031de4b81a17b991b72074603, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2374d85031de4b81a17b991b72074603,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_2374d85031de4b81a17b991b72074603 == cache_frame_2374d85031de4b81a17b991b72074603) {
        Py_DECREF(frame_2374d85031de4b81a17b991b72074603);
    }
    cache_frame_2374d85031de4b81a17b991b72074603 = NULL;

    assertFrameObject(frame_2374d85031de4b81a17b991b72074603);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_100___ne__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_101___hash__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_0c619b809dcf09b4a39bf5bdd60015b5;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_0c619b809dcf09b4a39bf5bdd60015b5 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_0c619b809dcf09b4a39bf5bdd60015b5, codeobj_0c619b809dcf09b4a39bf5bdd60015b5, module_cryptography$x509$extensions, sizeof(void *));
    frame_0c619b809dcf09b4a39bf5bdd60015b5 = cache_frame_0c619b809dcf09b4a39bf5bdd60015b5;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_0c619b809dcf09b4a39bf5bdd60015b5);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_0c619b809dcf09b4a39bf5bdd60015b5) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_hash_arg_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_tuple_arg_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_organization);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 814;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_hash_arg_1 = PyTuple_New(2);
        PyTuple_SET_ITEM(tmp_hash_arg_1, 0, tmp_tuple_element_1);
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_tuple_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_notice_numbers);
        if (tmp_tuple_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_hash_arg_1);

            exception_lineno = 814;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_tuple_element_1 = PySequence_Tuple(tmp_tuple_arg_1);
        Py_DECREF(tmp_tuple_arg_1);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_hash_arg_1);

            exception_lineno = 814;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM(tmp_hash_arg_1, 1, tmp_tuple_element_1);
        tmp_return_value = BUILTIN_HASH(tmp_hash_arg_1);
        Py_DECREF(tmp_hash_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 814;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0c619b809dcf09b4a39bf5bdd60015b5);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_0c619b809dcf09b4a39bf5bdd60015b5);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0c619b809dcf09b4a39bf5bdd60015b5);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_0c619b809dcf09b4a39bf5bdd60015b5, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_0c619b809dcf09b4a39bf5bdd60015b5->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_0c619b809dcf09b4a39bf5bdd60015b5, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0c619b809dcf09b4a39bf5bdd60015b5,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_0c619b809dcf09b4a39bf5bdd60015b5 == cache_frame_0c619b809dcf09b4a39bf5bdd60015b5) {
        Py_DECREF(frame_0c619b809dcf09b4a39bf5bdd60015b5);
    }
    cache_frame_0c619b809dcf09b4a39bf5bdd60015b5 = NULL;

    assertFrameObject(frame_0c619b809dcf09b4a39bf5bdd60015b5);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_101___hash__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_102___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_usages = python_pars[1];
    PyObject *tmp_genexpr_1__$0 = NULL;
    struct Nuitka_FrameObject *frame_f3ae497e09b3bd3a162b69cd7a04cd91;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_f3ae497e09b3bd3a162b69cd7a04cd91 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_f3ae497e09b3bd3a162b69cd7a04cd91, codeobj_f3ae497e09b3bd3a162b69cd7a04cd91, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_f3ae497e09b3bd3a162b69cd7a04cd91 = cache_frame_f3ae497e09b3bd3a162b69cd7a04cd91;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_f3ae497e09b3bd3a162b69cd7a04cd91);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_f3ae497e09b3bd3a162b69cd7a04cd91) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_list_arg_1;
        CHECK_OBJECT(par_usages);
        tmp_list_arg_1 = par_usages;
        tmp_assign_source_1 = PySequence_List(tmp_list_arg_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 825;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = par_usages;
            assert(old != NULL);
            par_usages = tmp_assign_source_1;
            Py_DECREF(old);
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_all_arg_1;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT(par_usages);
            tmp_iter_arg_1 = par_usages;
            tmp_assign_source_2 = MAKE_ITERATOR(tmp_iter_arg_1);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 826;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            assert(tmp_genexpr_1__$0 == NULL);
            tmp_genexpr_1__$0 = tmp_assign_source_2;
        }
        // Tried code:
        tmp_all_arg_1 = cryptography$x509$extensions$$$function_102___init__$$$genexpr_1_genexpr_maker();

        ((struct Nuitka_GeneratorObject *)tmp_all_arg_1)->m_closure[0] = PyCell_NEW0(tmp_genexpr_1__$0);


        goto try_return_handler_2;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_102___init__);
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        CHECK_OBJECT((PyObject *)tmp_genexpr_1__$0);
        Py_DECREF(tmp_genexpr_1__$0);
        tmp_genexpr_1__$0 = NULL;

        goto outline_result_1;
        // End of try:
        CHECK_OBJECT((PyObject *)tmp_genexpr_1__$0);
        Py_DECREF(tmp_genexpr_1__$0);
        tmp_genexpr_1__$0 = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_102___init__);
        return NULL;
        outline_result_1:;
        tmp_operand_name_1 = BUILTIN_ALL(tmp_all_arg_1);
        Py_DECREF(tmp_all_arg_1);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 826;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 826;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_a2ae3825a8b7f0237bc2c108542b8be9;
            frame_f3ae497e09b3bd3a162b69cd7a04cd91->m_frame.f_lineno = 827;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 827;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_usages);
        tmp_assattr_name_1 = par_usages;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__usages, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 831;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_f3ae497e09b3bd3a162b69cd7a04cd91);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_f3ae497e09b3bd3a162b69cd7a04cd91);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_f3ae497e09b3bd3a162b69cd7a04cd91, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_f3ae497e09b3bd3a162b69cd7a04cd91->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_f3ae497e09b3bd3a162b69cd7a04cd91, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f3ae497e09b3bd3a162b69cd7a04cd91,
        type_description_1,
        par_self,
        par_usages
    );


    // Release cached frame.
    if (frame_f3ae497e09b3bd3a162b69cd7a04cd91 == cache_frame_f3ae497e09b3bd3a162b69cd7a04cd91) {
        Py_DECREF(frame_f3ae497e09b3bd3a162b69cd7a04cd91);
    }
    cache_frame_f3ae497e09b3bd3a162b69cd7a04cd91 = NULL;

    assertFrameObject(frame_f3ae497e09b3bd3a162b69cd7a04cd91);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_102___init__);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)par_usages);
    Py_DECREF(par_usages);
    par_usages = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)par_usages);
    Py_DECREF(par_usages);
    par_usages = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_102___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}



struct cryptography$x509$extensions$$$function_102___init__$$$genexpr_1_genexpr_locals {
    PyObject *var_x;
    PyObject *tmp_iter_value_0;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    int tmp_res;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *cryptography$x509$extensions$$$function_102___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value ) {
    CHECK_OBJECT((PyObject *)generator);
    assert(Nuitka_Generator_Check( (PyObject *)generator ));

    // Heap access if used.
    struct cryptography$x509$extensions$$$function_102___init__$$$genexpr_1_genexpr_locals *generator_heap = (struct cryptography$x509$extensions$$$function_102___init__$$$genexpr_1_genexpr_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_x = NULL;
    generator_heap->tmp_iter_value_0 = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_m_frame, codeobj_d4589269dd21e1af6cba113639e39aef, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF(generator->m_frame);
    assert(Py_REFCNT(generator->m_frame) == 2); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR(generator->m_frame->m_frame.f_back);

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF(generator->m_frame->m_frame.f_back);

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF(generator->m_frame);

    Nuitka_Frame_MarkAsExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

        EXC_TYPE_F(generator) = EXC_TYPE(thread_state);
        if (EXC_TYPE_F(generator) == Py_None) EXC_TYPE_F(generator) = NULL;
        Py_XINCREF(EXC_TYPE_F(generator));
        EXC_VALUE_F(generator) = EXC_VALUE(thread_state);
        Py_XINCREF(EXC_VALUE_F(generator));
        EXC_TRACEBACK_F(generator) = EXC_TRACEBACK(thread_state);
        Py_XINCREF(EXC_TRACEBACK_F(generator));
    }

#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_1;
        CHECK_OBJECT(PyCell_GET(generator->m_closure[0]));
        tmp_next_source_1 = PyCell_GET(generator->m_closure[0]);
        tmp_assign_source_1 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_1 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);
                generator_heap->type_description_1 = "No";
                generator_heap->exception_lineno = 826;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_iter_value_0;
            generator_heap->tmp_iter_value_0 = tmp_assign_source_1;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT(generator_heap->tmp_iter_value_0);
        tmp_assign_source_2 = generator_heap->tmp_iter_value_0;
        {
            PyObject *old = generator_heap->var_x;
            generator_heap->var_x = tmp_assign_source_2;
            Py_INCREF(generator_heap->var_x);
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_expression_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        CHECK_OBJECT(generator_heap->var_x);
        tmp_isinstance_inst_1 = generator_heap->var_x;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ObjectIdentifier);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ObjectIdentifier);
        }

        if (tmp_mvar_value_1 == NULL) {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF(generator_heap->exception_type);
            generator_heap->exception_value = UNSTREAM_STRING(&constant_bin[ 18374 ], 45, 0);
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 826;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        generator_heap->tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (generator_heap->tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 826;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_expression_name_1 = (generator_heap->tmp_res != 0) ? Py_True : Py_False;
        Py_INCREF(tmp_expression_name_1);
        Nuitka_PreserveHeap(generator_heap->yield_tmps, &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), NULL);
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        Nuitka_RestoreHeap(generator_heap->yield_tmps, &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), NULL);
        if (yield_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 826;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


        generator_heap->exception_lineno = 826;
        generator_heap->type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    // Allow re-use of the frame again.
    Py_DECREF(generator->m_frame);
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if (!EXCEPTION_MATCH_GENERATOR(generator_heap->exception_type)) {
        if (generator_heap->exception_tb == NULL) {
            generator_heap->exception_tb = MAKE_TRACEBACK(generator->m_frame, generator_heap->exception_lineno);
        } else if (generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame) {
            generator_heap->exception_tb = ADD_TRACEBACK(generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno);
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            NULL,
            generator_heap->var_x
        );


        // Release cached frame.
        if (generator->m_frame == cache_m_frame) {
            Py_DECREF(generator->m_frame);
        }
        cache_m_frame = NULL;

        assertFrameObject(generator->m_frame);
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    Py_DECREF(generator->m_frame);

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->var_x);
    generator_heap->var_x = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    Py_XDECREF(generator_heap->var_x);
    generator_heap->var_x = NULL;



    return NULL;

    function_exception_exit:
    assert(generator_heap->exception_type);
    RESTORE_ERROR_OCCURRED(generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb);

    return NULL;

}

static PyObject *cryptography$x509$extensions$$$function_102___init__$$$genexpr_1_genexpr_maker(void) {
    return Nuitka_Generator_New(
        cryptography$x509$extensions$$$function_102___init__$$$genexpr_1_genexpr_context,
        module_cryptography$x509$extensions,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_d4589269dd21e1af6cba113639e39aef,
        1,
        sizeof(struct cryptography$x509$extensions$$$function_102___init__$$$genexpr_1_genexpr_locals)
    );
}


static PyObject *impl_cryptography$x509$extensions$$$function_103___iter__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_c1b3c10743df6cec00e4bd32ad5436e8;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_c1b3c10743df6cec00e4bd32ad5436e8 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_c1b3c10743df6cec00e4bd32ad5436e8, codeobj_c1b3c10743df6cec00e4bd32ad5436e8, module_cryptography$x509$extensions, sizeof(void *));
    frame_c1b3c10743df6cec00e4bd32ad5436e8 = cache_frame_c1b3c10743df6cec00e4bd32ad5436e8;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_c1b3c10743df6cec00e4bd32ad5436e8);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_c1b3c10743df6cec00e4bd32ad5436e8) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_iter_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__usages);
        if (tmp_iter_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 834;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = MAKE_ITERATOR(tmp_iter_arg_1);
        Py_DECREF(tmp_iter_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 834;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c1b3c10743df6cec00e4bd32ad5436e8);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_c1b3c10743df6cec00e4bd32ad5436e8);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c1b3c10743df6cec00e4bd32ad5436e8);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_c1b3c10743df6cec00e4bd32ad5436e8, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_c1b3c10743df6cec00e4bd32ad5436e8->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_c1b3c10743df6cec00e4bd32ad5436e8, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c1b3c10743df6cec00e4bd32ad5436e8,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_c1b3c10743df6cec00e4bd32ad5436e8 == cache_frame_c1b3c10743df6cec00e4bd32ad5436e8) {
        Py_DECREF(frame_c1b3c10743df6cec00e4bd32ad5436e8);
    }
    cache_frame_c1b3c10743df6cec00e4bd32ad5436e8 = NULL;

    assertFrameObject(frame_c1b3c10743df6cec00e4bd32ad5436e8);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_103___iter__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_104___len__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_b1f676c1cba4b20ff4369028da50b101;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_b1f676c1cba4b20ff4369028da50b101 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_b1f676c1cba4b20ff4369028da50b101, codeobj_b1f676c1cba4b20ff4369028da50b101, module_cryptography$x509$extensions, sizeof(void *));
    frame_b1f676c1cba4b20ff4369028da50b101 = cache_frame_b1f676c1cba4b20ff4369028da50b101;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_b1f676c1cba4b20ff4369028da50b101);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_b1f676c1cba4b20ff4369028da50b101) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_len_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_len_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__usages);
        if (tmp_len_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 837;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = BUILTIN_LEN(tmp_len_arg_1);
        Py_DECREF(tmp_len_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 837;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b1f676c1cba4b20ff4369028da50b101);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_b1f676c1cba4b20ff4369028da50b101);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b1f676c1cba4b20ff4369028da50b101);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_b1f676c1cba4b20ff4369028da50b101, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_b1f676c1cba4b20ff4369028da50b101->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_b1f676c1cba4b20ff4369028da50b101, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b1f676c1cba4b20ff4369028da50b101,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_b1f676c1cba4b20ff4369028da50b101 == cache_frame_b1f676c1cba4b20ff4369028da50b101) {
        Py_DECREF(frame_b1f676c1cba4b20ff4369028da50b101);
    }
    cache_frame_b1f676c1cba4b20ff4369028da50b101 = NULL;

    assertFrameObject(frame_b1f676c1cba4b20ff4369028da50b101);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_104___len__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_105___repr__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_5e3e9860782562fdba9865949f9a1aad;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_5e3e9860782562fdba9865949f9a1aad = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_5e3e9860782562fdba9865949f9a1aad, codeobj_5e3e9860782562fdba9865949f9a1aad, module_cryptography$x509$extensions, sizeof(void *));
    frame_5e3e9860782562fdba9865949f9a1aad = cache_frame_5e3e9860782562fdba9865949f9a1aad;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_5e3e9860782562fdba9865949f9a1aad);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_5e3e9860782562fdba9865949f9a1aad) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_source_name_1 = const_str_digest_548641877ac6c51da15a8285d67846ee;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_format);
        assert(!(tmp_called_name_1 == NULL));
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__usages);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 840;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_5e3e9860782562fdba9865949f9a1aad->m_frame.f_lineno = 840;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 840;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5e3e9860782562fdba9865949f9a1aad);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_5e3e9860782562fdba9865949f9a1aad);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5e3e9860782562fdba9865949f9a1aad);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_5e3e9860782562fdba9865949f9a1aad, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_5e3e9860782562fdba9865949f9a1aad->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_5e3e9860782562fdba9865949f9a1aad, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5e3e9860782562fdba9865949f9a1aad,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_5e3e9860782562fdba9865949f9a1aad == cache_frame_5e3e9860782562fdba9865949f9a1aad) {
        Py_DECREF(frame_5e3e9860782562fdba9865949f9a1aad);
    }
    cache_frame_5e3e9860782562fdba9865949f9a1aad = NULL;

    assertFrameObject(frame_5e3e9860782562fdba9865949f9a1aad);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_105___repr__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_106___eq__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_49ab98a368a06f5b62e3090207811653;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_49ab98a368a06f5b62e3090207811653 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_49ab98a368a06f5b62e3090207811653, codeobj_49ab98a368a06f5b62e3090207811653, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_49ab98a368a06f5b62e3090207811653 = cache_frame_49ab98a368a06f5b62e3090207811653;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_49ab98a368a06f5b62e3090207811653);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_49ab98a368a06f5b62e3090207811653) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_other);
        tmp_isinstance_inst_1 = par_other;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtendedKeyUsage);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtendedKeyUsage);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 37037 ], 45, 0);
            exception_tb = NULL;

            exception_lineno = 843;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 843;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 843;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__usages);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 846;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_2 = par_other;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__usages);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_1);

            exception_lineno = 846;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 846;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_49ab98a368a06f5b62e3090207811653);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_49ab98a368a06f5b62e3090207811653);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_49ab98a368a06f5b62e3090207811653);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_49ab98a368a06f5b62e3090207811653, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_49ab98a368a06f5b62e3090207811653->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_49ab98a368a06f5b62e3090207811653, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_49ab98a368a06f5b62e3090207811653,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_49ab98a368a06f5b62e3090207811653 == cache_frame_49ab98a368a06f5b62e3090207811653) {
        Py_DECREF(frame_49ab98a368a06f5b62e3090207811653);
    }
    cache_frame_49ab98a368a06f5b62e3090207811653 = NULL;

    assertFrameObject(frame_49ab98a368a06f5b62e3090207811653);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_106___eq__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_107___ne__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_14de2d48cc6d86d7990ead778de5ef55;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_14de2d48cc6d86d7990ead778de5ef55 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_14de2d48cc6d86d7990ead778de5ef55, codeobj_14de2d48cc6d86d7990ead778de5ef55, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_14de2d48cc6d86d7990ead778de5ef55 = cache_frame_14de2d48cc6d86d7990ead778de5ef55;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_14de2d48cc6d86d7990ead778de5ef55);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_14de2d48cc6d86d7990ead778de5ef55) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_self);
        tmp_compexpr_left_1 = par_self;
        CHECK_OBJECT(par_other);
        tmp_compexpr_right_1 = par_other;
        tmp_operand_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 849;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 849;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = (tmp_res == 0) ? Py_True : Py_False;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_14de2d48cc6d86d7990ead778de5ef55);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_14de2d48cc6d86d7990ead778de5ef55);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_14de2d48cc6d86d7990ead778de5ef55);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_14de2d48cc6d86d7990ead778de5ef55, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_14de2d48cc6d86d7990ead778de5ef55->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_14de2d48cc6d86d7990ead778de5ef55, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_14de2d48cc6d86d7990ead778de5ef55,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_14de2d48cc6d86d7990ead778de5ef55 == cache_frame_14de2d48cc6d86d7990ead778de5ef55) {
        Py_DECREF(frame_14de2d48cc6d86d7990ead778de5ef55);
    }
    cache_frame_14de2d48cc6d86d7990ead778de5ef55 = NULL;

    assertFrameObject(frame_14de2d48cc6d86d7990ead778de5ef55);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_107___ne__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_108___hash__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_307c2c80549b8830ab1bdc50cebac581;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_307c2c80549b8830ab1bdc50cebac581 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_307c2c80549b8830ab1bdc50cebac581, codeobj_307c2c80549b8830ab1bdc50cebac581, module_cryptography$x509$extensions, sizeof(void *));
    frame_307c2c80549b8830ab1bdc50cebac581 = cache_frame_307c2c80549b8830ab1bdc50cebac581;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_307c2c80549b8830ab1bdc50cebac581);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_307c2c80549b8830ab1bdc50cebac581) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_hash_arg_1;
        PyObject *tmp_tuple_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_tuple_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__usages);
        if (tmp_tuple_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 852;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_hash_arg_1 = PySequence_Tuple(tmp_tuple_arg_1);
        Py_DECREF(tmp_tuple_arg_1);
        if (tmp_hash_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 852;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = BUILTIN_HASH(tmp_hash_arg_1);
        Py_DECREF(tmp_hash_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 852;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_307c2c80549b8830ab1bdc50cebac581);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_307c2c80549b8830ab1bdc50cebac581);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_307c2c80549b8830ab1bdc50cebac581);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_307c2c80549b8830ab1bdc50cebac581, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_307c2c80549b8830ab1bdc50cebac581->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_307c2c80549b8830ab1bdc50cebac581, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_307c2c80549b8830ab1bdc50cebac581,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_307c2c80549b8830ab1bdc50cebac581 == cache_frame_307c2c80549b8830ab1bdc50cebac581) {
        Py_DECREF(frame_307c2c80549b8830ab1bdc50cebac581);
    }
    cache_frame_307c2c80549b8830ab1bdc50cebac581 = NULL;

    assertFrameObject(frame_307c2c80549b8830ab1bdc50cebac581);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_108___hash__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_109___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_features = python_pars[1];
    PyObject *tmp_genexpr_1__$0 = NULL;
    struct Nuitka_FrameObject *frame_15065a31e94060fc1e6f2be62d1bb441;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_15065a31e94060fc1e6f2be62d1bb441 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_15065a31e94060fc1e6f2be62d1bb441, codeobj_15065a31e94060fc1e6f2be62d1bb441, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_15065a31e94060fc1e6f2be62d1bb441 = cache_frame_15065a31e94060fc1e6f2be62d1bb441;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_15065a31e94060fc1e6f2be62d1bb441);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_15065a31e94060fc1e6f2be62d1bb441) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_list_arg_1;
        CHECK_OBJECT(par_features);
        tmp_list_arg_1 = par_features;
        tmp_assign_source_1 = PySequence_List(tmp_list_arg_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 870;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = par_features;
            assert(old != NULL);
            par_features = tmp_assign_source_1;
            Py_DECREF(old);
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_or_left_truth_1;
        nuitka_bool tmp_or_left_value_1;
        nuitka_bool tmp_or_right_value_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_all_arg_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_len_arg_1;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT(par_features);
            tmp_iter_arg_1 = par_features;
            tmp_assign_source_2 = MAKE_ITERATOR(tmp_iter_arg_1);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 872;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            assert(tmp_genexpr_1__$0 == NULL);
            tmp_genexpr_1__$0 = tmp_assign_source_2;
        }
        // Tried code:
        tmp_all_arg_1 = cryptography$x509$extensions$$$function_109___init__$$$genexpr_1_genexpr_maker();

        ((struct Nuitka_GeneratorObject *)tmp_all_arg_1)->m_closure[0] = PyCell_NEW0(tmp_genexpr_1__$0);


        goto try_return_handler_2;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_109___init__);
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        CHECK_OBJECT((PyObject *)tmp_genexpr_1__$0);
        Py_DECREF(tmp_genexpr_1__$0);
        tmp_genexpr_1__$0 = NULL;

        goto outline_result_1;
        // End of try:
        CHECK_OBJECT((PyObject *)tmp_genexpr_1__$0);
        Py_DECREF(tmp_genexpr_1__$0);
        tmp_genexpr_1__$0 = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_109___init__);
        return NULL;
        outline_result_1:;
        tmp_operand_name_1 = BUILTIN_ALL(tmp_all_arg_1);
        Py_DECREF(tmp_all_arg_1);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 872;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 872;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_or_left_value_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_or_left_truth_1 = tmp_or_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if (tmp_or_left_truth_1 == 1) {
            goto or_left_1;
        } else {
            goto or_right_1;
        }
        or_right_1:;
        CHECK_OBJECT(par_features);
        tmp_len_arg_1 = par_features;
        tmp_compexpr_left_1 = BUILTIN_LEN(tmp_len_arg_1);
        assert(!(tmp_compexpr_left_1 == NULL));
        tmp_compexpr_right_1 = const_int_0;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_INT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        assert(!(tmp_res == -1));
        tmp_or_right_value_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_condition_result_1 = tmp_or_right_value_1;
        goto or_end_1;
        or_left_1:;
        tmp_condition_result_1 = tmp_or_left_value_1;
        or_end_1:;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_908210834a8fb4c8eaca7a64e23a4bed;
            frame_15065a31e94060fc1e6f2be62d1bb441->m_frame.f_lineno = 875;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 875;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_features);
        tmp_assattr_name_1 = par_features;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__features, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 880;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_15065a31e94060fc1e6f2be62d1bb441);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_15065a31e94060fc1e6f2be62d1bb441);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_15065a31e94060fc1e6f2be62d1bb441, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_15065a31e94060fc1e6f2be62d1bb441->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_15065a31e94060fc1e6f2be62d1bb441, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_15065a31e94060fc1e6f2be62d1bb441,
        type_description_1,
        par_self,
        par_features
    );


    // Release cached frame.
    if (frame_15065a31e94060fc1e6f2be62d1bb441 == cache_frame_15065a31e94060fc1e6f2be62d1bb441) {
        Py_DECREF(frame_15065a31e94060fc1e6f2be62d1bb441);
    }
    cache_frame_15065a31e94060fc1e6f2be62d1bb441 = NULL;

    assertFrameObject(frame_15065a31e94060fc1e6f2be62d1bb441);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_109___init__);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)par_features);
    Py_DECREF(par_features);
    par_features = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)par_features);
    Py_DECREF(par_features);
    par_features = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_109___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}



struct cryptography$x509$extensions$$$function_109___init__$$$genexpr_1_genexpr_locals {
    PyObject *var_x;
    PyObject *tmp_iter_value_0;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    int tmp_res;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *cryptography$x509$extensions$$$function_109___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value ) {
    CHECK_OBJECT((PyObject *)generator);
    assert(Nuitka_Generator_Check( (PyObject *)generator ));

    // Heap access if used.
    struct cryptography$x509$extensions$$$function_109___init__$$$genexpr_1_genexpr_locals *generator_heap = (struct cryptography$x509$extensions$$$function_109___init__$$$genexpr_1_genexpr_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_x = NULL;
    generator_heap->tmp_iter_value_0 = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_m_frame, codeobj_9ed3c9ca3659a47dcc7d6a0adafc3ab6, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF(generator->m_frame);
    assert(Py_REFCNT(generator->m_frame) == 2); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR(generator->m_frame->m_frame.f_back);

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF(generator->m_frame->m_frame.f_back);

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF(generator->m_frame);

    Nuitka_Frame_MarkAsExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

        EXC_TYPE_F(generator) = EXC_TYPE(thread_state);
        if (EXC_TYPE_F(generator) == Py_None) EXC_TYPE_F(generator) = NULL;
        Py_XINCREF(EXC_TYPE_F(generator));
        EXC_VALUE_F(generator) = EXC_VALUE(thread_state);
        Py_XINCREF(EXC_VALUE_F(generator));
        EXC_TRACEBACK_F(generator) = EXC_TRACEBACK(thread_state);
        Py_XINCREF(EXC_TRACEBACK_F(generator));
    }

#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_1;
        CHECK_OBJECT(PyCell_GET(generator->m_closure[0]));
        tmp_next_source_1 = PyCell_GET(generator->m_closure[0]);
        tmp_assign_source_1 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_1 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);
                generator_heap->type_description_1 = "No";
                generator_heap->exception_lineno = 872;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_iter_value_0;
            generator_heap->tmp_iter_value_0 = tmp_assign_source_1;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT(generator_heap->tmp_iter_value_0);
        tmp_assign_source_2 = generator_heap->tmp_iter_value_0;
        {
            PyObject *old = generator_heap->var_x;
            generator_heap->var_x = tmp_assign_source_2;
            Py_INCREF(generator_heap->var_x);
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_expression_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        CHECK_OBJECT(generator_heap->var_x);
        tmp_isinstance_inst_1 = generator_heap->var_x;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_TLSFeatureType);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_TLSFeatureType);
        }

        if (tmp_mvar_value_1 == NULL) {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF(generator_heap->exception_type);
            generator_heap->exception_value = UNSTREAM_STRING(&constant_bin[ 37082 ], 43, 0);
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 872;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        generator_heap->tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (generator_heap->tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 872;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_expression_name_1 = (generator_heap->tmp_res != 0) ? Py_True : Py_False;
        Py_INCREF(tmp_expression_name_1);
        Nuitka_PreserveHeap(generator_heap->yield_tmps, &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), NULL);
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        Nuitka_RestoreHeap(generator_heap->yield_tmps, &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), NULL);
        if (yield_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 872;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


        generator_heap->exception_lineno = 872;
        generator_heap->type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    // Allow re-use of the frame again.
    Py_DECREF(generator->m_frame);
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if (!EXCEPTION_MATCH_GENERATOR(generator_heap->exception_type)) {
        if (generator_heap->exception_tb == NULL) {
            generator_heap->exception_tb = MAKE_TRACEBACK(generator->m_frame, generator_heap->exception_lineno);
        } else if (generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame) {
            generator_heap->exception_tb = ADD_TRACEBACK(generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno);
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            NULL,
            generator_heap->var_x
        );


        // Release cached frame.
        if (generator->m_frame == cache_m_frame) {
            Py_DECREF(generator->m_frame);
        }
        cache_m_frame = NULL;

        assertFrameObject(generator->m_frame);
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    Py_DECREF(generator->m_frame);

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->var_x);
    generator_heap->var_x = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    Py_XDECREF(generator_heap->var_x);
    generator_heap->var_x = NULL;



    return NULL;

    function_exception_exit:
    assert(generator_heap->exception_type);
    RESTORE_ERROR_OCCURRED(generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb);

    return NULL;

}

static PyObject *cryptography$x509$extensions$$$function_109___init__$$$genexpr_1_genexpr_maker(void) {
    return Nuitka_Generator_New(
        cryptography$x509$extensions$$$function_109___init__$$$genexpr_1_genexpr_context,
        module_cryptography$x509$extensions,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_9ed3c9ca3659a47dcc7d6a0adafc3ab6,
        1,
        sizeof(struct cryptography$x509$extensions$$$function_109___init__$$$genexpr_1_genexpr_locals)
    );
}


static PyObject *impl_cryptography$x509$extensions$$$function_110___iter__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_52ac52abb76c5766947a23493d41a735;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_52ac52abb76c5766947a23493d41a735 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_52ac52abb76c5766947a23493d41a735, codeobj_52ac52abb76c5766947a23493d41a735, module_cryptography$x509$extensions, sizeof(void *));
    frame_52ac52abb76c5766947a23493d41a735 = cache_frame_52ac52abb76c5766947a23493d41a735;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_52ac52abb76c5766947a23493d41a735);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_52ac52abb76c5766947a23493d41a735) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_iter_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__features);
        if (tmp_iter_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 883;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = MAKE_ITERATOR(tmp_iter_arg_1);
        Py_DECREF(tmp_iter_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 883;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_52ac52abb76c5766947a23493d41a735);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_52ac52abb76c5766947a23493d41a735);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_52ac52abb76c5766947a23493d41a735);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_52ac52abb76c5766947a23493d41a735, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_52ac52abb76c5766947a23493d41a735->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_52ac52abb76c5766947a23493d41a735, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_52ac52abb76c5766947a23493d41a735,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_52ac52abb76c5766947a23493d41a735 == cache_frame_52ac52abb76c5766947a23493d41a735) {
        Py_DECREF(frame_52ac52abb76c5766947a23493d41a735);
    }
    cache_frame_52ac52abb76c5766947a23493d41a735 = NULL;

    assertFrameObject(frame_52ac52abb76c5766947a23493d41a735);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_110___iter__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_111___len__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_516022e569c9c2d4e801766d1e23a7a9;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_516022e569c9c2d4e801766d1e23a7a9 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_516022e569c9c2d4e801766d1e23a7a9, codeobj_516022e569c9c2d4e801766d1e23a7a9, module_cryptography$x509$extensions, sizeof(void *));
    frame_516022e569c9c2d4e801766d1e23a7a9 = cache_frame_516022e569c9c2d4e801766d1e23a7a9;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_516022e569c9c2d4e801766d1e23a7a9);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_516022e569c9c2d4e801766d1e23a7a9) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_len_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_len_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__features);
        if (tmp_len_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 886;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = BUILTIN_LEN(tmp_len_arg_1);
        Py_DECREF(tmp_len_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 886;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_516022e569c9c2d4e801766d1e23a7a9);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_516022e569c9c2d4e801766d1e23a7a9);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_516022e569c9c2d4e801766d1e23a7a9);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_516022e569c9c2d4e801766d1e23a7a9, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_516022e569c9c2d4e801766d1e23a7a9->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_516022e569c9c2d4e801766d1e23a7a9, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_516022e569c9c2d4e801766d1e23a7a9,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_516022e569c9c2d4e801766d1e23a7a9 == cache_frame_516022e569c9c2d4e801766d1e23a7a9) {
        Py_DECREF(frame_516022e569c9c2d4e801766d1e23a7a9);
    }
    cache_frame_516022e569c9c2d4e801766d1e23a7a9 = NULL;

    assertFrameObject(frame_516022e569c9c2d4e801766d1e23a7a9);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_111___len__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_112___repr__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_3e4f26f00524b986eaad778de10be378;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_3e4f26f00524b986eaad778de10be378 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_3e4f26f00524b986eaad778de10be378, codeobj_3e4f26f00524b986eaad778de10be378, module_cryptography$x509$extensions, sizeof(void *));
    frame_3e4f26f00524b986eaad778de10be378 = cache_frame_3e4f26f00524b986eaad778de10be378;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_3e4f26f00524b986eaad778de10be378);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_3e4f26f00524b986eaad778de10be378) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        tmp_called_instance_1 = const_str_digest_f68da15c98dbc7b7660e8e5bee0179e6;
        CHECK_OBJECT(par_self);
        tmp_args_element_name_1 = par_self;
        frame_3e4f26f00524b986eaad778de10be378->m_frame.f_lineno = 889;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_format, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 889;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3e4f26f00524b986eaad778de10be378);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_3e4f26f00524b986eaad778de10be378);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3e4f26f00524b986eaad778de10be378);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_3e4f26f00524b986eaad778de10be378, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_3e4f26f00524b986eaad778de10be378->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_3e4f26f00524b986eaad778de10be378, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3e4f26f00524b986eaad778de10be378,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_3e4f26f00524b986eaad778de10be378 == cache_frame_3e4f26f00524b986eaad778de10be378) {
        Py_DECREF(frame_3e4f26f00524b986eaad778de10be378);
    }
    cache_frame_3e4f26f00524b986eaad778de10be378 = NULL;

    assertFrameObject(frame_3e4f26f00524b986eaad778de10be378);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_112___repr__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_113___eq__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_24e7e599f7a9ff62dccfaaca7a767e34;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_24e7e599f7a9ff62dccfaaca7a767e34 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_24e7e599f7a9ff62dccfaaca7a767e34, codeobj_24e7e599f7a9ff62dccfaaca7a767e34, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_24e7e599f7a9ff62dccfaaca7a767e34 = cache_frame_24e7e599f7a9ff62dccfaaca7a767e34;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_24e7e599f7a9ff62dccfaaca7a767e34);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_24e7e599f7a9ff62dccfaaca7a767e34) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_other);
        tmp_isinstance_inst_1 = par_other;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_TLSFeature);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_TLSFeature);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 37125 ], 39, 0);
            exception_tb = NULL;

            exception_lineno = 892;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 892;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 892;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__features);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 895;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_2 = par_other;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__features);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_1);

            exception_lineno = 895;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 895;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_24e7e599f7a9ff62dccfaaca7a767e34);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_24e7e599f7a9ff62dccfaaca7a767e34);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_24e7e599f7a9ff62dccfaaca7a767e34);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_24e7e599f7a9ff62dccfaaca7a767e34, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_24e7e599f7a9ff62dccfaaca7a767e34->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_24e7e599f7a9ff62dccfaaca7a767e34, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_24e7e599f7a9ff62dccfaaca7a767e34,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_24e7e599f7a9ff62dccfaaca7a767e34 == cache_frame_24e7e599f7a9ff62dccfaaca7a767e34) {
        Py_DECREF(frame_24e7e599f7a9ff62dccfaaca7a767e34);
    }
    cache_frame_24e7e599f7a9ff62dccfaaca7a767e34 = NULL;

    assertFrameObject(frame_24e7e599f7a9ff62dccfaaca7a767e34);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_113___eq__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_114___getitem__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_idx = python_pars[1];
    struct Nuitka_FrameObject *frame_4be51afc529a9d1699ae3aaaaf3cc631;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_4be51afc529a9d1699ae3aaaaf3cc631 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_4be51afc529a9d1699ae3aaaaf3cc631, codeobj_4be51afc529a9d1699ae3aaaaf3cc631, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_4be51afc529a9d1699ae3aaaaf3cc631 = cache_frame_4be51afc529a9d1699ae3aaaaf3cc631;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_4be51afc529a9d1699ae3aaaaf3cc631);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_4be51afc529a9d1699ae3aaaaf3cc631) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_subscript_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__features);
        if (tmp_subscribed_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 898;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_idx);
        tmp_subscript_name_1 = par_idx;
        tmp_return_value = LOOKUP_SUBSCRIPT(tmp_subscribed_name_1, tmp_subscript_name_1);
        Py_DECREF(tmp_subscribed_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 898;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_4be51afc529a9d1699ae3aaaaf3cc631);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_4be51afc529a9d1699ae3aaaaf3cc631);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_4be51afc529a9d1699ae3aaaaf3cc631);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_4be51afc529a9d1699ae3aaaaf3cc631, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_4be51afc529a9d1699ae3aaaaf3cc631->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_4be51afc529a9d1699ae3aaaaf3cc631, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4be51afc529a9d1699ae3aaaaf3cc631,
        type_description_1,
        par_self,
        par_idx
    );


    // Release cached frame.
    if (frame_4be51afc529a9d1699ae3aaaaf3cc631 == cache_frame_4be51afc529a9d1699ae3aaaaf3cc631) {
        Py_DECREF(frame_4be51afc529a9d1699ae3aaaaf3cc631);
    }
    cache_frame_4be51afc529a9d1699ae3aaaaf3cc631 = NULL;

    assertFrameObject(frame_4be51afc529a9d1699ae3aaaaf3cc631);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_114___getitem__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_idx);
    Py_DECREF(par_idx);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_idx);
    Py_DECREF(par_idx);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_115___ne__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_45ed442e1506cc9b5cff022672c2bdc7;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_45ed442e1506cc9b5cff022672c2bdc7 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_45ed442e1506cc9b5cff022672c2bdc7, codeobj_45ed442e1506cc9b5cff022672c2bdc7, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_45ed442e1506cc9b5cff022672c2bdc7 = cache_frame_45ed442e1506cc9b5cff022672c2bdc7;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_45ed442e1506cc9b5cff022672c2bdc7);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_45ed442e1506cc9b5cff022672c2bdc7) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_self);
        tmp_compexpr_left_1 = par_self;
        CHECK_OBJECT(par_other);
        tmp_compexpr_right_1 = par_other;
        tmp_operand_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 901;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 901;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = (tmp_res == 0) ? Py_True : Py_False;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_45ed442e1506cc9b5cff022672c2bdc7);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_45ed442e1506cc9b5cff022672c2bdc7);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_45ed442e1506cc9b5cff022672c2bdc7);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_45ed442e1506cc9b5cff022672c2bdc7, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_45ed442e1506cc9b5cff022672c2bdc7->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_45ed442e1506cc9b5cff022672c2bdc7, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_45ed442e1506cc9b5cff022672c2bdc7,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_45ed442e1506cc9b5cff022672c2bdc7 == cache_frame_45ed442e1506cc9b5cff022672c2bdc7) {
        Py_DECREF(frame_45ed442e1506cc9b5cff022672c2bdc7);
    }
    cache_frame_45ed442e1506cc9b5cff022672c2bdc7 = NULL;

    assertFrameObject(frame_45ed442e1506cc9b5cff022672c2bdc7);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_115___ne__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_116___hash__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_630983a0bc3c12aec05d1c102c6f9427;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_630983a0bc3c12aec05d1c102c6f9427 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_630983a0bc3c12aec05d1c102c6f9427, codeobj_630983a0bc3c12aec05d1c102c6f9427, module_cryptography$x509$extensions, sizeof(void *));
    frame_630983a0bc3c12aec05d1c102c6f9427 = cache_frame_630983a0bc3c12aec05d1c102c6f9427;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_630983a0bc3c12aec05d1c102c6f9427);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_630983a0bc3c12aec05d1c102c6f9427) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_hash_arg_1;
        PyObject *tmp_tuple_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_tuple_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__features);
        if (tmp_tuple_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 904;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_hash_arg_1 = PySequence_Tuple(tmp_tuple_arg_1);
        Py_DECREF(tmp_tuple_arg_1);
        if (tmp_hash_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 904;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = BUILTIN_HASH(tmp_hash_arg_1);
        Py_DECREF(tmp_hash_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 904;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_630983a0bc3c12aec05d1c102c6f9427);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_630983a0bc3c12aec05d1c102c6f9427);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_630983a0bc3c12aec05d1c102c6f9427);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_630983a0bc3c12aec05d1c102c6f9427, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_630983a0bc3c12aec05d1c102c6f9427->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_630983a0bc3c12aec05d1c102c6f9427, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_630983a0bc3c12aec05d1c102c6f9427,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_630983a0bc3c12aec05d1c102c6f9427 == cache_frame_630983a0bc3c12aec05d1c102c6f9427) {
        Py_DECREF(frame_630983a0bc3c12aec05d1c102c6f9427);
    }
    cache_frame_630983a0bc3c12aec05d1c102c6f9427 = NULL;

    assertFrameObject(frame_630983a0bc3c12aec05d1c102c6f9427);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_116___hash__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}



struct cryptography$x509$extensions$$$genexpr_1_genexpr_locals {
    PyObject *var_x;
    PyObject *tmp_iter_value_0;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *cryptography$x509$extensions$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value ) {
    CHECK_OBJECT((PyObject *)generator);
    assert(Nuitka_Generator_Check( (PyObject *)generator ));

    // Heap access if used.
    struct cryptography$x509$extensions$$$genexpr_1_genexpr_locals *generator_heap = (struct cryptography$x509$extensions$$$genexpr_1_genexpr_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_x = NULL;
    generator_heap->tmp_iter_value_0 = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_m_frame, codeobj_e842a3817de07d4676702c4ec5cd46ff, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF(generator->m_frame);
    assert(Py_REFCNT(generator->m_frame) == 2); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR(generator->m_frame->m_frame.f_back);

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF(generator->m_frame->m_frame.f_back);

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF(generator->m_frame);

    Nuitka_Frame_MarkAsExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

        EXC_TYPE_F(generator) = EXC_TYPE(thread_state);
        if (EXC_TYPE_F(generator) == Py_None) EXC_TYPE_F(generator) = NULL;
        Py_XINCREF(EXC_TYPE_F(generator));
        EXC_VALUE_F(generator) = EXC_VALUE(thread_state);
        Py_XINCREF(EXC_VALUE_F(generator));
        EXC_TRACEBACK_F(generator) = EXC_TRACEBACK(thread_state);
        Py_XINCREF(EXC_TRACEBACK_F(generator));
    }

#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_1;
        CHECK_OBJECT(PyCell_GET(generator->m_closure[0]));
        tmp_next_source_1 = PyCell_GET(generator->m_closure[0]);
        tmp_assign_source_1 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_1 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);
                generator_heap->type_description_1 = "No";
                generator_heap->exception_lineno = 918;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_iter_value_0;
            generator_heap->tmp_iter_value_0 = tmp_assign_source_1;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT(generator_heap->tmp_iter_value_0);
        tmp_assign_source_2 = generator_heap->tmp_iter_value_0;
        {
            PyObject *old = generator_heap->var_x;
            generator_heap->var_x = tmp_assign_source_2;
            Py_INCREF(generator_heap->var_x);
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_expression_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_1;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        CHECK_OBJECT(generator_heap->var_x);
        tmp_source_name_1 = generator_heap->var_x;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_value);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 918;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_expression_name_1 = PyTuple_New(2);
        PyTuple_SET_ITEM(tmp_expression_name_1, 0, tmp_tuple_element_1);
        CHECK_OBJECT(generator_heap->var_x);
        tmp_tuple_element_1 = generator_heap->var_x;
        Py_INCREF(tmp_tuple_element_1);
        PyTuple_SET_ITEM(tmp_expression_name_1, 1, tmp_tuple_element_1);
        Nuitka_PreserveHeap(generator_heap->yield_tmps, &tmp_tuple_element_1, sizeof(PyObject *), &tmp_source_name_1, sizeof(PyObject *), NULL);
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        Nuitka_RestoreHeap(generator_heap->yield_tmps, &tmp_tuple_element_1, sizeof(PyObject *), &tmp_source_name_1, sizeof(PyObject *), NULL);
        if (yield_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 918;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


        generator_heap->exception_lineno = 918;
        generator_heap->type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    // Allow re-use of the frame again.
    Py_DECREF(generator->m_frame);
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if (!EXCEPTION_MATCH_GENERATOR(generator_heap->exception_type)) {
        if (generator_heap->exception_tb == NULL) {
            generator_heap->exception_tb = MAKE_TRACEBACK(generator->m_frame, generator_heap->exception_lineno);
        } else if (generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame) {
            generator_heap->exception_tb = ADD_TRACEBACK(generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno);
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            NULL,
            generator_heap->var_x
        );


        // Release cached frame.
        if (generator->m_frame == cache_m_frame) {
            Py_DECREF(generator->m_frame);
        }
        cache_m_frame = NULL;

        assertFrameObject(generator->m_frame);
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    Py_DECREF(generator->m_frame);

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->var_x);
    generator_heap->var_x = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    Py_XDECREF(generator_heap->var_x);
    generator_heap->var_x = NULL;



    return NULL;

    function_exception_exit:
    assert(generator_heap->exception_type);
    RESTORE_ERROR_OCCURRED(generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb);

    return NULL;

}

static PyObject *cryptography$x509$extensions$$$genexpr_1_genexpr_maker(void) {
    return Nuitka_Generator_New(
        cryptography$x509$extensions$$$genexpr_1_genexpr_context,
        module_cryptography$x509$extensions,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_e842a3817de07d4676702c4ec5cd46ff,
        1,
        sizeof(struct cryptography$x509$extensions$$$genexpr_1_genexpr_locals)
    );
}


static PyObject *impl_cryptography$x509$extensions$$$function_117___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_skip_certs = python_pars[1];
    struct Nuitka_FrameObject *frame_6ef664bce779bb8c807c67c1e9b5d169;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_6ef664bce779bb8c807c67c1e9b5d169 = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_6ef664bce779bb8c807c67c1e9b5d169, codeobj_6ef664bce779bb8c807c67c1e9b5d169, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_6ef664bce779bb8c807c67c1e9b5d169 = cache_frame_6ef664bce779bb8c807c67c1e9b5d169;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_6ef664bce779bb8c807c67c1e9b5d169);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_6ef664bce779bb8c807c67c1e9b5d169) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_skip_certs);
        tmp_isinstance_inst_1 = par_skip_certs;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_six);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_six);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 19694 ], 32, 0);
            exception_tb = NULL;

            exception_lineno = 926;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_isinstance_cls_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_integer_types);
        if (tmp_isinstance_cls_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 926;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        Py_DECREF(tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 926;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 926;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_e796fffc6f5e8d4c3d564875b854a9ed;
            frame_6ef664bce779bb8c807c67c1e9b5d169->m_frame.f_lineno = 927;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 927;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_skip_certs);
        tmp_compexpr_left_1 = par_skip_certs;
        tmp_compexpr_right_1 = const_int_0;
        tmp_res = RICH_COMPARE_BOOL_LT_OBJECT_INT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 929;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            tmp_make_exception_arg_2 = const_str_digest_87fc424e9112e6987e5fe8e83a94ae22;
            frame_6ef664bce779bb8c807c67c1e9b5d169->m_frame.f_lineno = 930;
            tmp_raise_type_2 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_2);
            assert(!(tmp_raise_type_2 == NULL));
            exception_type = tmp_raise_type_2;
            exception_lineno = 930;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_skip_certs);
        tmp_assattr_name_1 = par_skip_certs;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__skip_certs, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 932;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_6ef664bce779bb8c807c67c1e9b5d169);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_6ef664bce779bb8c807c67c1e9b5d169);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_6ef664bce779bb8c807c67c1e9b5d169, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_6ef664bce779bb8c807c67c1e9b5d169->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_6ef664bce779bb8c807c67c1e9b5d169, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6ef664bce779bb8c807c67c1e9b5d169,
        type_description_1,
        par_self,
        par_skip_certs
    );


    // Release cached frame.
    if (frame_6ef664bce779bb8c807c67c1e9b5d169 == cache_frame_6ef664bce779bb8c807c67c1e9b5d169) {
        Py_DECREF(frame_6ef664bce779bb8c807c67c1e9b5d169);
    }
    cache_frame_6ef664bce779bb8c807c67c1e9b5d169 = NULL;

    assertFrameObject(frame_6ef664bce779bb8c807c67c1e9b5d169);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_117___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_skip_certs);
    Py_DECREF(par_skip_certs);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_skip_certs);
    Py_DECREF(par_skip_certs);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_118___repr__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_a40ae5465b1fee60f90d6ba7f74ac049;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_a40ae5465b1fee60f90d6ba7f74ac049 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_a40ae5465b1fee60f90d6ba7f74ac049, codeobj_a40ae5465b1fee60f90d6ba7f74ac049, module_cryptography$x509$extensions, sizeof(void *));
    frame_a40ae5465b1fee60f90d6ba7f74ac049 = cache_frame_a40ae5465b1fee60f90d6ba7f74ac049;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_a40ae5465b1fee60f90d6ba7f74ac049);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_a40ae5465b1fee60f90d6ba7f74ac049) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        tmp_called_instance_1 = const_str_digest_2a63548c17bc773344f27e5819855b7b;
        CHECK_OBJECT(par_self);
        tmp_args_element_name_1 = par_self;
        frame_a40ae5465b1fee60f90d6ba7f74ac049->m_frame.f_lineno = 935;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_format, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 935;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a40ae5465b1fee60f90d6ba7f74ac049);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_a40ae5465b1fee60f90d6ba7f74ac049);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a40ae5465b1fee60f90d6ba7f74ac049);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_a40ae5465b1fee60f90d6ba7f74ac049, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_a40ae5465b1fee60f90d6ba7f74ac049->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_a40ae5465b1fee60f90d6ba7f74ac049, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a40ae5465b1fee60f90d6ba7f74ac049,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_a40ae5465b1fee60f90d6ba7f74ac049 == cache_frame_a40ae5465b1fee60f90d6ba7f74ac049) {
        Py_DECREF(frame_a40ae5465b1fee60f90d6ba7f74ac049);
    }
    cache_frame_a40ae5465b1fee60f90d6ba7f74ac049 = NULL;

    assertFrameObject(frame_a40ae5465b1fee60f90d6ba7f74ac049);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_118___repr__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_119___eq__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_2907138fdb90eed1a368f2b6f66fa0e6;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_2907138fdb90eed1a368f2b6f66fa0e6 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_2907138fdb90eed1a368f2b6f66fa0e6, codeobj_2907138fdb90eed1a368f2b6f66fa0e6, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_2907138fdb90eed1a368f2b6f66fa0e6 = cache_frame_2907138fdb90eed1a368f2b6f66fa0e6;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_2907138fdb90eed1a368f2b6f66fa0e6);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_2907138fdb90eed1a368f2b6f66fa0e6) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_other);
        tmp_isinstance_inst_1 = par_other;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_InhibitAnyPolicy);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_InhibitAnyPolicy);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 37164 ], 45, 0);
            exception_tb = NULL;

            exception_lineno = 938;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 938;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 938;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_skip_certs);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 941;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_2 = par_other;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_skip_certs);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_1);

            exception_lineno = 941;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 941;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2907138fdb90eed1a368f2b6f66fa0e6);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_2907138fdb90eed1a368f2b6f66fa0e6);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2907138fdb90eed1a368f2b6f66fa0e6);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_2907138fdb90eed1a368f2b6f66fa0e6, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_2907138fdb90eed1a368f2b6f66fa0e6->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_2907138fdb90eed1a368f2b6f66fa0e6, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2907138fdb90eed1a368f2b6f66fa0e6,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_2907138fdb90eed1a368f2b6f66fa0e6 == cache_frame_2907138fdb90eed1a368f2b6f66fa0e6) {
        Py_DECREF(frame_2907138fdb90eed1a368f2b6f66fa0e6);
    }
    cache_frame_2907138fdb90eed1a368f2b6f66fa0e6 = NULL;

    assertFrameObject(frame_2907138fdb90eed1a368f2b6f66fa0e6);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_119___eq__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_120___ne__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_56db8f3ad7ac017dddd0e01deae6912d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_56db8f3ad7ac017dddd0e01deae6912d = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_56db8f3ad7ac017dddd0e01deae6912d, codeobj_56db8f3ad7ac017dddd0e01deae6912d, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_56db8f3ad7ac017dddd0e01deae6912d = cache_frame_56db8f3ad7ac017dddd0e01deae6912d;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_56db8f3ad7ac017dddd0e01deae6912d);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_56db8f3ad7ac017dddd0e01deae6912d) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_self);
        tmp_compexpr_left_1 = par_self;
        CHECK_OBJECT(par_other);
        tmp_compexpr_right_1 = par_other;
        tmp_operand_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 944;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 944;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = (tmp_res == 0) ? Py_True : Py_False;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_56db8f3ad7ac017dddd0e01deae6912d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_56db8f3ad7ac017dddd0e01deae6912d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_56db8f3ad7ac017dddd0e01deae6912d);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_56db8f3ad7ac017dddd0e01deae6912d, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_56db8f3ad7ac017dddd0e01deae6912d->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_56db8f3ad7ac017dddd0e01deae6912d, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_56db8f3ad7ac017dddd0e01deae6912d,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_56db8f3ad7ac017dddd0e01deae6912d == cache_frame_56db8f3ad7ac017dddd0e01deae6912d) {
        Py_DECREF(frame_56db8f3ad7ac017dddd0e01deae6912d);
    }
    cache_frame_56db8f3ad7ac017dddd0e01deae6912d = NULL;

    assertFrameObject(frame_56db8f3ad7ac017dddd0e01deae6912d);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_120___ne__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_121___hash__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_1915b0ec2af236e889c5e58dce17d01b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_1915b0ec2af236e889c5e58dce17d01b = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_1915b0ec2af236e889c5e58dce17d01b, codeobj_1915b0ec2af236e889c5e58dce17d01b, module_cryptography$x509$extensions, sizeof(void *));
    frame_1915b0ec2af236e889c5e58dce17d01b = cache_frame_1915b0ec2af236e889c5e58dce17d01b;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_1915b0ec2af236e889c5e58dce17d01b);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_1915b0ec2af236e889c5e58dce17d01b) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_hash_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_hash_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_skip_certs);
        if (tmp_hash_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 947;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = BUILTIN_HASH(tmp_hash_arg_1);
        Py_DECREF(tmp_hash_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 947;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_1915b0ec2af236e889c5e58dce17d01b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_1915b0ec2af236e889c5e58dce17d01b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_1915b0ec2af236e889c5e58dce17d01b);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_1915b0ec2af236e889c5e58dce17d01b, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_1915b0ec2af236e889c5e58dce17d01b->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_1915b0ec2af236e889c5e58dce17d01b, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1915b0ec2af236e889c5e58dce17d01b,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_1915b0ec2af236e889c5e58dce17d01b == cache_frame_1915b0ec2af236e889c5e58dce17d01b) {
        Py_DECREF(frame_1915b0ec2af236e889c5e58dce17d01b);
    }
    cache_frame_1915b0ec2af236e889c5e58dce17d01b = NULL;

    assertFrameObject(frame_1915b0ec2af236e889c5e58dce17d01b);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_121___hash__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_122___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_digital_signature = python_pars[1];
    PyObject *par_content_commitment = python_pars[2];
    PyObject *par_key_encipherment = python_pars[3];
    PyObject *par_data_encipherment = python_pars[4];
    PyObject *par_key_agreement = python_pars[5];
    PyObject *par_key_cert_sign = python_pars[6];
    PyObject *par_crl_sign = python_pars[7];
    PyObject *par_encipher_only = python_pars[8];
    PyObject *par_decipher_only = python_pars[9];
    struct Nuitka_FrameObject *frame_77c11ff9d369e4a1284f82ff18ea0eb6;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_77c11ff9d369e4a1284f82ff18ea0eb6 = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_77c11ff9d369e4a1284f82ff18ea0eb6, codeobj_77c11ff9d369e4a1284f82ff18ea0eb6, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_77c11ff9d369e4a1284f82ff18ea0eb6 = cache_frame_77c11ff9d369e4a1284f82ff18ea0eb6;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_77c11ff9d369e4a1284f82ff18ea0eb6);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_77c11ff9d369e4a1284f82ff18ea0eb6) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_and_left_truth_1;
        nuitka_bool tmp_and_left_value_1;
        nuitka_bool tmp_and_right_value_1;
        PyObject *tmp_operand_name_1;
        int tmp_or_left_truth_1;
        nuitka_bool tmp_or_left_value_1;
        nuitka_bool tmp_or_right_value_1;
        int tmp_truth_name_1;
        int tmp_truth_name_2;
        CHECK_OBJECT(par_key_agreement);
        tmp_operand_name_1 = par_key_agreement;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 959;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if (tmp_and_left_truth_1 == 1) {
            goto and_right_1;
        } else {
            goto and_left_1;
        }
        and_right_1:;
        CHECK_OBJECT(par_encipher_only);
        tmp_truth_name_1 = CHECK_IF_TRUE(par_encipher_only);
        if (tmp_truth_name_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 959;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_or_left_value_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_or_left_truth_1 = tmp_or_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if (tmp_or_left_truth_1 == 1) {
            goto or_left_1;
        } else {
            goto or_right_1;
        }
        or_right_1:;
        CHECK_OBJECT(par_decipher_only);
        tmp_truth_name_2 = CHECK_IF_TRUE(par_decipher_only);
        if (tmp_truth_name_2 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 959;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_or_right_value_1 = tmp_truth_name_2 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_right_value_1 = tmp_or_right_value_1;
        goto or_end_1;
        or_left_1:;
        tmp_and_right_value_1 = tmp_or_left_value_1;
        or_end_1:;
        tmp_condition_result_1 = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_condition_result_1 = tmp_and_left_value_1;
        and_end_1:;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_1695020c9fca9629cae2bba3b13ed98d;
            frame_77c11ff9d369e4a1284f82ff18ea0eb6->m_frame.f_lineno = 960;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 960;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_digital_signature);
        tmp_assattr_name_1 = par_digital_signature;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__digital_signature, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 965;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT(par_content_commitment);
        tmp_assattr_name_2 = par_content_commitment;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain__content_commitment, tmp_assattr_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 966;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_assattr_target_3;
        CHECK_OBJECT(par_key_encipherment);
        tmp_assattr_name_3 = par_key_encipherment;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_3 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_3, const_str_plain__key_encipherment, tmp_assattr_name_3);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 967;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_4;
        PyObject *tmp_assattr_target_4;
        CHECK_OBJECT(par_data_encipherment);
        tmp_assattr_name_4 = par_data_encipherment;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_4 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_4, const_str_plain__data_encipherment, tmp_assattr_name_4);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 968;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_5;
        PyObject *tmp_assattr_target_5;
        CHECK_OBJECT(par_key_agreement);
        tmp_assattr_name_5 = par_key_agreement;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_5 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_5, const_str_plain__key_agreement, tmp_assattr_name_5);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 969;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_6;
        PyObject *tmp_assattr_target_6;
        CHECK_OBJECT(par_key_cert_sign);
        tmp_assattr_name_6 = par_key_cert_sign;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_6 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_6, const_str_plain__key_cert_sign, tmp_assattr_name_6);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 970;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_7;
        PyObject *tmp_assattr_target_7;
        CHECK_OBJECT(par_crl_sign);
        tmp_assattr_name_7 = par_crl_sign;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_7 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_7, const_str_plain__crl_sign, tmp_assattr_name_7);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 971;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_8;
        PyObject *tmp_assattr_target_8;
        CHECK_OBJECT(par_encipher_only);
        tmp_assattr_name_8 = par_encipher_only;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_8 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_8, const_str_plain__encipher_only, tmp_assattr_name_8);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 972;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_9;
        PyObject *tmp_assattr_target_9;
        CHECK_OBJECT(par_decipher_only);
        tmp_assattr_name_9 = par_decipher_only;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_9 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_9, const_str_plain__decipher_only, tmp_assattr_name_9);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 973;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_77c11ff9d369e4a1284f82ff18ea0eb6);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_77c11ff9d369e4a1284f82ff18ea0eb6);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_77c11ff9d369e4a1284f82ff18ea0eb6, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_77c11ff9d369e4a1284f82ff18ea0eb6->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_77c11ff9d369e4a1284f82ff18ea0eb6, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_77c11ff9d369e4a1284f82ff18ea0eb6,
        type_description_1,
        par_self,
        par_digital_signature,
        par_content_commitment,
        par_key_encipherment,
        par_data_encipherment,
        par_key_agreement,
        par_key_cert_sign,
        par_crl_sign,
        par_encipher_only,
        par_decipher_only
    );


    // Release cached frame.
    if (frame_77c11ff9d369e4a1284f82ff18ea0eb6 == cache_frame_77c11ff9d369e4a1284f82ff18ea0eb6) {
        Py_DECREF(frame_77c11ff9d369e4a1284f82ff18ea0eb6);
    }
    cache_frame_77c11ff9d369e4a1284f82ff18ea0eb6 = NULL;

    assertFrameObject(frame_77c11ff9d369e4a1284f82ff18ea0eb6);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_122___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_crl_sign);
    Py_DECREF(par_crl_sign);
    CHECK_OBJECT(par_key_encipherment);
    Py_DECREF(par_key_encipherment);
    CHECK_OBJECT(par_digital_signature);
    Py_DECREF(par_digital_signature);
    CHECK_OBJECT(par_decipher_only);
    Py_DECREF(par_decipher_only);
    CHECK_OBJECT(par_key_agreement);
    Py_DECREF(par_key_agreement);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_encipher_only);
    Py_DECREF(par_encipher_only);
    CHECK_OBJECT(par_content_commitment);
    Py_DECREF(par_content_commitment);
    CHECK_OBJECT(par_key_cert_sign);
    Py_DECREF(par_key_cert_sign);
    CHECK_OBJECT(par_data_encipherment);
    Py_DECREF(par_data_encipherment);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_crl_sign);
    Py_DECREF(par_crl_sign);
    CHECK_OBJECT(par_key_encipherment);
    Py_DECREF(par_key_encipherment);
    CHECK_OBJECT(par_digital_signature);
    Py_DECREF(par_digital_signature);
    CHECK_OBJECT(par_decipher_only);
    Py_DECREF(par_decipher_only);
    CHECK_OBJECT(par_key_agreement);
    Py_DECREF(par_key_agreement);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_encipher_only);
    Py_DECREF(par_encipher_only);
    CHECK_OBJECT(par_content_commitment);
    Py_DECREF(par_content_commitment);
    CHECK_OBJECT(par_key_cert_sign);
    Py_DECREF(par_key_cert_sign);
    CHECK_OBJECT(par_data_encipherment);
    Py_DECREF(par_data_encipherment);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_123_encipher_only(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_7aaeec7d13e2fa45c91143278c9384ed;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_7aaeec7d13e2fa45c91143278c9384ed = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_7aaeec7d13e2fa45c91143278c9384ed, codeobj_7aaeec7d13e2fa45c91143278c9384ed, module_cryptography$x509$extensions, sizeof(void *));
    frame_7aaeec7d13e2fa45c91143278c9384ed = cache_frame_7aaeec7d13e2fa45c91143278c9384ed;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_7aaeec7d13e2fa45c91143278c9384ed);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_7aaeec7d13e2fa45c91143278c9384ed) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_operand_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_key_agreement);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 985;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 985;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_fdf88dfad66dd7b1bb721469f9f06736;
            frame_7aaeec7d13e2fa45c91143278c9384ed->m_frame.f_lineno = 986;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 986;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_source_name_2;
            CHECK_OBJECT(par_self);
            tmp_source_name_2 = par_self;
            tmp_return_value = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__encipher_only);
            if (tmp_return_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 990;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_7aaeec7d13e2fa45c91143278c9384ed);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_7aaeec7d13e2fa45c91143278c9384ed);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_7aaeec7d13e2fa45c91143278c9384ed);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_7aaeec7d13e2fa45c91143278c9384ed, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_7aaeec7d13e2fa45c91143278c9384ed->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_7aaeec7d13e2fa45c91143278c9384ed, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7aaeec7d13e2fa45c91143278c9384ed,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_7aaeec7d13e2fa45c91143278c9384ed == cache_frame_7aaeec7d13e2fa45c91143278c9384ed) {
        Py_DECREF(frame_7aaeec7d13e2fa45c91143278c9384ed);
    }
    cache_frame_7aaeec7d13e2fa45c91143278c9384ed = NULL;

    assertFrameObject(frame_7aaeec7d13e2fa45c91143278c9384ed);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_123_encipher_only);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_124_decipher_only(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_b961bdee1fe305fdfe9be48d53ac2abd;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_b961bdee1fe305fdfe9be48d53ac2abd = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_b961bdee1fe305fdfe9be48d53ac2abd, codeobj_b961bdee1fe305fdfe9be48d53ac2abd, module_cryptography$x509$extensions, sizeof(void *));
    frame_b961bdee1fe305fdfe9be48d53ac2abd = cache_frame_b961bdee1fe305fdfe9be48d53ac2abd;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_b961bdee1fe305fdfe9be48d53ac2abd);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_b961bdee1fe305fdfe9be48d53ac2abd) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_operand_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_key_agreement);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 994;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 994;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_a173082fd91f8794530005b1589bf6b2;
            frame_b961bdee1fe305fdfe9be48d53ac2abd->m_frame.f_lineno = 995;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 995;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_source_name_2;
            CHECK_OBJECT(par_self);
            tmp_source_name_2 = par_self;
            tmp_return_value = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__decipher_only);
            if (tmp_return_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 999;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b961bdee1fe305fdfe9be48d53ac2abd);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_b961bdee1fe305fdfe9be48d53ac2abd);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b961bdee1fe305fdfe9be48d53ac2abd);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_b961bdee1fe305fdfe9be48d53ac2abd, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_b961bdee1fe305fdfe9be48d53ac2abd->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_b961bdee1fe305fdfe9be48d53ac2abd, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b961bdee1fe305fdfe9be48d53ac2abd,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_b961bdee1fe305fdfe9be48d53ac2abd == cache_frame_b961bdee1fe305fdfe9be48d53ac2abd) {
        Py_DECREF(frame_b961bdee1fe305fdfe9be48d53ac2abd);
    }
    cache_frame_b961bdee1fe305fdfe9be48d53ac2abd = NULL;

    assertFrameObject(frame_b961bdee1fe305fdfe9be48d53ac2abd);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_124_decipher_only);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_125___repr__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_encipher_only = NULL;
    PyObject *var_decipher_only = NULL;
    struct Nuitka_FrameObject *frame_de70240140ef9e6a0e5c1e2d00e223d2;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_de70240140ef9e6a0e5c1e2d00e223d2 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_de70240140ef9e6a0e5c1e2d00e223d2, codeobj_de70240140ef9e6a0e5c1e2d00e223d2, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_de70240140ef9e6a0e5c1e2d00e223d2 = cache_frame_de70240140ef9e6a0e5c1e2d00e223d2;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_de70240140ef9e6a0e5c1e2d00e223d2);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_de70240140ef9e6a0e5c1e2d00e223d2) == 2); // Frame stack

    // Framed code:
    // Tried code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_assign_source_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_encipher_only);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1003;
            type_description_1 = "ooo";
            goto try_except_handler_2;
        }
        assert(var_encipher_only == NULL);
        var_encipher_only = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_assign_source_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_decipher_only);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1004;
            type_description_1 = "ooo";
            goto try_except_handler_2;
        }
        assert(var_decipher_only == NULL);
        var_decipher_only = tmp_assign_source_2;
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION(frame_de70240140ef9e6a0e5c1e2d00e223d2);
    if (exception_keeper_tb_1 == NULL) {
        exception_keeper_tb_1 = MAKE_TRACEBACK(frame_de70240140ef9e6a0e5c1e2d00e223d2, exception_keeper_lineno_1);
    } else if (exception_keeper_lineno_1 != 0) {
        exception_keeper_tb_1 = ADD_TRACEBACK(exception_keeper_tb_1, frame_de70240140ef9e6a0e5c1e2d00e223d2, exception_keeper_lineno_1);
    }

    NORMALIZE_EXCEPTION(&exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1);
    PUBLISH_EXCEPTION(&exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1);
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_compexpr_left_1 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_1 = PyExc_ValueError;
        tmp_res = EXCEPTION_MATCH_BOOL(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1005;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_3;
            tmp_assign_source_3 = Py_None;
            {
                PyObject *old = var_encipher_only;
                var_encipher_only = tmp_assign_source_3;
                Py_INCREF(var_encipher_only);
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_assign_source_4;
            tmp_assign_source_4 = Py_None;
            assert(var_decipher_only == NULL);
            Py_INCREF(tmp_assign_source_4);
            var_decipher_only = tmp_assign_source_4;
        }
        goto branch_end_1;
        branch_no_1:;
        tmp_result = RERAISE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
        if (unlikely(tmp_result == false)) {
            exception_lineno = 1002;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_de70240140ef9e6a0e5c1e2d00e223d2->m_frame) frame_de70240140ef9e6a0e5c1e2d00e223d2->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
        branch_end_1:;
    }
    goto try_end_1;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_125___repr__);
    return NULL;
    // End of try:
    try_end_1:;
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_source_name_3 = const_str_digest_c3da50fdd18d409ebf6fe1322cd35c5d;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_format);
        assert(!(tmp_called_name_1 == NULL));
        CHECK_OBJECT(par_self);
        tmp_args_element_name_1 = par_self;
        if (var_encipher_only == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("local variable '%s' referenced before assignment", "encipher_only");
            exception_tb = NULL;

            exception_lineno = 1016;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_2 = var_encipher_only;
        if (var_decipher_only == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("local variable '%s' referenced before assignment", "decipher_only");
            exception_tb = NULL;

            exception_lineno = 1016;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_3 = var_decipher_only;
        frame_de70240140ef9e6a0e5c1e2d00e223d2->m_frame.f_lineno = 1009;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_return_value = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1009;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 1
    RESTORE_FRAME_EXCEPTION(frame_de70240140ef9e6a0e5c1e2d00e223d2);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION(frame_de70240140ef9e6a0e5c1e2d00e223d2);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION(frame_de70240140ef9e6a0e5c1e2d00e223d2);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_de70240140ef9e6a0e5c1e2d00e223d2, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_de70240140ef9e6a0e5c1e2d00e223d2->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_de70240140ef9e6a0e5c1e2d00e223d2, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_de70240140ef9e6a0e5c1e2d00e223d2,
        type_description_1,
        par_self,
        var_encipher_only,
        var_decipher_only
    );


    // Release cached frame.
    if (frame_de70240140ef9e6a0e5c1e2d00e223d2 == cache_frame_de70240140ef9e6a0e5c1e2d00e223d2) {
        Py_DECREF(frame_de70240140ef9e6a0e5c1e2d00e223d2);
    }
    cache_frame_de70240140ef9e6a0e5c1e2d00e223d2 = NULL;

    assertFrameObject(frame_de70240140ef9e6a0e5c1e2d00e223d2);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_125___repr__);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_encipher_only);
    var_encipher_only = NULL;

    Py_XDECREF(var_decipher_only);
    var_decipher_only = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_encipher_only);
    var_encipher_only = NULL;

    Py_XDECREF(var_decipher_only);
    var_decipher_only = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_125___repr__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_126___eq__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_9355c6ab964f8819c44a92cf3a8a7bc7;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_9355c6ab964f8819c44a92cf3a8a7bc7 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_9355c6ab964f8819c44a92cf3a8a7bc7, codeobj_9355c6ab964f8819c44a92cf3a8a7bc7, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_9355c6ab964f8819c44a92cf3a8a7bc7 = cache_frame_9355c6ab964f8819c44a92cf3a8a7bc7;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_9355c6ab964f8819c44a92cf3a8a7bc7);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_9355c6ab964f8819c44a92cf3a8a7bc7) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_other);
        tmp_isinstance_inst_1 = par_other;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_KeyUsage);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_KeyUsage);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 37209 ], 37, 0);
            exception_tb = NULL;

            exception_lineno = 1019;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1019;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1019;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        int tmp_and_left_truth_1;
        PyObject *tmp_and_left_value_1;
        PyObject *tmp_and_right_value_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        int tmp_and_left_truth_2;
        PyObject *tmp_and_left_value_2;
        PyObject *tmp_and_right_value_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_source_name_4;
        int tmp_and_left_truth_3;
        PyObject *tmp_and_left_value_3;
        PyObject *tmp_and_right_value_3;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_source_name_5;
        PyObject *tmp_source_name_6;
        int tmp_and_left_truth_4;
        PyObject *tmp_and_left_value_4;
        PyObject *tmp_and_right_value_4;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        PyObject *tmp_source_name_7;
        PyObject *tmp_source_name_8;
        int tmp_and_left_truth_5;
        PyObject *tmp_and_left_value_5;
        PyObject *tmp_and_right_value_5;
        PyObject *tmp_compexpr_left_5;
        PyObject *tmp_compexpr_right_5;
        PyObject *tmp_source_name_9;
        PyObject *tmp_source_name_10;
        int tmp_and_left_truth_6;
        PyObject *tmp_and_left_value_6;
        PyObject *tmp_and_right_value_6;
        PyObject *tmp_compexpr_left_6;
        PyObject *tmp_compexpr_right_6;
        PyObject *tmp_source_name_11;
        PyObject *tmp_source_name_12;
        int tmp_and_left_truth_7;
        PyObject *tmp_and_left_value_7;
        PyObject *tmp_and_right_value_7;
        PyObject *tmp_compexpr_left_7;
        PyObject *tmp_compexpr_right_7;
        PyObject *tmp_source_name_13;
        PyObject *tmp_source_name_14;
        int tmp_and_left_truth_8;
        PyObject *tmp_and_left_value_8;
        PyObject *tmp_and_right_value_8;
        PyObject *tmp_compexpr_left_8;
        PyObject *tmp_compexpr_right_8;
        PyObject *tmp_source_name_15;
        PyObject *tmp_source_name_16;
        PyObject *tmp_compexpr_left_9;
        PyObject *tmp_compexpr_right_9;
        PyObject *tmp_source_name_17;
        PyObject *tmp_source_name_18;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_digital_signature);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1023;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_2 = par_other;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_digital_signature);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_1);

            exception_lineno = 1023;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_and_left_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1023;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_truth_1 = CHECK_IF_TRUE(tmp_and_left_value_1);
        if (tmp_and_left_truth_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_and_left_value_1);

            exception_lineno = 1031;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        if (tmp_and_left_truth_1 == 1) {
            goto and_right_1;
        } else {
            goto and_left_1;
        }
        and_right_1:;
        Py_DECREF(tmp_and_left_value_1);
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_content_commitment);
        if (tmp_compexpr_left_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1024;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_4 = par_other;
        tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_content_commitment);
        if (tmp_compexpr_right_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_2);

            exception_lineno = 1024;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_2 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
        Py_DECREF(tmp_compexpr_left_2);
        Py_DECREF(tmp_compexpr_right_2);
        if (tmp_and_left_value_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1024;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_truth_2 = CHECK_IF_TRUE(tmp_and_left_value_2);
        if (tmp_and_left_truth_2 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_and_left_value_2);

            exception_lineno = 1031;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        if (tmp_and_left_truth_2 == 1) {
            goto and_right_2;
        } else {
            goto and_left_2;
        }
        and_right_2:;
        Py_DECREF(tmp_and_left_value_2);
        CHECK_OBJECT(par_self);
        tmp_source_name_5 = par_self;
        tmp_compexpr_left_3 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_key_encipherment);
        if (tmp_compexpr_left_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1025;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_6 = par_other;
        tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_key_encipherment);
        if (tmp_compexpr_right_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_3);

            exception_lineno = 1025;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_3 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_3, tmp_compexpr_right_3);
        Py_DECREF(tmp_compexpr_left_3);
        Py_DECREF(tmp_compexpr_right_3);
        if (tmp_and_left_value_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1025;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_truth_3 = CHECK_IF_TRUE(tmp_and_left_value_3);
        if (tmp_and_left_truth_3 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_and_left_value_3);

            exception_lineno = 1031;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        if (tmp_and_left_truth_3 == 1) {
            goto and_right_3;
        } else {
            goto and_left_3;
        }
        and_right_3:;
        Py_DECREF(tmp_and_left_value_3);
        CHECK_OBJECT(par_self);
        tmp_source_name_7 = par_self;
        tmp_compexpr_left_4 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain_data_encipherment);
        if (tmp_compexpr_left_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1026;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_8 = par_other;
        tmp_compexpr_right_4 = LOOKUP_ATTRIBUTE(tmp_source_name_8, const_str_plain_data_encipherment);
        if (tmp_compexpr_right_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_4);

            exception_lineno = 1026;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_4 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_4, tmp_compexpr_right_4);
        Py_DECREF(tmp_compexpr_left_4);
        Py_DECREF(tmp_compexpr_right_4);
        if (tmp_and_left_value_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1026;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_truth_4 = CHECK_IF_TRUE(tmp_and_left_value_4);
        if (tmp_and_left_truth_4 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_and_left_value_4);

            exception_lineno = 1031;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        if (tmp_and_left_truth_4 == 1) {
            goto and_right_4;
        } else {
            goto and_left_4;
        }
        and_right_4:;
        Py_DECREF(tmp_and_left_value_4);
        CHECK_OBJECT(par_self);
        tmp_source_name_9 = par_self;
        tmp_compexpr_left_5 = LOOKUP_ATTRIBUTE(tmp_source_name_9, const_str_plain_key_agreement);
        if (tmp_compexpr_left_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1027;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_10 = par_other;
        tmp_compexpr_right_5 = LOOKUP_ATTRIBUTE(tmp_source_name_10, const_str_plain_key_agreement);
        if (tmp_compexpr_right_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_5);

            exception_lineno = 1027;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_5 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_5, tmp_compexpr_right_5);
        Py_DECREF(tmp_compexpr_left_5);
        Py_DECREF(tmp_compexpr_right_5);
        if (tmp_and_left_value_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1027;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_truth_5 = CHECK_IF_TRUE(tmp_and_left_value_5);
        if (tmp_and_left_truth_5 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_and_left_value_5);

            exception_lineno = 1031;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        if (tmp_and_left_truth_5 == 1) {
            goto and_right_5;
        } else {
            goto and_left_5;
        }
        and_right_5:;
        Py_DECREF(tmp_and_left_value_5);
        CHECK_OBJECT(par_self);
        tmp_source_name_11 = par_self;
        tmp_compexpr_left_6 = LOOKUP_ATTRIBUTE(tmp_source_name_11, const_str_plain_key_cert_sign);
        if (tmp_compexpr_left_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1028;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_12 = par_other;
        tmp_compexpr_right_6 = LOOKUP_ATTRIBUTE(tmp_source_name_12, const_str_plain_key_cert_sign);
        if (tmp_compexpr_right_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_6);

            exception_lineno = 1028;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_6 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_6, tmp_compexpr_right_6);
        Py_DECREF(tmp_compexpr_left_6);
        Py_DECREF(tmp_compexpr_right_6);
        if (tmp_and_left_value_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1028;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_truth_6 = CHECK_IF_TRUE(tmp_and_left_value_6);
        if (tmp_and_left_truth_6 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_and_left_value_6);

            exception_lineno = 1031;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        if (tmp_and_left_truth_6 == 1) {
            goto and_right_6;
        } else {
            goto and_left_6;
        }
        and_right_6:;
        Py_DECREF(tmp_and_left_value_6);
        CHECK_OBJECT(par_self);
        tmp_source_name_13 = par_self;
        tmp_compexpr_left_7 = LOOKUP_ATTRIBUTE(tmp_source_name_13, const_str_plain_crl_sign);
        if (tmp_compexpr_left_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1029;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_14 = par_other;
        tmp_compexpr_right_7 = LOOKUP_ATTRIBUTE(tmp_source_name_14, const_str_plain_crl_sign);
        if (tmp_compexpr_right_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_7);

            exception_lineno = 1029;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_7 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_7, tmp_compexpr_right_7);
        Py_DECREF(tmp_compexpr_left_7);
        Py_DECREF(tmp_compexpr_right_7);
        if (tmp_and_left_value_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1029;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_truth_7 = CHECK_IF_TRUE(tmp_and_left_value_7);
        if (tmp_and_left_truth_7 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_and_left_value_7);

            exception_lineno = 1031;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        if (tmp_and_left_truth_7 == 1) {
            goto and_right_7;
        } else {
            goto and_left_7;
        }
        and_right_7:;
        Py_DECREF(tmp_and_left_value_7);
        CHECK_OBJECT(par_self);
        tmp_source_name_15 = par_self;
        tmp_compexpr_left_8 = LOOKUP_ATTRIBUTE(tmp_source_name_15, const_str_plain__encipher_only);
        if (tmp_compexpr_left_8 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1030;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_16 = par_other;
        tmp_compexpr_right_8 = LOOKUP_ATTRIBUTE(tmp_source_name_16, const_str_plain__encipher_only);
        if (tmp_compexpr_right_8 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_8);

            exception_lineno = 1030;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_8 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_8, tmp_compexpr_right_8);
        Py_DECREF(tmp_compexpr_left_8);
        Py_DECREF(tmp_compexpr_right_8);
        if (tmp_and_left_value_8 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1030;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_truth_8 = CHECK_IF_TRUE(tmp_and_left_value_8);
        if (tmp_and_left_truth_8 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_and_left_value_8);

            exception_lineno = 1031;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        if (tmp_and_left_truth_8 == 1) {
            goto and_right_8;
        } else {
            goto and_left_8;
        }
        and_right_8:;
        Py_DECREF(tmp_and_left_value_8);
        CHECK_OBJECT(par_self);
        tmp_source_name_17 = par_self;
        tmp_compexpr_left_9 = LOOKUP_ATTRIBUTE(tmp_source_name_17, const_str_plain__decipher_only);
        if (tmp_compexpr_left_9 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1031;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_18 = par_other;
        tmp_compexpr_right_9 = LOOKUP_ATTRIBUTE(tmp_source_name_18, const_str_plain__decipher_only);
        if (tmp_compexpr_right_9 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_9);

            exception_lineno = 1031;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_8 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_9, tmp_compexpr_right_9);
        Py_DECREF(tmp_compexpr_left_9);
        Py_DECREF(tmp_compexpr_right_9);
        if (tmp_and_right_value_8 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1031;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_7 = tmp_and_right_value_8;
        goto and_end_8;
        and_left_8:;
        tmp_and_right_value_7 = tmp_and_left_value_8;
        and_end_8:;
        tmp_and_right_value_6 = tmp_and_right_value_7;
        goto and_end_7;
        and_left_7:;
        tmp_and_right_value_6 = tmp_and_left_value_7;
        and_end_7:;
        tmp_and_right_value_5 = tmp_and_right_value_6;
        goto and_end_6;
        and_left_6:;
        tmp_and_right_value_5 = tmp_and_left_value_6;
        and_end_6:;
        tmp_and_right_value_4 = tmp_and_right_value_5;
        goto and_end_5;
        and_left_5:;
        tmp_and_right_value_4 = tmp_and_left_value_5;
        and_end_5:;
        tmp_and_right_value_3 = tmp_and_right_value_4;
        goto and_end_4;
        and_left_4:;
        tmp_and_right_value_3 = tmp_and_left_value_4;
        and_end_4:;
        tmp_and_right_value_2 = tmp_and_right_value_3;
        goto and_end_3;
        and_left_3:;
        tmp_and_right_value_2 = tmp_and_left_value_3;
        and_end_3:;
        tmp_and_right_value_1 = tmp_and_right_value_2;
        goto and_end_2;
        and_left_2:;
        tmp_and_right_value_1 = tmp_and_left_value_2;
        and_end_2:;
        tmp_return_value = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_return_value = tmp_and_left_value_1;
        and_end_1:;
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9355c6ab964f8819c44a92cf3a8a7bc7);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_9355c6ab964f8819c44a92cf3a8a7bc7);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9355c6ab964f8819c44a92cf3a8a7bc7);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_9355c6ab964f8819c44a92cf3a8a7bc7, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_9355c6ab964f8819c44a92cf3a8a7bc7->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_9355c6ab964f8819c44a92cf3a8a7bc7, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9355c6ab964f8819c44a92cf3a8a7bc7,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_9355c6ab964f8819c44a92cf3a8a7bc7 == cache_frame_9355c6ab964f8819c44a92cf3a8a7bc7) {
        Py_DECREF(frame_9355c6ab964f8819c44a92cf3a8a7bc7);
    }
    cache_frame_9355c6ab964f8819c44a92cf3a8a7bc7 = NULL;

    assertFrameObject(frame_9355c6ab964f8819c44a92cf3a8a7bc7);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_126___eq__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_127___ne__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_57e36cbbce323c916e9e798bf8dbed90;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_57e36cbbce323c916e9e798bf8dbed90 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_57e36cbbce323c916e9e798bf8dbed90, codeobj_57e36cbbce323c916e9e798bf8dbed90, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_57e36cbbce323c916e9e798bf8dbed90 = cache_frame_57e36cbbce323c916e9e798bf8dbed90;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_57e36cbbce323c916e9e798bf8dbed90);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_57e36cbbce323c916e9e798bf8dbed90) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_self);
        tmp_compexpr_left_1 = par_self;
        CHECK_OBJECT(par_other);
        tmp_compexpr_right_1 = par_other;
        tmp_operand_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1035;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1035;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = (tmp_res == 0) ? Py_True : Py_False;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_57e36cbbce323c916e9e798bf8dbed90);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_57e36cbbce323c916e9e798bf8dbed90);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_57e36cbbce323c916e9e798bf8dbed90);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_57e36cbbce323c916e9e798bf8dbed90, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_57e36cbbce323c916e9e798bf8dbed90->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_57e36cbbce323c916e9e798bf8dbed90, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_57e36cbbce323c916e9e798bf8dbed90,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_57e36cbbce323c916e9e798bf8dbed90 == cache_frame_57e36cbbce323c916e9e798bf8dbed90) {
        Py_DECREF(frame_57e36cbbce323c916e9e798bf8dbed90);
    }
    cache_frame_57e36cbbce323c916e9e798bf8dbed90 = NULL;

    assertFrameObject(frame_57e36cbbce323c916e9e798bf8dbed90);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_127___ne__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_128___hash__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_4319d0fde202e8d91251639b1f99c86f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_4319d0fde202e8d91251639b1f99c86f = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_4319d0fde202e8d91251639b1f99c86f, codeobj_4319d0fde202e8d91251639b1f99c86f, module_cryptography$x509$extensions, sizeof(void *));
    frame_4319d0fde202e8d91251639b1f99c86f = cache_frame_4319d0fde202e8d91251639b1f99c86f;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_4319d0fde202e8d91251639b1f99c86f);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_4319d0fde202e8d91251639b1f99c86f) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_hash_arg_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_source_name_4;
        PyObject *tmp_source_name_5;
        PyObject *tmp_source_name_6;
        PyObject *tmp_source_name_7;
        PyObject *tmp_source_name_8;
        PyObject *tmp_source_name_9;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_digital_signature);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1039;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_hash_arg_1 = PyTuple_New(9);
        PyTuple_SET_ITEM(tmp_hash_arg_1, 0, tmp_tuple_element_1);
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_content_commitment);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_hash_arg_1);

            exception_lineno = 1039;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM(tmp_hash_arg_1, 1, tmp_tuple_element_1);
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_key_encipherment);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_hash_arg_1);

            exception_lineno = 1040;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM(tmp_hash_arg_1, 2, tmp_tuple_element_1);
        CHECK_OBJECT(par_self);
        tmp_source_name_4 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_data_encipherment);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_hash_arg_1);

            exception_lineno = 1040;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM(tmp_hash_arg_1, 3, tmp_tuple_element_1);
        CHECK_OBJECT(par_self);
        tmp_source_name_5 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_key_agreement);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_hash_arg_1);

            exception_lineno = 1041;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM(tmp_hash_arg_1, 4, tmp_tuple_element_1);
        CHECK_OBJECT(par_self);
        tmp_source_name_6 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_key_cert_sign);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_hash_arg_1);

            exception_lineno = 1041;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM(tmp_hash_arg_1, 5, tmp_tuple_element_1);
        CHECK_OBJECT(par_self);
        tmp_source_name_7 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain_crl_sign);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_hash_arg_1);

            exception_lineno = 1042;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM(tmp_hash_arg_1, 6, tmp_tuple_element_1);
        CHECK_OBJECT(par_self);
        tmp_source_name_8 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_8, const_str_plain__encipher_only);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_hash_arg_1);

            exception_lineno = 1042;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM(tmp_hash_arg_1, 7, tmp_tuple_element_1);
        CHECK_OBJECT(par_self);
        tmp_source_name_9 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_9, const_str_plain__decipher_only);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_hash_arg_1);

            exception_lineno = 1043;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM(tmp_hash_arg_1, 8, tmp_tuple_element_1);
        tmp_return_value = BUILTIN_HASH(tmp_hash_arg_1);
        Py_DECREF(tmp_hash_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1038;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_4319d0fde202e8d91251639b1f99c86f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_4319d0fde202e8d91251639b1f99c86f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_4319d0fde202e8d91251639b1f99c86f);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_4319d0fde202e8d91251639b1f99c86f, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_4319d0fde202e8d91251639b1f99c86f->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_4319d0fde202e8d91251639b1f99c86f, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4319d0fde202e8d91251639b1f99c86f,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_4319d0fde202e8d91251639b1f99c86f == cache_frame_4319d0fde202e8d91251639b1f99c86f) {
        Py_DECREF(frame_4319d0fde202e8d91251639b1f99c86f);
    }
    cache_frame_4319d0fde202e8d91251639b1f99c86f = NULL;

    assertFrameObject(frame_4319d0fde202e8d91251639b1f99c86f);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_128___hash__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_129___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_permitted_subtrees = python_pars[1];
    PyObject *par_excluded_subtrees = python_pars[2];
    PyObject *tmp_genexpr_1__$0 = NULL;
    PyObject *tmp_genexpr_2__$0 = NULL;
    struct Nuitka_FrameObject *frame_15444db29e1e916a45d41f13f5c606ec;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_15444db29e1e916a45d41f13f5c606ec = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_15444db29e1e916a45d41f13f5c606ec, codeobj_15444db29e1e916a45d41f13f5c606ec, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_15444db29e1e916a45d41f13f5c606ec = cache_frame_15444db29e1e916a45d41f13f5c606ec;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_15444db29e1e916a45d41f13f5c606ec);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_15444db29e1e916a45d41f13f5c606ec) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_permitted_subtrees);
        tmp_compexpr_left_1 = par_permitted_subtrees;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 != tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_list_arg_1;
            CHECK_OBJECT(par_permitted_subtrees);
            tmp_list_arg_1 = par_permitted_subtrees;
            tmp_assign_source_1 = PySequence_List(tmp_list_arg_1);
            if (tmp_assign_source_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1053;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_permitted_subtrees;
                assert(old != NULL);
                par_permitted_subtrees = tmp_assign_source_1;
                Py_DECREF(old);
            }

        }
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_operand_name_1;
            PyObject *tmp_all_arg_1;
            {
                PyObject *tmp_assign_source_2;
                PyObject *tmp_iter_arg_1;
                CHECK_OBJECT(par_permitted_subtrees);
                tmp_iter_arg_1 = par_permitted_subtrees;
                tmp_assign_source_2 = MAKE_ITERATOR(tmp_iter_arg_1);
                if (tmp_assign_source_2 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 1055;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                assert(tmp_genexpr_1__$0 == NULL);
                tmp_genexpr_1__$0 = tmp_assign_source_2;
            }
            // Tried code:
            tmp_all_arg_1 = cryptography$x509$extensions$$$function_129___init__$$$genexpr_1_genexpr_maker();

            ((struct Nuitka_GeneratorObject *)tmp_all_arg_1)->m_closure[0] = PyCell_NEW0(tmp_genexpr_1__$0);


            goto try_return_handler_2;
            // tried codes exits in all cases
            NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_129___init__);
            return NULL;
            // Return handler code:
            try_return_handler_2:;
            CHECK_OBJECT((PyObject *)tmp_genexpr_1__$0);
            Py_DECREF(tmp_genexpr_1__$0);
            tmp_genexpr_1__$0 = NULL;

            goto outline_result_1;
            // End of try:
            CHECK_OBJECT((PyObject *)tmp_genexpr_1__$0);
            Py_DECREF(tmp_genexpr_1__$0);
            tmp_genexpr_1__$0 = NULL;

            // Return statement must have exited already.
            NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_129___init__);
            return NULL;
            outline_result_1:;
            tmp_operand_name_1 = BUILTIN_ALL(tmp_all_arg_1);
            Py_DECREF(tmp_all_arg_1);
            if (tmp_operand_name_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1054;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
            Py_DECREF(tmp_operand_name_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1054;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
                goto branch_yes_2;
            } else {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_raise_type_1;
                PyObject *tmp_make_exception_arg_1;
                tmp_make_exception_arg_1 = const_str_digest_881d5fa81af108f32d6b1d8d2d35a638;
                frame_15444db29e1e916a45d41f13f5c606ec->m_frame.f_lineno = 1057;
                tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
                assert(!(tmp_raise_type_1 == NULL));
                exception_type = tmp_raise_type_1;
                exception_lineno = 1057;
                RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            branch_no_2:;
        }
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_1;
            CHECK_OBJECT(par_self);
            tmp_called_instance_1 = par_self;
            CHECK_OBJECT(par_permitted_subtrees);
            tmp_args_element_name_1 = par_permitted_subtrees;
            frame_15444db29e1e916a45d41f13f5c606ec->m_frame.f_lineno = 1062;
            {
                PyObject *call_args[] = {tmp_args_element_name_1};
                tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain__validate_ip_name, call_args);
            }

            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1062;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_1);
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        CHECK_OBJECT(par_excluded_subtrees);
        tmp_compexpr_left_2 = par_excluded_subtrees;
        tmp_compexpr_right_2 = Py_None;
        tmp_condition_result_3 = (tmp_compexpr_left_2 != tmp_compexpr_right_2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
            goto branch_yes_3;
        } else {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_list_arg_2;
            CHECK_OBJECT(par_excluded_subtrees);
            tmp_list_arg_2 = par_excluded_subtrees;
            tmp_assign_source_3 = PySequence_List(tmp_list_arg_2);
            if (tmp_assign_source_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1065;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_excluded_subtrees;
                assert(old != NULL);
                par_excluded_subtrees = tmp_assign_source_3;
                Py_DECREF(old);
            }

        }
        {
            nuitka_bool tmp_condition_result_4;
            PyObject *tmp_operand_name_2;
            PyObject *tmp_all_arg_2;
            {
                PyObject *tmp_assign_source_4;
                PyObject *tmp_iter_arg_2;
                CHECK_OBJECT(par_excluded_subtrees);
                tmp_iter_arg_2 = par_excluded_subtrees;
                tmp_assign_source_4 = MAKE_ITERATOR(tmp_iter_arg_2);
                if (tmp_assign_source_4 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 1067;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                assert(tmp_genexpr_2__$0 == NULL);
                tmp_genexpr_2__$0 = tmp_assign_source_4;
            }
            // Tried code:
            tmp_all_arg_2 = cryptography$x509$extensions$$$function_129___init__$$$genexpr_2_genexpr_maker();

            ((struct Nuitka_GeneratorObject *)tmp_all_arg_2)->m_closure[0] = PyCell_NEW0(tmp_genexpr_2__$0);


            goto try_return_handler_3;
            // tried codes exits in all cases
            NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_129___init__);
            return NULL;
            // Return handler code:
            try_return_handler_3:;
            CHECK_OBJECT((PyObject *)tmp_genexpr_2__$0);
            Py_DECREF(tmp_genexpr_2__$0);
            tmp_genexpr_2__$0 = NULL;

            goto outline_result_2;
            // End of try:
            CHECK_OBJECT((PyObject *)tmp_genexpr_2__$0);
            Py_DECREF(tmp_genexpr_2__$0);
            tmp_genexpr_2__$0 = NULL;

            // Return statement must have exited already.
            NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_129___init__);
            return NULL;
            outline_result_2:;
            tmp_operand_name_2 = BUILTIN_ALL(tmp_all_arg_2);
            Py_DECREF(tmp_all_arg_2);
            if (tmp_operand_name_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1066;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_res = CHECK_IF_TRUE(tmp_operand_name_2);
            Py_DECREF(tmp_operand_name_2);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1066;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_4 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_4 == NUITKA_BOOL_TRUE) {
                goto branch_yes_4;
            } else {
                goto branch_no_4;
            }
            branch_yes_4:;
            {
                PyObject *tmp_raise_type_2;
                PyObject *tmp_make_exception_arg_2;
                tmp_make_exception_arg_2 = const_str_digest_a0744842c59ec0ec1342dee683ec7ac8;
                frame_15444db29e1e916a45d41f13f5c606ec->m_frame.f_lineno = 1069;
                tmp_raise_type_2 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_2);
                assert(!(tmp_raise_type_2 == NULL));
                exception_type = tmp_raise_type_2;
                exception_lineno = 1069;
                RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            branch_no_4:;
        }
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_call_result_2;
            PyObject *tmp_args_element_name_2;
            CHECK_OBJECT(par_self);
            tmp_called_instance_2 = par_self;
            CHECK_OBJECT(par_excluded_subtrees);
            tmp_args_element_name_2 = par_excluded_subtrees;
            frame_15444db29e1e916a45d41f13f5c606ec->m_frame.f_lineno = 1074;
            {
                PyObject *call_args[] = {tmp_args_element_name_2};
                tmp_call_result_2 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain__validate_ip_name, call_args);
            }

            if (tmp_call_result_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1074;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_2);
        }
        branch_no_3:;
    }
    {
        nuitka_bool tmp_condition_result_5;
        int tmp_and_left_truth_1;
        nuitka_bool tmp_and_left_value_1;
        nuitka_bool tmp_and_right_value_1;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        CHECK_OBJECT(par_permitted_subtrees);
        tmp_compexpr_left_3 = par_permitted_subtrees;
        tmp_compexpr_right_3 = Py_None;
        tmp_and_left_value_1 = (tmp_compexpr_left_3 == tmp_compexpr_right_3) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if (tmp_and_left_truth_1 == 1) {
            goto and_right_1;
        } else {
            goto and_left_1;
        }
        and_right_1:;
        CHECK_OBJECT(par_excluded_subtrees);
        tmp_compexpr_left_4 = par_excluded_subtrees;
        tmp_compexpr_right_4 = Py_None;
        tmp_and_right_value_1 = (tmp_compexpr_left_4 == tmp_compexpr_right_4) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_condition_result_5 = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_condition_result_5 = tmp_and_left_value_1;
        and_end_1:;
        if (tmp_condition_result_5 == NUITKA_BOOL_TRUE) {
            goto branch_yes_5;
        } else {
            goto branch_no_5;
        }
        branch_yes_5:;
        {
            PyObject *tmp_raise_type_3;
            PyObject *tmp_make_exception_arg_3;
            tmp_make_exception_arg_3 = const_str_digest_ccd052a57d9b2466ec6174083baebf1e;
            frame_15444db29e1e916a45d41f13f5c606ec->m_frame.f_lineno = 1077;
            tmp_raise_type_3 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_3);
            assert(!(tmp_raise_type_3 == NULL));
            exception_type = tmp_raise_type_3;
            exception_lineno = 1077;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_5:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_permitted_subtrees);
        tmp_assattr_name_1 = par_permitted_subtrees;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__permitted_subtrees, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1082;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT(par_excluded_subtrees);
        tmp_assattr_name_2 = par_excluded_subtrees;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain__excluded_subtrees, tmp_assattr_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1083;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_15444db29e1e916a45d41f13f5c606ec);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_15444db29e1e916a45d41f13f5c606ec);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_15444db29e1e916a45d41f13f5c606ec, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_15444db29e1e916a45d41f13f5c606ec->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_15444db29e1e916a45d41f13f5c606ec, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_15444db29e1e916a45d41f13f5c606ec,
        type_description_1,
        par_self,
        par_permitted_subtrees,
        par_excluded_subtrees
    );


    // Release cached frame.
    if (frame_15444db29e1e916a45d41f13f5c606ec == cache_frame_15444db29e1e916a45d41f13f5c606ec) {
        Py_DECREF(frame_15444db29e1e916a45d41f13f5c606ec);
    }
    cache_frame_15444db29e1e916a45d41f13f5c606ec = NULL;

    assertFrameObject(frame_15444db29e1e916a45d41f13f5c606ec);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_129___init__);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)par_permitted_subtrees);
    Py_DECREF(par_permitted_subtrees);
    par_permitted_subtrees = NULL;

    CHECK_OBJECT((PyObject *)par_excluded_subtrees);
    Py_DECREF(par_excluded_subtrees);
    par_excluded_subtrees = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(par_permitted_subtrees);
    par_permitted_subtrees = NULL;

    Py_XDECREF(par_excluded_subtrees);
    par_excluded_subtrees = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_129___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}



struct cryptography$x509$extensions$$$function_129___init__$$$genexpr_1_genexpr_locals {
    PyObject *var_x;
    PyObject *tmp_iter_value_0;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    int tmp_res;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *cryptography$x509$extensions$$$function_129___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value ) {
    CHECK_OBJECT((PyObject *)generator);
    assert(Nuitka_Generator_Check( (PyObject *)generator ));

    // Heap access if used.
    struct cryptography$x509$extensions$$$function_129___init__$$$genexpr_1_genexpr_locals *generator_heap = (struct cryptography$x509$extensions$$$function_129___init__$$$genexpr_1_genexpr_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_x = NULL;
    generator_heap->tmp_iter_value_0 = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_m_frame, codeobj_be6d215d5ccf72c4dd20589bf484df13, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF(generator->m_frame);
    assert(Py_REFCNT(generator->m_frame) == 2); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR(generator->m_frame->m_frame.f_back);

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF(generator->m_frame->m_frame.f_back);

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF(generator->m_frame);

    Nuitka_Frame_MarkAsExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

        EXC_TYPE_F(generator) = EXC_TYPE(thread_state);
        if (EXC_TYPE_F(generator) == Py_None) EXC_TYPE_F(generator) = NULL;
        Py_XINCREF(EXC_TYPE_F(generator));
        EXC_VALUE_F(generator) = EXC_VALUE(thread_state);
        Py_XINCREF(EXC_VALUE_F(generator));
        EXC_TRACEBACK_F(generator) = EXC_TRACEBACK(thread_state);
        Py_XINCREF(EXC_TRACEBACK_F(generator));
    }

#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_1;
        CHECK_OBJECT(PyCell_GET(generator->m_closure[0]));
        tmp_next_source_1 = PyCell_GET(generator->m_closure[0]);
        tmp_assign_source_1 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_1 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);
                generator_heap->type_description_1 = "No";
                generator_heap->exception_lineno = 1055;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_iter_value_0;
            generator_heap->tmp_iter_value_0 = tmp_assign_source_1;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT(generator_heap->tmp_iter_value_0);
        tmp_assign_source_2 = generator_heap->tmp_iter_value_0;
        {
            PyObject *old = generator_heap->var_x;
            generator_heap->var_x = tmp_assign_source_2;
            Py_INCREF(generator_heap->var_x);
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_expression_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        CHECK_OBJECT(generator_heap->var_x);
        tmp_isinstance_inst_1 = generator_heap->var_x;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_GeneralName);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_GeneralName);
        }

        if (tmp_mvar_value_1 == NULL) {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF(generator_heap->exception_type);
            generator_heap->exception_value = UNSTREAM_STRING(&constant_bin[ 36192 ], 40, 0);
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 1055;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        generator_heap->tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (generator_heap->tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 1055;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_expression_name_1 = (generator_heap->tmp_res != 0) ? Py_True : Py_False;
        Py_INCREF(tmp_expression_name_1);
        Nuitka_PreserveHeap(generator_heap->yield_tmps, &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), NULL);
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        Nuitka_RestoreHeap(generator_heap->yield_tmps, &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), NULL);
        if (yield_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 1055;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


        generator_heap->exception_lineno = 1055;
        generator_heap->type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    // Allow re-use of the frame again.
    Py_DECREF(generator->m_frame);
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if (!EXCEPTION_MATCH_GENERATOR(generator_heap->exception_type)) {
        if (generator_heap->exception_tb == NULL) {
            generator_heap->exception_tb = MAKE_TRACEBACK(generator->m_frame, generator_heap->exception_lineno);
        } else if (generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame) {
            generator_heap->exception_tb = ADD_TRACEBACK(generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno);
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            NULL,
            generator_heap->var_x
        );


        // Release cached frame.
        if (generator->m_frame == cache_m_frame) {
            Py_DECREF(generator->m_frame);
        }
        cache_m_frame = NULL;

        assertFrameObject(generator->m_frame);
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    Py_DECREF(generator->m_frame);

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->var_x);
    generator_heap->var_x = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    Py_XDECREF(generator_heap->var_x);
    generator_heap->var_x = NULL;



    return NULL;

    function_exception_exit:
    assert(generator_heap->exception_type);
    RESTORE_ERROR_OCCURRED(generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb);

    return NULL;

}

static PyObject *cryptography$x509$extensions$$$function_129___init__$$$genexpr_1_genexpr_maker(void) {
    return Nuitka_Generator_New(
        cryptography$x509$extensions$$$function_129___init__$$$genexpr_1_genexpr_context,
        module_cryptography$x509$extensions,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_be6d215d5ccf72c4dd20589bf484df13,
        1,
        sizeof(struct cryptography$x509$extensions$$$function_129___init__$$$genexpr_1_genexpr_locals)
    );
}



struct cryptography$x509$extensions$$$function_129___init__$$$genexpr_2_genexpr_locals {
    PyObject *var_x;
    PyObject *tmp_iter_value_0;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    int tmp_res;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *cryptography$x509$extensions$$$function_129___init__$$$genexpr_2_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value ) {
    CHECK_OBJECT((PyObject *)generator);
    assert(Nuitka_Generator_Check( (PyObject *)generator ));

    // Heap access if used.
    struct cryptography$x509$extensions$$$function_129___init__$$$genexpr_2_genexpr_locals *generator_heap = (struct cryptography$x509$extensions$$$function_129___init__$$$genexpr_2_genexpr_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_x = NULL;
    generator_heap->tmp_iter_value_0 = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_m_frame, codeobj_624e1fc6d94a612cab9b15afbf337091, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF(generator->m_frame);
    assert(Py_REFCNT(generator->m_frame) == 2); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR(generator->m_frame->m_frame.f_back);

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF(generator->m_frame->m_frame.f_back);

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF(generator->m_frame);

    Nuitka_Frame_MarkAsExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

        EXC_TYPE_F(generator) = EXC_TYPE(thread_state);
        if (EXC_TYPE_F(generator) == Py_None) EXC_TYPE_F(generator) = NULL;
        Py_XINCREF(EXC_TYPE_F(generator));
        EXC_VALUE_F(generator) = EXC_VALUE(thread_state);
        Py_XINCREF(EXC_VALUE_F(generator));
        EXC_TRACEBACK_F(generator) = EXC_TRACEBACK(thread_state);
        Py_XINCREF(EXC_TRACEBACK_F(generator));
    }

#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_1;
        CHECK_OBJECT(PyCell_GET(generator->m_closure[0]));
        tmp_next_source_1 = PyCell_GET(generator->m_closure[0]);
        tmp_assign_source_1 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_1 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);
                generator_heap->type_description_1 = "No";
                generator_heap->exception_lineno = 1067;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_iter_value_0;
            generator_heap->tmp_iter_value_0 = tmp_assign_source_1;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT(generator_heap->tmp_iter_value_0);
        tmp_assign_source_2 = generator_heap->tmp_iter_value_0;
        {
            PyObject *old = generator_heap->var_x;
            generator_heap->var_x = tmp_assign_source_2;
            Py_INCREF(generator_heap->var_x);
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_expression_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        CHECK_OBJECT(generator_heap->var_x);
        tmp_isinstance_inst_1 = generator_heap->var_x;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_GeneralName);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_GeneralName);
        }

        if (tmp_mvar_value_1 == NULL) {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF(generator_heap->exception_type);
            generator_heap->exception_value = UNSTREAM_STRING(&constant_bin[ 36192 ], 40, 0);
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 1067;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        generator_heap->tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (generator_heap->tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 1067;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_expression_name_1 = (generator_heap->tmp_res != 0) ? Py_True : Py_False;
        Py_INCREF(tmp_expression_name_1);
        Nuitka_PreserveHeap(generator_heap->yield_tmps, &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), NULL);
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        Nuitka_RestoreHeap(generator_heap->yield_tmps, &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), NULL);
        if (yield_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 1067;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


        generator_heap->exception_lineno = 1067;
        generator_heap->type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    // Allow re-use of the frame again.
    Py_DECREF(generator->m_frame);
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if (!EXCEPTION_MATCH_GENERATOR(generator_heap->exception_type)) {
        if (generator_heap->exception_tb == NULL) {
            generator_heap->exception_tb = MAKE_TRACEBACK(generator->m_frame, generator_heap->exception_lineno);
        } else if (generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame) {
            generator_heap->exception_tb = ADD_TRACEBACK(generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno);
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            NULL,
            generator_heap->var_x
        );


        // Release cached frame.
        if (generator->m_frame == cache_m_frame) {
            Py_DECREF(generator->m_frame);
        }
        cache_m_frame = NULL;

        assertFrameObject(generator->m_frame);
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    Py_DECREF(generator->m_frame);

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->var_x);
    generator_heap->var_x = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    Py_XDECREF(generator_heap->var_x);
    generator_heap->var_x = NULL;



    return NULL;

    function_exception_exit:
    assert(generator_heap->exception_type);
    RESTORE_ERROR_OCCURRED(generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb);

    return NULL;

}

static PyObject *cryptography$x509$extensions$$$function_129___init__$$$genexpr_2_genexpr_maker(void) {
    return Nuitka_Generator_New(
        cryptography$x509$extensions$$$function_129___init__$$$genexpr_2_genexpr_context,
        module_cryptography$x509$extensions,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_624e1fc6d94a612cab9b15afbf337091,
        1,
        sizeof(struct cryptography$x509$extensions$$$function_129___init__$$$genexpr_2_genexpr_locals)
    );
}


static PyObject *impl_cryptography$x509$extensions$$$function_130___eq__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_36f675ca210741eafa6fdae589c7d341;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_36f675ca210741eafa6fdae589c7d341 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_36f675ca210741eafa6fdae589c7d341, codeobj_36f675ca210741eafa6fdae589c7d341, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_36f675ca210741eafa6fdae589c7d341 = cache_frame_36f675ca210741eafa6fdae589c7d341;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_36f675ca210741eafa6fdae589c7d341);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_36f675ca210741eafa6fdae589c7d341) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_other);
        tmp_isinstance_inst_1 = par_other;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_NameConstraints);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_NameConstraints);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 37246 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 1086;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1086;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1086;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        int tmp_and_left_truth_1;
        PyObject *tmp_and_left_value_1;
        PyObject *tmp_and_right_value_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_source_name_4;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_excluded_subtrees);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1090;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_2 = par_other;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_excluded_subtrees);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_1);

            exception_lineno = 1090;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_and_left_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1090;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_truth_1 = CHECK_IF_TRUE(tmp_and_left_value_1);
        if (tmp_and_left_truth_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_and_left_value_1);

            exception_lineno = 1091;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        if (tmp_and_left_truth_1 == 1) {
            goto and_right_1;
        } else {
            goto and_left_1;
        }
        and_right_1:;
        Py_DECREF(tmp_and_left_value_1);
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_permitted_subtrees);
        if (tmp_compexpr_left_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1091;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_4 = par_other;
        tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_permitted_subtrees);
        if (tmp_compexpr_right_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_2);

            exception_lineno = 1091;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
        Py_DECREF(tmp_compexpr_left_2);
        Py_DECREF(tmp_compexpr_right_2);
        if (tmp_and_right_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1091;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_return_value = tmp_and_left_value_1;
        and_end_1:;
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_36f675ca210741eafa6fdae589c7d341);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_36f675ca210741eafa6fdae589c7d341);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_36f675ca210741eafa6fdae589c7d341);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_36f675ca210741eafa6fdae589c7d341, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_36f675ca210741eafa6fdae589c7d341->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_36f675ca210741eafa6fdae589c7d341, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_36f675ca210741eafa6fdae589c7d341,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_36f675ca210741eafa6fdae589c7d341 == cache_frame_36f675ca210741eafa6fdae589c7d341) {
        Py_DECREF(frame_36f675ca210741eafa6fdae589c7d341);
    }
    cache_frame_36f675ca210741eafa6fdae589c7d341 = NULL;

    assertFrameObject(frame_36f675ca210741eafa6fdae589c7d341);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_130___eq__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_131___ne__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_92c869c1bdf445f8c0f17651833850ef;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_92c869c1bdf445f8c0f17651833850ef = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_92c869c1bdf445f8c0f17651833850ef, codeobj_92c869c1bdf445f8c0f17651833850ef, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_92c869c1bdf445f8c0f17651833850ef = cache_frame_92c869c1bdf445f8c0f17651833850ef;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_92c869c1bdf445f8c0f17651833850ef);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_92c869c1bdf445f8c0f17651833850ef) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_self);
        tmp_compexpr_left_1 = par_self;
        CHECK_OBJECT(par_other);
        tmp_compexpr_right_1 = par_other;
        tmp_operand_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1095;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1095;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = (tmp_res == 0) ? Py_True : Py_False;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_92c869c1bdf445f8c0f17651833850ef);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_92c869c1bdf445f8c0f17651833850ef);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_92c869c1bdf445f8c0f17651833850ef);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_92c869c1bdf445f8c0f17651833850ef, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_92c869c1bdf445f8c0f17651833850ef->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_92c869c1bdf445f8c0f17651833850ef, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_92c869c1bdf445f8c0f17651833850ef,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_92c869c1bdf445f8c0f17651833850ef == cache_frame_92c869c1bdf445f8c0f17651833850ef) {
        Py_DECREF(frame_92c869c1bdf445f8c0f17651833850ef);
    }
    cache_frame_92c869c1bdf445f8c0f17651833850ef = NULL;

    assertFrameObject(frame_92c869c1bdf445f8c0f17651833850ef);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_131___ne__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_132__validate_ip_name(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_tree = python_pars[1];
    PyObject *tmp_genexpr_1__$0 = NULL;
    struct Nuitka_FrameObject *frame_6e7680fc6f0882a572f93f3695c4ac8d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_6e7680fc6f0882a572f93f3695c4ac8d = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_6e7680fc6f0882a572f93f3695c4ac8d, codeobj_6e7680fc6f0882a572f93f3695c4ac8d, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_6e7680fc6f0882a572f93f3695c4ac8d = cache_frame_6e7680fc6f0882a572f93f3695c4ac8d;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_6e7680fc6f0882a572f93f3695c4ac8d);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_6e7680fc6f0882a572f93f3695c4ac8d) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_any_arg_1;
        PyObject *tmp_capi_result_1;
        int tmp_truth_name_1;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT(par_tree);
            tmp_iter_arg_1 = par_tree;
            tmp_assign_source_1 = MAKE_ITERATOR(tmp_iter_arg_1);
            if (tmp_assign_source_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1098;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            assert(tmp_genexpr_1__$0 == NULL);
            tmp_genexpr_1__$0 = tmp_assign_source_1;
        }
        // Tried code:
        tmp_any_arg_1 = cryptography$x509$extensions$$$function_132__validate_ip_name$$$genexpr_1_genexpr_maker();

        ((struct Nuitka_GeneratorObject *)tmp_any_arg_1)->m_closure[0] = PyCell_NEW0(tmp_genexpr_1__$0);


        goto try_return_handler_1;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_132__validate_ip_name);
        return NULL;
        // Return handler code:
        try_return_handler_1:;
        CHECK_OBJECT((PyObject *)tmp_genexpr_1__$0);
        Py_DECREF(tmp_genexpr_1__$0);
        tmp_genexpr_1__$0 = NULL;

        goto outline_result_1;
        // End of try:
        CHECK_OBJECT((PyObject *)tmp_genexpr_1__$0);
        Py_DECREF(tmp_genexpr_1__$0);
        tmp_genexpr_1__$0 = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_132__validate_ip_name);
        return NULL;
        outline_result_1:;
        tmp_capi_result_1 = BUILTIN_ANY(tmp_any_arg_1);
        Py_DECREF(tmp_any_arg_1);
        if (tmp_capi_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1098;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE(tmp_capi_result_1);
        if (tmp_truth_name_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_capi_result_1);

            exception_lineno = 1098;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_capi_result_1);
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_7d42ffe02af672349902ee30e189a05b;
            frame_6e7680fc6f0882a572f93f3695c4ac8d->m_frame.f_lineno = 1101;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1101;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_6e7680fc6f0882a572f93f3695c4ac8d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_6e7680fc6f0882a572f93f3695c4ac8d);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_6e7680fc6f0882a572f93f3695c4ac8d, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_6e7680fc6f0882a572f93f3695c4ac8d->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_6e7680fc6f0882a572f93f3695c4ac8d, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6e7680fc6f0882a572f93f3695c4ac8d,
        type_description_1,
        par_self,
        par_tree
    );


    // Release cached frame.
    if (frame_6e7680fc6f0882a572f93f3695c4ac8d == cache_frame_6e7680fc6f0882a572f93f3695c4ac8d) {
        Py_DECREF(frame_6e7680fc6f0882a572f93f3695c4ac8d);
    }
    cache_frame_6e7680fc6f0882a572f93f3695c4ac8d = NULL;

    assertFrameObject(frame_6e7680fc6f0882a572f93f3695c4ac8d);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_132__validate_ip_name);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_tree);
    Py_DECREF(par_tree);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_tree);
    Py_DECREF(par_tree);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}



struct cryptography$x509$extensions$$$function_132__validate_ip_name$$$genexpr_1_genexpr_locals {
    PyObject *var_name;
    PyObject *tmp_iter_value_0;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    int tmp_res;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *cryptography$x509$extensions$$$function_132__validate_ip_name$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value ) {
    CHECK_OBJECT((PyObject *)generator);
    assert(Nuitka_Generator_Check( (PyObject *)generator ));

    // Heap access if used.
    struct cryptography$x509$extensions$$$function_132__validate_ip_name$$$genexpr_1_genexpr_locals *generator_heap = (struct cryptography$x509$extensions$$$function_132__validate_ip_name$$$genexpr_1_genexpr_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_name = NULL;
    generator_heap->tmp_iter_value_0 = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_m_frame, codeobj_7b975eeb631ffb9fcaa0a37fa763716e, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF(generator->m_frame);
    assert(Py_REFCNT(generator->m_frame) == 2); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR(generator->m_frame->m_frame.f_back);

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF(generator->m_frame->m_frame.f_back);

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF(generator->m_frame);

    Nuitka_Frame_MarkAsExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

        EXC_TYPE_F(generator) = EXC_TYPE(thread_state);
        if (EXC_TYPE_F(generator) == Py_None) EXC_TYPE_F(generator) = NULL;
        Py_XINCREF(EXC_TYPE_F(generator));
        EXC_VALUE_F(generator) = EXC_VALUE(thread_state);
        Py_XINCREF(EXC_VALUE_F(generator));
        EXC_TRACEBACK_F(generator) = EXC_TRACEBACK(thread_state);
        Py_XINCREF(EXC_TRACEBACK_F(generator));
    }

#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_1;
        CHECK_OBJECT(PyCell_GET(generator->m_closure[0]));
        tmp_next_source_1 = PyCell_GET(generator->m_closure[0]);
        tmp_assign_source_1 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_1 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);
                generator_heap->type_description_1 = "No";
                generator_heap->exception_lineno = 1098;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_iter_value_0;
            generator_heap->tmp_iter_value_0 = tmp_assign_source_1;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT(generator_heap->tmp_iter_value_0);
        tmp_assign_source_2 = generator_heap->tmp_iter_value_0;
        {
            PyObject *old = generator_heap->var_name;
            generator_heap->var_name = tmp_assign_source_2;
            Py_INCREF(generator_heap->var_name);
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_expression_name_1;
        int tmp_and_left_truth_1;
        PyObject *tmp_and_left_value_1;
        PyObject *tmp_and_right_value_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_2;
        PyObject *tmp_isinstance_cls_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_3;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        CHECK_OBJECT(generator_heap->var_name);
        tmp_isinstance_inst_1 = generator_heap->var_name;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_IPAddress);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_IPAddress);
        }

        if (tmp_mvar_value_1 == NULL) {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF(generator_heap->exception_type);
            generator_heap->exception_value = UNSTREAM_STRING(&constant_bin[ 37290 ], 38, 0);
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 1098;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        generator_heap->tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (generator_heap->tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 1098;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_and_left_value_1 = (generator_heap->tmp_res != 0) ? Py_True : Py_False;
        tmp_and_left_truth_1 = CHECK_IF_TRUE(tmp_and_left_value_1);
        if (tmp_and_left_truth_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 1098;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        if (tmp_and_left_truth_1 == 1) {
            goto and_right_1;
        } else {
            goto and_left_1;
        }
        and_right_1:;
        CHECK_OBJECT(generator_heap->var_name);
        tmp_source_name_1 = generator_heap->var_name;
        tmp_isinstance_inst_2 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_value);
        if (tmp_isinstance_inst_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 1099;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ipaddress);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ipaddress);
        }

        if (tmp_mvar_value_2 == NULL) {
            Py_DECREF(tmp_isinstance_inst_2);
            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF(generator_heap->exception_type);
            generator_heap->exception_value = UNSTREAM_STRING(&constant_bin[ 23229 ], 38, 0);
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 1099;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_IPv4Network);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);
            Py_DECREF(tmp_isinstance_inst_2);

            generator_heap->exception_lineno = 1099;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_isinstance_cls_2 = PyTuple_New(2);
        PyTuple_SET_ITEM(tmp_isinstance_cls_2, 0, tmp_tuple_element_1);
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ipaddress);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ipaddress);
        }

        if (tmp_mvar_value_3 == NULL) {
            Py_DECREF(tmp_isinstance_inst_2);
            Py_DECREF(tmp_isinstance_cls_2);
            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF(generator_heap->exception_type);
            generator_heap->exception_value = UNSTREAM_STRING(&constant_bin[ 23229 ], 38, 0);
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 1099;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }

        tmp_source_name_3 = tmp_mvar_value_3;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_IPv6Network);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);
            Py_DECREF(tmp_isinstance_inst_2);
            Py_DECREF(tmp_isinstance_cls_2);

            generator_heap->exception_lineno = 1099;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        PyTuple_SET_ITEM(tmp_isinstance_cls_2, 1, tmp_tuple_element_1);
        generator_heap->tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_2, tmp_isinstance_cls_2);
        Py_DECREF(tmp_isinstance_inst_2);
        Py_DECREF(tmp_isinstance_cls_2);
        if (generator_heap->tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 1098;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_operand_name_1 = (generator_heap->tmp_res != 0) ? Py_True : Py_False;
        generator_heap->tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (generator_heap->tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 1098;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_and_right_value_1 = (generator_heap->tmp_res == 0) ? Py_True : Py_False;
        tmp_expression_name_1 = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_expression_name_1 = tmp_and_left_value_1;
        and_end_1:;
        Py_INCREF(tmp_expression_name_1);
        Nuitka_PreserveHeap(generator_heap->yield_tmps, &tmp_and_left_truth_1, sizeof(int), &tmp_and_left_value_1, sizeof(PyObject *), &tmp_and_right_value_1, sizeof(PyObject *), &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), &tmp_operand_name_1, sizeof(PyObject *), &tmp_isinstance_inst_2, sizeof(PyObject *), &tmp_isinstance_cls_2, sizeof(PyObject *), &tmp_source_name_1, sizeof(PyObject *), &tmp_tuple_element_1, sizeof(PyObject *), &tmp_source_name_2, sizeof(PyObject *), &tmp_mvar_value_2, sizeof(PyObject *), &tmp_source_name_3, sizeof(PyObject *), &tmp_mvar_value_3, sizeof(PyObject *), NULL);
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        Nuitka_RestoreHeap(generator_heap->yield_tmps, &tmp_and_left_truth_1, sizeof(int), &tmp_and_left_value_1, sizeof(PyObject *), &tmp_and_right_value_1, sizeof(PyObject *), &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), &tmp_operand_name_1, sizeof(PyObject *), &tmp_isinstance_inst_2, sizeof(PyObject *), &tmp_isinstance_cls_2, sizeof(PyObject *), &tmp_source_name_1, sizeof(PyObject *), &tmp_tuple_element_1, sizeof(PyObject *), &tmp_source_name_2, sizeof(PyObject *), &tmp_mvar_value_2, sizeof(PyObject *), &tmp_source_name_3, sizeof(PyObject *), &tmp_mvar_value_3, sizeof(PyObject *), NULL);
        if (yield_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 1098;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


        generator_heap->exception_lineno = 1098;
        generator_heap->type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    // Allow re-use of the frame again.
    Py_DECREF(generator->m_frame);
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if (!EXCEPTION_MATCH_GENERATOR(generator_heap->exception_type)) {
        if (generator_heap->exception_tb == NULL) {
            generator_heap->exception_tb = MAKE_TRACEBACK(generator->m_frame, generator_heap->exception_lineno);
        } else if (generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame) {
            generator_heap->exception_tb = ADD_TRACEBACK(generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno);
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            NULL,
            generator_heap->var_name
        );


        // Release cached frame.
        if (generator->m_frame == cache_m_frame) {
            Py_DECREF(generator->m_frame);
        }
        cache_m_frame = NULL;

        assertFrameObject(generator->m_frame);
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    Py_DECREF(generator->m_frame);

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->var_name);
    generator_heap->var_name = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    Py_XDECREF(generator_heap->var_name);
    generator_heap->var_name = NULL;



    return NULL;

    function_exception_exit:
    assert(generator_heap->exception_type);
    RESTORE_ERROR_OCCURRED(generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb);

    return NULL;

}

static PyObject *cryptography$x509$extensions$$$function_132__validate_ip_name$$$genexpr_1_genexpr_maker(void) {
    return Nuitka_Generator_New(
        cryptography$x509$extensions$$$function_132__validate_ip_name$$$genexpr_1_genexpr_context,
        module_cryptography$x509$extensions,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_7b975eeb631ffb9fcaa0a37fa763716e,
        1,
        sizeof(struct cryptography$x509$extensions$$$function_132__validate_ip_name$$$genexpr_1_genexpr_locals)
    );
}


static PyObject *impl_cryptography$x509$extensions$$$function_133___repr__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_c5572338dcd2f002feb76dcfbb9e1d18;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_c5572338dcd2f002feb76dcfbb9e1d18 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_c5572338dcd2f002feb76dcfbb9e1d18, codeobj_c5572338dcd2f002feb76dcfbb9e1d18, module_cryptography$x509$extensions, sizeof(void *));
    frame_c5572338dcd2f002feb76dcfbb9e1d18 = cache_frame_c5572338dcd2f002feb76dcfbb9e1d18;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_c5572338dcd2f002feb76dcfbb9e1d18);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_c5572338dcd2f002feb76dcfbb9e1d18) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        tmp_called_instance_1 = const_unicode_digest_91632884773c30442b9e2ac13e53950d;
        CHECK_OBJECT(par_self);
        tmp_args_element_name_1 = par_self;
        frame_c5572338dcd2f002feb76dcfbb9e1d18->m_frame.f_lineno = 1108;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_format, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1108;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c5572338dcd2f002feb76dcfbb9e1d18);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_c5572338dcd2f002feb76dcfbb9e1d18);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c5572338dcd2f002feb76dcfbb9e1d18);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_c5572338dcd2f002feb76dcfbb9e1d18, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_c5572338dcd2f002feb76dcfbb9e1d18->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_c5572338dcd2f002feb76dcfbb9e1d18, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c5572338dcd2f002feb76dcfbb9e1d18,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_c5572338dcd2f002feb76dcfbb9e1d18 == cache_frame_c5572338dcd2f002feb76dcfbb9e1d18) {
        Py_DECREF(frame_c5572338dcd2f002feb76dcfbb9e1d18);
    }
    cache_frame_c5572338dcd2f002feb76dcfbb9e1d18 = NULL;

    assertFrameObject(frame_c5572338dcd2f002feb76dcfbb9e1d18);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_133___repr__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_134___hash__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_ps = NULL;
    PyObject *var_es = NULL;
    struct Nuitka_FrameObject *frame_f3eeb900b76619b4244a734caee1b5b1;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_f3eeb900b76619b4244a734caee1b5b1 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_f3eeb900b76619b4244a734caee1b5b1, codeobj_f3eeb900b76619b4244a734caee1b5b1, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_f3eeb900b76619b4244a734caee1b5b1 = cache_frame_f3eeb900b76619b4244a734caee1b5b1;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_f3eeb900b76619b4244a734caee1b5b1);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_f3eeb900b76619b4244a734caee1b5b1) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_permitted_subtrees);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1113;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 != tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_compexpr_left_1);
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_tuple_arg_1;
            PyObject *tmp_source_name_2;
            CHECK_OBJECT(par_self);
            tmp_source_name_2 = par_self;
            tmp_tuple_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_permitted_subtrees);
            if (tmp_tuple_arg_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1114;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_assign_source_1 = PySequence_Tuple(tmp_tuple_arg_1);
            Py_DECREF(tmp_tuple_arg_1);
            if (tmp_assign_source_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1114;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            assert(var_ps == NULL);
            var_ps = tmp_assign_source_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_2;
            tmp_assign_source_2 = Py_None;
            assert(var_ps == NULL);
            Py_INCREF(tmp_assign_source_2);
            var_ps = tmp_assign_source_2;
        }
        branch_end_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_3;
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_excluded_subtrees);
        if (tmp_compexpr_left_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1118;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_2 = Py_None;
        tmp_condition_result_2 = (tmp_compexpr_left_2 != tmp_compexpr_right_2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_compexpr_left_2);
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_tuple_arg_2;
            PyObject *tmp_source_name_4;
            CHECK_OBJECT(par_self);
            tmp_source_name_4 = par_self;
            tmp_tuple_arg_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_excluded_subtrees);
            if (tmp_tuple_arg_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1119;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_assign_source_3 = PySequence_Tuple(tmp_tuple_arg_2);
            Py_DECREF(tmp_tuple_arg_2);
            if (tmp_assign_source_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1119;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            assert(var_es == NULL);
            var_es = tmp_assign_source_3;
        }
        goto branch_end_2;
        branch_no_2:;
        {
            PyObject *tmp_assign_source_4;
            tmp_assign_source_4 = Py_None;
            assert(var_es == NULL);
            Py_INCREF(tmp_assign_source_4);
            var_es = tmp_assign_source_4;
        }
        branch_end_2:;
    }
    {
        PyObject *tmp_hash_arg_1;
        PyObject *tmp_tuple_element_1;
        CHECK_OBJECT(var_ps);
        tmp_tuple_element_1 = var_ps;
        tmp_hash_arg_1 = PyTuple_New(2);
        Py_INCREF(tmp_tuple_element_1);
        PyTuple_SET_ITEM(tmp_hash_arg_1, 0, tmp_tuple_element_1);
        CHECK_OBJECT(var_es);
        tmp_tuple_element_1 = var_es;
        Py_INCREF(tmp_tuple_element_1);
        PyTuple_SET_ITEM(tmp_hash_arg_1, 1, tmp_tuple_element_1);
        tmp_return_value = BUILTIN_HASH(tmp_hash_arg_1);
        Py_DECREF(tmp_hash_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1123;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_f3eeb900b76619b4244a734caee1b5b1);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_f3eeb900b76619b4244a734caee1b5b1);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_f3eeb900b76619b4244a734caee1b5b1);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_f3eeb900b76619b4244a734caee1b5b1, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_f3eeb900b76619b4244a734caee1b5b1->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_f3eeb900b76619b4244a734caee1b5b1, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f3eeb900b76619b4244a734caee1b5b1,
        type_description_1,
        par_self,
        var_ps,
        var_es
    );


    // Release cached frame.
    if (frame_f3eeb900b76619b4244a734caee1b5b1 == cache_frame_f3eeb900b76619b4244a734caee1b5b1) {
        Py_DECREF(frame_f3eeb900b76619b4244a734caee1b5b1);
    }
    cache_frame_f3eeb900b76619b4244a734caee1b5b1 = NULL;

    assertFrameObject(frame_f3eeb900b76619b4244a734caee1b5b1);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_134___hash__);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_ps);
    Py_DECREF(var_ps);
    var_ps = NULL;

    CHECK_OBJECT((PyObject *)var_es);
    Py_DECREF(var_es);
    var_es = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_ps);
    var_ps = NULL;

    Py_XDECREF(var_es);
    var_es = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_134___hash__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_135___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_oid = python_pars[1];
    PyObject *par_critical = python_pars[2];
    PyObject *par_value = python_pars[3];
    struct Nuitka_FrameObject *frame_8b50f1443742e7df185a6bfdd7fc3d1f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_8b50f1443742e7df185a6bfdd7fc3d1f = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_8b50f1443742e7df185a6bfdd7fc3d1f, codeobj_8b50f1443742e7df185a6bfdd7fc3d1f, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_8b50f1443742e7df185a6bfdd7fc3d1f = cache_frame_8b50f1443742e7df185a6bfdd7fc3d1f;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_8b50f1443742e7df185a6bfdd7fc3d1f);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_8b50f1443742e7df185a6bfdd7fc3d1f) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_oid);
        tmp_isinstance_inst_1 = par_oid;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ObjectIdentifier);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ObjectIdentifier);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 18374 ], 45, 0);
            exception_tb = NULL;

            exception_lineno = 1131;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1131;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1131;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_d8b4cb10b00d6765b713cf768245d18d;
            frame_8b50f1443742e7df185a6bfdd7fc3d1f->m_frame.f_lineno = 1132;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1132;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_2;
        PyObject *tmp_isinstance_inst_2;
        PyObject *tmp_isinstance_cls_2;
        CHECK_OBJECT(par_critical);
        tmp_isinstance_inst_2 = par_critical;
        tmp_isinstance_cls_2 = (PyObject *)&PyBool_Type;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_2, tmp_isinstance_cls_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1136;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_2 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1136;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            tmp_make_exception_arg_2 = const_str_digest_1961eae2d00689b393091e3fc681acbe;
            frame_8b50f1443742e7df185a6bfdd7fc3d1f->m_frame.f_lineno = 1137;
            tmp_raise_type_2 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_2);
            assert(!(tmp_raise_type_2 == NULL));
            exception_type = tmp_raise_type_2;
            exception_lineno = 1137;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_oid);
        tmp_assattr_name_1 = par_oid;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__oid, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1139;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT(par_critical);
        tmp_assattr_name_2 = par_critical;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain__critical, tmp_assattr_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1140;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_assattr_target_3;
        CHECK_OBJECT(par_value);
        tmp_assattr_name_3 = par_value;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_3 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_3, const_str_plain__value, tmp_assattr_name_3);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1141;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8b50f1443742e7df185a6bfdd7fc3d1f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8b50f1443742e7df185a6bfdd7fc3d1f);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_8b50f1443742e7df185a6bfdd7fc3d1f, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_8b50f1443742e7df185a6bfdd7fc3d1f->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_8b50f1443742e7df185a6bfdd7fc3d1f, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8b50f1443742e7df185a6bfdd7fc3d1f,
        type_description_1,
        par_self,
        par_oid,
        par_critical,
        par_value
    );


    // Release cached frame.
    if (frame_8b50f1443742e7df185a6bfdd7fc3d1f == cache_frame_8b50f1443742e7df185a6bfdd7fc3d1f) {
        Py_DECREF(frame_8b50f1443742e7df185a6bfdd7fc3d1f);
    }
    cache_frame_8b50f1443742e7df185a6bfdd7fc3d1f = NULL;

    assertFrameObject(frame_8b50f1443742e7df185a6bfdd7fc3d1f);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_135___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_oid);
    Py_DECREF(par_oid);
    CHECK_OBJECT(par_critical);
    Py_DECREF(par_critical);
    CHECK_OBJECT(par_value);
    Py_DECREF(par_value);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_oid);
    Py_DECREF(par_oid);
    CHECK_OBJECT(par_critical);
    Py_DECREF(par_critical);
    CHECK_OBJECT(par_value);
    Py_DECREF(par_value);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_136___repr__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_2032aff2dcfd5f708972757a2c967882;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_2032aff2dcfd5f708972757a2c967882 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_2032aff2dcfd5f708972757a2c967882, codeobj_2032aff2dcfd5f708972757a2c967882, module_cryptography$x509$extensions, sizeof(void *));
    frame_2032aff2dcfd5f708972757a2c967882 = cache_frame_2032aff2dcfd5f708972757a2c967882;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_2032aff2dcfd5f708972757a2c967882);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_2032aff2dcfd5f708972757a2c967882) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        tmp_called_instance_1 = const_str_digest_15f4645c15394598b5ad3d887ad62f4a;
        CHECK_OBJECT(par_self);
        tmp_args_element_name_1 = par_self;
        frame_2032aff2dcfd5f708972757a2c967882->m_frame.f_lineno = 1148;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_format, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1148;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2032aff2dcfd5f708972757a2c967882);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_2032aff2dcfd5f708972757a2c967882);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2032aff2dcfd5f708972757a2c967882);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_2032aff2dcfd5f708972757a2c967882, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_2032aff2dcfd5f708972757a2c967882->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_2032aff2dcfd5f708972757a2c967882, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2032aff2dcfd5f708972757a2c967882,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_2032aff2dcfd5f708972757a2c967882 == cache_frame_2032aff2dcfd5f708972757a2c967882) {
        Py_DECREF(frame_2032aff2dcfd5f708972757a2c967882);
    }
    cache_frame_2032aff2dcfd5f708972757a2c967882 = NULL;

    assertFrameObject(frame_2032aff2dcfd5f708972757a2c967882);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_136___repr__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_137___eq__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_c27b0e8e5456bfa1ce1df12003e5c214;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_c27b0e8e5456bfa1ce1df12003e5c214 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_c27b0e8e5456bfa1ce1df12003e5c214, codeobj_c27b0e8e5456bfa1ce1df12003e5c214, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_c27b0e8e5456bfa1ce1df12003e5c214 = cache_frame_c27b0e8e5456bfa1ce1df12003e5c214;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_c27b0e8e5456bfa1ce1df12003e5c214);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_c27b0e8e5456bfa1ce1df12003e5c214) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_other);
        tmp_isinstance_inst_1 = par_other;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_Extension);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_Extension);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 35519 ], 38, 0);
            exception_tb = NULL;

            exception_lineno = 1152;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1152;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1152;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        int tmp_and_left_truth_1;
        PyObject *tmp_and_left_value_1;
        PyObject *tmp_and_right_value_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        int tmp_and_left_truth_2;
        PyObject *tmp_and_left_value_2;
        PyObject *tmp_and_right_value_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_source_name_4;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_source_name_5;
        PyObject *tmp_source_name_6;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_oid);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1156;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_2 = par_other;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_oid);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_1);

            exception_lineno = 1156;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_and_left_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1156;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_truth_1 = CHECK_IF_TRUE(tmp_and_left_value_1);
        if (tmp_and_left_truth_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_and_left_value_1);

            exception_lineno = 1158;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        if (tmp_and_left_truth_1 == 1) {
            goto and_right_1;
        } else {
            goto and_left_1;
        }
        and_right_1:;
        Py_DECREF(tmp_and_left_value_1);
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_critical);
        if (tmp_compexpr_left_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1157;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_4 = par_other;
        tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_critical);
        if (tmp_compexpr_right_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_2);

            exception_lineno = 1157;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_2 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
        Py_DECREF(tmp_compexpr_left_2);
        Py_DECREF(tmp_compexpr_right_2);
        if (tmp_and_left_value_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1157;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_truth_2 = CHECK_IF_TRUE(tmp_and_left_value_2);
        if (tmp_and_left_truth_2 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_and_left_value_2);

            exception_lineno = 1158;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        if (tmp_and_left_truth_2 == 1) {
            goto and_right_2;
        } else {
            goto and_left_2;
        }
        and_right_2:;
        Py_DECREF(tmp_and_left_value_2);
        CHECK_OBJECT(par_self);
        tmp_source_name_5 = par_self;
        tmp_compexpr_left_3 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_value);
        if (tmp_compexpr_left_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1158;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_6 = par_other;
        tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_value);
        if (tmp_compexpr_right_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_3);

            exception_lineno = 1158;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_2 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_3, tmp_compexpr_right_3);
        Py_DECREF(tmp_compexpr_left_3);
        Py_DECREF(tmp_compexpr_right_3);
        if (tmp_and_right_value_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1158;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = tmp_and_right_value_2;
        goto and_end_2;
        and_left_2:;
        tmp_and_right_value_1 = tmp_and_left_value_2;
        and_end_2:;
        tmp_return_value = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_return_value = tmp_and_left_value_1;
        and_end_1:;
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c27b0e8e5456bfa1ce1df12003e5c214);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_c27b0e8e5456bfa1ce1df12003e5c214);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c27b0e8e5456bfa1ce1df12003e5c214);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_c27b0e8e5456bfa1ce1df12003e5c214, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_c27b0e8e5456bfa1ce1df12003e5c214->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_c27b0e8e5456bfa1ce1df12003e5c214, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c27b0e8e5456bfa1ce1df12003e5c214,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_c27b0e8e5456bfa1ce1df12003e5c214 == cache_frame_c27b0e8e5456bfa1ce1df12003e5c214) {
        Py_DECREF(frame_c27b0e8e5456bfa1ce1df12003e5c214);
    }
    cache_frame_c27b0e8e5456bfa1ce1df12003e5c214 = NULL;

    assertFrameObject(frame_c27b0e8e5456bfa1ce1df12003e5c214);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_137___eq__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_138___ne__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_67946727c71fd992c6c0b992e68c9b62;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_67946727c71fd992c6c0b992e68c9b62 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_67946727c71fd992c6c0b992e68c9b62, codeobj_67946727c71fd992c6c0b992e68c9b62, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_67946727c71fd992c6c0b992e68c9b62 = cache_frame_67946727c71fd992c6c0b992e68c9b62;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_67946727c71fd992c6c0b992e68c9b62);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_67946727c71fd992c6c0b992e68c9b62) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_self);
        tmp_compexpr_left_1 = par_self;
        CHECK_OBJECT(par_other);
        tmp_compexpr_right_1 = par_other;
        tmp_operand_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1162;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1162;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = (tmp_res == 0) ? Py_True : Py_False;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_67946727c71fd992c6c0b992e68c9b62);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_67946727c71fd992c6c0b992e68c9b62);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_67946727c71fd992c6c0b992e68c9b62);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_67946727c71fd992c6c0b992e68c9b62, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_67946727c71fd992c6c0b992e68c9b62->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_67946727c71fd992c6c0b992e68c9b62, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_67946727c71fd992c6c0b992e68c9b62,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_67946727c71fd992c6c0b992e68c9b62 == cache_frame_67946727c71fd992c6c0b992e68c9b62) {
        Py_DECREF(frame_67946727c71fd992c6c0b992e68c9b62);
    }
    cache_frame_67946727c71fd992c6c0b992e68c9b62 = NULL;

    assertFrameObject(frame_67946727c71fd992c6c0b992e68c9b62);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_138___ne__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_139___hash__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_6f49f5cfd885de7a42467f04151c4e4a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_6f49f5cfd885de7a42467f04151c4e4a = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_6f49f5cfd885de7a42467f04151c4e4a, codeobj_6f49f5cfd885de7a42467f04151c4e4a, module_cryptography$x509$extensions, sizeof(void *));
    frame_6f49f5cfd885de7a42467f04151c4e4a = cache_frame_6f49f5cfd885de7a42467f04151c4e4a;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_6f49f5cfd885de7a42467f04151c4e4a);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_6f49f5cfd885de7a42467f04151c4e4a) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_hash_arg_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_source_name_3;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_oid);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1165;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_hash_arg_1 = PyTuple_New(3);
        PyTuple_SET_ITEM(tmp_hash_arg_1, 0, tmp_tuple_element_1);
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_critical);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_hash_arg_1);

            exception_lineno = 1165;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM(tmp_hash_arg_1, 1, tmp_tuple_element_1);
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_value);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_hash_arg_1);

            exception_lineno = 1165;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM(tmp_hash_arg_1, 2, tmp_tuple_element_1);
        tmp_return_value = BUILTIN_HASH(tmp_hash_arg_1);
        Py_DECREF(tmp_hash_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1165;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_6f49f5cfd885de7a42467f04151c4e4a);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_6f49f5cfd885de7a42467f04151c4e4a);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_6f49f5cfd885de7a42467f04151c4e4a);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_6f49f5cfd885de7a42467f04151c4e4a, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_6f49f5cfd885de7a42467f04151c4e4a->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_6f49f5cfd885de7a42467f04151c4e4a, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6f49f5cfd885de7a42467f04151c4e4a,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_6f49f5cfd885de7a42467f04151c4e4a == cache_frame_6f49f5cfd885de7a42467f04151c4e4a) {
        Py_DECREF(frame_6f49f5cfd885de7a42467f04151c4e4a);
    }
    cache_frame_6f49f5cfd885de7a42467f04151c4e4a = NULL;

    assertFrameObject(frame_6f49f5cfd885de7a42467f04151c4e4a);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_139___hash__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_140___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_general_names = python_pars[1];
    PyObject *tmp_genexpr_1__$0 = NULL;
    struct Nuitka_FrameObject *frame_0c8e1253c96407b45c539de5f50b8b44;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_0c8e1253c96407b45c539de5f50b8b44 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_0c8e1253c96407b45c539de5f50b8b44, codeobj_0c8e1253c96407b45c539de5f50b8b44, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_0c8e1253c96407b45c539de5f50b8b44 = cache_frame_0c8e1253c96407b45c539de5f50b8b44;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_0c8e1253c96407b45c539de5f50b8b44);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_0c8e1253c96407b45c539de5f50b8b44) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_list_arg_1;
        CHECK_OBJECT(par_general_names);
        tmp_list_arg_1 = par_general_names;
        tmp_assign_source_1 = PySequence_List(tmp_list_arg_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1170;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = par_general_names;
            assert(old != NULL);
            par_general_names = tmp_assign_source_1;
            Py_DECREF(old);
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_all_arg_1;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT(par_general_names);
            tmp_iter_arg_1 = par_general_names;
            tmp_assign_source_2 = MAKE_ITERATOR(tmp_iter_arg_1);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1171;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            assert(tmp_genexpr_1__$0 == NULL);
            tmp_genexpr_1__$0 = tmp_assign_source_2;
        }
        // Tried code:
        tmp_all_arg_1 = cryptography$x509$extensions$$$function_140___init__$$$genexpr_1_genexpr_maker();

        ((struct Nuitka_GeneratorObject *)tmp_all_arg_1)->m_closure[0] = PyCell_NEW0(tmp_genexpr_1__$0);


        goto try_return_handler_2;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_140___init__);
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        CHECK_OBJECT((PyObject *)tmp_genexpr_1__$0);
        Py_DECREF(tmp_genexpr_1__$0);
        tmp_genexpr_1__$0 = NULL;

        goto outline_result_1;
        // End of try:
        CHECK_OBJECT((PyObject *)tmp_genexpr_1__$0);
        Py_DECREF(tmp_genexpr_1__$0);
        tmp_genexpr_1__$0 = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_140___init__);
        return NULL;
        outline_result_1:;
        tmp_operand_name_1 = BUILTIN_ALL(tmp_all_arg_1);
        Py_DECREF(tmp_all_arg_1);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1171;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1171;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_2622a0002f5b5df69415ebf4bce9a343;
            frame_0c8e1253c96407b45c539de5f50b8b44->m_frame.f_lineno = 1172;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1172;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_general_names);
        tmp_assattr_name_1 = par_general_names;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__general_names, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1177;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0c8e1253c96407b45c539de5f50b8b44);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0c8e1253c96407b45c539de5f50b8b44);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_0c8e1253c96407b45c539de5f50b8b44, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_0c8e1253c96407b45c539de5f50b8b44->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_0c8e1253c96407b45c539de5f50b8b44, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0c8e1253c96407b45c539de5f50b8b44,
        type_description_1,
        par_self,
        par_general_names
    );


    // Release cached frame.
    if (frame_0c8e1253c96407b45c539de5f50b8b44 == cache_frame_0c8e1253c96407b45c539de5f50b8b44) {
        Py_DECREF(frame_0c8e1253c96407b45c539de5f50b8b44);
    }
    cache_frame_0c8e1253c96407b45c539de5f50b8b44 = NULL;

    assertFrameObject(frame_0c8e1253c96407b45c539de5f50b8b44);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_140___init__);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)par_general_names);
    Py_DECREF(par_general_names);
    par_general_names = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)par_general_names);
    Py_DECREF(par_general_names);
    par_general_names = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_140___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}



struct cryptography$x509$extensions$$$function_140___init__$$$genexpr_1_genexpr_locals {
    PyObject *var_x;
    PyObject *tmp_iter_value_0;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    int tmp_res;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *cryptography$x509$extensions$$$function_140___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value ) {
    CHECK_OBJECT((PyObject *)generator);
    assert(Nuitka_Generator_Check( (PyObject *)generator ));

    // Heap access if used.
    struct cryptography$x509$extensions$$$function_140___init__$$$genexpr_1_genexpr_locals *generator_heap = (struct cryptography$x509$extensions$$$function_140___init__$$$genexpr_1_genexpr_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_x = NULL;
    generator_heap->tmp_iter_value_0 = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_m_frame, codeobj_649d76a7830e746a0a26b7e9c621710f, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF(generator->m_frame);
    assert(Py_REFCNT(generator->m_frame) == 2); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR(generator->m_frame->m_frame.f_back);

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF(generator->m_frame->m_frame.f_back);

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF(generator->m_frame);

    Nuitka_Frame_MarkAsExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

        EXC_TYPE_F(generator) = EXC_TYPE(thread_state);
        if (EXC_TYPE_F(generator) == Py_None) EXC_TYPE_F(generator) = NULL;
        Py_XINCREF(EXC_TYPE_F(generator));
        EXC_VALUE_F(generator) = EXC_VALUE(thread_state);
        Py_XINCREF(EXC_VALUE_F(generator));
        EXC_TRACEBACK_F(generator) = EXC_TRACEBACK(thread_state);
        Py_XINCREF(EXC_TRACEBACK_F(generator));
    }

#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_1;
        CHECK_OBJECT(PyCell_GET(generator->m_closure[0]));
        tmp_next_source_1 = PyCell_GET(generator->m_closure[0]);
        tmp_assign_source_1 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_1 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);
                generator_heap->type_description_1 = "No";
                generator_heap->exception_lineno = 1171;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_iter_value_0;
            generator_heap->tmp_iter_value_0 = tmp_assign_source_1;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT(generator_heap->tmp_iter_value_0);
        tmp_assign_source_2 = generator_heap->tmp_iter_value_0;
        {
            PyObject *old = generator_heap->var_x;
            generator_heap->var_x = tmp_assign_source_2;
            Py_INCREF(generator_heap->var_x);
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_expression_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        CHECK_OBJECT(generator_heap->var_x);
        tmp_isinstance_inst_1 = generator_heap->var_x;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_GeneralName);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_GeneralName);
        }

        if (tmp_mvar_value_1 == NULL) {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF(generator_heap->exception_type);
            generator_heap->exception_value = UNSTREAM_STRING(&constant_bin[ 36192 ], 40, 0);
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 1171;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        generator_heap->tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (generator_heap->tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 1171;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_expression_name_1 = (generator_heap->tmp_res != 0) ? Py_True : Py_False;
        Py_INCREF(tmp_expression_name_1);
        Nuitka_PreserveHeap(generator_heap->yield_tmps, &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), NULL);
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        Nuitka_RestoreHeap(generator_heap->yield_tmps, &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), NULL);
        if (yield_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 1171;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


        generator_heap->exception_lineno = 1171;
        generator_heap->type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    // Allow re-use of the frame again.
    Py_DECREF(generator->m_frame);
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if (!EXCEPTION_MATCH_GENERATOR(generator_heap->exception_type)) {
        if (generator_heap->exception_tb == NULL) {
            generator_heap->exception_tb = MAKE_TRACEBACK(generator->m_frame, generator_heap->exception_lineno);
        } else if (generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame) {
            generator_heap->exception_tb = ADD_TRACEBACK(generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno);
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            NULL,
            generator_heap->var_x
        );


        // Release cached frame.
        if (generator->m_frame == cache_m_frame) {
            Py_DECREF(generator->m_frame);
        }
        cache_m_frame = NULL;

        assertFrameObject(generator->m_frame);
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    Py_DECREF(generator->m_frame);

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->var_x);
    generator_heap->var_x = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    Py_XDECREF(generator_heap->var_x);
    generator_heap->var_x = NULL;



    return NULL;

    function_exception_exit:
    assert(generator_heap->exception_type);
    RESTORE_ERROR_OCCURRED(generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb);

    return NULL;

}

static PyObject *cryptography$x509$extensions$$$function_140___init__$$$genexpr_1_genexpr_maker(void) {
    return Nuitka_Generator_New(
        cryptography$x509$extensions$$$function_140___init__$$$genexpr_1_genexpr_context,
        module_cryptography$x509$extensions,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_649d76a7830e746a0a26b7e9c621710f,
        1,
        sizeof(struct cryptography$x509$extensions$$$function_140___init__$$$genexpr_1_genexpr_locals)
    );
}


static PyObject *impl_cryptography$x509$extensions$$$function_141___iter__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_e3238b208fe2e5d2a45d1c96985f203f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_e3238b208fe2e5d2a45d1c96985f203f = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_e3238b208fe2e5d2a45d1c96985f203f, codeobj_e3238b208fe2e5d2a45d1c96985f203f, module_cryptography$x509$extensions, sizeof(void *));
    frame_e3238b208fe2e5d2a45d1c96985f203f = cache_frame_e3238b208fe2e5d2a45d1c96985f203f;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_e3238b208fe2e5d2a45d1c96985f203f);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_e3238b208fe2e5d2a45d1c96985f203f) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_iter_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__general_names);
        if (tmp_iter_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1180;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = MAKE_ITERATOR(tmp_iter_arg_1);
        Py_DECREF(tmp_iter_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1180;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e3238b208fe2e5d2a45d1c96985f203f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_e3238b208fe2e5d2a45d1c96985f203f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e3238b208fe2e5d2a45d1c96985f203f);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_e3238b208fe2e5d2a45d1c96985f203f, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_e3238b208fe2e5d2a45d1c96985f203f->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_e3238b208fe2e5d2a45d1c96985f203f, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e3238b208fe2e5d2a45d1c96985f203f,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_e3238b208fe2e5d2a45d1c96985f203f == cache_frame_e3238b208fe2e5d2a45d1c96985f203f) {
        Py_DECREF(frame_e3238b208fe2e5d2a45d1c96985f203f);
    }
    cache_frame_e3238b208fe2e5d2a45d1c96985f203f = NULL;

    assertFrameObject(frame_e3238b208fe2e5d2a45d1c96985f203f);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_141___iter__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_142___len__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_8d9e40c8cfaba60d1272553c00ff35ed;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_8d9e40c8cfaba60d1272553c00ff35ed = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_8d9e40c8cfaba60d1272553c00ff35ed, codeobj_8d9e40c8cfaba60d1272553c00ff35ed, module_cryptography$x509$extensions, sizeof(void *));
    frame_8d9e40c8cfaba60d1272553c00ff35ed = cache_frame_8d9e40c8cfaba60d1272553c00ff35ed;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_8d9e40c8cfaba60d1272553c00ff35ed);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_8d9e40c8cfaba60d1272553c00ff35ed) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_len_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_len_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__general_names);
        if (tmp_len_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1183;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = BUILTIN_LEN(tmp_len_arg_1);
        Py_DECREF(tmp_len_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1183;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8d9e40c8cfaba60d1272553c00ff35ed);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_8d9e40c8cfaba60d1272553c00ff35ed);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8d9e40c8cfaba60d1272553c00ff35ed);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_8d9e40c8cfaba60d1272553c00ff35ed, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_8d9e40c8cfaba60d1272553c00ff35ed->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_8d9e40c8cfaba60d1272553c00ff35ed, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8d9e40c8cfaba60d1272553c00ff35ed,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_8d9e40c8cfaba60d1272553c00ff35ed == cache_frame_8d9e40c8cfaba60d1272553c00ff35ed) {
        Py_DECREF(frame_8d9e40c8cfaba60d1272553c00ff35ed);
    }
    cache_frame_8d9e40c8cfaba60d1272553c00ff35ed = NULL;

    assertFrameObject(frame_8d9e40c8cfaba60d1272553c00ff35ed);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_142___len__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_143_get_values_for_type(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_CellObject *par_type = PyCell_NEW1(python_pars[1]);
    PyObject *var_objs = NULL;
    PyObject *tmp_genexpr_1__$0 = NULL;
    PyObject *tmp_genexpr_2__$0 = NULL;
    struct Nuitka_FrameObject *frame_be19316fadb8714fcba11591040e6359;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_be19316fadb8714fcba11591040e6359 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_be19316fadb8714fcba11591040e6359, codeobj_be19316fadb8714fcba11591040e6359, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_be19316fadb8714fcba11591040e6359 = cache_frame_be19316fadb8714fcba11591040e6359;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_be19316fadb8714fcba11591040e6359);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_be19316fadb8714fcba11591040e6359) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT(par_self);
            tmp_iter_arg_1 = par_self;
            tmp_assign_source_2 = MAKE_ITERATOR(tmp_iter_arg_1);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1189;
                type_description_1 = "oco";
                goto frame_exception_exit_1;
            }
            assert(tmp_genexpr_1__$0 == NULL);
            tmp_genexpr_1__$0 = tmp_assign_source_2;
        }
        // Tried code:
        tmp_assign_source_1 = cryptography$x509$extensions$$$function_143_get_values_for_type$$$genexpr_1_genexpr_maker();

        ((struct Nuitka_GeneratorObject *)tmp_assign_source_1)->m_closure[0] = PyCell_NEW0(tmp_genexpr_1__$0);
        ((struct Nuitka_GeneratorObject *)tmp_assign_source_1)->m_closure[1] = par_type;
        Py_INCREF(((struct Nuitka_GeneratorObject *)tmp_assign_source_1)->m_closure[1]);


        goto try_return_handler_2;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_143_get_values_for_type);
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        CHECK_OBJECT((PyObject *)tmp_genexpr_1__$0);
        Py_DECREF(tmp_genexpr_1__$0);
        tmp_genexpr_1__$0 = NULL;

        goto outline_result_1;
        // End of try:
        CHECK_OBJECT((PyObject *)tmp_genexpr_1__$0);
        Py_DECREF(tmp_genexpr_1__$0);
        tmp_genexpr_1__$0 = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_143_get_values_for_type);
        return NULL;
        outline_result_1:;
        assert(var_objs == NULL);
        var_objs = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(PyCell_GET(par_type));
        tmp_compexpr_left_1 = PyCell_GET(par_type);
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_OtherName);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_OtherName);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 37328 ], 38, 0);
            exception_tb = NULL;

            exception_lineno = 1190;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1190;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_3;
            {
                PyObject *tmp_assign_source_4;
                PyObject *tmp_iter_arg_2;
                CHECK_OBJECT(var_objs);
                tmp_iter_arg_2 = var_objs;
                tmp_assign_source_4 = MAKE_ITERATOR(tmp_iter_arg_2);
                if (tmp_assign_source_4 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 1191;
                    type_description_1 = "oco";
                    goto frame_exception_exit_1;
                }
                assert(tmp_genexpr_2__$0 == NULL);
                tmp_genexpr_2__$0 = tmp_assign_source_4;
            }
            // Tried code:
            tmp_assign_source_3 = cryptography$x509$extensions$$$function_143_get_values_for_type$$$genexpr_2_genexpr_maker();

            ((struct Nuitka_GeneratorObject *)tmp_assign_source_3)->m_closure[0] = PyCell_NEW0(tmp_genexpr_2__$0);


            goto try_return_handler_3;
            // tried codes exits in all cases
            NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_143_get_values_for_type);
            return NULL;
            // Return handler code:
            try_return_handler_3:;
            CHECK_OBJECT((PyObject *)tmp_genexpr_2__$0);
            Py_DECREF(tmp_genexpr_2__$0);
            tmp_genexpr_2__$0 = NULL;

            goto outline_result_2;
            // End of try:
            CHECK_OBJECT((PyObject *)tmp_genexpr_2__$0);
            Py_DECREF(tmp_genexpr_2__$0);
            tmp_genexpr_2__$0 = NULL;

            // Return statement must have exited already.
            NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_143_get_values_for_type);
            return NULL;
            outline_result_2:;
            {
                PyObject *old = var_objs;
                assert(old != NULL);
                var_objs = tmp_assign_source_3;
                Py_DECREF(old);
            }

        }
        branch_no_1:;
    }
    {
        PyObject *tmp_list_arg_1;
        CHECK_OBJECT(var_objs);
        tmp_list_arg_1 = var_objs;
        tmp_return_value = PySequence_List(tmp_list_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1192;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_be19316fadb8714fcba11591040e6359);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_be19316fadb8714fcba11591040e6359);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_be19316fadb8714fcba11591040e6359);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_be19316fadb8714fcba11591040e6359, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_be19316fadb8714fcba11591040e6359->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_be19316fadb8714fcba11591040e6359, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_be19316fadb8714fcba11591040e6359,
        type_description_1,
        par_self,
        par_type,
        var_objs
    );


    // Release cached frame.
    if (frame_be19316fadb8714fcba11591040e6359 == cache_frame_be19316fadb8714fcba11591040e6359) {
        Py_DECREF(frame_be19316fadb8714fcba11591040e6359);
    }
    cache_frame_be19316fadb8714fcba11591040e6359 = NULL;

    assertFrameObject(frame_be19316fadb8714fcba11591040e6359);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_143_get_values_for_type);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_objs);
    Py_DECREF(var_objs);
    var_objs = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_objs);
    var_objs = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_143_get_values_for_type);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}



struct cryptography$x509$extensions$$$function_143_get_values_for_type$$$genexpr_1_genexpr_locals {
    PyObject *var_i;
    PyObject *tmp_iter_value_0;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    int tmp_res;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *cryptography$x509$extensions$$$function_143_get_values_for_type$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value ) {
    CHECK_OBJECT((PyObject *)generator);
    assert(Nuitka_Generator_Check( (PyObject *)generator ));

    // Heap access if used.
    struct cryptography$x509$extensions$$$function_143_get_values_for_type$$$genexpr_1_genexpr_locals *generator_heap = (struct cryptography$x509$extensions$$$function_143_get_values_for_type$$$genexpr_1_genexpr_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_i = NULL;
    generator_heap->tmp_iter_value_0 = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_m_frame, codeobj_d5ecd660941aa92ad81b0960ed9952bd, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *));
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF(generator->m_frame);
    assert(Py_REFCNT(generator->m_frame) == 2); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR(generator->m_frame->m_frame.f_back);

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF(generator->m_frame->m_frame.f_back);

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF(generator->m_frame);

    Nuitka_Frame_MarkAsExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

        EXC_TYPE_F(generator) = EXC_TYPE(thread_state);
        if (EXC_TYPE_F(generator) == Py_None) EXC_TYPE_F(generator) = NULL;
        Py_XINCREF(EXC_TYPE_F(generator));
        EXC_VALUE_F(generator) = EXC_VALUE(thread_state);
        Py_XINCREF(EXC_VALUE_F(generator));
        EXC_TRACEBACK_F(generator) = EXC_TRACEBACK(thread_state);
        Py_XINCREF(EXC_TRACEBACK_F(generator));
    }

#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_1;
        CHECK_OBJECT(PyCell_GET(generator->m_closure[0]));
        tmp_next_source_1 = PyCell_GET(generator->m_closure[0]);
        tmp_assign_source_1 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_1 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);
                generator_heap->type_description_1 = "Noc";
                generator_heap->exception_lineno = 1189;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_iter_value_0;
            generator_heap->tmp_iter_value_0 = tmp_assign_source_1;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT(generator_heap->tmp_iter_value_0);
        tmp_assign_source_2 = generator_heap->tmp_iter_value_0;
        {
            PyObject *old = generator_heap->var_i;
            generator_heap->var_i = tmp_assign_source_2;
            Py_INCREF(generator_heap->var_i);
            Py_XDECREF(old);
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        CHECK_OBJECT(generator_heap->var_i);
        tmp_isinstance_inst_1 = generator_heap->var_i;
        if (PyCell_GET(generator->m_closure[1]) == NULL) {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF(generator_heap->exception_type);
            generator_heap->exception_value = PyString_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "type");
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 1189;
            generator_heap->type_description_1 = "Noc";
            goto try_except_handler_2;
        }

        tmp_isinstance_cls_1 = PyCell_GET(generator->m_closure[1]);
        generator_heap->tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (generator_heap->tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 1189;
            generator_heap->type_description_1 = "Noc";
            goto try_except_handler_2;
        }
        tmp_condition_result_1 = (generator_heap->tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_expression_name_1;
            NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
            CHECK_OBJECT(generator_heap->var_i);
            tmp_expression_name_1 = generator_heap->var_i;
            Py_INCREF(tmp_expression_name_1);
            Nuitka_PreserveHeap(generator_heap->yield_tmps, &tmp_condition_result_1, sizeof(nuitka_bool), &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), NULL);
            generator->m_yield_return_index = 1;
            return tmp_expression_name_1;
            yield_return_1:
            Nuitka_RestoreHeap(generator_heap->yield_tmps, &tmp_condition_result_1, sizeof(nuitka_bool), &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), NULL);
            if (yield_return_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


                generator_heap->exception_lineno = 1189;
                generator_heap->type_description_1 = "Noc";
                goto try_except_handler_2;
            }
            tmp_yield_result_1 = yield_return_value;
        }
        branch_no_1:;
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


        generator_heap->exception_lineno = 1189;
        generator_heap->type_description_1 = "Noc";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    // Allow re-use of the frame again.
    Py_DECREF(generator->m_frame);
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if (!EXCEPTION_MATCH_GENERATOR(generator_heap->exception_type)) {
        if (generator_heap->exception_tb == NULL) {
            generator_heap->exception_tb = MAKE_TRACEBACK(generator->m_frame, generator_heap->exception_lineno);
        } else if (generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame) {
            generator_heap->exception_tb = ADD_TRACEBACK(generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno);
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            NULL,
            generator_heap->var_i,
            generator->m_closure[1]
        );


        // Release cached frame.
        if (generator->m_frame == cache_m_frame) {
            Py_DECREF(generator->m_frame);
        }
        cache_m_frame = NULL;

        assertFrameObject(generator->m_frame);
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    Py_DECREF(generator->m_frame);

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->var_i);
    generator_heap->var_i = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    Py_XDECREF(generator_heap->var_i);
    generator_heap->var_i = NULL;



    return NULL;

    function_exception_exit:
    assert(generator_heap->exception_type);
    RESTORE_ERROR_OCCURRED(generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb);

    return NULL;

}

static PyObject *cryptography$x509$extensions$$$function_143_get_values_for_type$$$genexpr_1_genexpr_maker(void) {
    return Nuitka_Generator_New(
        cryptography$x509$extensions$$$function_143_get_values_for_type$$$genexpr_1_genexpr_context,
        module_cryptography$x509$extensions,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_d5ecd660941aa92ad81b0960ed9952bd,
        2,
        sizeof(struct cryptography$x509$extensions$$$function_143_get_values_for_type$$$genexpr_1_genexpr_locals)
    );
}



struct cryptography$x509$extensions$$$function_143_get_values_for_type$$$genexpr_2_genexpr_locals {
    PyObject *var_i;
    PyObject *tmp_iter_value_0;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *cryptography$x509$extensions$$$function_143_get_values_for_type$$$genexpr_2_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value ) {
    CHECK_OBJECT((PyObject *)generator);
    assert(Nuitka_Generator_Check( (PyObject *)generator ));

    // Heap access if used.
    struct cryptography$x509$extensions$$$function_143_get_values_for_type$$$genexpr_2_genexpr_locals *generator_heap = (struct cryptography$x509$extensions$$$function_143_get_values_for_type$$$genexpr_2_genexpr_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_i = NULL;
    generator_heap->tmp_iter_value_0 = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_m_frame, codeobj_bd5a4ccd3526e581f6cff771453dcd80, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF(generator->m_frame);
    assert(Py_REFCNT(generator->m_frame) == 2); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR(generator->m_frame->m_frame.f_back);

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF(generator->m_frame->m_frame.f_back);

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF(generator->m_frame);

    Nuitka_Frame_MarkAsExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

        EXC_TYPE_F(generator) = EXC_TYPE(thread_state);
        if (EXC_TYPE_F(generator) == Py_None) EXC_TYPE_F(generator) = NULL;
        Py_XINCREF(EXC_TYPE_F(generator));
        EXC_VALUE_F(generator) = EXC_VALUE(thread_state);
        Py_XINCREF(EXC_VALUE_F(generator));
        EXC_TRACEBACK_F(generator) = EXC_TRACEBACK(thread_state);
        Py_XINCREF(EXC_TRACEBACK_F(generator));
    }

#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_1;
        CHECK_OBJECT(PyCell_GET(generator->m_closure[0]));
        tmp_next_source_1 = PyCell_GET(generator->m_closure[0]);
        tmp_assign_source_1 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_1 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);
                generator_heap->type_description_1 = "No";
                generator_heap->exception_lineno = 1191;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_iter_value_0;
            generator_heap->tmp_iter_value_0 = tmp_assign_source_1;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT(generator_heap->tmp_iter_value_0);
        tmp_assign_source_2 = generator_heap->tmp_iter_value_0;
        {
            PyObject *old = generator_heap->var_i;
            generator_heap->var_i = tmp_assign_source_2;
            Py_INCREF(generator_heap->var_i);
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_expression_name_1;
        PyObject *tmp_source_name_1;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        CHECK_OBJECT(generator_heap->var_i);
        tmp_source_name_1 = generator_heap->var_i;
        tmp_expression_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_value);
        if (tmp_expression_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 1191;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        Nuitka_PreserveHeap(generator_heap->yield_tmps, &tmp_source_name_1, sizeof(PyObject *), NULL);
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        Nuitka_RestoreHeap(generator_heap->yield_tmps, &tmp_source_name_1, sizeof(PyObject *), NULL);
        if (yield_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 1191;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


        generator_heap->exception_lineno = 1191;
        generator_heap->type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    // Allow re-use of the frame again.
    Py_DECREF(generator->m_frame);
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if (!EXCEPTION_MATCH_GENERATOR(generator_heap->exception_type)) {
        if (generator_heap->exception_tb == NULL) {
            generator_heap->exception_tb = MAKE_TRACEBACK(generator->m_frame, generator_heap->exception_lineno);
        } else if (generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame) {
            generator_heap->exception_tb = ADD_TRACEBACK(generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno);
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            NULL,
            generator_heap->var_i
        );


        // Release cached frame.
        if (generator->m_frame == cache_m_frame) {
            Py_DECREF(generator->m_frame);
        }
        cache_m_frame = NULL;

        assertFrameObject(generator->m_frame);
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    Py_DECREF(generator->m_frame);

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->var_i);
    generator_heap->var_i = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    Py_XDECREF(generator_heap->var_i);
    generator_heap->var_i = NULL;



    return NULL;

    function_exception_exit:
    assert(generator_heap->exception_type);
    RESTORE_ERROR_OCCURRED(generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb);

    return NULL;

}

static PyObject *cryptography$x509$extensions$$$function_143_get_values_for_type$$$genexpr_2_genexpr_maker(void) {
    return Nuitka_Generator_New(
        cryptography$x509$extensions$$$function_143_get_values_for_type$$$genexpr_2_genexpr_context,
        module_cryptography$x509$extensions,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_bd5a4ccd3526e581f6cff771453dcd80,
        1,
        sizeof(struct cryptography$x509$extensions$$$function_143_get_values_for_type$$$genexpr_2_genexpr_locals)
    );
}


static PyObject *impl_cryptography$x509$extensions$$$function_144___repr__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_efd34061bbe17d3f599acf52a0927a75;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_efd34061bbe17d3f599acf52a0927a75 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_efd34061bbe17d3f599acf52a0927a75, codeobj_efd34061bbe17d3f599acf52a0927a75, module_cryptography$x509$extensions, sizeof(void *));
    frame_efd34061bbe17d3f599acf52a0927a75 = cache_frame_efd34061bbe17d3f599acf52a0927a75;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_efd34061bbe17d3f599acf52a0927a75);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_efd34061bbe17d3f599acf52a0927a75) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_source_name_1 = const_str_digest_096877126149ba9ef6483d7f63c2f65e;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_format);
        assert(!(tmp_called_name_1 == NULL));
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__general_names);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1195;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_efd34061bbe17d3f599acf52a0927a75->m_frame.f_lineno = 1195;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1195;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_efd34061bbe17d3f599acf52a0927a75);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_efd34061bbe17d3f599acf52a0927a75);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_efd34061bbe17d3f599acf52a0927a75);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_efd34061bbe17d3f599acf52a0927a75, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_efd34061bbe17d3f599acf52a0927a75->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_efd34061bbe17d3f599acf52a0927a75, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_efd34061bbe17d3f599acf52a0927a75,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_efd34061bbe17d3f599acf52a0927a75 == cache_frame_efd34061bbe17d3f599acf52a0927a75) {
        Py_DECREF(frame_efd34061bbe17d3f599acf52a0927a75);
    }
    cache_frame_efd34061bbe17d3f599acf52a0927a75 = NULL;

    assertFrameObject(frame_efd34061bbe17d3f599acf52a0927a75);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_144___repr__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_145___eq__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_377dfaf8031601d6b3bbe8ecaa46a6da;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_377dfaf8031601d6b3bbe8ecaa46a6da = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_377dfaf8031601d6b3bbe8ecaa46a6da, codeobj_377dfaf8031601d6b3bbe8ecaa46a6da, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_377dfaf8031601d6b3bbe8ecaa46a6da = cache_frame_377dfaf8031601d6b3bbe8ecaa46a6da;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_377dfaf8031601d6b3bbe8ecaa46a6da);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_377dfaf8031601d6b3bbe8ecaa46a6da) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_other);
        tmp_isinstance_inst_1 = par_other;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_GeneralNames);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_GeneralNames);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 37366 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 1198;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1198;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1198;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__general_names);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1201;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_2 = par_other;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__general_names);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_1);

            exception_lineno = 1201;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1201;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_377dfaf8031601d6b3bbe8ecaa46a6da);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_377dfaf8031601d6b3bbe8ecaa46a6da);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_377dfaf8031601d6b3bbe8ecaa46a6da);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_377dfaf8031601d6b3bbe8ecaa46a6da, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_377dfaf8031601d6b3bbe8ecaa46a6da->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_377dfaf8031601d6b3bbe8ecaa46a6da, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_377dfaf8031601d6b3bbe8ecaa46a6da,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_377dfaf8031601d6b3bbe8ecaa46a6da == cache_frame_377dfaf8031601d6b3bbe8ecaa46a6da) {
        Py_DECREF(frame_377dfaf8031601d6b3bbe8ecaa46a6da);
    }
    cache_frame_377dfaf8031601d6b3bbe8ecaa46a6da = NULL;

    assertFrameObject(frame_377dfaf8031601d6b3bbe8ecaa46a6da);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_145___eq__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_146___ne__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_b5bbacf212743993a52b51355435ccb2;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_b5bbacf212743993a52b51355435ccb2 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_b5bbacf212743993a52b51355435ccb2, codeobj_b5bbacf212743993a52b51355435ccb2, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_b5bbacf212743993a52b51355435ccb2 = cache_frame_b5bbacf212743993a52b51355435ccb2;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_b5bbacf212743993a52b51355435ccb2);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_b5bbacf212743993a52b51355435ccb2) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_self);
        tmp_compexpr_left_1 = par_self;
        CHECK_OBJECT(par_other);
        tmp_compexpr_right_1 = par_other;
        tmp_operand_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1204;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1204;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = (tmp_res == 0) ? Py_True : Py_False;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b5bbacf212743993a52b51355435ccb2);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_b5bbacf212743993a52b51355435ccb2);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b5bbacf212743993a52b51355435ccb2);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_b5bbacf212743993a52b51355435ccb2, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_b5bbacf212743993a52b51355435ccb2->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_b5bbacf212743993a52b51355435ccb2, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b5bbacf212743993a52b51355435ccb2,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_b5bbacf212743993a52b51355435ccb2 == cache_frame_b5bbacf212743993a52b51355435ccb2) {
        Py_DECREF(frame_b5bbacf212743993a52b51355435ccb2);
    }
    cache_frame_b5bbacf212743993a52b51355435ccb2 = NULL;

    assertFrameObject(frame_b5bbacf212743993a52b51355435ccb2);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_146___ne__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_147___getitem__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_idx = python_pars[1];
    struct Nuitka_FrameObject *frame_e80eadbccd9a352af4d1530cb82eabd0;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_e80eadbccd9a352af4d1530cb82eabd0 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_e80eadbccd9a352af4d1530cb82eabd0, codeobj_e80eadbccd9a352af4d1530cb82eabd0, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_e80eadbccd9a352af4d1530cb82eabd0 = cache_frame_e80eadbccd9a352af4d1530cb82eabd0;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_e80eadbccd9a352af4d1530cb82eabd0);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_e80eadbccd9a352af4d1530cb82eabd0) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_subscript_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__general_names);
        if (tmp_subscribed_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1207;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_idx);
        tmp_subscript_name_1 = par_idx;
        tmp_return_value = LOOKUP_SUBSCRIPT(tmp_subscribed_name_1, tmp_subscript_name_1);
        Py_DECREF(tmp_subscribed_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1207;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e80eadbccd9a352af4d1530cb82eabd0);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_e80eadbccd9a352af4d1530cb82eabd0);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e80eadbccd9a352af4d1530cb82eabd0);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_e80eadbccd9a352af4d1530cb82eabd0, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_e80eadbccd9a352af4d1530cb82eabd0->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_e80eadbccd9a352af4d1530cb82eabd0, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e80eadbccd9a352af4d1530cb82eabd0,
        type_description_1,
        par_self,
        par_idx
    );


    // Release cached frame.
    if (frame_e80eadbccd9a352af4d1530cb82eabd0 == cache_frame_e80eadbccd9a352af4d1530cb82eabd0) {
        Py_DECREF(frame_e80eadbccd9a352af4d1530cb82eabd0);
    }
    cache_frame_e80eadbccd9a352af4d1530cb82eabd0 = NULL;

    assertFrameObject(frame_e80eadbccd9a352af4d1530cb82eabd0);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_147___getitem__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_idx);
    Py_DECREF(par_idx);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_idx);
    Py_DECREF(par_idx);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_148___hash__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_7e8a46f19303bcd303c87268495b4873;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_7e8a46f19303bcd303c87268495b4873 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_7e8a46f19303bcd303c87268495b4873, codeobj_7e8a46f19303bcd303c87268495b4873, module_cryptography$x509$extensions, sizeof(void *));
    frame_7e8a46f19303bcd303c87268495b4873 = cache_frame_7e8a46f19303bcd303c87268495b4873;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_7e8a46f19303bcd303c87268495b4873);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_7e8a46f19303bcd303c87268495b4873) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_hash_arg_1;
        PyObject *tmp_tuple_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_tuple_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__general_names);
        if (tmp_tuple_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1210;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_hash_arg_1 = PySequence_Tuple(tmp_tuple_arg_1);
        Py_DECREF(tmp_tuple_arg_1);
        if (tmp_hash_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1210;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = BUILTIN_HASH(tmp_hash_arg_1);
        Py_DECREF(tmp_hash_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1210;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_7e8a46f19303bcd303c87268495b4873);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_7e8a46f19303bcd303c87268495b4873);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_7e8a46f19303bcd303c87268495b4873);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_7e8a46f19303bcd303c87268495b4873, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_7e8a46f19303bcd303c87268495b4873->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_7e8a46f19303bcd303c87268495b4873, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7e8a46f19303bcd303c87268495b4873,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_7e8a46f19303bcd303c87268495b4873 == cache_frame_7e8a46f19303bcd303c87268495b4873) {
        Py_DECREF(frame_7e8a46f19303bcd303c87268495b4873);
    }
    cache_frame_7e8a46f19303bcd303c87268495b4873 = NULL;

    assertFrameObject(frame_7e8a46f19303bcd303c87268495b4873);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_148___hash__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_149___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_general_names = python_pars[1];
    struct Nuitka_FrameObject *frame_9fbea692e0648e29509653c9c860b09a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_9fbea692e0648e29509653c9c860b09a = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_9fbea692e0648e29509653c9c860b09a, codeobj_9fbea692e0648e29509653c9c860b09a, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_9fbea692e0648e29509653c9c860b09a = cache_frame_9fbea692e0648e29509653c9c860b09a;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_9fbea692e0648e29509653c9c860b09a);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_9fbea692e0648e29509653c9c860b09a) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_GeneralNames);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_GeneralNames);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 37366 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 1218;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT(par_general_names);
        tmp_args_element_name_1 = par_general_names;
        frame_9fbea692e0648e29509653c9c860b09a->m_frame.f_lineno = 1218;
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1218;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__general_names, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1218;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9fbea692e0648e29509653c9c860b09a);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9fbea692e0648e29509653c9c860b09a);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_9fbea692e0648e29509653c9c860b09a, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_9fbea692e0648e29509653c9c860b09a->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_9fbea692e0648e29509653c9c860b09a, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9fbea692e0648e29509653c9c860b09a,
        type_description_1,
        par_self,
        par_general_names
    );


    // Release cached frame.
    if (frame_9fbea692e0648e29509653c9c860b09a == cache_frame_9fbea692e0648e29509653c9c860b09a) {
        Py_DECREF(frame_9fbea692e0648e29509653c9c860b09a);
    }
    cache_frame_9fbea692e0648e29509653c9c860b09a = NULL;

    assertFrameObject(frame_9fbea692e0648e29509653c9c860b09a);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_149___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_general_names);
    Py_DECREF(par_general_names);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_general_names);
    Py_DECREF(par_general_names);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_150___iter__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_ae3e58b5effe48f6d27c07362c73d4d3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_ae3e58b5effe48f6d27c07362c73d4d3 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_ae3e58b5effe48f6d27c07362c73d4d3, codeobj_ae3e58b5effe48f6d27c07362c73d4d3, module_cryptography$x509$extensions, sizeof(void *));
    frame_ae3e58b5effe48f6d27c07362c73d4d3 = cache_frame_ae3e58b5effe48f6d27c07362c73d4d3;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_ae3e58b5effe48f6d27c07362c73d4d3);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_ae3e58b5effe48f6d27c07362c73d4d3) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_iter_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__general_names);
        if (tmp_iter_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1221;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = MAKE_ITERATOR(tmp_iter_arg_1);
        Py_DECREF(tmp_iter_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1221;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ae3e58b5effe48f6d27c07362c73d4d3);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_ae3e58b5effe48f6d27c07362c73d4d3);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ae3e58b5effe48f6d27c07362c73d4d3);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_ae3e58b5effe48f6d27c07362c73d4d3, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_ae3e58b5effe48f6d27c07362c73d4d3->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_ae3e58b5effe48f6d27c07362c73d4d3, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ae3e58b5effe48f6d27c07362c73d4d3,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_ae3e58b5effe48f6d27c07362c73d4d3 == cache_frame_ae3e58b5effe48f6d27c07362c73d4d3) {
        Py_DECREF(frame_ae3e58b5effe48f6d27c07362c73d4d3);
    }
    cache_frame_ae3e58b5effe48f6d27c07362c73d4d3 = NULL;

    assertFrameObject(frame_ae3e58b5effe48f6d27c07362c73d4d3);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_150___iter__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_151___len__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_107c6fa6753a52c5be47fed9637674ab;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_107c6fa6753a52c5be47fed9637674ab = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_107c6fa6753a52c5be47fed9637674ab, codeobj_107c6fa6753a52c5be47fed9637674ab, module_cryptography$x509$extensions, sizeof(void *));
    frame_107c6fa6753a52c5be47fed9637674ab = cache_frame_107c6fa6753a52c5be47fed9637674ab;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_107c6fa6753a52c5be47fed9637674ab);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_107c6fa6753a52c5be47fed9637674ab) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_len_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_len_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__general_names);
        if (tmp_len_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1224;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = BUILTIN_LEN(tmp_len_arg_1);
        Py_DECREF(tmp_len_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1224;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_107c6fa6753a52c5be47fed9637674ab);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_107c6fa6753a52c5be47fed9637674ab);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_107c6fa6753a52c5be47fed9637674ab);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_107c6fa6753a52c5be47fed9637674ab, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_107c6fa6753a52c5be47fed9637674ab->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_107c6fa6753a52c5be47fed9637674ab, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_107c6fa6753a52c5be47fed9637674ab,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_107c6fa6753a52c5be47fed9637674ab == cache_frame_107c6fa6753a52c5be47fed9637674ab) {
        Py_DECREF(frame_107c6fa6753a52c5be47fed9637674ab);
    }
    cache_frame_107c6fa6753a52c5be47fed9637674ab = NULL;

    assertFrameObject(frame_107c6fa6753a52c5be47fed9637674ab);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_151___len__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_152_get_values_for_type(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_type = python_pars[1];
    struct Nuitka_FrameObject *frame_f68866006367fc4d498eabfdb2ce5eab;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_f68866006367fc4d498eabfdb2ce5eab = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_f68866006367fc4d498eabfdb2ce5eab, codeobj_f68866006367fc4d498eabfdb2ce5eab, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_f68866006367fc4d498eabfdb2ce5eab = cache_frame_f68866006367fc4d498eabfdb2ce5eab;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_f68866006367fc4d498eabfdb2ce5eab);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_f68866006367fc4d498eabfdb2ce5eab) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__general_names);
        if (tmp_called_instance_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1227;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_type);
        tmp_args_element_name_1 = par_type;
        frame_f68866006367fc4d498eabfdb2ce5eab->m_frame.f_lineno = 1227;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_get_values_for_type, call_args);
        }

        Py_DECREF(tmp_called_instance_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1227;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_f68866006367fc4d498eabfdb2ce5eab);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_f68866006367fc4d498eabfdb2ce5eab);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_f68866006367fc4d498eabfdb2ce5eab);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_f68866006367fc4d498eabfdb2ce5eab, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_f68866006367fc4d498eabfdb2ce5eab->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_f68866006367fc4d498eabfdb2ce5eab, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f68866006367fc4d498eabfdb2ce5eab,
        type_description_1,
        par_self,
        par_type
    );


    // Release cached frame.
    if (frame_f68866006367fc4d498eabfdb2ce5eab == cache_frame_f68866006367fc4d498eabfdb2ce5eab) {
        Py_DECREF(frame_f68866006367fc4d498eabfdb2ce5eab);
    }
    cache_frame_f68866006367fc4d498eabfdb2ce5eab = NULL;

    assertFrameObject(frame_f68866006367fc4d498eabfdb2ce5eab);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_152_get_values_for_type);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_153___repr__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_ff22167bf97fbb91b6a1b6290ff782e8;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_ff22167bf97fbb91b6a1b6290ff782e8 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_ff22167bf97fbb91b6a1b6290ff782e8, codeobj_ff22167bf97fbb91b6a1b6290ff782e8, module_cryptography$x509$extensions, sizeof(void *));
    frame_ff22167bf97fbb91b6a1b6290ff782e8 = cache_frame_ff22167bf97fbb91b6a1b6290ff782e8;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_ff22167bf97fbb91b6a1b6290ff782e8);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_ff22167bf97fbb91b6a1b6290ff782e8) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_source_name_1 = const_str_digest_de6ca45cc2c0d21b3ea9542eeb752d64;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_format);
        assert(!(tmp_called_name_1 == NULL));
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__general_names);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1230;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_ff22167bf97fbb91b6a1b6290ff782e8->m_frame.f_lineno = 1230;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1230;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ff22167bf97fbb91b6a1b6290ff782e8);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_ff22167bf97fbb91b6a1b6290ff782e8);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ff22167bf97fbb91b6a1b6290ff782e8);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_ff22167bf97fbb91b6a1b6290ff782e8, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_ff22167bf97fbb91b6a1b6290ff782e8->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_ff22167bf97fbb91b6a1b6290ff782e8, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ff22167bf97fbb91b6a1b6290ff782e8,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_ff22167bf97fbb91b6a1b6290ff782e8 == cache_frame_ff22167bf97fbb91b6a1b6290ff782e8) {
        Py_DECREF(frame_ff22167bf97fbb91b6a1b6290ff782e8);
    }
    cache_frame_ff22167bf97fbb91b6a1b6290ff782e8 = NULL;

    assertFrameObject(frame_ff22167bf97fbb91b6a1b6290ff782e8);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_153___repr__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_154___eq__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_4faa79e5001d77385bdc0e9fd35de12b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_4faa79e5001d77385bdc0e9fd35de12b = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_4faa79e5001d77385bdc0e9fd35de12b, codeobj_4faa79e5001d77385bdc0e9fd35de12b, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_4faa79e5001d77385bdc0e9fd35de12b = cache_frame_4faa79e5001d77385bdc0e9fd35de12b;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_4faa79e5001d77385bdc0e9fd35de12b);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_4faa79e5001d77385bdc0e9fd35de12b) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_other);
        tmp_isinstance_inst_1 = par_other;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_SubjectAlternativeName);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_SubjectAlternativeName);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 37407 ], 51, 0);
            exception_tb = NULL;

            exception_lineno = 1233;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1233;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1233;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__general_names);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1236;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_2 = par_other;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__general_names);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_1);

            exception_lineno = 1236;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1236;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_4faa79e5001d77385bdc0e9fd35de12b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_4faa79e5001d77385bdc0e9fd35de12b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_4faa79e5001d77385bdc0e9fd35de12b);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_4faa79e5001d77385bdc0e9fd35de12b, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_4faa79e5001d77385bdc0e9fd35de12b->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_4faa79e5001d77385bdc0e9fd35de12b, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4faa79e5001d77385bdc0e9fd35de12b,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_4faa79e5001d77385bdc0e9fd35de12b == cache_frame_4faa79e5001d77385bdc0e9fd35de12b) {
        Py_DECREF(frame_4faa79e5001d77385bdc0e9fd35de12b);
    }
    cache_frame_4faa79e5001d77385bdc0e9fd35de12b = NULL;

    assertFrameObject(frame_4faa79e5001d77385bdc0e9fd35de12b);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_154___eq__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_155___getitem__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_idx = python_pars[1];
    struct Nuitka_FrameObject *frame_bc546761cdcfe97d2210ff9ffeb1d8d7;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_bc546761cdcfe97d2210ff9ffeb1d8d7 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_bc546761cdcfe97d2210ff9ffeb1d8d7, codeobj_bc546761cdcfe97d2210ff9ffeb1d8d7, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_bc546761cdcfe97d2210ff9ffeb1d8d7 = cache_frame_bc546761cdcfe97d2210ff9ffeb1d8d7;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_bc546761cdcfe97d2210ff9ffeb1d8d7);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_bc546761cdcfe97d2210ff9ffeb1d8d7) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_subscript_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__general_names);
        if (tmp_subscribed_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1239;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_idx);
        tmp_subscript_name_1 = par_idx;
        tmp_return_value = LOOKUP_SUBSCRIPT(tmp_subscribed_name_1, tmp_subscript_name_1);
        Py_DECREF(tmp_subscribed_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1239;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_bc546761cdcfe97d2210ff9ffeb1d8d7);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_bc546761cdcfe97d2210ff9ffeb1d8d7);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_bc546761cdcfe97d2210ff9ffeb1d8d7);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_bc546761cdcfe97d2210ff9ffeb1d8d7, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_bc546761cdcfe97d2210ff9ffeb1d8d7->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_bc546761cdcfe97d2210ff9ffeb1d8d7, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_bc546761cdcfe97d2210ff9ffeb1d8d7,
        type_description_1,
        par_self,
        par_idx
    );


    // Release cached frame.
    if (frame_bc546761cdcfe97d2210ff9ffeb1d8d7 == cache_frame_bc546761cdcfe97d2210ff9ffeb1d8d7) {
        Py_DECREF(frame_bc546761cdcfe97d2210ff9ffeb1d8d7);
    }
    cache_frame_bc546761cdcfe97d2210ff9ffeb1d8d7 = NULL;

    assertFrameObject(frame_bc546761cdcfe97d2210ff9ffeb1d8d7);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_155___getitem__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_idx);
    Py_DECREF(par_idx);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_idx);
    Py_DECREF(par_idx);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_156___ne__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_fe1e7a1a7475b74c7d82a70b9b2a7b1c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_fe1e7a1a7475b74c7d82a70b9b2a7b1c = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_fe1e7a1a7475b74c7d82a70b9b2a7b1c, codeobj_fe1e7a1a7475b74c7d82a70b9b2a7b1c, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_fe1e7a1a7475b74c7d82a70b9b2a7b1c = cache_frame_fe1e7a1a7475b74c7d82a70b9b2a7b1c;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_fe1e7a1a7475b74c7d82a70b9b2a7b1c);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_fe1e7a1a7475b74c7d82a70b9b2a7b1c) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_self);
        tmp_compexpr_left_1 = par_self;
        CHECK_OBJECT(par_other);
        tmp_compexpr_right_1 = par_other;
        tmp_operand_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1242;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1242;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = (tmp_res == 0) ? Py_True : Py_False;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_fe1e7a1a7475b74c7d82a70b9b2a7b1c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_fe1e7a1a7475b74c7d82a70b9b2a7b1c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_fe1e7a1a7475b74c7d82a70b9b2a7b1c);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_fe1e7a1a7475b74c7d82a70b9b2a7b1c, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_fe1e7a1a7475b74c7d82a70b9b2a7b1c->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_fe1e7a1a7475b74c7d82a70b9b2a7b1c, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_fe1e7a1a7475b74c7d82a70b9b2a7b1c,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_fe1e7a1a7475b74c7d82a70b9b2a7b1c == cache_frame_fe1e7a1a7475b74c7d82a70b9b2a7b1c) {
        Py_DECREF(frame_fe1e7a1a7475b74c7d82a70b9b2a7b1c);
    }
    cache_frame_fe1e7a1a7475b74c7d82a70b9b2a7b1c = NULL;

    assertFrameObject(frame_fe1e7a1a7475b74c7d82a70b9b2a7b1c);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_156___ne__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_157___hash__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_4e3af5c7e39f4d94e8e08cef824fb047;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_4e3af5c7e39f4d94e8e08cef824fb047 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_4e3af5c7e39f4d94e8e08cef824fb047, codeobj_4e3af5c7e39f4d94e8e08cef824fb047, module_cryptography$x509$extensions, sizeof(void *));
    frame_4e3af5c7e39f4d94e8e08cef824fb047 = cache_frame_4e3af5c7e39f4d94e8e08cef824fb047;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_4e3af5c7e39f4d94e8e08cef824fb047);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_4e3af5c7e39f4d94e8e08cef824fb047) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_hash_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_hash_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__general_names);
        if (tmp_hash_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1245;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = BUILTIN_HASH(tmp_hash_arg_1);
        Py_DECREF(tmp_hash_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1245;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_4e3af5c7e39f4d94e8e08cef824fb047);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_4e3af5c7e39f4d94e8e08cef824fb047);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_4e3af5c7e39f4d94e8e08cef824fb047);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_4e3af5c7e39f4d94e8e08cef824fb047, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_4e3af5c7e39f4d94e8e08cef824fb047->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_4e3af5c7e39f4d94e8e08cef824fb047, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4e3af5c7e39f4d94e8e08cef824fb047,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_4e3af5c7e39f4d94e8e08cef824fb047 == cache_frame_4e3af5c7e39f4d94e8e08cef824fb047) {
        Py_DECREF(frame_4e3af5c7e39f4d94e8e08cef824fb047);
    }
    cache_frame_4e3af5c7e39f4d94e8e08cef824fb047 = NULL;

    assertFrameObject(frame_4e3af5c7e39f4d94e8e08cef824fb047);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_157___hash__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_158___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_general_names = python_pars[1];
    struct Nuitka_FrameObject *frame_ff0e042effc3afe7e319d9d9426d8281;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_ff0e042effc3afe7e319d9d9426d8281 = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_ff0e042effc3afe7e319d9d9426d8281, codeobj_ff0e042effc3afe7e319d9d9426d8281, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_ff0e042effc3afe7e319d9d9426d8281 = cache_frame_ff0e042effc3afe7e319d9d9426d8281;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_ff0e042effc3afe7e319d9d9426d8281);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_ff0e042effc3afe7e319d9d9426d8281) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_GeneralNames);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_GeneralNames);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 37366 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 1253;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT(par_general_names);
        tmp_args_element_name_1 = par_general_names;
        frame_ff0e042effc3afe7e319d9d9426d8281->m_frame.f_lineno = 1253;
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1253;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__general_names, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1253;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ff0e042effc3afe7e319d9d9426d8281);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ff0e042effc3afe7e319d9d9426d8281);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_ff0e042effc3afe7e319d9d9426d8281, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_ff0e042effc3afe7e319d9d9426d8281->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_ff0e042effc3afe7e319d9d9426d8281, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ff0e042effc3afe7e319d9d9426d8281,
        type_description_1,
        par_self,
        par_general_names
    );


    // Release cached frame.
    if (frame_ff0e042effc3afe7e319d9d9426d8281 == cache_frame_ff0e042effc3afe7e319d9d9426d8281) {
        Py_DECREF(frame_ff0e042effc3afe7e319d9d9426d8281);
    }
    cache_frame_ff0e042effc3afe7e319d9d9426d8281 = NULL;

    assertFrameObject(frame_ff0e042effc3afe7e319d9d9426d8281);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_158___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_general_names);
    Py_DECREF(par_general_names);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_general_names);
    Py_DECREF(par_general_names);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_159___iter__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_1c9410bc25f1960eb621aefb650cc5ae;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_1c9410bc25f1960eb621aefb650cc5ae = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_1c9410bc25f1960eb621aefb650cc5ae, codeobj_1c9410bc25f1960eb621aefb650cc5ae, module_cryptography$x509$extensions, sizeof(void *));
    frame_1c9410bc25f1960eb621aefb650cc5ae = cache_frame_1c9410bc25f1960eb621aefb650cc5ae;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_1c9410bc25f1960eb621aefb650cc5ae);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_1c9410bc25f1960eb621aefb650cc5ae) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_iter_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__general_names);
        if (tmp_iter_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1256;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = MAKE_ITERATOR(tmp_iter_arg_1);
        Py_DECREF(tmp_iter_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1256;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_1c9410bc25f1960eb621aefb650cc5ae);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_1c9410bc25f1960eb621aefb650cc5ae);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_1c9410bc25f1960eb621aefb650cc5ae);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_1c9410bc25f1960eb621aefb650cc5ae, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_1c9410bc25f1960eb621aefb650cc5ae->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_1c9410bc25f1960eb621aefb650cc5ae, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1c9410bc25f1960eb621aefb650cc5ae,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_1c9410bc25f1960eb621aefb650cc5ae == cache_frame_1c9410bc25f1960eb621aefb650cc5ae) {
        Py_DECREF(frame_1c9410bc25f1960eb621aefb650cc5ae);
    }
    cache_frame_1c9410bc25f1960eb621aefb650cc5ae = NULL;

    assertFrameObject(frame_1c9410bc25f1960eb621aefb650cc5ae);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_159___iter__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_160___len__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_30f20714cec73f8af7aacc594b6386e4;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_30f20714cec73f8af7aacc594b6386e4 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_30f20714cec73f8af7aacc594b6386e4, codeobj_30f20714cec73f8af7aacc594b6386e4, module_cryptography$x509$extensions, sizeof(void *));
    frame_30f20714cec73f8af7aacc594b6386e4 = cache_frame_30f20714cec73f8af7aacc594b6386e4;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_30f20714cec73f8af7aacc594b6386e4);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_30f20714cec73f8af7aacc594b6386e4) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_len_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_len_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__general_names);
        if (tmp_len_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1259;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = BUILTIN_LEN(tmp_len_arg_1);
        Py_DECREF(tmp_len_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1259;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_30f20714cec73f8af7aacc594b6386e4);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_30f20714cec73f8af7aacc594b6386e4);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_30f20714cec73f8af7aacc594b6386e4);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_30f20714cec73f8af7aacc594b6386e4, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_30f20714cec73f8af7aacc594b6386e4->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_30f20714cec73f8af7aacc594b6386e4, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_30f20714cec73f8af7aacc594b6386e4,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_30f20714cec73f8af7aacc594b6386e4 == cache_frame_30f20714cec73f8af7aacc594b6386e4) {
        Py_DECREF(frame_30f20714cec73f8af7aacc594b6386e4);
    }
    cache_frame_30f20714cec73f8af7aacc594b6386e4 = NULL;

    assertFrameObject(frame_30f20714cec73f8af7aacc594b6386e4);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_160___len__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_161_get_values_for_type(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_type = python_pars[1];
    struct Nuitka_FrameObject *frame_38fda1c9e56fc83bd693815271a1967a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_38fda1c9e56fc83bd693815271a1967a = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_38fda1c9e56fc83bd693815271a1967a, codeobj_38fda1c9e56fc83bd693815271a1967a, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_38fda1c9e56fc83bd693815271a1967a = cache_frame_38fda1c9e56fc83bd693815271a1967a;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_38fda1c9e56fc83bd693815271a1967a);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_38fda1c9e56fc83bd693815271a1967a) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__general_names);
        if (tmp_called_instance_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1262;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_type);
        tmp_args_element_name_1 = par_type;
        frame_38fda1c9e56fc83bd693815271a1967a->m_frame.f_lineno = 1262;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_get_values_for_type, call_args);
        }

        Py_DECREF(tmp_called_instance_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1262;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_38fda1c9e56fc83bd693815271a1967a);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_38fda1c9e56fc83bd693815271a1967a);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_38fda1c9e56fc83bd693815271a1967a);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_38fda1c9e56fc83bd693815271a1967a, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_38fda1c9e56fc83bd693815271a1967a->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_38fda1c9e56fc83bd693815271a1967a, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_38fda1c9e56fc83bd693815271a1967a,
        type_description_1,
        par_self,
        par_type
    );


    // Release cached frame.
    if (frame_38fda1c9e56fc83bd693815271a1967a == cache_frame_38fda1c9e56fc83bd693815271a1967a) {
        Py_DECREF(frame_38fda1c9e56fc83bd693815271a1967a);
    }
    cache_frame_38fda1c9e56fc83bd693815271a1967a = NULL;

    assertFrameObject(frame_38fda1c9e56fc83bd693815271a1967a);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_161_get_values_for_type);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_162___repr__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_fadb2dc5d8bba71f9a8e9cfcaee28365;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_fadb2dc5d8bba71f9a8e9cfcaee28365 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_fadb2dc5d8bba71f9a8e9cfcaee28365, codeobj_fadb2dc5d8bba71f9a8e9cfcaee28365, module_cryptography$x509$extensions, sizeof(void *));
    frame_fadb2dc5d8bba71f9a8e9cfcaee28365 = cache_frame_fadb2dc5d8bba71f9a8e9cfcaee28365;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_fadb2dc5d8bba71f9a8e9cfcaee28365);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_fadb2dc5d8bba71f9a8e9cfcaee28365) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_source_name_1 = const_str_digest_afa42db89846e96e9cfc2ab56578058d;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_format);
        assert(!(tmp_called_name_1 == NULL));
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__general_names);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1265;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_fadb2dc5d8bba71f9a8e9cfcaee28365->m_frame.f_lineno = 1265;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1265;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_fadb2dc5d8bba71f9a8e9cfcaee28365);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_fadb2dc5d8bba71f9a8e9cfcaee28365);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_fadb2dc5d8bba71f9a8e9cfcaee28365);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_fadb2dc5d8bba71f9a8e9cfcaee28365, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_fadb2dc5d8bba71f9a8e9cfcaee28365->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_fadb2dc5d8bba71f9a8e9cfcaee28365, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_fadb2dc5d8bba71f9a8e9cfcaee28365,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_fadb2dc5d8bba71f9a8e9cfcaee28365 == cache_frame_fadb2dc5d8bba71f9a8e9cfcaee28365) {
        Py_DECREF(frame_fadb2dc5d8bba71f9a8e9cfcaee28365);
    }
    cache_frame_fadb2dc5d8bba71f9a8e9cfcaee28365 = NULL;

    assertFrameObject(frame_fadb2dc5d8bba71f9a8e9cfcaee28365);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_162___repr__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_163___eq__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_65acb965719b8331ceb73cf60da5a34d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_65acb965719b8331ceb73cf60da5a34d = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_65acb965719b8331ceb73cf60da5a34d, codeobj_65acb965719b8331ceb73cf60da5a34d, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_65acb965719b8331ceb73cf60da5a34d = cache_frame_65acb965719b8331ceb73cf60da5a34d;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_65acb965719b8331ceb73cf60da5a34d);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_65acb965719b8331ceb73cf60da5a34d) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_other);
        tmp_isinstance_inst_1 = par_other;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_IssuerAlternativeName);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_IssuerAlternativeName);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 37458 ], 50, 0);
            exception_tb = NULL;

            exception_lineno = 1268;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1268;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1268;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__general_names);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1271;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_2 = par_other;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__general_names);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_1);

            exception_lineno = 1271;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1271;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_65acb965719b8331ceb73cf60da5a34d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_65acb965719b8331ceb73cf60da5a34d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_65acb965719b8331ceb73cf60da5a34d);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_65acb965719b8331ceb73cf60da5a34d, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_65acb965719b8331ceb73cf60da5a34d->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_65acb965719b8331ceb73cf60da5a34d, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_65acb965719b8331ceb73cf60da5a34d,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_65acb965719b8331ceb73cf60da5a34d == cache_frame_65acb965719b8331ceb73cf60da5a34d) {
        Py_DECREF(frame_65acb965719b8331ceb73cf60da5a34d);
    }
    cache_frame_65acb965719b8331ceb73cf60da5a34d = NULL;

    assertFrameObject(frame_65acb965719b8331ceb73cf60da5a34d);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_163___eq__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_164___ne__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_9f3b3e38c30463863dd51d0304783462;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_9f3b3e38c30463863dd51d0304783462 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_9f3b3e38c30463863dd51d0304783462, codeobj_9f3b3e38c30463863dd51d0304783462, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_9f3b3e38c30463863dd51d0304783462 = cache_frame_9f3b3e38c30463863dd51d0304783462;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_9f3b3e38c30463863dd51d0304783462);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_9f3b3e38c30463863dd51d0304783462) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_self);
        tmp_compexpr_left_1 = par_self;
        CHECK_OBJECT(par_other);
        tmp_compexpr_right_1 = par_other;
        tmp_operand_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1274;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1274;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = (tmp_res == 0) ? Py_True : Py_False;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9f3b3e38c30463863dd51d0304783462);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_9f3b3e38c30463863dd51d0304783462);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9f3b3e38c30463863dd51d0304783462);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_9f3b3e38c30463863dd51d0304783462, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_9f3b3e38c30463863dd51d0304783462->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_9f3b3e38c30463863dd51d0304783462, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9f3b3e38c30463863dd51d0304783462,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_9f3b3e38c30463863dd51d0304783462 == cache_frame_9f3b3e38c30463863dd51d0304783462) {
        Py_DECREF(frame_9f3b3e38c30463863dd51d0304783462);
    }
    cache_frame_9f3b3e38c30463863dd51d0304783462 = NULL;

    assertFrameObject(frame_9f3b3e38c30463863dd51d0304783462);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_164___ne__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_165___getitem__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_idx = python_pars[1];
    struct Nuitka_FrameObject *frame_50faf74e5ca2c4814bf1e56953546672;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_50faf74e5ca2c4814bf1e56953546672 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_50faf74e5ca2c4814bf1e56953546672, codeobj_50faf74e5ca2c4814bf1e56953546672, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_50faf74e5ca2c4814bf1e56953546672 = cache_frame_50faf74e5ca2c4814bf1e56953546672;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_50faf74e5ca2c4814bf1e56953546672);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_50faf74e5ca2c4814bf1e56953546672) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_subscript_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__general_names);
        if (tmp_subscribed_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1277;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_idx);
        tmp_subscript_name_1 = par_idx;
        tmp_return_value = LOOKUP_SUBSCRIPT(tmp_subscribed_name_1, tmp_subscript_name_1);
        Py_DECREF(tmp_subscribed_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1277;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_50faf74e5ca2c4814bf1e56953546672);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_50faf74e5ca2c4814bf1e56953546672);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_50faf74e5ca2c4814bf1e56953546672);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_50faf74e5ca2c4814bf1e56953546672, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_50faf74e5ca2c4814bf1e56953546672->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_50faf74e5ca2c4814bf1e56953546672, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_50faf74e5ca2c4814bf1e56953546672,
        type_description_1,
        par_self,
        par_idx
    );


    // Release cached frame.
    if (frame_50faf74e5ca2c4814bf1e56953546672 == cache_frame_50faf74e5ca2c4814bf1e56953546672) {
        Py_DECREF(frame_50faf74e5ca2c4814bf1e56953546672);
    }
    cache_frame_50faf74e5ca2c4814bf1e56953546672 = NULL;

    assertFrameObject(frame_50faf74e5ca2c4814bf1e56953546672);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_165___getitem__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_idx);
    Py_DECREF(par_idx);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_idx);
    Py_DECREF(par_idx);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_166___hash__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_b9940654b29bb9eed381a2ae1f642803;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_b9940654b29bb9eed381a2ae1f642803 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_b9940654b29bb9eed381a2ae1f642803, codeobj_b9940654b29bb9eed381a2ae1f642803, module_cryptography$x509$extensions, sizeof(void *));
    frame_b9940654b29bb9eed381a2ae1f642803 = cache_frame_b9940654b29bb9eed381a2ae1f642803;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_b9940654b29bb9eed381a2ae1f642803);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_b9940654b29bb9eed381a2ae1f642803) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_hash_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_hash_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__general_names);
        if (tmp_hash_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1280;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = BUILTIN_HASH(tmp_hash_arg_1);
        Py_DECREF(tmp_hash_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1280;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b9940654b29bb9eed381a2ae1f642803);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_b9940654b29bb9eed381a2ae1f642803);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b9940654b29bb9eed381a2ae1f642803);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_b9940654b29bb9eed381a2ae1f642803, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_b9940654b29bb9eed381a2ae1f642803->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_b9940654b29bb9eed381a2ae1f642803, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b9940654b29bb9eed381a2ae1f642803,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_b9940654b29bb9eed381a2ae1f642803 == cache_frame_b9940654b29bb9eed381a2ae1f642803) {
        Py_DECREF(frame_b9940654b29bb9eed381a2ae1f642803);
    }
    cache_frame_b9940654b29bb9eed381a2ae1f642803 = NULL;

    assertFrameObject(frame_b9940654b29bb9eed381a2ae1f642803);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_166___hash__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_167___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_general_names = python_pars[1];
    struct Nuitka_FrameObject *frame_6b2b741db5b95eb288315358a396ca78;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_6b2b741db5b95eb288315358a396ca78 = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_6b2b741db5b95eb288315358a396ca78, codeobj_6b2b741db5b95eb288315358a396ca78, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_6b2b741db5b95eb288315358a396ca78 = cache_frame_6b2b741db5b95eb288315358a396ca78;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_6b2b741db5b95eb288315358a396ca78);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_6b2b741db5b95eb288315358a396ca78) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_GeneralNames);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_GeneralNames);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 37366 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 1288;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT(par_general_names);
        tmp_args_element_name_1 = par_general_names;
        frame_6b2b741db5b95eb288315358a396ca78->m_frame.f_lineno = 1288;
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1288;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__general_names, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1288;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_6b2b741db5b95eb288315358a396ca78);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_6b2b741db5b95eb288315358a396ca78);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_6b2b741db5b95eb288315358a396ca78, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_6b2b741db5b95eb288315358a396ca78->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_6b2b741db5b95eb288315358a396ca78, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6b2b741db5b95eb288315358a396ca78,
        type_description_1,
        par_self,
        par_general_names
    );


    // Release cached frame.
    if (frame_6b2b741db5b95eb288315358a396ca78 == cache_frame_6b2b741db5b95eb288315358a396ca78) {
        Py_DECREF(frame_6b2b741db5b95eb288315358a396ca78);
    }
    cache_frame_6b2b741db5b95eb288315358a396ca78 = NULL;

    assertFrameObject(frame_6b2b741db5b95eb288315358a396ca78);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_167___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_general_names);
    Py_DECREF(par_general_names);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_general_names);
    Py_DECREF(par_general_names);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_168___iter__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_6f3d7d0fdfecc3ad3243e2e88d74ced2;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_6f3d7d0fdfecc3ad3243e2e88d74ced2 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_6f3d7d0fdfecc3ad3243e2e88d74ced2, codeobj_6f3d7d0fdfecc3ad3243e2e88d74ced2, module_cryptography$x509$extensions, sizeof(void *));
    frame_6f3d7d0fdfecc3ad3243e2e88d74ced2 = cache_frame_6f3d7d0fdfecc3ad3243e2e88d74ced2;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_6f3d7d0fdfecc3ad3243e2e88d74ced2);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_6f3d7d0fdfecc3ad3243e2e88d74ced2) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_iter_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__general_names);
        if (tmp_iter_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1291;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = MAKE_ITERATOR(tmp_iter_arg_1);
        Py_DECREF(tmp_iter_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1291;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_6f3d7d0fdfecc3ad3243e2e88d74ced2);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_6f3d7d0fdfecc3ad3243e2e88d74ced2);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_6f3d7d0fdfecc3ad3243e2e88d74ced2);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_6f3d7d0fdfecc3ad3243e2e88d74ced2, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_6f3d7d0fdfecc3ad3243e2e88d74ced2->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_6f3d7d0fdfecc3ad3243e2e88d74ced2, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6f3d7d0fdfecc3ad3243e2e88d74ced2,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_6f3d7d0fdfecc3ad3243e2e88d74ced2 == cache_frame_6f3d7d0fdfecc3ad3243e2e88d74ced2) {
        Py_DECREF(frame_6f3d7d0fdfecc3ad3243e2e88d74ced2);
    }
    cache_frame_6f3d7d0fdfecc3ad3243e2e88d74ced2 = NULL;

    assertFrameObject(frame_6f3d7d0fdfecc3ad3243e2e88d74ced2);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_168___iter__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_169___len__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_c17219ee1ea6d14faa2513ce9bfe056f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_c17219ee1ea6d14faa2513ce9bfe056f = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_c17219ee1ea6d14faa2513ce9bfe056f, codeobj_c17219ee1ea6d14faa2513ce9bfe056f, module_cryptography$x509$extensions, sizeof(void *));
    frame_c17219ee1ea6d14faa2513ce9bfe056f = cache_frame_c17219ee1ea6d14faa2513ce9bfe056f;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_c17219ee1ea6d14faa2513ce9bfe056f);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_c17219ee1ea6d14faa2513ce9bfe056f) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_len_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_len_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__general_names);
        if (tmp_len_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1294;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = BUILTIN_LEN(tmp_len_arg_1);
        Py_DECREF(tmp_len_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1294;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c17219ee1ea6d14faa2513ce9bfe056f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_c17219ee1ea6d14faa2513ce9bfe056f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c17219ee1ea6d14faa2513ce9bfe056f);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_c17219ee1ea6d14faa2513ce9bfe056f, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_c17219ee1ea6d14faa2513ce9bfe056f->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_c17219ee1ea6d14faa2513ce9bfe056f, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c17219ee1ea6d14faa2513ce9bfe056f,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_c17219ee1ea6d14faa2513ce9bfe056f == cache_frame_c17219ee1ea6d14faa2513ce9bfe056f) {
        Py_DECREF(frame_c17219ee1ea6d14faa2513ce9bfe056f);
    }
    cache_frame_c17219ee1ea6d14faa2513ce9bfe056f = NULL;

    assertFrameObject(frame_c17219ee1ea6d14faa2513ce9bfe056f);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_169___len__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_170_get_values_for_type(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_type = python_pars[1];
    struct Nuitka_FrameObject *frame_54e466a14b6f5af1981cb3aaa414eccb;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_54e466a14b6f5af1981cb3aaa414eccb = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_54e466a14b6f5af1981cb3aaa414eccb, codeobj_54e466a14b6f5af1981cb3aaa414eccb, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_54e466a14b6f5af1981cb3aaa414eccb = cache_frame_54e466a14b6f5af1981cb3aaa414eccb;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_54e466a14b6f5af1981cb3aaa414eccb);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_54e466a14b6f5af1981cb3aaa414eccb) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__general_names);
        if (tmp_called_instance_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1297;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_type);
        tmp_args_element_name_1 = par_type;
        frame_54e466a14b6f5af1981cb3aaa414eccb->m_frame.f_lineno = 1297;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_get_values_for_type, call_args);
        }

        Py_DECREF(tmp_called_instance_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1297;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_54e466a14b6f5af1981cb3aaa414eccb);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_54e466a14b6f5af1981cb3aaa414eccb);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_54e466a14b6f5af1981cb3aaa414eccb);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_54e466a14b6f5af1981cb3aaa414eccb, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_54e466a14b6f5af1981cb3aaa414eccb->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_54e466a14b6f5af1981cb3aaa414eccb, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_54e466a14b6f5af1981cb3aaa414eccb,
        type_description_1,
        par_self,
        par_type
    );


    // Release cached frame.
    if (frame_54e466a14b6f5af1981cb3aaa414eccb == cache_frame_54e466a14b6f5af1981cb3aaa414eccb) {
        Py_DECREF(frame_54e466a14b6f5af1981cb3aaa414eccb);
    }
    cache_frame_54e466a14b6f5af1981cb3aaa414eccb = NULL;

    assertFrameObject(frame_54e466a14b6f5af1981cb3aaa414eccb);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_170_get_values_for_type);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_171___repr__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_993858ded2f3066e6cc14f93b879c724;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_993858ded2f3066e6cc14f93b879c724 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_993858ded2f3066e6cc14f93b879c724, codeobj_993858ded2f3066e6cc14f93b879c724, module_cryptography$x509$extensions, sizeof(void *));
    frame_993858ded2f3066e6cc14f93b879c724 = cache_frame_993858ded2f3066e6cc14f93b879c724;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_993858ded2f3066e6cc14f93b879c724);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_993858ded2f3066e6cc14f93b879c724) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_source_name_1 = const_str_digest_2a0138f3ee2cd707fb386e46f1612821;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_format);
        assert(!(tmp_called_name_1 == NULL));
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__general_names);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1300;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_993858ded2f3066e6cc14f93b879c724->m_frame.f_lineno = 1300;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1300;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_993858ded2f3066e6cc14f93b879c724);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_993858ded2f3066e6cc14f93b879c724);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_993858ded2f3066e6cc14f93b879c724);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_993858ded2f3066e6cc14f93b879c724, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_993858ded2f3066e6cc14f93b879c724->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_993858ded2f3066e6cc14f93b879c724, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_993858ded2f3066e6cc14f93b879c724,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_993858ded2f3066e6cc14f93b879c724 == cache_frame_993858ded2f3066e6cc14f93b879c724) {
        Py_DECREF(frame_993858ded2f3066e6cc14f93b879c724);
    }
    cache_frame_993858ded2f3066e6cc14f93b879c724 = NULL;

    assertFrameObject(frame_993858ded2f3066e6cc14f93b879c724);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_171___repr__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_172___eq__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_763a08aeeae201c12ea113ce4cfc00d1;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_763a08aeeae201c12ea113ce4cfc00d1 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_763a08aeeae201c12ea113ce4cfc00d1, codeobj_763a08aeeae201c12ea113ce4cfc00d1, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_763a08aeeae201c12ea113ce4cfc00d1 = cache_frame_763a08aeeae201c12ea113ce4cfc00d1;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_763a08aeeae201c12ea113ce4cfc00d1);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_763a08aeeae201c12ea113ce4cfc00d1) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_other);
        tmp_isinstance_inst_1 = par_other;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_CertificateIssuer);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_CertificateIssuer);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 37508 ], 46, 0);
            exception_tb = NULL;

            exception_lineno = 1303;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1303;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1303;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__general_names);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1306;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_2 = par_other;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__general_names);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_1);

            exception_lineno = 1306;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1306;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_763a08aeeae201c12ea113ce4cfc00d1);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_763a08aeeae201c12ea113ce4cfc00d1);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_763a08aeeae201c12ea113ce4cfc00d1);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_763a08aeeae201c12ea113ce4cfc00d1, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_763a08aeeae201c12ea113ce4cfc00d1->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_763a08aeeae201c12ea113ce4cfc00d1, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_763a08aeeae201c12ea113ce4cfc00d1,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_763a08aeeae201c12ea113ce4cfc00d1 == cache_frame_763a08aeeae201c12ea113ce4cfc00d1) {
        Py_DECREF(frame_763a08aeeae201c12ea113ce4cfc00d1);
    }
    cache_frame_763a08aeeae201c12ea113ce4cfc00d1 = NULL;

    assertFrameObject(frame_763a08aeeae201c12ea113ce4cfc00d1);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_172___eq__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_173___ne__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_ee82fcb5a179d6e83101dbacd640bb17;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_ee82fcb5a179d6e83101dbacd640bb17 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_ee82fcb5a179d6e83101dbacd640bb17, codeobj_ee82fcb5a179d6e83101dbacd640bb17, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_ee82fcb5a179d6e83101dbacd640bb17 = cache_frame_ee82fcb5a179d6e83101dbacd640bb17;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_ee82fcb5a179d6e83101dbacd640bb17);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_ee82fcb5a179d6e83101dbacd640bb17) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_self);
        tmp_compexpr_left_1 = par_self;
        CHECK_OBJECT(par_other);
        tmp_compexpr_right_1 = par_other;
        tmp_operand_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1309;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1309;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = (tmp_res == 0) ? Py_True : Py_False;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ee82fcb5a179d6e83101dbacd640bb17);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_ee82fcb5a179d6e83101dbacd640bb17);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ee82fcb5a179d6e83101dbacd640bb17);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_ee82fcb5a179d6e83101dbacd640bb17, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_ee82fcb5a179d6e83101dbacd640bb17->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_ee82fcb5a179d6e83101dbacd640bb17, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ee82fcb5a179d6e83101dbacd640bb17,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_ee82fcb5a179d6e83101dbacd640bb17 == cache_frame_ee82fcb5a179d6e83101dbacd640bb17) {
        Py_DECREF(frame_ee82fcb5a179d6e83101dbacd640bb17);
    }
    cache_frame_ee82fcb5a179d6e83101dbacd640bb17 = NULL;

    assertFrameObject(frame_ee82fcb5a179d6e83101dbacd640bb17);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_173___ne__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_174___getitem__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_idx = python_pars[1];
    struct Nuitka_FrameObject *frame_e2014de1836f1bbfee700d36c26440be;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_e2014de1836f1bbfee700d36c26440be = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_e2014de1836f1bbfee700d36c26440be, codeobj_e2014de1836f1bbfee700d36c26440be, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_e2014de1836f1bbfee700d36c26440be = cache_frame_e2014de1836f1bbfee700d36c26440be;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_e2014de1836f1bbfee700d36c26440be);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_e2014de1836f1bbfee700d36c26440be) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_subscript_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__general_names);
        if (tmp_subscribed_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1312;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_idx);
        tmp_subscript_name_1 = par_idx;
        tmp_return_value = LOOKUP_SUBSCRIPT(tmp_subscribed_name_1, tmp_subscript_name_1);
        Py_DECREF(tmp_subscribed_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1312;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e2014de1836f1bbfee700d36c26440be);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_e2014de1836f1bbfee700d36c26440be);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e2014de1836f1bbfee700d36c26440be);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_e2014de1836f1bbfee700d36c26440be, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_e2014de1836f1bbfee700d36c26440be->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_e2014de1836f1bbfee700d36c26440be, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e2014de1836f1bbfee700d36c26440be,
        type_description_1,
        par_self,
        par_idx
    );


    // Release cached frame.
    if (frame_e2014de1836f1bbfee700d36c26440be == cache_frame_e2014de1836f1bbfee700d36c26440be) {
        Py_DECREF(frame_e2014de1836f1bbfee700d36c26440be);
    }
    cache_frame_e2014de1836f1bbfee700d36c26440be = NULL;

    assertFrameObject(frame_e2014de1836f1bbfee700d36c26440be);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_174___getitem__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_idx);
    Py_DECREF(par_idx);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_idx);
    Py_DECREF(par_idx);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_175___hash__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_617ec1273e01aa3bf39c7d8e1a305e70;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_617ec1273e01aa3bf39c7d8e1a305e70 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_617ec1273e01aa3bf39c7d8e1a305e70, codeobj_617ec1273e01aa3bf39c7d8e1a305e70, module_cryptography$x509$extensions, sizeof(void *));
    frame_617ec1273e01aa3bf39c7d8e1a305e70 = cache_frame_617ec1273e01aa3bf39c7d8e1a305e70;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_617ec1273e01aa3bf39c7d8e1a305e70);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_617ec1273e01aa3bf39c7d8e1a305e70) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_hash_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_hash_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__general_names);
        if (tmp_hash_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1315;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = BUILTIN_HASH(tmp_hash_arg_1);
        Py_DECREF(tmp_hash_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1315;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_617ec1273e01aa3bf39c7d8e1a305e70);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_617ec1273e01aa3bf39c7d8e1a305e70);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_617ec1273e01aa3bf39c7d8e1a305e70);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_617ec1273e01aa3bf39c7d8e1a305e70, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_617ec1273e01aa3bf39c7d8e1a305e70->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_617ec1273e01aa3bf39c7d8e1a305e70, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_617ec1273e01aa3bf39c7d8e1a305e70,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_617ec1273e01aa3bf39c7d8e1a305e70 == cache_frame_617ec1273e01aa3bf39c7d8e1a305e70) {
        Py_DECREF(frame_617ec1273e01aa3bf39c7d8e1a305e70);
    }
    cache_frame_617ec1273e01aa3bf39c7d8e1a305e70 = NULL;

    assertFrameObject(frame_617ec1273e01aa3bf39c7d8e1a305e70);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_175___hash__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_176___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_reason = python_pars[1];
    struct Nuitka_FrameObject *frame_6c658cb11fbcf33d94d501986e68c1ff;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_6c658cb11fbcf33d94d501986e68c1ff = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_6c658cb11fbcf33d94d501986e68c1ff, codeobj_6c658cb11fbcf33d94d501986e68c1ff, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_6c658cb11fbcf33d94d501986e68c1ff = cache_frame_6c658cb11fbcf33d94d501986e68c1ff;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_6c658cb11fbcf33d94d501986e68c1ff);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_6c658cb11fbcf33d94d501986e68c1ff) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_reason);
        tmp_isinstance_inst_1 = par_reason;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ReasonFlags);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ReasonFlags);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 36774 ], 40, 0);
            exception_tb = NULL;

            exception_lineno = 1323;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1323;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1323;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_d04c4a4e63138db9ecc900ec9847717c;
            frame_6c658cb11fbcf33d94d501986e68c1ff->m_frame.f_lineno = 1324;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1324;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_reason);
        tmp_assattr_name_1 = par_reason;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__reason, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1326;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_6c658cb11fbcf33d94d501986e68c1ff);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_6c658cb11fbcf33d94d501986e68c1ff);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_6c658cb11fbcf33d94d501986e68c1ff, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_6c658cb11fbcf33d94d501986e68c1ff->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_6c658cb11fbcf33d94d501986e68c1ff, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6c658cb11fbcf33d94d501986e68c1ff,
        type_description_1,
        par_self,
        par_reason
    );


    // Release cached frame.
    if (frame_6c658cb11fbcf33d94d501986e68c1ff == cache_frame_6c658cb11fbcf33d94d501986e68c1ff) {
        Py_DECREF(frame_6c658cb11fbcf33d94d501986e68c1ff);
    }
    cache_frame_6c658cb11fbcf33d94d501986e68c1ff = NULL;

    assertFrameObject(frame_6c658cb11fbcf33d94d501986e68c1ff);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_176___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_reason);
    Py_DECREF(par_reason);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_reason);
    Py_DECREF(par_reason);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_177___repr__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_a5f1941815e6a4456d1d13832b07f311;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_a5f1941815e6a4456d1d13832b07f311 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_a5f1941815e6a4456d1d13832b07f311, codeobj_a5f1941815e6a4456d1d13832b07f311, module_cryptography$x509$extensions, sizeof(void *));
    frame_a5f1941815e6a4456d1d13832b07f311 = cache_frame_a5f1941815e6a4456d1d13832b07f311;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_a5f1941815e6a4456d1d13832b07f311);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_a5f1941815e6a4456d1d13832b07f311) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_source_name_1 = const_str_digest_73d50e8900e7f2ac40a53b664096aa15;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_format);
        assert(!(tmp_called_name_1 == NULL));
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__reason);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1329;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_a5f1941815e6a4456d1d13832b07f311->m_frame.f_lineno = 1329;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1329;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a5f1941815e6a4456d1d13832b07f311);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_a5f1941815e6a4456d1d13832b07f311);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a5f1941815e6a4456d1d13832b07f311);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_a5f1941815e6a4456d1d13832b07f311, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_a5f1941815e6a4456d1d13832b07f311->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_a5f1941815e6a4456d1d13832b07f311, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a5f1941815e6a4456d1d13832b07f311,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_a5f1941815e6a4456d1d13832b07f311 == cache_frame_a5f1941815e6a4456d1d13832b07f311) {
        Py_DECREF(frame_a5f1941815e6a4456d1d13832b07f311);
    }
    cache_frame_a5f1941815e6a4456d1d13832b07f311 = NULL;

    assertFrameObject(frame_a5f1941815e6a4456d1d13832b07f311);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_177___repr__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_178___eq__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_a121d78d607dd566078ad638d3fd9345;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_a121d78d607dd566078ad638d3fd9345 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_a121d78d607dd566078ad638d3fd9345, codeobj_a121d78d607dd566078ad638d3fd9345, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_a121d78d607dd566078ad638d3fd9345 = cache_frame_a121d78d607dd566078ad638d3fd9345;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_a121d78d607dd566078ad638d3fd9345);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_a121d78d607dd566078ad638d3fd9345) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_other);
        tmp_isinstance_inst_1 = par_other;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_CRLReason);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_CRLReason);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 37554 ], 38, 0);
            exception_tb = NULL;

            exception_lineno = 1332;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1332;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1332;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_reason);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1335;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_2 = par_other;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_reason);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_1);

            exception_lineno = 1335;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1335;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a121d78d607dd566078ad638d3fd9345);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_a121d78d607dd566078ad638d3fd9345);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a121d78d607dd566078ad638d3fd9345);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_a121d78d607dd566078ad638d3fd9345, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_a121d78d607dd566078ad638d3fd9345->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_a121d78d607dd566078ad638d3fd9345, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a121d78d607dd566078ad638d3fd9345,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_a121d78d607dd566078ad638d3fd9345 == cache_frame_a121d78d607dd566078ad638d3fd9345) {
        Py_DECREF(frame_a121d78d607dd566078ad638d3fd9345);
    }
    cache_frame_a121d78d607dd566078ad638d3fd9345 = NULL;

    assertFrameObject(frame_a121d78d607dd566078ad638d3fd9345);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_178___eq__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_179___ne__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_9b60c539be2d599550e02a9e38767f40;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_9b60c539be2d599550e02a9e38767f40 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_9b60c539be2d599550e02a9e38767f40, codeobj_9b60c539be2d599550e02a9e38767f40, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_9b60c539be2d599550e02a9e38767f40 = cache_frame_9b60c539be2d599550e02a9e38767f40;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_9b60c539be2d599550e02a9e38767f40);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_9b60c539be2d599550e02a9e38767f40) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_self);
        tmp_compexpr_left_1 = par_self;
        CHECK_OBJECT(par_other);
        tmp_compexpr_right_1 = par_other;
        tmp_operand_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1338;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1338;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = (tmp_res == 0) ? Py_True : Py_False;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9b60c539be2d599550e02a9e38767f40);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_9b60c539be2d599550e02a9e38767f40);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9b60c539be2d599550e02a9e38767f40);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_9b60c539be2d599550e02a9e38767f40, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_9b60c539be2d599550e02a9e38767f40->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_9b60c539be2d599550e02a9e38767f40, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9b60c539be2d599550e02a9e38767f40,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_9b60c539be2d599550e02a9e38767f40 == cache_frame_9b60c539be2d599550e02a9e38767f40) {
        Py_DECREF(frame_9b60c539be2d599550e02a9e38767f40);
    }
    cache_frame_9b60c539be2d599550e02a9e38767f40 = NULL;

    assertFrameObject(frame_9b60c539be2d599550e02a9e38767f40);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_179___ne__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_180___hash__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_860103f2dcafc72031eb1f0cb95f4dfe;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_860103f2dcafc72031eb1f0cb95f4dfe = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_860103f2dcafc72031eb1f0cb95f4dfe, codeobj_860103f2dcafc72031eb1f0cb95f4dfe, module_cryptography$x509$extensions, sizeof(void *));
    frame_860103f2dcafc72031eb1f0cb95f4dfe = cache_frame_860103f2dcafc72031eb1f0cb95f4dfe;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_860103f2dcafc72031eb1f0cb95f4dfe);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_860103f2dcafc72031eb1f0cb95f4dfe) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_hash_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_hash_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_reason);
        if (tmp_hash_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1341;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = BUILTIN_HASH(tmp_hash_arg_1);
        Py_DECREF(tmp_hash_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1341;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_860103f2dcafc72031eb1f0cb95f4dfe);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_860103f2dcafc72031eb1f0cb95f4dfe);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_860103f2dcafc72031eb1f0cb95f4dfe);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_860103f2dcafc72031eb1f0cb95f4dfe, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_860103f2dcafc72031eb1f0cb95f4dfe->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_860103f2dcafc72031eb1f0cb95f4dfe, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_860103f2dcafc72031eb1f0cb95f4dfe,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_860103f2dcafc72031eb1f0cb95f4dfe == cache_frame_860103f2dcafc72031eb1f0cb95f4dfe) {
        Py_DECREF(frame_860103f2dcafc72031eb1f0cb95f4dfe);
    }
    cache_frame_860103f2dcafc72031eb1f0cb95f4dfe = NULL;

    assertFrameObject(frame_860103f2dcafc72031eb1f0cb95f4dfe);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_180___hash__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_181___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_invalidity_date = python_pars[1];
    struct Nuitka_FrameObject *frame_de12b3c1eb89792f5ed199d2ecb02247;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_de12b3c1eb89792f5ed199d2ecb02247 = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_de12b3c1eb89792f5ed199d2ecb02247, codeobj_de12b3c1eb89792f5ed199d2ecb02247, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_de12b3c1eb89792f5ed199d2ecb02247 = cache_frame_de12b3c1eb89792f5ed199d2ecb02247;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_de12b3c1eb89792f5ed199d2ecb02247);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_de12b3c1eb89792f5ed199d2ecb02247) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_invalidity_date);
        tmp_isinstance_inst_1 = par_invalidity_date;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_datetime);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_datetime);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3880 ], 37, 0);
            exception_tb = NULL;

            exception_lineno = 1351;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_isinstance_cls_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_datetime);
        if (tmp_isinstance_cls_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1351;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        Py_DECREF(tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1351;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1351;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_91034dde8ef1b9b2896e23f094ab68ec;
            frame_de12b3c1eb89792f5ed199d2ecb02247->m_frame.f_lineno = 1352;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1352;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_invalidity_date);
        tmp_assattr_name_1 = par_invalidity_date;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__invalidity_date, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1354;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_de12b3c1eb89792f5ed199d2ecb02247);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_de12b3c1eb89792f5ed199d2ecb02247);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_de12b3c1eb89792f5ed199d2ecb02247, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_de12b3c1eb89792f5ed199d2ecb02247->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_de12b3c1eb89792f5ed199d2ecb02247, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_de12b3c1eb89792f5ed199d2ecb02247,
        type_description_1,
        par_self,
        par_invalidity_date
    );


    // Release cached frame.
    if (frame_de12b3c1eb89792f5ed199d2ecb02247 == cache_frame_de12b3c1eb89792f5ed199d2ecb02247) {
        Py_DECREF(frame_de12b3c1eb89792f5ed199d2ecb02247);
    }
    cache_frame_de12b3c1eb89792f5ed199d2ecb02247 = NULL;

    assertFrameObject(frame_de12b3c1eb89792f5ed199d2ecb02247);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_181___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_invalidity_date);
    Py_DECREF(par_invalidity_date);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_invalidity_date);
    Py_DECREF(par_invalidity_date);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_182___repr__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_8188b9ec4ae4d8387eb82dac38e406e0;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_8188b9ec4ae4d8387eb82dac38e406e0 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_8188b9ec4ae4d8387eb82dac38e406e0, codeobj_8188b9ec4ae4d8387eb82dac38e406e0, module_cryptography$x509$extensions, sizeof(void *));
    frame_8188b9ec4ae4d8387eb82dac38e406e0 = cache_frame_8188b9ec4ae4d8387eb82dac38e406e0;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_8188b9ec4ae4d8387eb82dac38e406e0);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_8188b9ec4ae4d8387eb82dac38e406e0) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_source_name_1 = const_str_digest_2e6a7667e25628285e79573956cb938f;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_format);
        assert(!(tmp_called_name_1 == NULL));
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__invalidity_date);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1358;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_8188b9ec4ae4d8387eb82dac38e406e0->m_frame.f_lineno = 1357;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1357;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8188b9ec4ae4d8387eb82dac38e406e0);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_8188b9ec4ae4d8387eb82dac38e406e0);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8188b9ec4ae4d8387eb82dac38e406e0);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_8188b9ec4ae4d8387eb82dac38e406e0, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_8188b9ec4ae4d8387eb82dac38e406e0->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_8188b9ec4ae4d8387eb82dac38e406e0, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8188b9ec4ae4d8387eb82dac38e406e0,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_8188b9ec4ae4d8387eb82dac38e406e0 == cache_frame_8188b9ec4ae4d8387eb82dac38e406e0) {
        Py_DECREF(frame_8188b9ec4ae4d8387eb82dac38e406e0);
    }
    cache_frame_8188b9ec4ae4d8387eb82dac38e406e0 = NULL;

    assertFrameObject(frame_8188b9ec4ae4d8387eb82dac38e406e0);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_182___repr__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_183___eq__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_794acec4cbbb193c4d12f82b7f02da0c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_794acec4cbbb193c4d12f82b7f02da0c = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_794acec4cbbb193c4d12f82b7f02da0c, codeobj_794acec4cbbb193c4d12f82b7f02da0c, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_794acec4cbbb193c4d12f82b7f02da0c = cache_frame_794acec4cbbb193c4d12f82b7f02da0c;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_794acec4cbbb193c4d12f82b7f02da0c);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_794acec4cbbb193c4d12f82b7f02da0c) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_other);
        tmp_isinstance_inst_1 = par_other;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_InvalidityDate);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_InvalidityDate);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 37592 ], 43, 0);
            exception_tb = NULL;

            exception_lineno = 1362;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1362;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1362;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_invalidity_date);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1365;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_2 = par_other;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_invalidity_date);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_1);

            exception_lineno = 1365;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1365;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_794acec4cbbb193c4d12f82b7f02da0c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_794acec4cbbb193c4d12f82b7f02da0c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_794acec4cbbb193c4d12f82b7f02da0c);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_794acec4cbbb193c4d12f82b7f02da0c, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_794acec4cbbb193c4d12f82b7f02da0c->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_794acec4cbbb193c4d12f82b7f02da0c, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_794acec4cbbb193c4d12f82b7f02da0c,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_794acec4cbbb193c4d12f82b7f02da0c == cache_frame_794acec4cbbb193c4d12f82b7f02da0c) {
        Py_DECREF(frame_794acec4cbbb193c4d12f82b7f02da0c);
    }
    cache_frame_794acec4cbbb193c4d12f82b7f02da0c = NULL;

    assertFrameObject(frame_794acec4cbbb193c4d12f82b7f02da0c);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_183___eq__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_184___ne__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_8df0a17a4cea47e2942cb3a703b1e430;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_8df0a17a4cea47e2942cb3a703b1e430 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_8df0a17a4cea47e2942cb3a703b1e430, codeobj_8df0a17a4cea47e2942cb3a703b1e430, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_8df0a17a4cea47e2942cb3a703b1e430 = cache_frame_8df0a17a4cea47e2942cb3a703b1e430;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_8df0a17a4cea47e2942cb3a703b1e430);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_8df0a17a4cea47e2942cb3a703b1e430) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_self);
        tmp_compexpr_left_1 = par_self;
        CHECK_OBJECT(par_other);
        tmp_compexpr_right_1 = par_other;
        tmp_operand_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1368;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1368;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = (tmp_res == 0) ? Py_True : Py_False;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8df0a17a4cea47e2942cb3a703b1e430);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_8df0a17a4cea47e2942cb3a703b1e430);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8df0a17a4cea47e2942cb3a703b1e430);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_8df0a17a4cea47e2942cb3a703b1e430, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_8df0a17a4cea47e2942cb3a703b1e430->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_8df0a17a4cea47e2942cb3a703b1e430, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8df0a17a4cea47e2942cb3a703b1e430,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_8df0a17a4cea47e2942cb3a703b1e430 == cache_frame_8df0a17a4cea47e2942cb3a703b1e430) {
        Py_DECREF(frame_8df0a17a4cea47e2942cb3a703b1e430);
    }
    cache_frame_8df0a17a4cea47e2942cb3a703b1e430 = NULL;

    assertFrameObject(frame_8df0a17a4cea47e2942cb3a703b1e430);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_184___ne__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_185___hash__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_ff20a1f819ea51d73291e30a17f7b7d5;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_ff20a1f819ea51d73291e30a17f7b7d5 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_ff20a1f819ea51d73291e30a17f7b7d5, codeobj_ff20a1f819ea51d73291e30a17f7b7d5, module_cryptography$x509$extensions, sizeof(void *));
    frame_ff20a1f819ea51d73291e30a17f7b7d5 = cache_frame_ff20a1f819ea51d73291e30a17f7b7d5;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_ff20a1f819ea51d73291e30a17f7b7d5);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_ff20a1f819ea51d73291e30a17f7b7d5) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_hash_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_hash_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_invalidity_date);
        if (tmp_hash_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1371;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = BUILTIN_HASH(tmp_hash_arg_1);
        Py_DECREF(tmp_hash_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1371;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ff20a1f819ea51d73291e30a17f7b7d5);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_ff20a1f819ea51d73291e30a17f7b7d5);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ff20a1f819ea51d73291e30a17f7b7d5);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_ff20a1f819ea51d73291e30a17f7b7d5, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_ff20a1f819ea51d73291e30a17f7b7d5->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_ff20a1f819ea51d73291e30a17f7b7d5, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ff20a1f819ea51d73291e30a17f7b7d5,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_ff20a1f819ea51d73291e30a17f7b7d5 == cache_frame_ff20a1f819ea51d73291e30a17f7b7d5) {
        Py_DECREF(frame_ff20a1f819ea51d73291e30a17f7b7d5);
    }
    cache_frame_ff20a1f819ea51d73291e30a17f7b7d5 = NULL;

    assertFrameObject(frame_ff20a1f819ea51d73291e30a17f7b7d5);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_185___hash__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_186___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_signed_certificate_timestamps = python_pars[1];
    PyObject *tmp_genexpr_1__$0 = NULL;
    struct Nuitka_FrameObject *frame_5c40cf088e4ab97ee21bf262ce67d13d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_5c40cf088e4ab97ee21bf262ce67d13d = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_5c40cf088e4ab97ee21bf262ce67d13d, codeobj_5c40cf088e4ab97ee21bf262ce67d13d, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_5c40cf088e4ab97ee21bf262ce67d13d = cache_frame_5c40cf088e4ab97ee21bf262ce67d13d;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_5c40cf088e4ab97ee21bf262ce67d13d);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_5c40cf088e4ab97ee21bf262ce67d13d) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_list_arg_1;
        CHECK_OBJECT(par_signed_certificate_timestamps);
        tmp_list_arg_1 = par_signed_certificate_timestamps;
        tmp_assign_source_1 = PySequence_List(tmp_list_arg_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1381;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = par_signed_certificate_timestamps;
            assert(old != NULL);
            par_signed_certificate_timestamps = tmp_assign_source_1;
            Py_DECREF(old);
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_all_arg_1;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT(par_signed_certificate_timestamps);
            tmp_iter_arg_1 = par_signed_certificate_timestamps;
            tmp_assign_source_2 = MAKE_ITERATOR(tmp_iter_arg_1);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1383;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            assert(tmp_genexpr_1__$0 == NULL);
            tmp_genexpr_1__$0 = tmp_assign_source_2;
        }
        // Tried code:
        tmp_all_arg_1 = cryptography$x509$extensions$$$function_186___init__$$$genexpr_1_genexpr_maker();

        ((struct Nuitka_GeneratorObject *)tmp_all_arg_1)->m_closure[0] = PyCell_NEW0(tmp_genexpr_1__$0);


        goto try_return_handler_2;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_186___init__);
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        CHECK_OBJECT((PyObject *)tmp_genexpr_1__$0);
        Py_DECREF(tmp_genexpr_1__$0);
        tmp_genexpr_1__$0 = NULL;

        goto outline_result_1;
        // End of try:
        CHECK_OBJECT((PyObject *)tmp_genexpr_1__$0);
        Py_DECREF(tmp_genexpr_1__$0);
        tmp_genexpr_1__$0 = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_186___init__);
        return NULL;
        outline_result_1:;
        tmp_operand_name_1 = BUILTIN_ALL(tmp_all_arg_1);
        Py_DECREF(tmp_all_arg_1);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1382;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1382;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_d3e161c72eca6237cebf732e747f2482;
            frame_5c40cf088e4ab97ee21bf262ce67d13d->m_frame.f_lineno = 1386;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1386;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_signed_certificate_timestamps);
        tmp_assattr_name_1 = par_signed_certificate_timestamps;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__signed_certificate_timestamps, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1390;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5c40cf088e4ab97ee21bf262ce67d13d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5c40cf088e4ab97ee21bf262ce67d13d);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_5c40cf088e4ab97ee21bf262ce67d13d, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_5c40cf088e4ab97ee21bf262ce67d13d->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_5c40cf088e4ab97ee21bf262ce67d13d, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5c40cf088e4ab97ee21bf262ce67d13d,
        type_description_1,
        par_self,
        par_signed_certificate_timestamps
    );


    // Release cached frame.
    if (frame_5c40cf088e4ab97ee21bf262ce67d13d == cache_frame_5c40cf088e4ab97ee21bf262ce67d13d) {
        Py_DECREF(frame_5c40cf088e4ab97ee21bf262ce67d13d);
    }
    cache_frame_5c40cf088e4ab97ee21bf262ce67d13d = NULL;

    assertFrameObject(frame_5c40cf088e4ab97ee21bf262ce67d13d);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_186___init__);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)par_signed_certificate_timestamps);
    Py_DECREF(par_signed_certificate_timestamps);
    par_signed_certificate_timestamps = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)par_signed_certificate_timestamps);
    Py_DECREF(par_signed_certificate_timestamps);
    par_signed_certificate_timestamps = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_186___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}



struct cryptography$x509$extensions$$$function_186___init__$$$genexpr_1_genexpr_locals {
    PyObject *var_sct;
    PyObject *tmp_iter_value_0;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    int tmp_res;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *cryptography$x509$extensions$$$function_186___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value ) {
    CHECK_OBJECT((PyObject *)generator);
    assert(Nuitka_Generator_Check( (PyObject *)generator ));

    // Heap access if used.
    struct cryptography$x509$extensions$$$function_186___init__$$$genexpr_1_genexpr_locals *generator_heap = (struct cryptography$x509$extensions$$$function_186___init__$$$genexpr_1_genexpr_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_sct = NULL;
    generator_heap->tmp_iter_value_0 = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_m_frame, codeobj_6cc5423ab0acdb175d93b9726ccbd1a5, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF(generator->m_frame);
    assert(Py_REFCNT(generator->m_frame) == 2); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR(generator->m_frame->m_frame.f_back);

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF(generator->m_frame->m_frame.f_back);

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF(generator->m_frame);

    Nuitka_Frame_MarkAsExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

        EXC_TYPE_F(generator) = EXC_TYPE(thread_state);
        if (EXC_TYPE_F(generator) == Py_None) EXC_TYPE_F(generator) = NULL;
        Py_XINCREF(EXC_TYPE_F(generator));
        EXC_VALUE_F(generator) = EXC_VALUE(thread_state);
        Py_XINCREF(EXC_VALUE_F(generator));
        EXC_TRACEBACK_F(generator) = EXC_TRACEBACK(thread_state);
        Py_XINCREF(EXC_TRACEBACK_F(generator));
    }

#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_1;
        CHECK_OBJECT(PyCell_GET(generator->m_closure[0]));
        tmp_next_source_1 = PyCell_GET(generator->m_closure[0]);
        tmp_assign_source_1 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_1 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);
                generator_heap->type_description_1 = "No";
                generator_heap->exception_lineno = 1383;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_iter_value_0;
            generator_heap->tmp_iter_value_0 = tmp_assign_source_1;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT(generator_heap->tmp_iter_value_0);
        tmp_assign_source_2 = generator_heap->tmp_iter_value_0;
        {
            PyObject *old = generator_heap->var_sct;
            generator_heap->var_sct = tmp_assign_source_2;
            Py_INCREF(generator_heap->var_sct);
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_expression_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        CHECK_OBJECT(generator_heap->var_sct);
        tmp_isinstance_inst_1 = generator_heap->var_sct;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_SignedCertificateTimestamp);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_SignedCertificateTimestamp);
        }

        if (tmp_mvar_value_1 == NULL) {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF(generator_heap->exception_type);
            generator_heap->exception_value = UNSTREAM_STRING(&constant_bin[ 37635 ], 55, 0);
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 1383;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        generator_heap->tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (generator_heap->tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 1383;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_expression_name_1 = (generator_heap->tmp_res != 0) ? Py_True : Py_False;
        Py_INCREF(tmp_expression_name_1);
        Nuitka_PreserveHeap(generator_heap->yield_tmps, &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), NULL);
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        Nuitka_RestoreHeap(generator_heap->yield_tmps, &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), NULL);
        if (yield_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 1383;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


        generator_heap->exception_lineno = 1383;
        generator_heap->type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    // Allow re-use of the frame again.
    Py_DECREF(generator->m_frame);
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if (!EXCEPTION_MATCH_GENERATOR(generator_heap->exception_type)) {
        if (generator_heap->exception_tb == NULL) {
            generator_heap->exception_tb = MAKE_TRACEBACK(generator->m_frame, generator_heap->exception_lineno);
        } else if (generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame) {
            generator_heap->exception_tb = ADD_TRACEBACK(generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno);
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            NULL,
            generator_heap->var_sct
        );


        // Release cached frame.
        if (generator->m_frame == cache_m_frame) {
            Py_DECREF(generator->m_frame);
        }
        cache_m_frame = NULL;

        assertFrameObject(generator->m_frame);
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    Py_DECREF(generator->m_frame);

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->var_sct);
    generator_heap->var_sct = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    Py_XDECREF(generator_heap->var_sct);
    generator_heap->var_sct = NULL;



    return NULL;

    function_exception_exit:
    assert(generator_heap->exception_type);
    RESTORE_ERROR_OCCURRED(generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb);

    return NULL;

}

static PyObject *cryptography$x509$extensions$$$function_186___init__$$$genexpr_1_genexpr_maker(void) {
    return Nuitka_Generator_New(
        cryptography$x509$extensions$$$function_186___init__$$$genexpr_1_genexpr_context,
        module_cryptography$x509$extensions,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_6cc5423ab0acdb175d93b9726ccbd1a5,
        1,
        sizeof(struct cryptography$x509$extensions$$$function_186___init__$$$genexpr_1_genexpr_locals)
    );
}


static PyObject *impl_cryptography$x509$extensions$$$function_187___iter__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_d19dda71d3d42b410ec1cac06f83952c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_d19dda71d3d42b410ec1cac06f83952c = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_d19dda71d3d42b410ec1cac06f83952c, codeobj_d19dda71d3d42b410ec1cac06f83952c, module_cryptography$x509$extensions, sizeof(void *));
    frame_d19dda71d3d42b410ec1cac06f83952c = cache_frame_d19dda71d3d42b410ec1cac06f83952c;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_d19dda71d3d42b410ec1cac06f83952c);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_d19dda71d3d42b410ec1cac06f83952c) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_iter_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__signed_certificate_timestamps);
        if (tmp_iter_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1393;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = MAKE_ITERATOR(tmp_iter_arg_1);
        Py_DECREF(tmp_iter_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1393;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_d19dda71d3d42b410ec1cac06f83952c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_d19dda71d3d42b410ec1cac06f83952c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_d19dda71d3d42b410ec1cac06f83952c);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_d19dda71d3d42b410ec1cac06f83952c, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_d19dda71d3d42b410ec1cac06f83952c->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_d19dda71d3d42b410ec1cac06f83952c, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d19dda71d3d42b410ec1cac06f83952c,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_d19dda71d3d42b410ec1cac06f83952c == cache_frame_d19dda71d3d42b410ec1cac06f83952c) {
        Py_DECREF(frame_d19dda71d3d42b410ec1cac06f83952c);
    }
    cache_frame_d19dda71d3d42b410ec1cac06f83952c = NULL;

    assertFrameObject(frame_d19dda71d3d42b410ec1cac06f83952c);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_187___iter__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_188___len__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_538db483ab62c4241ff17d2733bb07d0;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_538db483ab62c4241ff17d2733bb07d0 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_538db483ab62c4241ff17d2733bb07d0, codeobj_538db483ab62c4241ff17d2733bb07d0, module_cryptography$x509$extensions, sizeof(void *));
    frame_538db483ab62c4241ff17d2733bb07d0 = cache_frame_538db483ab62c4241ff17d2733bb07d0;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_538db483ab62c4241ff17d2733bb07d0);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_538db483ab62c4241ff17d2733bb07d0) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_len_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_len_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__signed_certificate_timestamps);
        if (tmp_len_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1396;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = BUILTIN_LEN(tmp_len_arg_1);
        Py_DECREF(tmp_len_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1396;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_538db483ab62c4241ff17d2733bb07d0);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_538db483ab62c4241ff17d2733bb07d0);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_538db483ab62c4241ff17d2733bb07d0);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_538db483ab62c4241ff17d2733bb07d0, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_538db483ab62c4241ff17d2733bb07d0->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_538db483ab62c4241ff17d2733bb07d0, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_538db483ab62c4241ff17d2733bb07d0,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_538db483ab62c4241ff17d2733bb07d0 == cache_frame_538db483ab62c4241ff17d2733bb07d0) {
        Py_DECREF(frame_538db483ab62c4241ff17d2733bb07d0);
    }
    cache_frame_538db483ab62c4241ff17d2733bb07d0 = NULL;

    assertFrameObject(frame_538db483ab62c4241ff17d2733bb07d0);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_188___len__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_189___getitem__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_idx = python_pars[1];
    struct Nuitka_FrameObject *frame_2cd7211ae0497207f8bc2f43f4d4f414;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_2cd7211ae0497207f8bc2f43f4d4f414 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_2cd7211ae0497207f8bc2f43f4d4f414, codeobj_2cd7211ae0497207f8bc2f43f4d4f414, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_2cd7211ae0497207f8bc2f43f4d4f414 = cache_frame_2cd7211ae0497207f8bc2f43f4d4f414;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_2cd7211ae0497207f8bc2f43f4d4f414);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_2cd7211ae0497207f8bc2f43f4d4f414) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_subscript_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__signed_certificate_timestamps);
        if (tmp_subscribed_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1399;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_idx);
        tmp_subscript_name_1 = par_idx;
        tmp_return_value = LOOKUP_SUBSCRIPT(tmp_subscribed_name_1, tmp_subscript_name_1);
        Py_DECREF(tmp_subscribed_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1399;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2cd7211ae0497207f8bc2f43f4d4f414);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_2cd7211ae0497207f8bc2f43f4d4f414);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2cd7211ae0497207f8bc2f43f4d4f414);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_2cd7211ae0497207f8bc2f43f4d4f414, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_2cd7211ae0497207f8bc2f43f4d4f414->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_2cd7211ae0497207f8bc2f43f4d4f414, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2cd7211ae0497207f8bc2f43f4d4f414,
        type_description_1,
        par_self,
        par_idx
    );


    // Release cached frame.
    if (frame_2cd7211ae0497207f8bc2f43f4d4f414 == cache_frame_2cd7211ae0497207f8bc2f43f4d4f414) {
        Py_DECREF(frame_2cd7211ae0497207f8bc2f43f4d4f414);
    }
    cache_frame_2cd7211ae0497207f8bc2f43f4d4f414 = NULL;

    assertFrameObject(frame_2cd7211ae0497207f8bc2f43f4d4f414);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_189___getitem__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_idx);
    Py_DECREF(par_idx);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_idx);
    Py_DECREF(par_idx);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_190___repr__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_cd9319f1e2a709da2e67b8939c90e219;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_cd9319f1e2a709da2e67b8939c90e219 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_cd9319f1e2a709da2e67b8939c90e219, codeobj_cd9319f1e2a709da2e67b8939c90e219, module_cryptography$x509$extensions, sizeof(void *));
    frame_cd9319f1e2a709da2e67b8939c90e219 = cache_frame_cd9319f1e2a709da2e67b8939c90e219;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_cd9319f1e2a709da2e67b8939c90e219);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_cd9319f1e2a709da2e67b8939c90e219) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_list_arg_1;
        tmp_source_name_1 = const_str_digest_171541ce3e17f273a42b3961194a7b72;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_format);
        assert(!(tmp_called_name_1 == NULL));
        CHECK_OBJECT(par_self);
        tmp_list_arg_1 = par_self;
        tmp_args_element_name_1 = PySequence_List(tmp_list_arg_1);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1404;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_cd9319f1e2a709da2e67b8939c90e219->m_frame.f_lineno = 1403;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1403;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_cd9319f1e2a709da2e67b8939c90e219);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_cd9319f1e2a709da2e67b8939c90e219);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_cd9319f1e2a709da2e67b8939c90e219);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_cd9319f1e2a709da2e67b8939c90e219, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_cd9319f1e2a709da2e67b8939c90e219->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_cd9319f1e2a709da2e67b8939c90e219, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_cd9319f1e2a709da2e67b8939c90e219,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_cd9319f1e2a709da2e67b8939c90e219 == cache_frame_cd9319f1e2a709da2e67b8939c90e219) {
        Py_DECREF(frame_cd9319f1e2a709da2e67b8939c90e219);
    }
    cache_frame_cd9319f1e2a709da2e67b8939c90e219 = NULL;

    assertFrameObject(frame_cd9319f1e2a709da2e67b8939c90e219);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_190___repr__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_191___hash__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_54cad17ac3bd5403abe61737684eaa45;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_54cad17ac3bd5403abe61737684eaa45 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_54cad17ac3bd5403abe61737684eaa45, codeobj_54cad17ac3bd5403abe61737684eaa45, module_cryptography$x509$extensions, sizeof(void *));
    frame_54cad17ac3bd5403abe61737684eaa45 = cache_frame_54cad17ac3bd5403abe61737684eaa45;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_54cad17ac3bd5403abe61737684eaa45);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_54cad17ac3bd5403abe61737684eaa45) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_hash_arg_1;
        PyObject *tmp_tuple_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_tuple_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__signed_certificate_timestamps);
        if (tmp_tuple_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1409;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_hash_arg_1 = PySequence_Tuple(tmp_tuple_arg_1);
        Py_DECREF(tmp_tuple_arg_1);
        if (tmp_hash_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1409;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = BUILTIN_HASH(tmp_hash_arg_1);
        Py_DECREF(tmp_hash_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1409;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_54cad17ac3bd5403abe61737684eaa45);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_54cad17ac3bd5403abe61737684eaa45);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_54cad17ac3bd5403abe61737684eaa45);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_54cad17ac3bd5403abe61737684eaa45, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_54cad17ac3bd5403abe61737684eaa45->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_54cad17ac3bd5403abe61737684eaa45, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_54cad17ac3bd5403abe61737684eaa45,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_54cad17ac3bd5403abe61737684eaa45 == cache_frame_54cad17ac3bd5403abe61737684eaa45) {
        Py_DECREF(frame_54cad17ac3bd5403abe61737684eaa45);
    }
    cache_frame_54cad17ac3bd5403abe61737684eaa45 = NULL;

    assertFrameObject(frame_54cad17ac3bd5403abe61737684eaa45);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_191___hash__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_192___eq__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_01367d6abaf9a9706fda30395db202db;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_01367d6abaf9a9706fda30395db202db = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_01367d6abaf9a9706fda30395db202db, codeobj_01367d6abaf9a9706fda30395db202db, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_01367d6abaf9a9706fda30395db202db = cache_frame_01367d6abaf9a9706fda30395db202db;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_01367d6abaf9a9706fda30395db202db);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_01367d6abaf9a9706fda30395db202db) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_other);
        tmp_isinstance_inst_1 = par_other;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_digest_97ac982b098bfd0facb64df38773c335);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_digest_97ac982b098bfd0facb64df38773c335);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 37690 ], 70, 0);
            exception_tb = NULL;

            exception_lineno = 1412;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1412;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1412;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__signed_certificate_timestamps);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1416;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_2 = par_other;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__signed_certificate_timestamps);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_1);

            exception_lineno = 1417;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1416;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_01367d6abaf9a9706fda30395db202db);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_01367d6abaf9a9706fda30395db202db);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_01367d6abaf9a9706fda30395db202db);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_01367d6abaf9a9706fda30395db202db, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_01367d6abaf9a9706fda30395db202db->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_01367d6abaf9a9706fda30395db202db, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_01367d6abaf9a9706fda30395db202db,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_01367d6abaf9a9706fda30395db202db == cache_frame_01367d6abaf9a9706fda30395db202db) {
        Py_DECREF(frame_01367d6abaf9a9706fda30395db202db);
    }
    cache_frame_01367d6abaf9a9706fda30395db202db = NULL;

    assertFrameObject(frame_01367d6abaf9a9706fda30395db202db);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_192___eq__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_193___ne__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_b1baa4b5a4f28808018d8437290cabf1;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_b1baa4b5a4f28808018d8437290cabf1 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_b1baa4b5a4f28808018d8437290cabf1, codeobj_b1baa4b5a4f28808018d8437290cabf1, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_b1baa4b5a4f28808018d8437290cabf1 = cache_frame_b1baa4b5a4f28808018d8437290cabf1;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_b1baa4b5a4f28808018d8437290cabf1);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_b1baa4b5a4f28808018d8437290cabf1) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_self);
        tmp_compexpr_left_1 = par_self;
        CHECK_OBJECT(par_other);
        tmp_compexpr_right_1 = par_other;
        tmp_operand_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1421;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1421;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = (tmp_res == 0) ? Py_True : Py_False;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b1baa4b5a4f28808018d8437290cabf1);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_b1baa4b5a4f28808018d8437290cabf1);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b1baa4b5a4f28808018d8437290cabf1);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_b1baa4b5a4f28808018d8437290cabf1, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_b1baa4b5a4f28808018d8437290cabf1->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_b1baa4b5a4f28808018d8437290cabf1, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b1baa4b5a4f28808018d8437290cabf1,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_b1baa4b5a4f28808018d8437290cabf1 == cache_frame_b1baa4b5a4f28808018d8437290cabf1) {
        Py_DECREF(frame_b1baa4b5a4f28808018d8437290cabf1);
    }
    cache_frame_b1baa4b5a4f28808018d8437290cabf1 = NULL;

    assertFrameObject(frame_b1baa4b5a4f28808018d8437290cabf1);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_193___ne__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_194___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_nonce = python_pars[1];
    struct Nuitka_FrameObject *frame_93c4a51e5d5a057df74d80318f8994b9;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_93c4a51e5d5a057df74d80318f8994b9 = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_93c4a51e5d5a057df74d80318f8994b9, codeobj_93c4a51e5d5a057df74d80318f8994b9, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_93c4a51e5d5a057df74d80318f8994b9 = cache_frame_93c4a51e5d5a057df74d80318f8994b9;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_93c4a51e5d5a057df74d80318f8994b9);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_93c4a51e5d5a057df74d80318f8994b9) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        CHECK_OBJECT(par_nonce);
        tmp_isinstance_inst_1 = par_nonce;
        tmp_isinstance_cls_1 = (PyObject *)&PyString_Type;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1429;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1429;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_f37468dd5629ccacfbc304506e5ed113;
            frame_93c4a51e5d5a057df74d80318f8994b9->m_frame.f_lineno = 1430;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1430;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_nonce);
        tmp_assattr_name_1 = par_nonce;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__nonce, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1432;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_93c4a51e5d5a057df74d80318f8994b9);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_93c4a51e5d5a057df74d80318f8994b9);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_93c4a51e5d5a057df74d80318f8994b9, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_93c4a51e5d5a057df74d80318f8994b9->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_93c4a51e5d5a057df74d80318f8994b9, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_93c4a51e5d5a057df74d80318f8994b9,
        type_description_1,
        par_self,
        par_nonce
    );


    // Release cached frame.
    if (frame_93c4a51e5d5a057df74d80318f8994b9 == cache_frame_93c4a51e5d5a057df74d80318f8994b9) {
        Py_DECREF(frame_93c4a51e5d5a057df74d80318f8994b9);
    }
    cache_frame_93c4a51e5d5a057df74d80318f8994b9 = NULL;

    assertFrameObject(frame_93c4a51e5d5a057df74d80318f8994b9);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_194___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_nonce);
    Py_DECREF(par_nonce);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_nonce);
    Py_DECREF(par_nonce);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_195___eq__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_7028bdbd3fa71c0482994e203d0dd60c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_7028bdbd3fa71c0482994e203d0dd60c = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_7028bdbd3fa71c0482994e203d0dd60c, codeobj_7028bdbd3fa71c0482994e203d0dd60c, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_7028bdbd3fa71c0482994e203d0dd60c = cache_frame_7028bdbd3fa71c0482994e203d0dd60c;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_7028bdbd3fa71c0482994e203d0dd60c);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_7028bdbd3fa71c0482994e203d0dd60c) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_other);
        tmp_isinstance_inst_1 = par_other;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_OCSPNonce);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_OCSPNonce);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 37760 ], 38, 0);
            exception_tb = NULL;

            exception_lineno = 1435;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1435;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1435;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_nonce);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1438;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_2 = par_other;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_nonce);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_1);

            exception_lineno = 1438;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1438;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_7028bdbd3fa71c0482994e203d0dd60c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_7028bdbd3fa71c0482994e203d0dd60c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_7028bdbd3fa71c0482994e203d0dd60c);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_7028bdbd3fa71c0482994e203d0dd60c, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_7028bdbd3fa71c0482994e203d0dd60c->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_7028bdbd3fa71c0482994e203d0dd60c, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7028bdbd3fa71c0482994e203d0dd60c,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_7028bdbd3fa71c0482994e203d0dd60c == cache_frame_7028bdbd3fa71c0482994e203d0dd60c) {
        Py_DECREF(frame_7028bdbd3fa71c0482994e203d0dd60c);
    }
    cache_frame_7028bdbd3fa71c0482994e203d0dd60c = NULL;

    assertFrameObject(frame_7028bdbd3fa71c0482994e203d0dd60c);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_195___eq__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_196___ne__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_2b9f0db2a0884ae0c464ed42cbe0ca77;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_2b9f0db2a0884ae0c464ed42cbe0ca77 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_2b9f0db2a0884ae0c464ed42cbe0ca77, codeobj_2b9f0db2a0884ae0c464ed42cbe0ca77, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_2b9f0db2a0884ae0c464ed42cbe0ca77 = cache_frame_2b9f0db2a0884ae0c464ed42cbe0ca77;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_2b9f0db2a0884ae0c464ed42cbe0ca77);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_2b9f0db2a0884ae0c464ed42cbe0ca77) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_self);
        tmp_compexpr_left_1 = par_self;
        CHECK_OBJECT(par_other);
        tmp_compexpr_right_1 = par_other;
        tmp_operand_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1441;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1441;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = (tmp_res == 0) ? Py_True : Py_False;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2b9f0db2a0884ae0c464ed42cbe0ca77);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_2b9f0db2a0884ae0c464ed42cbe0ca77);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2b9f0db2a0884ae0c464ed42cbe0ca77);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_2b9f0db2a0884ae0c464ed42cbe0ca77, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_2b9f0db2a0884ae0c464ed42cbe0ca77->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_2b9f0db2a0884ae0c464ed42cbe0ca77, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2b9f0db2a0884ae0c464ed42cbe0ca77,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_2b9f0db2a0884ae0c464ed42cbe0ca77 == cache_frame_2b9f0db2a0884ae0c464ed42cbe0ca77) {
        Py_DECREF(frame_2b9f0db2a0884ae0c464ed42cbe0ca77);
    }
    cache_frame_2b9f0db2a0884ae0c464ed42cbe0ca77 = NULL;

    assertFrameObject(frame_2b9f0db2a0884ae0c464ed42cbe0ca77);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_196___ne__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_197___hash__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_bbff8841f994d0861901167e26c77f21;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_bbff8841f994d0861901167e26c77f21 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_bbff8841f994d0861901167e26c77f21, codeobj_bbff8841f994d0861901167e26c77f21, module_cryptography$x509$extensions, sizeof(void *));
    frame_bbff8841f994d0861901167e26c77f21 = cache_frame_bbff8841f994d0861901167e26c77f21;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_bbff8841f994d0861901167e26c77f21);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_bbff8841f994d0861901167e26c77f21) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_hash_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_hash_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_nonce);
        if (tmp_hash_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1444;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = BUILTIN_HASH(tmp_hash_arg_1);
        Py_DECREF(tmp_hash_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1444;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_bbff8841f994d0861901167e26c77f21);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_bbff8841f994d0861901167e26c77f21);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_bbff8841f994d0861901167e26c77f21);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_bbff8841f994d0861901167e26c77f21, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_bbff8841f994d0861901167e26c77f21->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_bbff8841f994d0861901167e26c77f21, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_bbff8841f994d0861901167e26c77f21,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_bbff8841f994d0861901167e26c77f21 == cache_frame_bbff8841f994d0861901167e26c77f21) {
        Py_DECREF(frame_bbff8841f994d0861901167e26c77f21);
    }
    cache_frame_bbff8841f994d0861901167e26c77f21 = NULL;

    assertFrameObject(frame_bbff8841f994d0861901167e26c77f21);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_197___hash__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_198___repr__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_1492769ae6147f752f0b4b6f237cf894;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_1492769ae6147f752f0b4b6f237cf894 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_1492769ae6147f752f0b4b6f237cf894, codeobj_1492769ae6147f752f0b4b6f237cf894, module_cryptography$x509$extensions, sizeof(void *));
    frame_1492769ae6147f752f0b4b6f237cf894 = cache_frame_1492769ae6147f752f0b4b6f237cf894;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_1492769ae6147f752f0b4b6f237cf894);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_1492769ae6147f752f0b4b6f237cf894) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        tmp_called_instance_1 = const_str_digest_92ebfd7d825e182438411c24725c884a;
        CHECK_OBJECT(par_self);
        tmp_args_element_name_1 = par_self;
        frame_1492769ae6147f752f0b4b6f237cf894->m_frame.f_lineno = 1447;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_format, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1447;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_1492769ae6147f752f0b4b6f237cf894);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_1492769ae6147f752f0b4b6f237cf894);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_1492769ae6147f752f0b4b6f237cf894);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_1492769ae6147f752f0b4b6f237cf894, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_1492769ae6147f752f0b4b6f237cf894->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_1492769ae6147f752f0b4b6f237cf894, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1492769ae6147f752f0b4b6f237cf894,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_1492769ae6147f752f0b4b6f237cf894 == cache_frame_1492769ae6147f752f0b4b6f237cf894) {
        Py_DECREF(frame_1492769ae6147f752f0b4b6f237cf894);
    }
    cache_frame_1492769ae6147f752f0b4b6f237cf894 = NULL;

    assertFrameObject(frame_1492769ae6147f752f0b4b6f237cf894);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_198___repr__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_199___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_full_name = python_pars[1];
    PyObject *par_relative_name = python_pars[2];
    PyObject *par_only_contains_user_certs = python_pars[3];
    PyObject *par_only_contains_ca_certs = python_pars[4];
    PyObject *par_only_some_reasons = python_pars[5];
    PyObject *par_indirect_crl = python_pars[6];
    PyObject *par_only_contains_attribute_certs = python_pars[7];
    PyObject *var_crl_constraints = NULL;
    PyObject *var_x = NULL;
    PyObject *tmp_genexpr_1__$0 = NULL;
    PyObject *tmp_list_contraction_1__$0 = NULL;
    PyObject *tmp_list_contraction_1__contraction_result = NULL;
    PyObject *tmp_list_contraction_1__iter_value_0 = NULL;
    struct Nuitka_FrameObject *frame_6b50228316171cb46aa5f942471d78c9;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_6b50228316171cb46aa5f942471d78c9 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_6b50228316171cb46aa5f942471d78c9, codeobj_6b50228316171cb46aa5f942471d78c9, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_6b50228316171cb46aa5f942471d78c9 = cache_frame_6b50228316171cb46aa5f942471d78c9;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_6b50228316171cb46aa5f942471d78c9);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_6b50228316171cb46aa5f942471d78c9) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_and_left_truth_1;
        nuitka_bool tmp_and_left_value_1;
        nuitka_bool tmp_and_right_value_1;
        int tmp_truth_name_1;
        int tmp_or_left_truth_1;
        nuitka_bool tmp_or_left_value_1;
        nuitka_bool tmp_or_right_value_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_operand_name_2;
        PyObject *tmp_all_arg_1;
        CHECK_OBJECT(par_only_some_reasons);
        tmp_truth_name_1 = CHECK_IF_TRUE(par_only_some_reasons);
        if (tmp_truth_name_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1460;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if (tmp_and_left_truth_1 == 1) {
            goto and_right_1;
        } else {
            goto and_left_1;
        }
        and_right_1:;
        CHECK_OBJECT(par_only_some_reasons);
        tmp_isinstance_inst_1 = par_only_some_reasons;
        tmp_isinstance_cls_1 = (PyObject *)&PyFrozenSet_Type;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1461;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1461;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_or_left_value_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_or_left_truth_1 = tmp_or_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if (tmp_or_left_truth_1 == 1) {
            goto or_left_1;
        } else {
            goto or_right_1;
        }
        or_right_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT(par_only_some_reasons);
            tmp_iter_arg_1 = par_only_some_reasons;
            tmp_assign_source_1 = MAKE_ITERATOR(tmp_iter_arg_1);
            if (tmp_assign_source_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1462;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }
            assert(tmp_genexpr_1__$0 == NULL);
            tmp_genexpr_1__$0 = tmp_assign_source_1;
        }
        // Tried code:
        tmp_all_arg_1 = cryptography$x509$extensions$$$function_199___init__$$$genexpr_1_genexpr_maker();

        ((struct Nuitka_GeneratorObject *)tmp_all_arg_1)->m_closure[0] = PyCell_NEW0(tmp_genexpr_1__$0);


        goto try_return_handler_2;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_199___init__);
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        CHECK_OBJECT((PyObject *)tmp_genexpr_1__$0);
        Py_DECREF(tmp_genexpr_1__$0);
        tmp_genexpr_1__$0 = NULL;

        goto outline_result_1;
        // End of try:
        CHECK_OBJECT((PyObject *)tmp_genexpr_1__$0);
        Py_DECREF(tmp_genexpr_1__$0);
        tmp_genexpr_1__$0 = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_199___init__);
        return NULL;
        outline_result_1:;
        tmp_operand_name_2 = BUILTIN_ALL(tmp_all_arg_1);
        Py_DECREF(tmp_all_arg_1);
        if (tmp_operand_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1461;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_2);
        Py_DECREF(tmp_operand_name_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1461;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_or_right_value_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_right_value_1 = tmp_or_right_value_1;
        goto or_end_1;
        or_left_1:;
        tmp_and_right_value_1 = tmp_or_left_value_1;
        or_end_1:;
        tmp_condition_result_1 = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_condition_result_1 = tmp_and_left_value_1;
        and_end_1:;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_28228272e91a15a54ff010026fcf7af8;
            frame_6b50228316171cb46aa5f942471d78c9->m_frame.f_lineno = 1466;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1466;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        int tmp_and_left_truth_2;
        nuitka_bool tmp_and_left_value_2;
        nuitka_bool tmp_and_right_value_2;
        int tmp_truth_name_2;
        int tmp_or_left_truth_2;
        nuitka_bool tmp_or_left_value_2;
        nuitka_bool tmp_or_right_value_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT(par_only_some_reasons);
        tmp_truth_name_2 = CHECK_IF_TRUE(par_only_some_reasons);
        if (tmp_truth_name_2 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1470;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_2 = tmp_truth_name_2 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_2 = tmp_and_left_value_2 == NUITKA_BOOL_TRUE ? 1 : 0;
        if (tmp_and_left_truth_2 == 1) {
            goto and_right_2;
        } else {
            goto and_left_2;
        }
        and_right_2:;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ReasonFlags);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ReasonFlags);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 36774 ], 40, 0);
            exception_tb = NULL;

            exception_lineno = 1471;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_unspecified);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1471;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_only_some_reasons);
        tmp_compexpr_right_1 = par_only_some_reasons;
        tmp_res = PySequence_Contains(tmp_compexpr_right_1, tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_left_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1471;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_or_left_value_2 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_or_left_truth_2 = tmp_or_left_value_2 == NUITKA_BOOL_TRUE ? 1 : 0;
        if (tmp_or_left_truth_2 == 1) {
            goto or_left_2;
        } else {
            goto or_right_2;
        }
        or_right_2:;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ReasonFlags);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ReasonFlags);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 36774 ], 40, 0);
            exception_tb = NULL;

            exception_lineno = 1472;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_remove_from_crl);
        if (tmp_compexpr_left_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1472;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_only_some_reasons);
        tmp_compexpr_right_2 = par_only_some_reasons;
        tmp_res = PySequence_Contains(tmp_compexpr_right_2, tmp_compexpr_left_2);
        Py_DECREF(tmp_compexpr_left_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1472;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_or_right_value_2 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_right_value_2 = tmp_or_right_value_2;
        goto or_end_2;
        or_left_2:;
        tmp_and_right_value_2 = tmp_or_left_value_2;
        or_end_2:;
        tmp_condition_result_2 = tmp_and_right_value_2;
        goto and_end_2;
        and_left_2:;
        tmp_condition_result_2 = tmp_and_left_value_2;
        and_end_2:;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            tmp_make_exception_arg_2 = const_str_digest_c6c3dada1f7f971d20a3492ccb208681;
            frame_6b50228316171cb46aa5f942471d78c9->m_frame.f_lineno = 1474;
            tmp_raise_type_2 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_2);
            assert(!(tmp_raise_type_2 == NULL));
            exception_type = tmp_raise_type_2;
            exception_lineno = 1474;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_operand_name_3;
        int tmp_and_left_truth_3;
        PyObject *tmp_and_left_value_3;
        PyObject *tmp_and_right_value_3;
        PyObject *tmp_isinstance_inst_2;
        PyObject *tmp_isinstance_cls_2;
        int tmp_and_left_truth_4;
        PyObject *tmp_and_left_value_4;
        PyObject *tmp_and_right_value_4;
        PyObject *tmp_isinstance_inst_3;
        PyObject *tmp_isinstance_cls_3;
        int tmp_and_left_truth_5;
        PyObject *tmp_and_left_value_5;
        PyObject *tmp_and_right_value_5;
        PyObject *tmp_isinstance_inst_4;
        PyObject *tmp_isinstance_cls_4;
        PyObject *tmp_isinstance_inst_5;
        PyObject *tmp_isinstance_cls_5;
        CHECK_OBJECT(par_only_contains_user_certs);
        tmp_isinstance_inst_2 = par_only_contains_user_certs;
        tmp_isinstance_cls_2 = (PyObject *)&PyBool_Type;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_2, tmp_isinstance_cls_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1480;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_3 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_and_left_truth_3 = CHECK_IF_TRUE(tmp_and_left_value_3);
        if (tmp_and_left_truth_3 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1483;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        if (tmp_and_left_truth_3 == 1) {
            goto and_right_3;
        } else {
            goto and_left_3;
        }
        and_right_3:;
        CHECK_OBJECT(par_only_contains_ca_certs);
        tmp_isinstance_inst_3 = par_only_contains_ca_certs;
        tmp_isinstance_cls_3 = (PyObject *)&PyBool_Type;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_3, tmp_isinstance_cls_3);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1481;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_4 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_and_left_truth_4 = CHECK_IF_TRUE(tmp_and_left_value_4);
        if (tmp_and_left_truth_4 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1483;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        if (tmp_and_left_truth_4 == 1) {
            goto and_right_4;
        } else {
            goto and_left_4;
        }
        and_right_4:;
        CHECK_OBJECT(par_indirect_crl);
        tmp_isinstance_inst_4 = par_indirect_crl;
        tmp_isinstance_cls_4 = (PyObject *)&PyBool_Type;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_4, tmp_isinstance_cls_4);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1482;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_5 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_and_left_truth_5 = CHECK_IF_TRUE(tmp_and_left_value_5);
        if (tmp_and_left_truth_5 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1483;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        if (tmp_and_left_truth_5 == 1) {
            goto and_right_5;
        } else {
            goto and_left_5;
        }
        and_right_5:;
        CHECK_OBJECT(par_only_contains_attribute_certs);
        tmp_isinstance_inst_5 = par_only_contains_attribute_certs;
        tmp_isinstance_cls_5 = (PyObject *)&PyBool_Type;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_5, tmp_isinstance_cls_5);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1483;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_5 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_and_right_value_4 = tmp_and_right_value_5;
        goto and_end_5;
        and_left_5:;
        tmp_and_right_value_4 = tmp_and_left_value_5;
        and_end_5:;
        tmp_and_right_value_3 = tmp_and_right_value_4;
        goto and_end_4;
        and_left_4:;
        tmp_and_right_value_3 = tmp_and_left_value_4;
        and_end_4:;
        tmp_operand_name_3 = tmp_and_right_value_3;
        goto and_end_3;
        and_left_3:;
        tmp_operand_name_3 = tmp_and_left_value_3;
        and_end_3:;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_3);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1479;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
            goto branch_yes_3;
        } else {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_raise_type_3;
            PyObject *tmp_make_exception_arg_3;
            tmp_make_exception_arg_3 = const_str_digest_c47beb1c7d1e047c9170d20aad4fb97b;
            frame_6b50228316171cb46aa5f942471d78c9->m_frame.f_lineno = 1485;
            tmp_raise_type_3 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_3);
            assert(!(tmp_raise_type_3 == NULL));
            exception_type = tmp_raise_type_3;
            exception_lineno = 1485;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_3:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_list_element_1;
        CHECK_OBJECT(par_only_contains_user_certs);
        tmp_list_element_1 = par_only_contains_user_certs;
        tmp_assign_source_2 = PyList_New(4);
        Py_INCREF(tmp_list_element_1);
        PyList_SET_ITEM(tmp_assign_source_2, 0, tmp_list_element_1);
        CHECK_OBJECT(par_only_contains_ca_certs);
        tmp_list_element_1 = par_only_contains_ca_certs;
        Py_INCREF(tmp_list_element_1);
        PyList_SET_ITEM(tmp_assign_source_2, 1, tmp_list_element_1);
        CHECK_OBJECT(par_indirect_crl);
        tmp_list_element_1 = par_indirect_crl;
        Py_INCREF(tmp_list_element_1);
        PyList_SET_ITEM(tmp_assign_source_2, 2, tmp_list_element_1);
        CHECK_OBJECT(par_only_contains_attribute_certs);
        tmp_list_element_1 = par_only_contains_attribute_certs;
        Py_INCREF(tmp_list_element_1);
        PyList_SET_ITEM(tmp_assign_source_2, 3, tmp_list_element_1);
        assert(var_crl_constraints == NULL);
        var_crl_constraints = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_len_arg_1;
        // Tried code:
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_iter_arg_2;
            CHECK_OBJECT(var_crl_constraints);
            tmp_iter_arg_2 = var_crl_constraints;
            tmp_assign_source_3 = MAKE_ITERATOR(tmp_iter_arg_2);
            if (tmp_assign_source_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1496;
                type_description_1 = "oooooooooo";
                goto try_except_handler_3;
            }
            assert(tmp_list_contraction_1__$0 == NULL);
            tmp_list_contraction_1__$0 = tmp_assign_source_3;
        }
        {
            PyObject *tmp_assign_source_4;
            tmp_assign_source_4 = PyList_New(0);
            assert(tmp_list_contraction_1__contraction_result == NULL);
            tmp_list_contraction_1__contraction_result = tmp_assign_source_4;
        }
        loop_start_1:;
        {
            PyObject *tmp_next_source_1;
            PyObject *tmp_assign_source_5;
            CHECK_OBJECT(tmp_list_contraction_1__$0);
            tmp_next_source_1 = tmp_list_contraction_1__$0;
            tmp_assign_source_5 = ITERATOR_NEXT(tmp_next_source_1);
            if (tmp_assign_source_5 == NULL) {
                if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                    goto loop_end_1;
                } else {

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    type_description_1 = "oooooooooo";
                    exception_lineno = 1496;
                    goto try_except_handler_3;
                }
            }

            {
                PyObject *old = tmp_list_contraction_1__iter_value_0;
                tmp_list_contraction_1__iter_value_0 = tmp_assign_source_5;
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_assign_source_6;
            CHECK_OBJECT(tmp_list_contraction_1__iter_value_0);
            tmp_assign_source_6 = tmp_list_contraction_1__iter_value_0;
            {
                PyObject *old = var_x;
                var_x = tmp_assign_source_6;
                Py_INCREF(var_x);
                Py_XDECREF(old);
            }

        }
        {
            nuitka_bool tmp_condition_result_5;
            int tmp_truth_name_3;
            CHECK_OBJECT(var_x);
            tmp_truth_name_3 = CHECK_IF_TRUE(var_x);
            if (tmp_truth_name_3 == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1496;
                type_description_1 = "oooooooooo";
                goto try_except_handler_3;
            }
            tmp_condition_result_5 = tmp_truth_name_3 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_5 == NUITKA_BOOL_TRUE) {
                goto branch_yes_5;
            } else {
                goto branch_no_5;
            }
            branch_yes_5:;
            {
                PyObject *tmp_append_list_1;
                PyObject *tmp_append_value_1;
                CHECK_OBJECT(tmp_list_contraction_1__contraction_result);
                tmp_append_list_1 = tmp_list_contraction_1__contraction_result;
                CHECK_OBJECT(var_x);
                tmp_append_value_1 = var_x;
                assert(PyList_Check(tmp_append_list_1));
                tmp_res = PyList_Append(tmp_append_list_1, tmp_append_value_1);
                if (tmp_res == -1) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 1496;
                    type_description_1 = "oooooooooo";
                    goto try_except_handler_3;
                }
            }
            branch_no_5:;
        }
        if (CONSIDER_THREADING() == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1496;
            type_description_1 = "oooooooooo";
            goto try_except_handler_3;
        }
        goto loop_start_1;
        loop_end_1:;
        CHECK_OBJECT(tmp_list_contraction_1__contraction_result);
        tmp_len_arg_1 = tmp_list_contraction_1__contraction_result;
        Py_INCREF(tmp_len_arg_1);
        goto try_return_handler_3;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_199___init__);
        return NULL;
        // Return handler code:
        try_return_handler_3:;
        CHECK_OBJECT((PyObject *)tmp_list_contraction_1__$0);
        Py_DECREF(tmp_list_contraction_1__$0);
        tmp_list_contraction_1__$0 = NULL;

        CHECK_OBJECT((PyObject *)tmp_list_contraction_1__contraction_result);
        Py_DECREF(tmp_list_contraction_1__contraction_result);
        tmp_list_contraction_1__contraction_result = NULL;

        Py_XDECREF(tmp_list_contraction_1__iter_value_0);
        tmp_list_contraction_1__iter_value_0 = NULL;

        goto outline_result_2;
        // Exception handler code:
        try_except_handler_3:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF(tmp_list_contraction_1__$0);
        tmp_list_contraction_1__$0 = NULL;

        Py_XDECREF(tmp_list_contraction_1__contraction_result);
        tmp_list_contraction_1__contraction_result = NULL;

        Py_XDECREF(tmp_list_contraction_1__iter_value_0);
        tmp_list_contraction_1__iter_value_0 = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto frame_exception_exit_1;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_199___init__);
        return NULL;
        outline_result_2:;
        tmp_compexpr_left_3 = BUILTIN_LEN(tmp_len_arg_1);
        Py_DECREF(tmp_len_arg_1);
        if (tmp_compexpr_left_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1496;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_3 = const_int_pos_1;
        tmp_res = RICH_COMPARE_BOOL_GT_OBJECT_INT(tmp_compexpr_left_3, tmp_compexpr_right_3);
        Py_DECREF(tmp_compexpr_left_3);
        assert(!(tmp_res == -1));
        tmp_condition_result_4 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_4 == NUITKA_BOOL_TRUE) {
            goto branch_yes_4;
        } else {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_raise_type_4;
            PyObject *tmp_make_exception_arg_4;
            tmp_make_exception_arg_4 = const_str_digest_1ea9692159fa7fd9f8e15a3506f4463c;
            frame_6b50228316171cb46aa5f942471d78c9->m_frame.f_lineno = 1497;
            tmp_raise_type_4 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_4);
            assert(!(tmp_raise_type_4 == NULL));
            exception_type = tmp_raise_type_4;
            exception_lineno = 1497;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_4:;
    }
    {
        nuitka_bool tmp_condition_result_6;
        PyObject *tmp_operand_name_4;
        PyObject *tmp_any_arg_1;
        PyObject *tmp_list_element_2;
        CHECK_OBJECT(par_only_contains_user_certs);
        tmp_list_element_2 = par_only_contains_user_certs;
        tmp_any_arg_1 = PyList_New(7);
        Py_INCREF(tmp_list_element_2);
        PyList_SET_ITEM(tmp_any_arg_1, 0, tmp_list_element_2);
        CHECK_OBJECT(par_only_contains_ca_certs);
        tmp_list_element_2 = par_only_contains_ca_certs;
        Py_INCREF(tmp_list_element_2);
        PyList_SET_ITEM(tmp_any_arg_1, 1, tmp_list_element_2);
        CHECK_OBJECT(par_indirect_crl);
        tmp_list_element_2 = par_indirect_crl;
        Py_INCREF(tmp_list_element_2);
        PyList_SET_ITEM(tmp_any_arg_1, 2, tmp_list_element_2);
        CHECK_OBJECT(par_only_contains_attribute_certs);
        tmp_list_element_2 = par_only_contains_attribute_certs;
        Py_INCREF(tmp_list_element_2);
        PyList_SET_ITEM(tmp_any_arg_1, 3, tmp_list_element_2);
        CHECK_OBJECT(par_full_name);
        tmp_list_element_2 = par_full_name;
        Py_INCREF(tmp_list_element_2);
        PyList_SET_ITEM(tmp_any_arg_1, 4, tmp_list_element_2);
        CHECK_OBJECT(par_relative_name);
        tmp_list_element_2 = par_relative_name;
        Py_INCREF(tmp_list_element_2);
        PyList_SET_ITEM(tmp_any_arg_1, 5, tmp_list_element_2);
        CHECK_OBJECT(par_only_some_reasons);
        tmp_list_element_2 = par_only_some_reasons;
        Py_INCREF(tmp_list_element_2);
        PyList_SET_ITEM(tmp_any_arg_1, 6, tmp_list_element_2);
        tmp_operand_name_4 = BUILTIN_ANY(tmp_any_arg_1);
        Py_DECREF(tmp_any_arg_1);
        assert(!(tmp_operand_name_4 == NULL));
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_4);
        Py_DECREF(tmp_operand_name_4);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1504;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_6 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_6 == NUITKA_BOOL_TRUE) {
            goto branch_yes_6;
        } else {
            goto branch_no_6;
        }
        branch_yes_6:;
        {
            PyObject *tmp_raise_type_5;
            PyObject *tmp_make_exception_arg_5;
            tmp_make_exception_arg_5 = const_str_digest_de9abd61df15d9c64a5a616e9749f115;
            frame_6b50228316171cb46aa5f942471d78c9->m_frame.f_lineno = 1510;
            tmp_raise_type_5 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_5);
            assert(!(tmp_raise_type_5 == NULL));
            exception_type = tmp_raise_type_5;
            exception_lineno = 1510;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_6:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_only_contains_user_certs);
        tmp_assattr_name_1 = par_only_contains_user_certs;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__only_contains_user_certs, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1518;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT(par_only_contains_ca_certs);
        tmp_assattr_name_2 = par_only_contains_ca_certs;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain__only_contains_ca_certs, tmp_assattr_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1519;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_assattr_target_3;
        CHECK_OBJECT(par_indirect_crl);
        tmp_assattr_name_3 = par_indirect_crl;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_3 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_3, const_str_plain__indirect_crl, tmp_assattr_name_3);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1520;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_4;
        PyObject *tmp_assattr_target_4;
        CHECK_OBJECT(par_only_contains_attribute_certs);
        tmp_assattr_name_4 = par_only_contains_attribute_certs;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_4 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_4, const_str_plain__only_contains_attribute_certs, tmp_assattr_name_4);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1521;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_5;
        PyObject *tmp_assattr_target_5;
        CHECK_OBJECT(par_only_some_reasons);
        tmp_assattr_name_5 = par_only_some_reasons;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_5 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_5, const_str_plain__only_some_reasons, tmp_assattr_name_5);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1522;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_6;
        PyObject *tmp_assattr_target_6;
        CHECK_OBJECT(par_full_name);
        tmp_assattr_name_6 = par_full_name;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_6 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_6, const_str_plain__full_name, tmp_assattr_name_6);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1523;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_7;
        PyObject *tmp_assattr_target_7;
        CHECK_OBJECT(par_relative_name);
        tmp_assattr_name_7 = par_relative_name;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_7 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_7, const_str_plain__relative_name, tmp_assattr_name_7);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1524;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_6b50228316171cb46aa5f942471d78c9);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_6b50228316171cb46aa5f942471d78c9);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_6b50228316171cb46aa5f942471d78c9, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_6b50228316171cb46aa5f942471d78c9->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_6b50228316171cb46aa5f942471d78c9, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6b50228316171cb46aa5f942471d78c9,
        type_description_1,
        par_self,
        par_full_name,
        par_relative_name,
        par_only_contains_user_certs,
        par_only_contains_ca_certs,
        par_only_some_reasons,
        par_indirect_crl,
        par_only_contains_attribute_certs,
        var_crl_constraints,
        var_x
    );


    // Release cached frame.
    if (frame_6b50228316171cb46aa5f942471d78c9 == cache_frame_6b50228316171cb46aa5f942471d78c9) {
        Py_DECREF(frame_6b50228316171cb46aa5f942471d78c9);
    }
    cache_frame_6b50228316171cb46aa5f942471d78c9 = NULL;

    assertFrameObject(frame_6b50228316171cb46aa5f942471d78c9);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_199___init__);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_crl_constraints);
    Py_DECREF(var_crl_constraints);
    var_crl_constraints = NULL;

    Py_XDECREF(var_x);
    var_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_crl_constraints);
    var_crl_constraints = NULL;

    Py_XDECREF(var_x);
    var_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_199___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_only_some_reasons);
    Py_DECREF(par_only_some_reasons);
    CHECK_OBJECT(par_only_contains_ca_certs);
    Py_DECREF(par_only_contains_ca_certs);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_only_contains_attribute_certs);
    Py_DECREF(par_only_contains_attribute_certs);
    CHECK_OBJECT(par_indirect_crl);
    Py_DECREF(par_indirect_crl);
    CHECK_OBJECT(par_relative_name);
    Py_DECREF(par_relative_name);
    CHECK_OBJECT(par_only_contains_user_certs);
    Py_DECREF(par_only_contains_user_certs);
    CHECK_OBJECT(par_full_name);
    Py_DECREF(par_full_name);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_only_some_reasons);
    Py_DECREF(par_only_some_reasons);
    CHECK_OBJECT(par_only_contains_ca_certs);
    Py_DECREF(par_only_contains_ca_certs);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_only_contains_attribute_certs);
    Py_DECREF(par_only_contains_attribute_certs);
    CHECK_OBJECT(par_indirect_crl);
    Py_DECREF(par_indirect_crl);
    CHECK_OBJECT(par_relative_name);
    Py_DECREF(par_relative_name);
    CHECK_OBJECT(par_only_contains_user_certs);
    Py_DECREF(par_only_contains_user_certs);
    CHECK_OBJECT(par_full_name);
    Py_DECREF(par_full_name);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}



struct cryptography$x509$extensions$$$function_199___init__$$$genexpr_1_genexpr_locals {
    PyObject *var_x;
    PyObject *tmp_iter_value_0;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    int tmp_res;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *cryptography$x509$extensions$$$function_199___init__$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value ) {
    CHECK_OBJECT((PyObject *)generator);
    assert(Nuitka_Generator_Check( (PyObject *)generator ));

    // Heap access if used.
    struct cryptography$x509$extensions$$$function_199___init__$$$genexpr_1_genexpr_locals *generator_heap = (struct cryptography$x509$extensions$$$function_199___init__$$$genexpr_1_genexpr_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_x = NULL;
    generator_heap->tmp_iter_value_0 = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_m_frame, codeobj_2e7cf4e83e69f15d24fde995cefd2a7c, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF(generator->m_frame);
    assert(Py_REFCNT(generator->m_frame) == 2); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR(generator->m_frame->m_frame.f_back);

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF(generator->m_frame->m_frame.f_back);

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF(generator->m_frame);

    Nuitka_Frame_MarkAsExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

        EXC_TYPE_F(generator) = EXC_TYPE(thread_state);
        if (EXC_TYPE_F(generator) == Py_None) EXC_TYPE_F(generator) = NULL;
        Py_XINCREF(EXC_TYPE_F(generator));
        EXC_VALUE_F(generator) = EXC_VALUE(thread_state);
        Py_XINCREF(EXC_VALUE_F(generator));
        EXC_TRACEBACK_F(generator) = EXC_TRACEBACK(thread_state);
        Py_XINCREF(EXC_TRACEBACK_F(generator));
    }

#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_1;
        CHECK_OBJECT(PyCell_GET(generator->m_closure[0]));
        tmp_next_source_1 = PyCell_GET(generator->m_closure[0]);
        tmp_assign_source_1 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_1 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);
                generator_heap->type_description_1 = "No";
                generator_heap->exception_lineno = 1462;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_iter_value_0;
            generator_heap->tmp_iter_value_0 = tmp_assign_source_1;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT(generator_heap->tmp_iter_value_0);
        tmp_assign_source_2 = generator_heap->tmp_iter_value_0;
        {
            PyObject *old = generator_heap->var_x;
            generator_heap->var_x = tmp_assign_source_2;
            Py_INCREF(generator_heap->var_x);
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_expression_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        CHECK_OBJECT(generator_heap->var_x);
        tmp_isinstance_inst_1 = generator_heap->var_x;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ReasonFlags);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ReasonFlags);
        }

        if (tmp_mvar_value_1 == NULL) {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF(generator_heap->exception_type);
            generator_heap->exception_value = UNSTREAM_STRING(&constant_bin[ 36774 ], 40, 0);
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 1462;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        generator_heap->tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (generator_heap->tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 1462;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_expression_name_1 = (generator_heap->tmp_res != 0) ? Py_True : Py_False;
        Py_INCREF(tmp_expression_name_1);
        Nuitka_PreserveHeap(generator_heap->yield_tmps, &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), NULL);
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        Nuitka_RestoreHeap(generator_heap->yield_tmps, &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), NULL);
        if (yield_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 1462;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


        generator_heap->exception_lineno = 1462;
        generator_heap->type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    // Allow re-use of the frame again.
    Py_DECREF(generator->m_frame);
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if (!EXCEPTION_MATCH_GENERATOR(generator_heap->exception_type)) {
        if (generator_heap->exception_tb == NULL) {
            generator_heap->exception_tb = MAKE_TRACEBACK(generator->m_frame, generator_heap->exception_lineno);
        } else if (generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame) {
            generator_heap->exception_tb = ADD_TRACEBACK(generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno);
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            NULL,
            generator_heap->var_x
        );


        // Release cached frame.
        if (generator->m_frame == cache_m_frame) {
            Py_DECREF(generator->m_frame);
        }
        cache_m_frame = NULL;

        assertFrameObject(generator->m_frame);
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    Py_DECREF(generator->m_frame);

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->var_x);
    generator_heap->var_x = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    Py_XDECREF(generator_heap->var_x);
    generator_heap->var_x = NULL;



    return NULL;

    function_exception_exit:
    assert(generator_heap->exception_type);
    RESTORE_ERROR_OCCURRED(generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb);

    return NULL;

}

static PyObject *cryptography$x509$extensions$$$function_199___init__$$$genexpr_1_genexpr_maker(void) {
    return Nuitka_Generator_New(
        cryptography$x509$extensions$$$function_199___init__$$$genexpr_1_genexpr_context,
        module_cryptography$x509$extensions,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_2e7cf4e83e69f15d24fde995cefd2a7c,
        1,
        sizeof(struct cryptography$x509$extensions$$$function_199___init__$$$genexpr_1_genexpr_locals)
    );
}


static PyObject *impl_cryptography$x509$extensions$$$function_200___repr__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_4ccea98cae174f5c67a2d51a294f6880;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_4ccea98cae174f5c67a2d51a294f6880 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_4ccea98cae174f5c67a2d51a294f6880, codeobj_4ccea98cae174f5c67a2d51a294f6880, module_cryptography$x509$extensions, sizeof(void *));
    frame_4ccea98cae174f5c67a2d51a294f6880 = cache_frame_4ccea98cae174f5c67a2d51a294f6880;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_4ccea98cae174f5c67a2d51a294f6880);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_4ccea98cae174f5c67a2d51a294f6880) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        tmp_called_instance_1 = const_str_digest_4896564d0ed5e6b06237436d00bf3cad;
        CHECK_OBJECT(par_self);
        tmp_args_element_name_1 = par_self;
        frame_4ccea98cae174f5c67a2d51a294f6880->m_frame.f_lineno = 1528;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_format, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1528;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_4ccea98cae174f5c67a2d51a294f6880);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_4ccea98cae174f5c67a2d51a294f6880);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_4ccea98cae174f5c67a2d51a294f6880);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_4ccea98cae174f5c67a2d51a294f6880, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_4ccea98cae174f5c67a2d51a294f6880->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_4ccea98cae174f5c67a2d51a294f6880, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4ccea98cae174f5c67a2d51a294f6880,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_4ccea98cae174f5c67a2d51a294f6880 == cache_frame_4ccea98cae174f5c67a2d51a294f6880) {
        Py_DECREF(frame_4ccea98cae174f5c67a2d51a294f6880);
    }
    cache_frame_4ccea98cae174f5c67a2d51a294f6880 = NULL;

    assertFrameObject(frame_4ccea98cae174f5c67a2d51a294f6880);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_200___repr__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_201___eq__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_0baf7dc256d01cc71597fc9143b60403;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_0baf7dc256d01cc71597fc9143b60403 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_0baf7dc256d01cc71597fc9143b60403, codeobj_0baf7dc256d01cc71597fc9143b60403, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_0baf7dc256d01cc71597fc9143b60403 = cache_frame_0baf7dc256d01cc71597fc9143b60403;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_0baf7dc256d01cc71597fc9143b60403);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_0baf7dc256d01cc71597fc9143b60403) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_other);
        tmp_isinstance_inst_1 = par_other;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_IssuingDistributionPoint);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_IssuingDistributionPoint);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 37798 ], 53, 0);
            exception_tb = NULL;

            exception_lineno = 1539;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1539;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1539;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        int tmp_and_left_truth_1;
        PyObject *tmp_and_left_value_1;
        PyObject *tmp_and_right_value_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        int tmp_and_left_truth_2;
        PyObject *tmp_and_left_value_2;
        PyObject *tmp_and_right_value_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_source_name_4;
        int tmp_and_left_truth_3;
        PyObject *tmp_and_left_value_3;
        PyObject *tmp_and_right_value_3;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_source_name_5;
        PyObject *tmp_source_name_6;
        int tmp_and_left_truth_4;
        PyObject *tmp_and_left_value_4;
        PyObject *tmp_and_right_value_4;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        PyObject *tmp_source_name_7;
        PyObject *tmp_source_name_8;
        int tmp_and_left_truth_5;
        PyObject *tmp_and_left_value_5;
        PyObject *tmp_and_right_value_5;
        PyObject *tmp_compexpr_left_5;
        PyObject *tmp_compexpr_right_5;
        PyObject *tmp_source_name_9;
        PyObject *tmp_source_name_10;
        int tmp_and_left_truth_6;
        PyObject *tmp_and_left_value_6;
        PyObject *tmp_and_right_value_6;
        PyObject *tmp_compexpr_left_6;
        PyObject *tmp_compexpr_right_6;
        PyObject *tmp_source_name_11;
        PyObject *tmp_source_name_12;
        PyObject *tmp_compexpr_left_7;
        PyObject *tmp_compexpr_right_7;
        PyObject *tmp_source_name_13;
        PyObject *tmp_source_name_14;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_full_name);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1543;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_2 = par_other;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_full_name);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_1);

            exception_lineno = 1543;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_and_left_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1543;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_truth_1 = CHECK_IF_TRUE(tmp_and_left_value_1);
        if (tmp_and_left_truth_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_and_left_value_1);

            exception_lineno = 1549;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        if (tmp_and_left_truth_1 == 1) {
            goto and_right_1;
        } else {
            goto and_left_1;
        }
        and_right_1:;
        Py_DECREF(tmp_and_left_value_1);
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_relative_name);
        if (tmp_compexpr_left_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1544;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_4 = par_other;
        tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_relative_name);
        if (tmp_compexpr_right_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_2);

            exception_lineno = 1544;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_2 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
        Py_DECREF(tmp_compexpr_left_2);
        Py_DECREF(tmp_compexpr_right_2);
        if (tmp_and_left_value_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1544;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_truth_2 = CHECK_IF_TRUE(tmp_and_left_value_2);
        if (tmp_and_left_truth_2 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_and_left_value_2);

            exception_lineno = 1549;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        if (tmp_and_left_truth_2 == 1) {
            goto and_right_2;
        } else {
            goto and_left_2;
        }
        and_right_2:;
        Py_DECREF(tmp_and_left_value_2);
        CHECK_OBJECT(par_self);
        tmp_source_name_5 = par_self;
        tmp_compexpr_left_3 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_only_contains_user_certs);
        if (tmp_compexpr_left_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1545;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_6 = par_other;
        tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_only_contains_user_certs);
        if (tmp_compexpr_right_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_3);

            exception_lineno = 1545;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_3 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_3, tmp_compexpr_right_3);
        Py_DECREF(tmp_compexpr_left_3);
        Py_DECREF(tmp_compexpr_right_3);
        if (tmp_and_left_value_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1545;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_truth_3 = CHECK_IF_TRUE(tmp_and_left_value_3);
        if (tmp_and_left_truth_3 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_and_left_value_3);

            exception_lineno = 1549;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        if (tmp_and_left_truth_3 == 1) {
            goto and_right_3;
        } else {
            goto and_left_3;
        }
        and_right_3:;
        Py_DECREF(tmp_and_left_value_3);
        CHECK_OBJECT(par_self);
        tmp_source_name_7 = par_self;
        tmp_compexpr_left_4 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain_only_contains_ca_certs);
        if (tmp_compexpr_left_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1546;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_8 = par_other;
        tmp_compexpr_right_4 = LOOKUP_ATTRIBUTE(tmp_source_name_8, const_str_plain_only_contains_ca_certs);
        if (tmp_compexpr_right_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_4);

            exception_lineno = 1546;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_4 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_4, tmp_compexpr_right_4);
        Py_DECREF(tmp_compexpr_left_4);
        Py_DECREF(tmp_compexpr_right_4);
        if (tmp_and_left_value_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1546;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_truth_4 = CHECK_IF_TRUE(tmp_and_left_value_4);
        if (tmp_and_left_truth_4 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_and_left_value_4);

            exception_lineno = 1549;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        if (tmp_and_left_truth_4 == 1) {
            goto and_right_4;
        } else {
            goto and_left_4;
        }
        and_right_4:;
        Py_DECREF(tmp_and_left_value_4);
        CHECK_OBJECT(par_self);
        tmp_source_name_9 = par_self;
        tmp_compexpr_left_5 = LOOKUP_ATTRIBUTE(tmp_source_name_9, const_str_plain_only_some_reasons);
        if (tmp_compexpr_left_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1547;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_10 = par_other;
        tmp_compexpr_right_5 = LOOKUP_ATTRIBUTE(tmp_source_name_10, const_str_plain_only_some_reasons);
        if (tmp_compexpr_right_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_5);

            exception_lineno = 1547;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_5 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_5, tmp_compexpr_right_5);
        Py_DECREF(tmp_compexpr_left_5);
        Py_DECREF(tmp_compexpr_right_5);
        if (tmp_and_left_value_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1547;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_truth_5 = CHECK_IF_TRUE(tmp_and_left_value_5);
        if (tmp_and_left_truth_5 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_and_left_value_5);

            exception_lineno = 1549;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        if (tmp_and_left_truth_5 == 1) {
            goto and_right_5;
        } else {
            goto and_left_5;
        }
        and_right_5:;
        Py_DECREF(tmp_and_left_value_5);
        CHECK_OBJECT(par_self);
        tmp_source_name_11 = par_self;
        tmp_compexpr_left_6 = LOOKUP_ATTRIBUTE(tmp_source_name_11, const_str_plain_indirect_crl);
        if (tmp_compexpr_left_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1548;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_12 = par_other;
        tmp_compexpr_right_6 = LOOKUP_ATTRIBUTE(tmp_source_name_12, const_str_plain_indirect_crl);
        if (tmp_compexpr_right_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_6);

            exception_lineno = 1548;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_6 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_6, tmp_compexpr_right_6);
        Py_DECREF(tmp_compexpr_left_6);
        Py_DECREF(tmp_compexpr_right_6);
        if (tmp_and_left_value_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1548;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_truth_6 = CHECK_IF_TRUE(tmp_and_left_value_6);
        if (tmp_and_left_truth_6 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_and_left_value_6);

            exception_lineno = 1549;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        if (tmp_and_left_truth_6 == 1) {
            goto and_right_6;
        } else {
            goto and_left_6;
        }
        and_right_6:;
        Py_DECREF(tmp_and_left_value_6);
        CHECK_OBJECT(par_self);
        tmp_source_name_13 = par_self;
        tmp_compexpr_left_7 = LOOKUP_ATTRIBUTE(tmp_source_name_13, const_str_plain_only_contains_attribute_certs);
        if (tmp_compexpr_left_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1549;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_14 = par_other;
        tmp_compexpr_right_7 = LOOKUP_ATTRIBUTE(tmp_source_name_14, const_str_plain_only_contains_attribute_certs);
        if (tmp_compexpr_right_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_7);

            exception_lineno = 1550;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_6 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_7, tmp_compexpr_right_7);
        Py_DECREF(tmp_compexpr_left_7);
        Py_DECREF(tmp_compexpr_right_7);
        if (tmp_and_right_value_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1549;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_5 = tmp_and_right_value_6;
        goto and_end_6;
        and_left_6:;
        tmp_and_right_value_5 = tmp_and_left_value_6;
        and_end_6:;
        tmp_and_right_value_4 = tmp_and_right_value_5;
        goto and_end_5;
        and_left_5:;
        tmp_and_right_value_4 = tmp_and_left_value_5;
        and_end_5:;
        tmp_and_right_value_3 = tmp_and_right_value_4;
        goto and_end_4;
        and_left_4:;
        tmp_and_right_value_3 = tmp_and_left_value_4;
        and_end_4:;
        tmp_and_right_value_2 = tmp_and_right_value_3;
        goto and_end_3;
        and_left_3:;
        tmp_and_right_value_2 = tmp_and_left_value_3;
        and_end_3:;
        tmp_and_right_value_1 = tmp_and_right_value_2;
        goto and_end_2;
        and_left_2:;
        tmp_and_right_value_1 = tmp_and_left_value_2;
        and_end_2:;
        tmp_return_value = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_return_value = tmp_and_left_value_1;
        and_end_1:;
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0baf7dc256d01cc71597fc9143b60403);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_0baf7dc256d01cc71597fc9143b60403);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0baf7dc256d01cc71597fc9143b60403);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_0baf7dc256d01cc71597fc9143b60403, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_0baf7dc256d01cc71597fc9143b60403->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_0baf7dc256d01cc71597fc9143b60403, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0baf7dc256d01cc71597fc9143b60403,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_0baf7dc256d01cc71597fc9143b60403 == cache_frame_0baf7dc256d01cc71597fc9143b60403) {
        Py_DECREF(frame_0baf7dc256d01cc71597fc9143b60403);
    }
    cache_frame_0baf7dc256d01cc71597fc9143b60403 = NULL;

    assertFrameObject(frame_0baf7dc256d01cc71597fc9143b60403);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_201___eq__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_202___ne__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_7573520d98579b7184ce117cbc63b138;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_7573520d98579b7184ce117cbc63b138 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_7573520d98579b7184ce117cbc63b138, codeobj_7573520d98579b7184ce117cbc63b138, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_7573520d98579b7184ce117cbc63b138 = cache_frame_7573520d98579b7184ce117cbc63b138;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_7573520d98579b7184ce117cbc63b138);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_7573520d98579b7184ce117cbc63b138) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_self);
        tmp_compexpr_left_1 = par_self;
        CHECK_OBJECT(par_other);
        tmp_compexpr_right_1 = par_other;
        tmp_operand_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1554;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1554;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = (tmp_res == 0) ? Py_True : Py_False;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_7573520d98579b7184ce117cbc63b138);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_7573520d98579b7184ce117cbc63b138);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_7573520d98579b7184ce117cbc63b138);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_7573520d98579b7184ce117cbc63b138, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_7573520d98579b7184ce117cbc63b138->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_7573520d98579b7184ce117cbc63b138, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7573520d98579b7184ce117cbc63b138,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_7573520d98579b7184ce117cbc63b138 == cache_frame_7573520d98579b7184ce117cbc63b138) {
        Py_DECREF(frame_7573520d98579b7184ce117cbc63b138);
    }
    cache_frame_7573520d98579b7184ce117cbc63b138 = NULL;

    assertFrameObject(frame_7573520d98579b7184ce117cbc63b138);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_202___ne__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_203___hash__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_f2d176069a53125e7129d5de6997a323;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_f2d176069a53125e7129d5de6997a323 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_f2d176069a53125e7129d5de6997a323, codeobj_f2d176069a53125e7129d5de6997a323, module_cryptography$x509$extensions, sizeof(void *));
    frame_f2d176069a53125e7129d5de6997a323 = cache_frame_f2d176069a53125e7129d5de6997a323;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_f2d176069a53125e7129d5de6997a323);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_f2d176069a53125e7129d5de6997a323) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_hash_arg_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_source_name_4;
        PyObject *tmp_source_name_5;
        PyObject *tmp_source_name_6;
        PyObject *tmp_source_name_7;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_full_name);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1558;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_hash_arg_1 = PyTuple_New(7);
        PyTuple_SET_ITEM(tmp_hash_arg_1, 0, tmp_tuple_element_1);
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_relative_name);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_hash_arg_1);

            exception_lineno = 1559;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM(tmp_hash_arg_1, 1, tmp_tuple_element_1);
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_only_contains_user_certs);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_hash_arg_1);

            exception_lineno = 1560;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM(tmp_hash_arg_1, 2, tmp_tuple_element_1);
        CHECK_OBJECT(par_self);
        tmp_source_name_4 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_only_contains_ca_certs);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_hash_arg_1);

            exception_lineno = 1561;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM(tmp_hash_arg_1, 3, tmp_tuple_element_1);
        CHECK_OBJECT(par_self);
        tmp_source_name_5 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_only_some_reasons);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_hash_arg_1);

            exception_lineno = 1562;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM(tmp_hash_arg_1, 4, tmp_tuple_element_1);
        CHECK_OBJECT(par_self);
        tmp_source_name_6 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_indirect_crl);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_hash_arg_1);

            exception_lineno = 1563;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM(tmp_hash_arg_1, 5, tmp_tuple_element_1);
        CHECK_OBJECT(par_self);
        tmp_source_name_7 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain_only_contains_attribute_certs);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_hash_arg_1);

            exception_lineno = 1564;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM(tmp_hash_arg_1, 6, tmp_tuple_element_1);
        tmp_return_value = BUILTIN_HASH(tmp_hash_arg_1);
        Py_DECREF(tmp_hash_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1557;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_f2d176069a53125e7129d5de6997a323);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_f2d176069a53125e7129d5de6997a323);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_f2d176069a53125e7129d5de6997a323);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_f2d176069a53125e7129d5de6997a323, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_f2d176069a53125e7129d5de6997a323->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_f2d176069a53125e7129d5de6997a323, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f2d176069a53125e7129d5de6997a323,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_f2d176069a53125e7129d5de6997a323 == cache_frame_f2d176069a53125e7129d5de6997a323) {
        Py_DECREF(frame_f2d176069a53125e7129d5de6997a323);
    }
    cache_frame_f2d176069a53125e7129d5de6997a323 = NULL;

    assertFrameObject(frame_f2d176069a53125e7129d5de6997a323);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_203___hash__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_204___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_oid = python_pars[1];
    PyObject *par_value = python_pars[2];
    struct Nuitka_FrameObject *frame_84a0291d7ab205891af2466b9e0377ec;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_84a0291d7ab205891af2466b9e0377ec = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_84a0291d7ab205891af2466b9e0377ec, codeobj_84a0291d7ab205891af2466b9e0377ec, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_84a0291d7ab205891af2466b9e0377ec = cache_frame_84a0291d7ab205891af2466b9e0377ec;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_84a0291d7ab205891af2466b9e0377ec);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_84a0291d7ab205891af2466b9e0377ec) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_oid);
        tmp_isinstance_inst_1 = par_oid;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ObjectIdentifier);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ObjectIdentifier);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 18374 ], 45, 0);
            exception_tb = NULL;

            exception_lineno = 1585;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1585;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1585;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_f63518e696f94cef547d30428c9b8408;
            frame_84a0291d7ab205891af2466b9e0377ec->m_frame.f_lineno = 1586;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1586;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_oid);
        tmp_assattr_name_1 = par_oid;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__oid, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1587;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT(par_value);
        tmp_assattr_name_2 = par_value;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain__value, tmp_assattr_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1588;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_84a0291d7ab205891af2466b9e0377ec);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_84a0291d7ab205891af2466b9e0377ec);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_84a0291d7ab205891af2466b9e0377ec, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_84a0291d7ab205891af2466b9e0377ec->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_84a0291d7ab205891af2466b9e0377ec, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_84a0291d7ab205891af2466b9e0377ec,
        type_description_1,
        par_self,
        par_oid,
        par_value
    );


    // Release cached frame.
    if (frame_84a0291d7ab205891af2466b9e0377ec == cache_frame_84a0291d7ab205891af2466b9e0377ec) {
        Py_DECREF(frame_84a0291d7ab205891af2466b9e0377ec);
    }
    cache_frame_84a0291d7ab205891af2466b9e0377ec = NULL;

    assertFrameObject(frame_84a0291d7ab205891af2466b9e0377ec);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_204___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_oid);
    Py_DECREF(par_oid);
    CHECK_OBJECT(par_value);
    Py_DECREF(par_value);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_oid);
    Py_DECREF(par_oid);
    CHECK_OBJECT(par_value);
    Py_DECREF(par_value);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_205___repr__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_53f581e08696ed1cb55d8d59dd2376ac;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_53f581e08696ed1cb55d8d59dd2376ac = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_53f581e08696ed1cb55d8d59dd2376ac, codeobj_53f581e08696ed1cb55d8d59dd2376ac, module_cryptography$x509$extensions, sizeof(void *));
    frame_53f581e08696ed1cb55d8d59dd2376ac = cache_frame_53f581e08696ed1cb55d8d59dd2376ac;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_53f581e08696ed1cb55d8d59dd2376ac);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_53f581e08696ed1cb55d8d59dd2376ac) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        tmp_called_instance_1 = const_str_digest_293839491199d08c5eee9ab993bbfcfe;
        CHECK_OBJECT(par_self);
        tmp_args_element_name_1 = par_self;
        frame_53f581e08696ed1cb55d8d59dd2376ac->m_frame.f_lineno = 1595;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_format, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1595;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_53f581e08696ed1cb55d8d59dd2376ac);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_53f581e08696ed1cb55d8d59dd2376ac);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_53f581e08696ed1cb55d8d59dd2376ac);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_53f581e08696ed1cb55d8d59dd2376ac, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_53f581e08696ed1cb55d8d59dd2376ac->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_53f581e08696ed1cb55d8d59dd2376ac, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_53f581e08696ed1cb55d8d59dd2376ac,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_53f581e08696ed1cb55d8d59dd2376ac == cache_frame_53f581e08696ed1cb55d8d59dd2376ac) {
        Py_DECREF(frame_53f581e08696ed1cb55d8d59dd2376ac);
    }
    cache_frame_53f581e08696ed1cb55d8d59dd2376ac = NULL;

    assertFrameObject(frame_53f581e08696ed1cb55d8d59dd2376ac);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_205___repr__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_206___eq__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_0072f7a0ccd296332a271d4a8e480c77;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_0072f7a0ccd296332a271d4a8e480c77 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_0072f7a0ccd296332a271d4a8e480c77, codeobj_0072f7a0ccd296332a271d4a8e480c77, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_0072f7a0ccd296332a271d4a8e480c77 = cache_frame_0072f7a0ccd296332a271d4a8e480c77;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_0072f7a0ccd296332a271d4a8e480c77);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_0072f7a0ccd296332a271d4a8e480c77) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_other);
        tmp_isinstance_inst_1 = par_other;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_UnrecognizedExtension);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_UnrecognizedExtension);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 36104 ], 50, 0);
            exception_tb = NULL;

            exception_lineno = 1601;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1601;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1601;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        int tmp_and_left_truth_1;
        PyObject *tmp_and_left_value_1;
        PyObject *tmp_and_right_value_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_source_name_4;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_oid);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1604;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_2 = par_other;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_oid);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_1);

            exception_lineno = 1604;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_and_left_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1604;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_truth_1 = CHECK_IF_TRUE(tmp_and_left_value_1);
        if (tmp_and_left_truth_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_and_left_value_1);

            exception_lineno = 1604;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        if (tmp_and_left_truth_1 == 1) {
            goto and_right_1;
        } else {
            goto and_left_1;
        }
        and_right_1:;
        Py_DECREF(tmp_and_left_value_1);
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_value);
        if (tmp_compexpr_left_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1604;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_4 = par_other;
        tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_value);
        if (tmp_compexpr_right_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_2);

            exception_lineno = 1604;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
        Py_DECREF(tmp_compexpr_left_2);
        Py_DECREF(tmp_compexpr_right_2);
        if (tmp_and_right_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1604;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_return_value = tmp_and_left_value_1;
        and_end_1:;
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0072f7a0ccd296332a271d4a8e480c77);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_0072f7a0ccd296332a271d4a8e480c77);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0072f7a0ccd296332a271d4a8e480c77);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_0072f7a0ccd296332a271d4a8e480c77, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_0072f7a0ccd296332a271d4a8e480c77->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_0072f7a0ccd296332a271d4a8e480c77, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0072f7a0ccd296332a271d4a8e480c77,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_0072f7a0ccd296332a271d4a8e480c77 == cache_frame_0072f7a0ccd296332a271d4a8e480c77) {
        Py_DECREF(frame_0072f7a0ccd296332a271d4a8e480c77);
    }
    cache_frame_0072f7a0ccd296332a271d4a8e480c77 = NULL;

    assertFrameObject(frame_0072f7a0ccd296332a271d4a8e480c77);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_206___eq__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_207___ne__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_4db96353b2604ba4e009beb772a0e03c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_4db96353b2604ba4e009beb772a0e03c = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_4db96353b2604ba4e009beb772a0e03c, codeobj_4db96353b2604ba4e009beb772a0e03c, module_cryptography$x509$extensions, sizeof(void *)+sizeof(void *));
    frame_4db96353b2604ba4e009beb772a0e03c = cache_frame_4db96353b2604ba4e009beb772a0e03c;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_4db96353b2604ba4e009beb772a0e03c);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_4db96353b2604ba4e009beb772a0e03c) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_self);
        tmp_compexpr_left_1 = par_self;
        CHECK_OBJECT(par_other);
        tmp_compexpr_right_1 = par_other;
        tmp_operand_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1607;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1607;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = (tmp_res == 0) ? Py_True : Py_False;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_4db96353b2604ba4e009beb772a0e03c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_4db96353b2604ba4e009beb772a0e03c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_4db96353b2604ba4e009beb772a0e03c);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_4db96353b2604ba4e009beb772a0e03c, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_4db96353b2604ba4e009beb772a0e03c->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_4db96353b2604ba4e009beb772a0e03c, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4db96353b2604ba4e009beb772a0e03c,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_4db96353b2604ba4e009beb772a0e03c == cache_frame_4db96353b2604ba4e009beb772a0e03c) {
        Py_DECREF(frame_4db96353b2604ba4e009beb772a0e03c);
    }
    cache_frame_4db96353b2604ba4e009beb772a0e03c = NULL;

    assertFrameObject(frame_4db96353b2604ba4e009beb772a0e03c);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_207___ne__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_cryptography$x509$extensions$$$function_208___hash__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_a404729c83b1ce7e50c89c3a34394158;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_a404729c83b1ce7e50c89c3a34394158 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_a404729c83b1ce7e50c89c3a34394158, codeobj_a404729c83b1ce7e50c89c3a34394158, module_cryptography$x509$extensions, sizeof(void *));
    frame_a404729c83b1ce7e50c89c3a34394158 = cache_frame_a404729c83b1ce7e50c89c3a34394158;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_a404729c83b1ce7e50c89c3a34394158);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_a404729c83b1ce7e50c89c3a34394158) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_hash_arg_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_oid);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1610;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_hash_arg_1 = PyTuple_New(2);
        PyTuple_SET_ITEM(tmp_hash_arg_1, 0, tmp_tuple_element_1);
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_value);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_hash_arg_1);

            exception_lineno = 1610;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM(tmp_hash_arg_1, 1, tmp_tuple_element_1);
        tmp_return_value = BUILTIN_HASH(tmp_hash_arg_1);
        Py_DECREF(tmp_hash_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1610;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a404729c83b1ce7e50c89c3a34394158);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_a404729c83b1ce7e50c89c3a34394158);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a404729c83b1ce7e50c89c3a34394158);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_a404729c83b1ce7e50c89c3a34394158, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_a404729c83b1ce7e50c89c3a34394158->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_a404729c83b1ce7e50c89c3a34394158, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a404729c83b1ce7e50c89c3a34394158,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_a404729c83b1ce7e50c89c3a34394158 == cache_frame_a404729c83b1ce7e50c89c3a34394158) {
        Py_DECREF(frame_a404729c83b1ce7e50c89c3a34394158);
    }
    cache_frame_a404729c83b1ce7e50c89c3a34394158 = NULL;

    assertFrameObject(frame_a404729c83b1ce7e50c89c3a34394158);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions$$$function_208___hash__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_100___ne__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_100___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_2374d85031de4b81a17b991b72074603,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_101___hash__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_101___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0c619b809dcf09b4a39bf5bdd60015b5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_102___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_102___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f3ae497e09b3bd3a162b69cd7a04cd91,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_103___iter__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_103___iter__,
        const_str_plain___iter__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c1b3c10743df6cec00e4bd32ad5436e8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_104___len__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_104___len__,
        const_str_plain___len__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_b1f676c1cba4b20ff4369028da50b101,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_105___repr__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_105___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_5e3e9860782562fdba9865949f9a1aad,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_106___eq__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_106___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_49ab98a368a06f5b62e3090207811653,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_107___ne__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_107___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_14de2d48cc6d86d7990ead778de5ef55,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_108___hash__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_108___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_307c2c80549b8830ab1bdc50cebac581,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_109___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_109___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_15065a31e94060fc1e6f2be62d1bb441,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_10___getitem__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_10___getitem__,
        const_str_plain___getitem__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_60d2d44b2848d82367f482e630058a14,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_110___iter__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_110___iter__,
        const_str_plain___iter__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_52ac52abb76c5766947a23493d41a735,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_111___len__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_111___len__,
        const_str_plain___len__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_516022e569c9c2d4e801766d1e23a7a9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_112___repr__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_112___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_3e4f26f00524b986eaad778de10be378,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_113___eq__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_113___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_24e7e599f7a9ff62dccfaaca7a767e34,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_114___getitem__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_114___getitem__,
        const_str_plain___getitem__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_4be51afc529a9d1699ae3aaaaf3cc631,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_115___ne__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_115___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_45ed442e1506cc9b5cff022672c2bdc7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_116___hash__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_116___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_630983a0bc3c12aec05d1c102c6f9427,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_117___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_117___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_6ef664bce779bb8c807c67c1e9b5d169,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_118___repr__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_118___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a40ae5465b1fee60f90d6ba7f74ac049,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_119___eq__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_119___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_2907138fdb90eed1a368f2b6f66fa0e6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_11___repr__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_11___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_8405f2e69630444edfa5d22fe7c6076e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_120___ne__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_120___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_56db8f3ad7ac017dddd0e01deae6912d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_121___hash__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_121___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_1915b0ec2af236e889c5e58dce17d01b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_122___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_122___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_77c11ff9d369e4a1284f82ff18ea0eb6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_123_encipher_only() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_123_encipher_only,
        const_str_plain_encipher_only,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_7aaeec7d13e2fa45c91143278c9384ed,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_124_decipher_only() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_124_decipher_only,
        const_str_plain_decipher_only,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_b961bdee1fe305fdfe9be48d53ac2abd,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_125___repr__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_125___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_de70240140ef9e6a0e5c1e2d00e223d2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_126___eq__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_126___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_9355c6ab964f8819c44a92cf3a8a7bc7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_127___ne__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_127___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_57e36cbbce323c916e9e798bf8dbed90,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_128___hash__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_128___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_4319d0fde202e8d91251639b1f99c86f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_129___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_129___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_15444db29e1e916a45d41f13f5c606ec,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_12___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_12___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_3e9816c5343a0a17dd4693ad9ed8aef1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_130___eq__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_130___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_36f675ca210741eafa6fdae589c7d341,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_131___ne__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_131___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_92c869c1bdf445f8c0f17651833850ef,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_132__validate_ip_name() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_132__validate_ip_name,
        const_str_plain__validate_ip_name,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_6e7680fc6f0882a572f93f3695c4ac8d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_133___repr__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_133___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c5572338dcd2f002feb76dcfbb9e1d18,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_134___hash__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_134___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f3eeb900b76619b4244a734caee1b5b1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_135___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_135___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_8b50f1443742e7df185a6bfdd7fc3d1f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_136___repr__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_136___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_2032aff2dcfd5f708972757a2c967882,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_137___eq__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_137___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c27b0e8e5456bfa1ce1df12003e5c214,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_138___ne__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_138___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_67946727c71fd992c6c0b992e68c9b62,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_139___hash__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_139___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_6f49f5cfd885de7a42467f04151c4e4a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_13___eq__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_13___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_5be6c71ea22dc937c8590e3714a0e70f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_140___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_140___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0c8e1253c96407b45c539de5f50b8b44,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_141___iter__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_141___iter__,
        const_str_plain___iter__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_e3238b208fe2e5d2a45d1c96985f203f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_142___len__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_142___len__,
        const_str_plain___len__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_8d9e40c8cfaba60d1272553c00ff35ed,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_143_get_values_for_type() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_143_get_values_for_type,
        const_str_plain_get_values_for_type,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_be19316fadb8714fcba11591040e6359,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_144___repr__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_144___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_efd34061bbe17d3f599acf52a0927a75,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_145___eq__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_145___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_377dfaf8031601d6b3bbe8ecaa46a6da,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_146___ne__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_146___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_b5bbacf212743993a52b51355435ccb2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_147___getitem__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_147___getitem__,
        const_str_plain___getitem__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_e80eadbccd9a352af4d1530cb82eabd0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_148___hash__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_148___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_7e8a46f19303bcd303c87268495b4873,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_149___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_149___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_9fbea692e0648e29509653c9c860b09a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_14___ne__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_14___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_e290bf4f69c1366e896d88d19cc6fb02,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_150___iter__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_150___iter__,
        const_str_plain___iter__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ae3e58b5effe48f6d27c07362c73d4d3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_151___len__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_151___len__,
        const_str_plain___len__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_107c6fa6753a52c5be47fed9637674ab,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_152_get_values_for_type() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_152_get_values_for_type,
        const_str_plain_get_values_for_type,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f68866006367fc4d498eabfdb2ce5eab,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_153___repr__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_153___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ff22167bf97fbb91b6a1b6290ff782e8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_154___eq__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_154___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_4faa79e5001d77385bdc0e9fd35de12b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_155___getitem__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_155___getitem__,
        const_str_plain___getitem__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_bc546761cdcfe97d2210ff9ffeb1d8d7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_156___ne__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_156___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_fe1e7a1a7475b74c7d82a70b9b2a7b1c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_157___hash__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_157___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_4e3af5c7e39f4d94e8e08cef824fb047,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_158___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_158___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ff0e042effc3afe7e319d9d9426d8281,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_159___iter__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_159___iter__,
        const_str_plain___iter__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_1c9410bc25f1960eb621aefb650cc5ae,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_15___hash__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_15___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_dccf9a51dd0e5d88d3e5ed45b6d434bd,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_160___len__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_160___len__,
        const_str_plain___len__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_30f20714cec73f8af7aacc594b6386e4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_161_get_values_for_type() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_161_get_values_for_type,
        const_str_plain_get_values_for_type,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_38fda1c9e56fc83bd693815271a1967a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_162___repr__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_162___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_fadb2dc5d8bba71f9a8e9cfcaee28365,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_163___eq__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_163___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_65acb965719b8331ceb73cf60da5a34d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_164___ne__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_164___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_9f3b3e38c30463863dd51d0304783462,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_165___getitem__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_165___getitem__,
        const_str_plain___getitem__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_50faf74e5ca2c4814bf1e56953546672,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_166___hash__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_166___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_b9940654b29bb9eed381a2ae1f642803,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_167___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_167___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_6b2b741db5b95eb288315358a396ca78,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_168___iter__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_168___iter__,
        const_str_plain___iter__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_6f3d7d0fdfecc3ad3243e2e88d74ced2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_169___len__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_169___len__,
        const_str_plain___len__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c17219ee1ea6d14faa2513ce9bfe056f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_16___repr__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_16___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_5627fc3a583d3cb6bbb8c8b56cc5ee6e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_170_get_values_for_type() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_170_get_values_for_type,
        const_str_plain_get_values_for_type,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_54e466a14b6f5af1981cb3aaa414eccb,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_171___repr__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_171___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_993858ded2f3066e6cc14f93b879c724,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_172___eq__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_172___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_763a08aeeae201c12ea113ce4cfc00d1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_173___ne__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_173___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ee82fcb5a179d6e83101dbacd640bb17,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_174___getitem__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_174___getitem__,
        const_str_plain___getitem__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_e2014de1836f1bbfee700d36c26440be,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_175___hash__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_175___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_617ec1273e01aa3bf39c7d8e1a305e70,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_176___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_176___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_6c658cb11fbcf33d94d501986e68c1ff,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_177___repr__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_177___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a5f1941815e6a4456d1d13832b07f311,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_178___eq__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_178___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a121d78d607dd566078ad638d3fd9345,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_179___ne__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_179___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_9b60c539be2d599550e02a9e38767f40,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_17___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_17___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a6ea834c6003bc7491321f01345f19da,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_180___hash__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_180___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_860103f2dcafc72031eb1f0cb95f4dfe,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_181___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_181___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_de12b3c1eb89792f5ed199d2ecb02247,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_182___repr__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_182___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_8188b9ec4ae4d8387eb82dac38e406e0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_183___eq__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_183___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_794acec4cbbb193c4d12f82b7f02da0c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_184___ne__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_184___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_8df0a17a4cea47e2942cb3a703b1e430,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_185___hash__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_185___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ff20a1f819ea51d73291e30a17f7b7d5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_186___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_186___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_5c40cf088e4ab97ee21bf262ce67d13d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_187___iter__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_187___iter__,
        const_str_plain___iter__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d19dda71d3d42b410ec1cac06f83952c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_188___len__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_188___len__,
        const_str_plain___len__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_538db483ab62c4241ff17d2733bb07d0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_189___getitem__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_189___getitem__,
        const_str_plain___getitem__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_2cd7211ae0497207f8bc2f43f4d4f414,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_18_from_issuer_public_key() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_18_from_issuer_public_key,
        const_str_plain_from_issuer_public_key,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_b2c6519047820697d77e44d8bdcfd13b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_190___repr__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_190___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_cd9319f1e2a709da2e67b8939c90e219,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_191___hash__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_191___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_54cad17ac3bd5403abe61737684eaa45,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_192___eq__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_192___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_01367d6abaf9a9706fda30395db202db,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_193___ne__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_193___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_b1baa4b5a4f28808018d8437290cabf1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_194___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_194___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_93c4a51e5d5a057df74d80318f8994b9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_195___eq__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_195___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_7028bdbd3fa71c0482994e203d0dd60c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_196___ne__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_196___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_2b9f0db2a0884ae0c464ed42cbe0ca77,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_197___hash__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_197___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_bbff8841f994d0861901167e26c77f21,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_198___repr__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_198___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_1492769ae6147f752f0b4b6f237cf894,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_199___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_199___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_6b50228316171cb46aa5f942471d78c9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_19_from_issuer_subject_key_identifier() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_19_from_issuer_subject_key_identifier,
        const_str_plain_from_issuer_subject_key_identifier,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a653d45da8baa6d488220c38863ffcf2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_1__key_identifier_from_public_key() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_1__key_identifier_from_public_key,
        const_str_plain__key_identifier_from_public_key,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_29760e1180446b273ed27a21f53c7d5b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_200___repr__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_200___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_4ccea98cae174f5c67a2d51a294f6880,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_201___eq__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_201___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0baf7dc256d01cc71597fc9143b60403,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_202___ne__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_202___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_7573520d98579b7184ce117cbc63b138,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_203___hash__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_203___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f2d176069a53125e7129d5de6997a323,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_204___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_204___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_84a0291d7ab205891af2466b9e0377ec,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_205___repr__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_205___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_53f581e08696ed1cb55d8d59dd2376ac,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_206___eq__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_206___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0072f7a0ccd296332a271d4a8e480c77,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_207___ne__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_207___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_4db96353b2604ba4e009beb772a0e03c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_208___hash__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_208___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a404729c83b1ce7e50c89c3a34394158,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_20___repr__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_20___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ab8c5a8b684c9fef58474266c7dffadb,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_21___eq__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_21___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ec606af4719e836adceac6092dca2c44,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_22___ne__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_22___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_9e02fda17edc241d52be17c732abc823,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_23___hash__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_23___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_7b2b4c038ecf3dd78ddb14477ee2e367,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_24___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_24___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_35d20cf5a412ee09604cd65c988906ca,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_25_from_public_key() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_25_from_public_key,
        const_str_plain_from_public_key,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_3e69ec24bcd58b7600541c49b05642f9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_26___repr__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_26___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_8fbc2a08b5ca5a8f7c260de621689a56,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_27___eq__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_27___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_3bb78211f559ebe4d881b75b546ffc0a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_28___ne__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_28___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_2a76b8a7a0619e7e50369de1896fb82e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_29___hash__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_29___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_7c6b59f6602706780fb2366013d7677d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_2___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_2___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a639918ff9b53f9ac4ca97850d09e8b5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_30___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_30___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_2ac5cbbcb3461b660306ae84e4908ce0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_31___iter__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_31___iter__,
        const_str_plain___iter__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_8abc18ccaef36115f2eefe103b30849a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_32___len__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_32___len__,
        const_str_plain___len__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d617f84754084510e6e33c98f465dfab,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_33___repr__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_33___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_aa37e82ac1bfe382d743f376673b24de,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_34___eq__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_34___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ec6763a25cc283c8349cad2c66a21488,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_35___ne__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_35___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_bafa1748f4280a8d96a8ef0430df7fda,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_36___getitem__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_36___getitem__,
        const_str_plain___getitem__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a61d36331eed656537469cdb25841c38,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_37___hash__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_37___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d4d5e0153429c0273ebb4e9160719179,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_38___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_38___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d82db69e835d9e68e136650ca07bce53,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_39___repr__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_39___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_cef83b92118b0cfd63adac31a6c2c4dd,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_3___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_3___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_060b6428f7e0298a84738a381d9a7335,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_40___eq__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_40___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_b89be643f7a61f3d81c6671d6ad51b78,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_41___ne__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_41___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0717dde802ff3bf828c32149b86f91c5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_42___hash__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_42___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_9e5fdab2f284d2dbd1ea4bcd02f4243a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_43___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_43___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_fc83f25a35c64baf86fc9abec28579bf,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_44___repr__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_44___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_574e55e9b19a65578d5335f615e3ce1f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_45___eq__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_45___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_bf509f0149490c9f7ccf380ab57d6798,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_46___ne__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_46___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_b2624bbf7f2345dffc42b8356201f32c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_47___hash__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_47___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_94ad4941638ca2d741d049b1fa5e9734,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_48___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_48___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_8947fe591337cc5a2cf6de779a4c5523,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_49___eq__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_49___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_56e3c65f02e773e82d404aa393504dde,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_4_oid() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        NULL,
        const_str_plain_oid,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_cfe41ce1eddc8e60170273ac53a9bcf1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        const_str_digest_35185795abbb3b5bbc0cab5aa03aab83,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_50___ne__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_50___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_6eec4ed29d652d67297334df34b9efea,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_51___hash__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_51___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_24e6c32aa2722cf4ecaa3b16048d4738,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_52___repr__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_52___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_149b439b28110db47c6d802c9ba60c85,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_53___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_53___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_9dea707d642354d82eb245b14decc508,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_54___iter__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_54___iter__,
        const_str_plain___iter__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0cc8a86e0089204a5f1ba5499e750c59,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_55___len__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_55___len__,
        const_str_plain___len__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_149307d85299be0e2bb512b521807433,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_56___repr__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_56___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0e38c8c915cfa3f59056d06f346243bf,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_57___eq__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_57___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_401579719c1f990019f327b475e920c9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_58___ne__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_58___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a1d6f2aea8a4d49139a6df2ca29a43e4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_59___getitem__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_59___getitem__,
        const_str_plain___getitem__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_e1fa255798e8bef9d045790b180982af,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_5___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_5___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ccb81d58c538921fd6eadf0f5f9021bf,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_60___hash__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_60___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_2ee369f8faadbdd2a80c9b8c92f1b573,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_61___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_61___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f39e2c4ef794a49e891ba944e62753a1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_62___iter__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_62___iter__,
        const_str_plain___iter__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_b916760a1adc6a39fbf1144eb6bf82c6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_63___len__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_63___len__,
        const_str_plain___len__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_76098b86abab8a2ab9554e3939fdd518,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_64___repr__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_64___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_3538b6f5a5b90a8f1ad1699f31158e85,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_65___eq__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_65___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_bca7cfb63f34239fb1479c0362918cf5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_66___ne__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_66___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_eec0c8b89a2742f11fc8c57f2f33ab22,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_67___getitem__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_67___getitem__,
        const_str_plain___getitem__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c4a263fab24d4b74487740f36bc3c59f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_68___hash__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_68___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_660db49e2668f19c95e04c246a6a5dd8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_69___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_69___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_168b828ef0bd5b03004b55cf5ee199a8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_6_get_extension_for_oid() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_6_get_extension_for_oid,
        const_str_plain_get_extension_for_oid,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_44fcf979e33c233af5f80d7c35b13be4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_70___repr__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_70___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_2b572ac717ef65df74ce99e5f8b136a9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_71___eq__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_71___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_fd2f7ac83c7c2c75bf12c49dee786140,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_72___ne__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_72___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_50bc9a59774bc50fc0ac2d1a07ffc38a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_73___hash__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_73___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f20ef46fc2f13e0d2c1ca2898c462ef4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_74___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_74___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_8c74ccf08a9d69888a5bac51f8974a06,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_75___repr__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_75___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_2e2a967d61caf9026b18b0e9c6006146,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_76___eq__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_76___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_37be6aa945e0555a84befbfd36f8ffc2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_77___ne__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_77___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_1d077a2aa446b600dd44fa19b0fba0f2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_78___hash__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_78___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0bf109aa3d44d653af2864e48ed4fe06,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_79___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_79___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_2d8993bbcf695d23055ae2f7cb247a4b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_7_get_extension_for_class() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_7_get_extension_for_class,
        const_str_plain_get_extension_for_class,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a3b7117cfaf5b59269aee17d1606e823,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_80___iter__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_80___iter__,
        const_str_plain___iter__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_cd33e2543397d1324358a2e61f8977a4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_81___len__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_81___len__,
        const_str_plain___len__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_9dfb2f031074454e5d12da987d075118,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_82___repr__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_82___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_7165db6d77156f077838a6ffb710eb7d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_83___eq__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_83___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_7c03c4c0f3dcfa4c04cd5abaf3b9020a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_84___ne__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_84___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_19f4c0df1d648fcd98396d2760645fff,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_85___getitem__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_85___getitem__,
        const_str_plain___getitem__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_91ef01aeefd39e14a3a497daec6f2d50,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_86___hash__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_86___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_54048dea6a948c37f34018f06d8c86ff,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_87___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_87___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_08aca7543267a89e2589b8bd1ffcee16,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_88___repr__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_88___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c8ca74f375a5b66d21788a9c199bc810,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_89___eq__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_89___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d85838fa42326f320c88255032c5fca7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_8___iter__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_8___iter__,
        const_str_plain___iter__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_2a0bf5a2c89e7fa0fdc8aac5f0ceb989,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_90___ne__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_90___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f02229ffaecf12b0bda4fcfc8980ff2f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_91___hash__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_91___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0243f386a7ef791aa70475a164a2b63a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_92___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_92___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_bea296a7219ecd602eca25edc4652bad,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_93___repr__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_93___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_275913114fb9b83a1dbb762593bb7bc5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_94___eq__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_94___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_2321762013dc0ff29c834d130737aec5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_95___ne__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_95___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_2572b3a6c05f0075fc8737e5fda0c78b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_96___hash__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_96___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_9a7626d648d17d2d5ed8388969ae0bd5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_97___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_97___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_fcf5dbe695d0fd2e4622c11a67638dce,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_98___repr__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_98___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_55a2c931a1b128be07012db2099f9f07,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_99___eq__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_99___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a4f75b426139664f5a0ed587effcf9e3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_cryptography$x509$extensions$$$function_9___len__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_cryptography$x509$extensions$$$function_9___len__,
        const_str_plain___len__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_df6b91143147712a389f7e389566de10,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_cryptography$x509$extensions,
        NULL,
        0
    );

    return (PyObject *)result;
}



#if PYTHON_VERSION >= 300
static struct PyModuleDef mdef_cryptography$x509$extensions =
{
    PyModuleDef_HEAD_INIT,
    NULL,                /* m_name, filled later */
    NULL,                /* m_doc */
    -1,                  /* m_size */
    NULL,                /* m_methods */
    NULL,                /* m_reload */
    NULL,                /* m_traverse */
    NULL,                /* m_clear */
    NULL,                /* m_free */
  };
#endif

extern PyObject *const_str_plain___compiled__;

extern PyObject *const_str_plain___package__;
extern PyObject *const_str_empty;

#if PYTHON_VERSION >= 300
extern PyObject *const_str_dot;
extern PyObject *const_str_plain___loader__;
#endif

#if PYTHON_VERSION >= 340
extern PyObject *const_str_plain___spec__;
extern PyObject *const_str_plain__initializing;
extern PyObject *const_str_plain_submodule_search_locations;
#endif

extern void _initCompiledCellType();
extern void _initCompiledGeneratorType();
extern void _initCompiledFunctionType();
extern void _initCompiledMethodType();
extern void _initCompiledFrameType();
#if PYTHON_VERSION >= 350
extern void _initCompiledCoroutineTypes();
#endif
#if PYTHON_VERSION >= 360
extern void _initCompiledAsyncgenTypes();
#endif

extern PyTypeObject Nuitka_Loader_Type;

#ifdef _NUITKA_PLUGIN_DILL_ENABLED
// Provide a way to create find a function via its C code and create it back
// in another process, useful for multiprocessing extensions like dill

function_impl_code functable_cryptography$x509$extensions[] = {
    impl_cryptography$x509$extensions$$$function_1__key_identifier_from_public_key,
    impl_cryptography$x509$extensions$$$function_2___init__,
    impl_cryptography$x509$extensions$$$function_3___init__,
    NULL,
    impl_cryptography$x509$extensions$$$function_5___init__,
    impl_cryptography$x509$extensions$$$function_6_get_extension_for_oid,
    impl_cryptography$x509$extensions$$$function_7_get_extension_for_class,
    impl_cryptography$x509$extensions$$$function_8___iter__,
    impl_cryptography$x509$extensions$$$function_9___len__,
    impl_cryptography$x509$extensions$$$function_10___getitem__,
    impl_cryptography$x509$extensions$$$function_11___repr__,
    impl_cryptography$x509$extensions$$$function_12___init__,
    impl_cryptography$x509$extensions$$$function_13___eq__,
    impl_cryptography$x509$extensions$$$function_14___ne__,
    impl_cryptography$x509$extensions$$$function_15___hash__,
    impl_cryptography$x509$extensions$$$function_16___repr__,
    impl_cryptography$x509$extensions$$$function_17___init__,
    impl_cryptography$x509$extensions$$$function_18_from_issuer_public_key,
    impl_cryptography$x509$extensions$$$function_19_from_issuer_subject_key_identifier,
    impl_cryptography$x509$extensions$$$function_20___repr__,
    impl_cryptography$x509$extensions$$$function_21___eq__,
    impl_cryptography$x509$extensions$$$function_22___ne__,
    impl_cryptography$x509$extensions$$$function_23___hash__,
    impl_cryptography$x509$extensions$$$function_24___init__,
    impl_cryptography$x509$extensions$$$function_25_from_public_key,
    impl_cryptography$x509$extensions$$$function_26___repr__,
    impl_cryptography$x509$extensions$$$function_27___eq__,
    impl_cryptography$x509$extensions$$$function_28___ne__,
    impl_cryptography$x509$extensions$$$function_29___hash__,
    impl_cryptography$x509$extensions$$$function_30___init__,
    impl_cryptography$x509$extensions$$$function_31___iter__,
    impl_cryptography$x509$extensions$$$function_32___len__,
    impl_cryptography$x509$extensions$$$function_33___repr__,
    impl_cryptography$x509$extensions$$$function_34___eq__,
    impl_cryptography$x509$extensions$$$function_35___ne__,
    impl_cryptography$x509$extensions$$$function_36___getitem__,
    impl_cryptography$x509$extensions$$$function_37___hash__,
    impl_cryptography$x509$extensions$$$function_38___init__,
    impl_cryptography$x509$extensions$$$function_39___repr__,
    impl_cryptography$x509$extensions$$$function_40___eq__,
    impl_cryptography$x509$extensions$$$function_41___ne__,
    impl_cryptography$x509$extensions$$$function_42___hash__,
    impl_cryptography$x509$extensions$$$function_43___init__,
    impl_cryptography$x509$extensions$$$function_44___repr__,
    impl_cryptography$x509$extensions$$$function_45___eq__,
    impl_cryptography$x509$extensions$$$function_46___ne__,
    impl_cryptography$x509$extensions$$$function_47___hash__,
    impl_cryptography$x509$extensions$$$function_48___init__,
    impl_cryptography$x509$extensions$$$function_49___eq__,
    impl_cryptography$x509$extensions$$$function_50___ne__,
    impl_cryptography$x509$extensions$$$function_51___hash__,
    impl_cryptography$x509$extensions$$$function_52___repr__,
    impl_cryptography$x509$extensions$$$function_53___init__,
    impl_cryptography$x509$extensions$$$function_54___iter__,
    impl_cryptography$x509$extensions$$$function_55___len__,
    impl_cryptography$x509$extensions$$$function_56___repr__,
    impl_cryptography$x509$extensions$$$function_57___eq__,
    impl_cryptography$x509$extensions$$$function_58___ne__,
    impl_cryptography$x509$extensions$$$function_59___getitem__,
    impl_cryptography$x509$extensions$$$function_60___hash__,
    impl_cryptography$x509$extensions$$$function_61___init__,
    impl_cryptography$x509$extensions$$$function_62___iter__,
    impl_cryptography$x509$extensions$$$function_63___len__,
    impl_cryptography$x509$extensions$$$function_64___repr__,
    impl_cryptography$x509$extensions$$$function_65___eq__,
    impl_cryptography$x509$extensions$$$function_66___ne__,
    impl_cryptography$x509$extensions$$$function_67___getitem__,
    impl_cryptography$x509$extensions$$$function_68___hash__,
    impl_cryptography$x509$extensions$$$function_69___init__,
    impl_cryptography$x509$extensions$$$function_70___repr__,
    impl_cryptography$x509$extensions$$$function_71___eq__,
    impl_cryptography$x509$extensions$$$function_72___ne__,
    impl_cryptography$x509$extensions$$$function_73___hash__,
    impl_cryptography$x509$extensions$$$function_74___init__,
    impl_cryptography$x509$extensions$$$function_75___repr__,
    impl_cryptography$x509$extensions$$$function_76___eq__,
    impl_cryptography$x509$extensions$$$function_77___ne__,
    impl_cryptography$x509$extensions$$$function_78___hash__,
    impl_cryptography$x509$extensions$$$function_79___init__,
    impl_cryptography$x509$extensions$$$function_80___iter__,
    impl_cryptography$x509$extensions$$$function_81___len__,
    impl_cryptography$x509$extensions$$$function_82___repr__,
    impl_cryptography$x509$extensions$$$function_83___eq__,
    impl_cryptography$x509$extensions$$$function_84___ne__,
    impl_cryptography$x509$extensions$$$function_85___getitem__,
    impl_cryptography$x509$extensions$$$function_86___hash__,
    impl_cryptography$x509$extensions$$$function_87___init__,
    impl_cryptography$x509$extensions$$$function_88___repr__,
    impl_cryptography$x509$extensions$$$function_89___eq__,
    impl_cryptography$x509$extensions$$$function_90___ne__,
    impl_cryptography$x509$extensions$$$function_91___hash__,
    impl_cryptography$x509$extensions$$$function_92___init__,
    impl_cryptography$x509$extensions$$$function_93___repr__,
    impl_cryptography$x509$extensions$$$function_94___eq__,
    impl_cryptography$x509$extensions$$$function_95___ne__,
    impl_cryptography$x509$extensions$$$function_96___hash__,
    impl_cryptography$x509$extensions$$$function_97___init__,
    impl_cryptography$x509$extensions$$$function_98___repr__,
    impl_cryptography$x509$extensions$$$function_99___eq__,
    impl_cryptography$x509$extensions$$$function_100___ne__,
    impl_cryptography$x509$extensions$$$function_101___hash__,
    impl_cryptography$x509$extensions$$$function_102___init__,
    impl_cryptography$x509$extensions$$$function_103___iter__,
    impl_cryptography$x509$extensions$$$function_104___len__,
    impl_cryptography$x509$extensions$$$function_105___repr__,
    impl_cryptography$x509$extensions$$$function_106___eq__,
    impl_cryptography$x509$extensions$$$function_107___ne__,
    impl_cryptography$x509$extensions$$$function_108___hash__,
    impl_cryptography$x509$extensions$$$function_109___init__,
    impl_cryptography$x509$extensions$$$function_110___iter__,
    impl_cryptography$x509$extensions$$$function_111___len__,
    impl_cryptography$x509$extensions$$$function_112___repr__,
    impl_cryptography$x509$extensions$$$function_113___eq__,
    impl_cryptography$x509$extensions$$$function_114___getitem__,
    impl_cryptography$x509$extensions$$$function_115___ne__,
    impl_cryptography$x509$extensions$$$function_116___hash__,
    impl_cryptography$x509$extensions$$$function_117___init__,
    impl_cryptography$x509$extensions$$$function_118___repr__,
    impl_cryptography$x509$extensions$$$function_119___eq__,
    impl_cryptography$x509$extensions$$$function_120___ne__,
    impl_cryptography$x509$extensions$$$function_121___hash__,
    impl_cryptography$x509$extensions$$$function_122___init__,
    impl_cryptography$x509$extensions$$$function_123_encipher_only,
    impl_cryptography$x509$extensions$$$function_124_decipher_only,
    impl_cryptography$x509$extensions$$$function_125___repr__,
    impl_cryptography$x509$extensions$$$function_126___eq__,
    impl_cryptography$x509$extensions$$$function_127___ne__,
    impl_cryptography$x509$extensions$$$function_128___hash__,
    impl_cryptography$x509$extensions$$$function_129___init__,
    impl_cryptography$x509$extensions$$$function_130___eq__,
    impl_cryptography$x509$extensions$$$function_131___ne__,
    impl_cryptography$x509$extensions$$$function_132__validate_ip_name,
    impl_cryptography$x509$extensions$$$function_133___repr__,
    impl_cryptography$x509$extensions$$$function_134___hash__,
    impl_cryptography$x509$extensions$$$function_135___init__,
    impl_cryptography$x509$extensions$$$function_136___repr__,
    impl_cryptography$x509$extensions$$$function_137___eq__,
    impl_cryptography$x509$extensions$$$function_138___ne__,
    impl_cryptography$x509$extensions$$$function_139___hash__,
    impl_cryptography$x509$extensions$$$function_140___init__,
    impl_cryptography$x509$extensions$$$function_141___iter__,
    impl_cryptography$x509$extensions$$$function_142___len__,
    impl_cryptography$x509$extensions$$$function_143_get_values_for_type,
    impl_cryptography$x509$extensions$$$function_144___repr__,
    impl_cryptography$x509$extensions$$$function_145___eq__,
    impl_cryptography$x509$extensions$$$function_146___ne__,
    impl_cryptography$x509$extensions$$$function_147___getitem__,
    impl_cryptography$x509$extensions$$$function_148___hash__,
    impl_cryptography$x509$extensions$$$function_149___init__,
    impl_cryptography$x509$extensions$$$function_150___iter__,
    impl_cryptography$x509$extensions$$$function_151___len__,
    impl_cryptography$x509$extensions$$$function_152_get_values_for_type,
    impl_cryptography$x509$extensions$$$function_153___repr__,
    impl_cryptography$x509$extensions$$$function_154___eq__,
    impl_cryptography$x509$extensions$$$function_155___getitem__,
    impl_cryptography$x509$extensions$$$function_156___ne__,
    impl_cryptography$x509$extensions$$$function_157___hash__,
    impl_cryptography$x509$extensions$$$function_158___init__,
    impl_cryptography$x509$extensions$$$function_159___iter__,
    impl_cryptography$x509$extensions$$$function_160___len__,
    impl_cryptography$x509$extensions$$$function_161_get_values_for_type,
    impl_cryptography$x509$extensions$$$function_162___repr__,
    impl_cryptography$x509$extensions$$$function_163___eq__,
    impl_cryptography$x509$extensions$$$function_164___ne__,
    impl_cryptography$x509$extensions$$$function_165___getitem__,
    impl_cryptography$x509$extensions$$$function_166___hash__,
    impl_cryptography$x509$extensions$$$function_167___init__,
    impl_cryptography$x509$extensions$$$function_168___iter__,
    impl_cryptography$x509$extensions$$$function_169___len__,
    impl_cryptography$x509$extensions$$$function_170_get_values_for_type,
    impl_cryptography$x509$extensions$$$function_171___repr__,
    impl_cryptography$x509$extensions$$$function_172___eq__,
    impl_cryptography$x509$extensions$$$function_173___ne__,
    impl_cryptography$x509$extensions$$$function_174___getitem__,
    impl_cryptography$x509$extensions$$$function_175___hash__,
    impl_cryptography$x509$extensions$$$function_176___init__,
    impl_cryptography$x509$extensions$$$function_177___repr__,
    impl_cryptography$x509$extensions$$$function_178___eq__,
    impl_cryptography$x509$extensions$$$function_179___ne__,
    impl_cryptography$x509$extensions$$$function_180___hash__,
    impl_cryptography$x509$extensions$$$function_181___init__,
    impl_cryptography$x509$extensions$$$function_182___repr__,
    impl_cryptography$x509$extensions$$$function_183___eq__,
    impl_cryptography$x509$extensions$$$function_184___ne__,
    impl_cryptography$x509$extensions$$$function_185___hash__,
    impl_cryptography$x509$extensions$$$function_186___init__,
    impl_cryptography$x509$extensions$$$function_187___iter__,
    impl_cryptography$x509$extensions$$$function_188___len__,
    impl_cryptography$x509$extensions$$$function_189___getitem__,
    impl_cryptography$x509$extensions$$$function_190___repr__,
    impl_cryptography$x509$extensions$$$function_191___hash__,
    impl_cryptography$x509$extensions$$$function_192___eq__,
    impl_cryptography$x509$extensions$$$function_193___ne__,
    impl_cryptography$x509$extensions$$$function_194___init__,
    impl_cryptography$x509$extensions$$$function_195___eq__,
    impl_cryptography$x509$extensions$$$function_196___ne__,
    impl_cryptography$x509$extensions$$$function_197___hash__,
    impl_cryptography$x509$extensions$$$function_198___repr__,
    impl_cryptography$x509$extensions$$$function_199___init__,
    impl_cryptography$x509$extensions$$$function_200___repr__,
    impl_cryptography$x509$extensions$$$function_201___eq__,
    impl_cryptography$x509$extensions$$$function_202___ne__,
    impl_cryptography$x509$extensions$$$function_203___hash__,
    impl_cryptography$x509$extensions$$$function_204___init__,
    impl_cryptography$x509$extensions$$$function_205___repr__,
    impl_cryptography$x509$extensions$$$function_206___eq__,
    impl_cryptography$x509$extensions$$$function_207___ne__,
    impl_cryptography$x509$extensions$$$function_208___hash__,
    NULL
};

static char const *_reduce_compiled_function_argnames[] = {
    "func",
    NULL
};

static PyObject *_reduce_compiled_function(PyObject *self, PyObject *args, PyObject *kwds) {
    PyObject *func;

    if (!PyArg_ParseTupleAndKeywords(args, kwds, "O:reduce_compiled_function", (char **)_reduce_compiled_function_argnames, &func, NULL)) {
        return NULL;
    }

    if (Nuitka_Function_Check(func) == false) {
        PyErr_Format(PyExc_TypeError, "not a compiled function");
        return NULL;
    }

    struct Nuitka_FunctionObject *function = (struct Nuitka_FunctionObject *)func;

    function_impl_code *current = functable_cryptography$x509$extensions;
    int offset = 0;

    while (*current != NULL) {
        if (*current == function->m_c_code) {
            break;
        }

        current += 1;
        offset += 1;
    }

    if (*current == NULL) {
        PyErr_Format(PyExc_TypeError, "Cannot find compiled function in module.");
        return NULL;
    }

    PyObject *code_object_desc = PyTuple_New(6);
    PyTuple_SET_ITEM0(code_object_desc, 0, function->m_code_object->co_filename);
    PyTuple_SET_ITEM0(code_object_desc, 1, function->m_code_object->co_name);
    PyTuple_SET_ITEM(code_object_desc, 2, PyLong_FromLong(function->m_code_object->co_firstlineno));
    PyTuple_SET_ITEM0(code_object_desc, 3, function->m_code_object->co_varnames);
    PyTuple_SET_ITEM(code_object_desc, 4, PyLong_FromLong(function->m_code_object->co_argcount));
    PyTuple_SET_ITEM(code_object_desc, 5, PyLong_FromLong(function->m_code_object->co_flags));

    CHECK_OBJECT_DEEP(code_object_desc);

    PyObject *result = PyTuple_New(4);
    PyTuple_SET_ITEM(result, 0, PyLong_FromLong(offset));
    PyTuple_SET_ITEM(result, 1, code_object_desc);
    PyTuple_SET_ITEM0(result, 2, function->m_defaults);
    PyTuple_SET_ITEM0(result, 3, function->m_doc != NULL ? function->m_doc : Py_None);

    CHECK_OBJECT_DEEP(result);

    return result;
}

static PyMethodDef _method_def_reduce_compiled_function = {"reduce_compiled_function", (PyCFunction)_reduce_compiled_function,
                                                           METH_VARARGS | METH_KEYWORDS, NULL};

static char const *_create_compiled_function_argnames[] = {
    "func",
    "code_object_desc",
    "defaults",
    "doc",
    NULL
};


static PyObject *_create_compiled_function(PyObject *self, PyObject *args, PyObject *kwds) {
    CHECK_OBJECT_DEEP(args);

    PyObject *func;
    PyObject *code_object_desc;
    PyObject *defaults;
    PyObject *doc;

    if (!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:create_compiled_function", (char **)_create_compiled_function_argnames, &func, &code_object_desc, &defaults, &doc, NULL)) {
        return NULL;
    }

    int offset = PyLong_AsLong(func);

    if (offset == -1 && ERROR_OCCURRED()) {
        return NULL;
    }

    if (offset > sizeof(functable_cryptography$x509$extensions) || offset < 0) {
        PyErr_Format(PyExc_TypeError, "Wrong offset for compiled function.");
        return NULL;
    }

    PyObject *filename = PyTuple_GET_ITEM(code_object_desc, 0);
    PyObject *function_name = PyTuple_GET_ITEM(code_object_desc, 1);
    PyObject *line = PyTuple_GET_ITEM(code_object_desc, 2);
    int line_int = PyLong_AsLong(line);
    assert(!ERROR_OCCURRED());

    PyObject *argnames = PyTuple_GET_ITEM(code_object_desc, 3);
    PyObject *arg_count = PyTuple_GET_ITEM(code_object_desc, 4);
    int arg_count_int = PyLong_AsLong(arg_count);
    assert(!ERROR_OCCURRED());
    PyObject *flags = PyTuple_GET_ITEM(code_object_desc, 5);
    int flags_int = PyLong_AsLong(flags);
    assert(!ERROR_OCCURRED());

    PyCodeObject *code_object = MAKE_CODEOBJECT(
        filename,
        line_int,
        flags_int,
        function_name,
        argnames,
        arg_count_int,
        0, // TODO: Missing kw_only_count
        0 // TODO: Missing pos_only_count
    );

    // TODO: More stuff needed for Python3, best to re-order arguments of MAKE_CODEOBJECT.
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        functable_cryptography$x509$extensions[offset],
        code_object->co_name,
#if PYTHON_VERSION >= 300
        NULL, // TODO: Not transferring qualname yet
#endif
        code_object,
        defaults,
#if PYTHON_VERSION >= 300
        NULL, // kwdefaults are done on the outside currently
        NULL, // TODO: Not transferring annotations
#endif
        module_cryptography$x509$extensions,
        doc,
        0
    );

    return (PyObject *)result;
}

static PyMethodDef _method_def_create_compiled_function = {
    "create_compiled_function",
    (PyCFunction)_create_compiled_function,
    METH_VARARGS | METH_KEYWORDS, NULL
};


#endif

// Internal entry point for module code.
PyObject *modulecode_cryptography$x509$extensions(char const *module_full_name) {
#if defined(_NUITKA_EXE) || PYTHON_VERSION >= 300
    static bool _init_done = false;

    // Modules might be imported repeatedly, which is to be ignored.
    if (_init_done) {
        return module_cryptography$x509$extensions;
    } else {
        _init_done = true;
    }
#endif

#ifdef _NUITKA_MODULE
    // In case of a stand alone extension module, need to call initialization
    // the init here because that's the first and only time we are going to get
    // called here.

    // May have to activate constants blob.
#if defined(_NUITKA_CONSTANTS_FROM_RESOURCE)
    loadConstantsResource();
#endif

    // Initialize the constant values used.
    _initBuiltinModule();
    createGlobalConstants();

    /* Initialize the compiled types of Nuitka. */
    _initCompiledCellType();
    _initCompiledGeneratorType();
    _initCompiledFunctionType();
    _initCompiledMethodType();
    _initCompiledFrameType();
#if PYTHON_VERSION >= 350
    _initCompiledCoroutineTypes();
#endif
#if PYTHON_VERSION >= 360
    _initCompiledAsyncgenTypes();
#endif

#if PYTHON_VERSION < 300
    _initSlotCompare();
#endif
#if PYTHON_VERSION >= 270
    _initSlotIternext();
#endif

    patchBuiltinModule();
    patchTypeComparison();

    // Enable meta path based loader if not already done.
#ifdef _NUITKA_TRACE
    PRINT_STRING("cryptography.x509.extensions: Calling setupMetaPathBasedLoader().\n");
#endif
    setupMetaPathBasedLoader();

#if PYTHON_VERSION >= 300
    patchInspectModule();
#endif

#endif

    /* The constants only used by this module are created now. */
#ifdef _NUITKA_TRACE
    PRINT_STRING("cryptography.x509.extensions: Calling createModuleConstants().\n");
#endif
    createModuleConstants();

    /* The code objects used by this module are created now. */
#ifdef _NUITKA_TRACE
    PRINT_STRING("cryptography.x509.extensions: Calling createModuleCodeObjects().\n");
#endif
    createModuleCodeObjects();

    // PRINT_STRING("in initcryptography$x509$extensions\n");

    // Create the module object first. There are no methods initially, all are
    // added dynamically in actual code only.  Also no "__doc__" is initially
    // set at this time, as it could not contain NUL characters this way, they
    // are instead set in early module code.  No "self" for modules, we have no
    // use for it.
#if PYTHON_VERSION < 300
    module_cryptography$x509$extensions = Py_InitModule4(
        module_full_name,        // Module Name
        NULL,                    // No methods initially, all are added
                                 // dynamically in actual module code only.
        NULL,                    // No "__doc__" is initially set, as it could
                                 // not contain NUL this way, added early in
                                 // actual code.
        NULL,                    // No self for modules, we don't use it.
        PYTHON_API_VERSION
    );
#else
    mdef_cryptography$x509$extensions.m_name = module_full_name;
    module_cryptography$x509$extensions = PyModule_Create(&mdef_cryptography$x509$extensions);
#endif

    moduledict_cryptography$x509$extensions = MODULE_DICT(module_cryptography$x509$extensions);

#ifdef _NUITKA_PLUGIN_DILL_ENABLED
    {
        PyObject *function_tables = PyObject_GetAttrString((PyObject *)builtin_module, "compiled_function_tables");
        if (function_tables == NULL)
        {
            DROP_ERROR_OCCURRED();
            function_tables = PyDict_New();
        }
        PyObject_SetAttrString((PyObject *)builtin_module, "compiled_function_tables", function_tables);
        PyObject *funcs = PyTuple_New(2);
        PyTuple_SetItem(funcs, 0, PyCFunction_New(&_method_def_reduce_compiled_function, NULL));
        PyTuple_SetItem(funcs, 1, PyCFunction_New(&_method_def_create_compiled_function, NULL));
        PyDict_SetItemString(function_tables, module_full_name, funcs);
    }
#endif

    // Set "__compiled__" to what version information we have.
    UPDATE_STRING_DICT0(
        moduledict_cryptography$x509$extensions,
        (Nuitka_StringObject *)const_str_plain___compiled__,
        Nuitka_dunder_compiled_value
    );

    // Update "__package__" value to what it ought to be.
    {
#if 0
        UPDATE_STRING_DICT0(
            moduledict_cryptography$x509$extensions,
            (Nuitka_StringObject *)const_str_plain___package__,
            const_str_empty
        );
#elif 0
        PyObject *module_name = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain___name__);

        UPDATE_STRING_DICT0(
            moduledict_cryptography$x509$extensions,
            (Nuitka_StringObject *)const_str_plain___package__,
            module_name
        );
#else

#if PYTHON_VERSION < 300
        PyObject *module_name = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain___name__);
        char const *module_name_cstr = PyString_AS_STRING(module_name);

        char const *last_dot = strrchr(module_name_cstr, '.');

        if (last_dot != NULL)
        {
            UPDATE_STRING_DICT1(
                moduledict_cryptography$x509$extensions,
                (Nuitka_StringObject *)const_str_plain___package__,
                PyString_FromStringAndSize(module_name_cstr, last_dot - module_name_cstr)
            );
        }
#else
        PyObject *module_name = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain___name__);
        Py_ssize_t dot_index = PyUnicode_Find(module_name, const_str_dot, 0, PyUnicode_GetLength(module_name), -1);

        if (dot_index != -1)
        {
            UPDATE_STRING_DICT1(
                moduledict_cryptography$x509$extensions,
                (Nuitka_StringObject *)const_str_plain___package__,
                PyUnicode_Substring(module_name, 0, dot_index)
            );
        }
#endif
#endif
    }

    CHECK_OBJECT(module_cryptography$x509$extensions);

// Seems to work for Python2.7 out of the box, but for Python3, the module
// doesn't automatically enter "sys.modules", so do it manually.
#if PYTHON_VERSION >= 300
    {
        int r = PyDict_SetItemString(PyImport_GetModuleDict(), module_full_name, module_cryptography$x509$extensions);
        assert(r != -1);
    }
#endif

    // For deep importing of a module we need to have "__builtins__", so we set
    // it ourselves in the same way than CPython does. Note: This must be done
    // before the frame object is allocated, or else it may fail.

    if (GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain___builtins__) == NULL)
    {
        PyObject *value = (PyObject *)builtin_module;

        // Check if main module, not a dict then but the module itself.
#if !defined(_NUITKA_EXE) || !0
        value = PyModule_GetDict(value);
#endif

        UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain___builtins__, value);
    }

#if PYTHON_VERSION >= 300
    UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain___loader__, (PyObject *)&Nuitka_Loader_Type);
#endif

#if PYTHON_VERSION >= 340
// Set the "__spec__" value

#if 0
    // Main modules just get "None" as spec.
    UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain___spec__, Py_None);
#else
    // Other modules get a "ModuleSpec" from the standard mechanism.
    {
        PyObject *bootstrap_module = PyImport_ImportModule("importlib._bootstrap");
        CHECK_OBJECT(bootstrap_module);
        PyObject *module_spec_class = PyObject_GetAttrString(bootstrap_module, "ModuleSpec");
        Py_DECREF(bootstrap_module);

        PyObject *args[] = {
            GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain___name__),
            (PyObject *)&Nuitka_Loader_Type
        };

        PyObject *spec_value = CALL_FUNCTION_WITH_ARGS2(
            module_spec_class,
            args
        );
        Py_DECREF(module_spec_class);

        // We can assume this to never fail, or else we are in trouble anyway.
        CHECK_OBJECT(spec_value);

// For packages set the submodule search locations as well, even if to empty
// list, so investigating code will consider it a package.
#if 0
        SET_ATTRIBUTE(spec_value, const_str_plain_submodule_search_locations, PyList_New(0));
#endif

// Mark the execution in the "__spec__" value.
        SET_ATTRIBUTE(spec_value, const_str_plain__initializing, Py_True);

        UPDATE_STRING_DICT1(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain___spec__, spec_value);
    }
#endif
#endif

    // Temp variables if any
    PyObject *tmp_class_creation_10__class = NULL;
    PyObject *tmp_class_creation_10__class_dict = NULL;
    PyObject *tmp_class_creation_10__metaclass = NULL;
    PyObject *tmp_class_creation_11__class = NULL;
    PyObject *tmp_class_creation_11__class_dict = NULL;
    PyObject *tmp_class_creation_11__metaclass = NULL;
    PyObject *tmp_class_creation_12__class = NULL;
    PyObject *tmp_class_creation_12__class_dict = NULL;
    PyObject *tmp_class_creation_12__metaclass = NULL;
    PyObject *tmp_class_creation_13__class = NULL;
    PyObject *tmp_class_creation_13__class_dict = NULL;
    PyObject *tmp_class_creation_13__metaclass = NULL;
    PyObject *tmp_class_creation_14__class = NULL;
    PyObject *tmp_class_creation_14__class_dict = NULL;
    PyObject *tmp_class_creation_14__metaclass = NULL;
    PyObject *tmp_class_creation_15__bases = NULL;
    PyObject *tmp_class_creation_15__class = NULL;
    PyObject *tmp_class_creation_15__class_dict = NULL;
    PyObject *tmp_class_creation_15__metaclass = NULL;
    PyObject *tmp_class_creation_16__class = NULL;
    PyObject *tmp_class_creation_16__class_dict = NULL;
    PyObject *tmp_class_creation_16__metaclass = NULL;
    PyObject *tmp_class_creation_17__class = NULL;
    PyObject *tmp_class_creation_17__class_dict = NULL;
    PyObject *tmp_class_creation_17__metaclass = NULL;
    PyObject *tmp_class_creation_18__class = NULL;
    PyObject *tmp_class_creation_18__class_dict = NULL;
    PyObject *tmp_class_creation_18__metaclass = NULL;
    PyObject *tmp_class_creation_19__class = NULL;
    PyObject *tmp_class_creation_19__class_dict = NULL;
    PyObject *tmp_class_creation_19__metaclass = NULL;
    PyObject *tmp_class_creation_1__class = NULL;
    PyObject *tmp_class_creation_1__class_dict = NULL;
    PyObject *tmp_class_creation_1__metaclass = NULL;
    PyObject *tmp_class_creation_20__class = NULL;
    PyObject *tmp_class_creation_20__class_dict = NULL;
    PyObject *tmp_class_creation_20__metaclass = NULL;
    PyObject *tmp_class_creation_21__class = NULL;
    PyObject *tmp_class_creation_21__class_dict = NULL;
    PyObject *tmp_class_creation_21__metaclass = NULL;
    PyObject *tmp_class_creation_22__class = NULL;
    PyObject *tmp_class_creation_22__class_dict = NULL;
    PyObject *tmp_class_creation_22__metaclass = NULL;
    PyObject *tmp_class_creation_23__class = NULL;
    PyObject *tmp_class_creation_23__class_dict = NULL;
    PyObject *tmp_class_creation_23__metaclass = NULL;
    PyObject *tmp_class_creation_24__class = NULL;
    PyObject *tmp_class_creation_24__class_dict = NULL;
    PyObject *tmp_class_creation_24__metaclass = NULL;
    PyObject *tmp_class_creation_25__bases = NULL;
    PyObject *tmp_class_creation_25__class = NULL;
    PyObject *tmp_class_creation_25__class_dict = NULL;
    PyObject *tmp_class_creation_25__metaclass = NULL;
    PyObject *tmp_class_creation_26__class = NULL;
    PyObject *tmp_class_creation_26__class_dict = NULL;
    PyObject *tmp_class_creation_26__metaclass = NULL;
    PyObject *tmp_class_creation_27__class = NULL;
    PyObject *tmp_class_creation_27__class_dict = NULL;
    PyObject *tmp_class_creation_27__metaclass = NULL;
    PyObject *tmp_class_creation_28__class = NULL;
    PyObject *tmp_class_creation_28__class_dict = NULL;
    PyObject *tmp_class_creation_28__metaclass = NULL;
    PyObject *tmp_class_creation_29__class = NULL;
    PyObject *tmp_class_creation_29__class_dict = NULL;
    PyObject *tmp_class_creation_29__metaclass = NULL;
    PyObject *tmp_class_creation_2__class = NULL;
    PyObject *tmp_class_creation_2__class_dict = NULL;
    PyObject *tmp_class_creation_2__metaclass = NULL;
    PyObject *tmp_class_creation_30__class = NULL;
    PyObject *tmp_class_creation_30__class_dict = NULL;
    PyObject *tmp_class_creation_30__metaclass = NULL;
    PyObject *tmp_class_creation_31__class = NULL;
    PyObject *tmp_class_creation_31__class_dict = NULL;
    PyObject *tmp_class_creation_31__metaclass = NULL;
    PyObject *tmp_class_creation_32__class = NULL;
    PyObject *tmp_class_creation_32__class_dict = NULL;
    PyObject *tmp_class_creation_32__metaclass = NULL;
    PyObject *tmp_class_creation_33__class = NULL;
    PyObject *tmp_class_creation_33__class_dict = NULL;
    PyObject *tmp_class_creation_33__metaclass = NULL;
    PyObject *tmp_class_creation_34__class = NULL;
    PyObject *tmp_class_creation_34__class_dict = NULL;
    PyObject *tmp_class_creation_34__metaclass = NULL;
    PyObject *tmp_class_creation_35__class = NULL;
    PyObject *tmp_class_creation_35__class_dict = NULL;
    PyObject *tmp_class_creation_35__metaclass = NULL;
    PyObject *tmp_class_creation_36__class = NULL;
    PyObject *tmp_class_creation_36__class_dict = NULL;
    PyObject *tmp_class_creation_36__metaclass = NULL;
    PyObject *tmp_class_creation_37__class = NULL;
    PyObject *tmp_class_creation_37__class_dict = NULL;
    PyObject *tmp_class_creation_37__metaclass = NULL;
    PyObject *tmp_class_creation_38__class = NULL;
    PyObject *tmp_class_creation_38__class_dict = NULL;
    PyObject *tmp_class_creation_38__metaclass = NULL;
    PyObject *tmp_class_creation_39__class = NULL;
    PyObject *tmp_class_creation_39__class_dict = NULL;
    PyObject *tmp_class_creation_39__metaclass = NULL;
    PyObject *tmp_class_creation_3__class = NULL;
    PyObject *tmp_class_creation_3__class_dict = NULL;
    PyObject *tmp_class_creation_3__metaclass = NULL;
    PyObject *tmp_class_creation_4__class = NULL;
    PyObject *tmp_class_creation_4__class_dict = NULL;
    PyObject *tmp_class_creation_4__metaclass = NULL;
    PyObject *tmp_class_creation_5__class = NULL;
    PyObject *tmp_class_creation_5__class_dict = NULL;
    PyObject *tmp_class_creation_5__metaclass = NULL;
    PyObject *tmp_class_creation_6__class = NULL;
    PyObject *tmp_class_creation_6__class_dict = NULL;
    PyObject *tmp_class_creation_6__metaclass = NULL;
    PyObject *tmp_class_creation_7__class = NULL;
    PyObject *tmp_class_creation_7__class_dict = NULL;
    PyObject *tmp_class_creation_7__metaclass = NULL;
    PyObject *tmp_class_creation_8__class = NULL;
    PyObject *tmp_class_creation_8__class_dict = NULL;
    PyObject *tmp_class_creation_8__metaclass = NULL;
    PyObject *tmp_class_creation_9__class = NULL;
    PyObject *tmp_class_creation_9__class_dict = NULL;
    PyObject *tmp_class_creation_9__metaclass = NULL;
    PyObject *tmp_genexpr_1__$0 = NULL;
    PyObject *tmp_import_from_1__module = NULL;
    PyObject *tmp_import_from_2__module = NULL;
    PyObject *tmp_import_from_3__module = NULL;
    PyObject *tmp_import_from_4__module = NULL;
    PyObject *tmp_locals_cryptography$x509$extensions_1168_key___eq__ = NULL;
    PyObject *tmp_locals_cryptography$x509$extensions_1168_key___getitem__ = NULL;
    PyObject *tmp_locals_cryptography$x509$extensions_1168_key___hash__ = NULL;
    PyObject *tmp_locals_cryptography$x509$extensions_1168_key___init__ = NULL;
    PyObject *tmp_locals_cryptography$x509$extensions_1168_key___iter__ = NULL;
    PyObject *tmp_locals_cryptography$x509$extensions_1168_key___len__ = NULL;
    PyObject *tmp_locals_cryptography$x509$extensions_1168_key___ne__ = NULL;
    PyObject *tmp_locals_cryptography$x509$extensions_1168_key___repr__ = NULL;
    PyObject *tmp_locals_cryptography$x509$extensions_1168_key_get_values_for_type = NULL;
    PyObject *tmp_locals_cryptography$x509$extensions_54_key___init__ = NULL;
    PyObject *tmp_locals_cryptography$x509$extensions_60_key___init__ = NULL;
    PyObject *tmp_locals_cryptography$x509$extensions_75_key___getitem__ = NULL;
    PyObject *tmp_locals_cryptography$x509$extensions_75_key___init__ = NULL;
    PyObject *tmp_locals_cryptography$x509$extensions_75_key___iter__ = NULL;
    PyObject *tmp_locals_cryptography$x509$extensions_75_key___len__ = NULL;
    PyObject *tmp_locals_cryptography$x509$extensions_75_key___repr__ = NULL;
    PyObject *tmp_locals_cryptography$x509$extensions_75_key_get_extension_for_class = NULL;
    PyObject *tmp_locals_cryptography$x509$extensions_75_key_get_extension_for_oid = NULL;
    PyObject *tmp_select_metaclass_15__base = NULL;
    PyObject *tmp_select_metaclass_25__base = NULL;
    struct Nuitka_FrameObject *frame_43c1c6d969ff6899544b1cfb272ea433;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    int tmp_res;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;
    PyObject *exception_keeper_type_6;
    PyObject *exception_keeper_value_6;
    PyTracebackObject *exception_keeper_tb_6;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_6;
    PyObject *locals_cryptography$x509$extensions_67 = NULL;
    PyObject *tmp_dictset_value;
    struct Nuitka_FrameObject *frame_8e8c1d14cc1f43c40fb686c3c332d970_2;
    NUITKA_MAY_BE_UNUSED char const *type_description_2 = NULL;
    static struct Nuitka_FrameObject *cache_frame_8e8c1d14cc1f43c40fb686c3c332d970_2 = NULL;
    PyObject *exception_keeper_type_7;
    PyObject *exception_keeper_value_7;
    PyTracebackObject *exception_keeper_tb_7;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_7;
    PyObject *exception_keeper_type_8;
    PyObject *exception_keeper_value_8;
    PyTracebackObject *exception_keeper_tb_8;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_8;
    PyObject *exception_keeper_type_9;
    PyObject *exception_keeper_value_9;
    PyTracebackObject *exception_keeper_tb_9;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_9;
    PyObject *locals_cryptography$x509$extensions_118 = NULL;
    struct Nuitka_FrameObject *frame_9c95e9ba0408147c3cfcb22e4b1c91c9_3;
    NUITKA_MAY_BE_UNUSED char const *type_description_3 = NULL;
    static struct Nuitka_FrameObject *cache_frame_9c95e9ba0408147c3cfcb22e4b1c91c9_3 = NULL;
    PyObject *exception_keeper_type_10;
    PyObject *exception_keeper_value_10;
    PyTracebackObject *exception_keeper_tb_10;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_10;
    PyObject *exception_keeper_type_11;
    PyObject *exception_keeper_value_11;
    PyTracebackObject *exception_keeper_tb_11;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_11;
    PyObject *locals_cryptography$x509$extensions_146 = NULL;
    struct Nuitka_FrameObject *frame_8af375243c51a3b11b69e7c775faf530_4;
    NUITKA_MAY_BE_UNUSED char const *type_description_4 = NULL;
    static struct Nuitka_FrameObject *cache_frame_8af375243c51a3b11b69e7c775faf530_4 = NULL;
    PyObject *exception_keeper_type_12;
    PyObject *exception_keeper_value_12;
    PyTracebackObject *exception_keeper_tb_12;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_12;
    PyObject *exception_keeper_type_13;
    PyObject *exception_keeper_value_13;
    PyTracebackObject *exception_keeper_tb_13;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_13;
    PyObject *locals_cryptography$x509$extensions_236 = NULL;
    struct Nuitka_FrameObject *frame_0bc1f437e02225d59bf32cb2d7a199ed_5;
    NUITKA_MAY_BE_UNUSED char const *type_description_5 = NULL;
    static struct Nuitka_FrameObject *cache_frame_0bc1f437e02225d59bf32cb2d7a199ed_5 = NULL;
    PyObject *exception_keeper_type_14;
    PyObject *exception_keeper_value_14;
    PyTracebackObject *exception_keeper_tb_14;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_14;
    PyObject *exception_keeper_type_15;
    PyObject *exception_keeper_value_15;
    PyTracebackObject *exception_keeper_tb_15;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_15;
    PyObject *locals_cryptography$x509$extensions_265 = NULL;
    struct Nuitka_FrameObject *frame_fdfe391b38b7f158ab41b6490db64d26_6;
    NUITKA_MAY_BE_UNUSED char const *type_description_6 = NULL;
    static struct Nuitka_FrameObject *cache_frame_fdfe391b38b7f158ab41b6490db64d26_6 = NULL;
    PyObject *exception_keeper_type_16;
    PyObject *exception_keeper_value_16;
    PyTracebackObject *exception_keeper_tb_16;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_16;
    PyObject *exception_keeper_type_17;
    PyObject *exception_keeper_value_17;
    PyTracebackObject *exception_keeper_tb_17;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_17;
    PyObject *locals_cryptography$x509$extensions_303 = NULL;
    struct Nuitka_FrameObject *frame_888390ddbc4bf33f48bfeea2ec680910_7;
    NUITKA_MAY_BE_UNUSED char const *type_description_7 = NULL;
    static struct Nuitka_FrameObject *cache_frame_888390ddbc4bf33f48bfeea2ec680910_7 = NULL;
    PyObject *exception_keeper_type_18;
    PyObject *exception_keeper_value_18;
    PyTracebackObject *exception_keeper_tb_18;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_18;
    PyObject *exception_keeper_type_19;
    PyObject *exception_keeper_value_19;
    PyTracebackObject *exception_keeper_tb_19;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_19;
    PyObject *locals_cryptography$x509$extensions_340 = NULL;
    struct Nuitka_FrameObject *frame_10cbbfd8fde45d6af5689d9068ecbd4d_8;
    NUITKA_MAY_BE_UNUSED char const *type_description_8 = NULL;
    static struct Nuitka_FrameObject *cache_frame_10cbbfd8fde45d6af5689d9068ecbd4d_8 = NULL;
    PyObject *exception_keeper_type_20;
    PyObject *exception_keeper_value_20;
    PyTracebackObject *exception_keeper_tb_20;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_20;
    PyObject *exception_keeper_type_21;
    PyObject *exception_keeper_value_21;
    PyTracebackObject *exception_keeper_tb_21;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_21;
    PyObject *locals_cryptography$x509$extensions_382 = NULL;
    struct Nuitka_FrameObject *frame_c40257bc666664b368a90a2bb591b69e_9;
    NUITKA_MAY_BE_UNUSED char const *type_description_9 = NULL;
    static struct Nuitka_FrameObject *cache_frame_c40257bc666664b368a90a2bb591b69e_9 = NULL;
    PyObject *exception_keeper_type_22;
    PyObject *exception_keeper_value_22;
    PyTracebackObject *exception_keeper_tb_22;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_22;
    PyObject *exception_keeper_type_23;
    PyObject *exception_keeper_value_23;
    PyTracebackObject *exception_keeper_tb_23;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_23;
    PyObject *locals_cryptography$x509$extensions_410 = NULL;
    struct Nuitka_FrameObject *frame_8cf535c0875cf42bdef61b5101de9850_10;
    NUITKA_MAY_BE_UNUSED char const *type_description_10 = NULL;
    static struct Nuitka_FrameObject *cache_frame_8cf535c0875cf42bdef61b5101de9850_10 = NULL;
    PyObject *exception_keeper_type_24;
    PyObject *exception_keeper_value_24;
    PyTracebackObject *exception_keeper_tb_24;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_24;
    PyObject *exception_keeper_type_25;
    PyObject *exception_keeper_value_25;
    PyTracebackObject *exception_keeper_tb_25;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_25;
    PyObject *locals_cryptography$x509$extensions_451 = NULL;
    struct Nuitka_FrameObject *frame_8be8c331db6797002bac5a779f59022d_11;
    NUITKA_MAY_BE_UNUSED char const *type_description_11 = NULL;
    static struct Nuitka_FrameObject *cache_frame_8be8c331db6797002bac5a779f59022d_11 = NULL;
    PyObject *exception_keeper_type_26;
    PyObject *exception_keeper_value_26;
    PyTracebackObject *exception_keeper_tb_26;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_26;
    PyObject *exception_keeper_type_27;
    PyObject *exception_keeper_value_27;
    PyTracebackObject *exception_keeper_tb_27;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_27;
    PyObject *locals_cryptography$x509$extensions_491 = NULL;
    struct Nuitka_FrameObject *frame_d9bb56bd96dd7fc707029f25f9b9879f_12;
    NUITKA_MAY_BE_UNUSED char const *type_description_12 = NULL;
    static struct Nuitka_FrameObject *cache_frame_d9bb56bd96dd7fc707029f25f9b9879f_12 = NULL;
    PyObject *exception_keeper_type_28;
    PyObject *exception_keeper_value_28;
    PyTracebackObject *exception_keeper_tb_28;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_28;
    PyObject *exception_keeper_type_29;
    PyObject *exception_keeper_value_29;
    PyTracebackObject *exception_keeper_tb_29;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_29;
    PyObject *locals_cryptography$x509$extensions_584 = NULL;
    PyObject *exception_keeper_type_30;
    PyObject *exception_keeper_value_30;
    PyTracebackObject *exception_keeper_tb_30;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_30;
    PyObject *exception_keeper_type_31;
    PyObject *exception_keeper_value_31;
    PyTracebackObject *exception_keeper_tb_31;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_31;
    PyObject *locals_cryptography$x509$extensions_598 = NULL;
    struct Nuitka_FrameObject *frame_4db2c46a45695eb12bac9cef5aa0180e_13;
    NUITKA_MAY_BE_UNUSED char const *type_description_13 = NULL;
    static struct Nuitka_FrameObject *cache_frame_4db2c46a45695eb12bac9cef5aa0180e_13 = NULL;
    PyObject *exception_keeper_type_32;
    PyObject *exception_keeper_value_32;
    PyTracebackObject *exception_keeper_tb_32;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_32;
    PyObject *exception_keeper_type_33;
    PyObject *exception_keeper_value_33;
    PyTracebackObject *exception_keeper_tb_33;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_33;
    PyObject *locals_cryptography$x509$extensions_659 = NULL;
    struct Nuitka_FrameObject *frame_6a2ac24867d838ebbfada582b800ac84_14;
    NUITKA_MAY_BE_UNUSED char const *type_description_14 = NULL;
    static struct Nuitka_FrameObject *cache_frame_6a2ac24867d838ebbfada582b800ac84_14 = NULL;
    PyObject *exception_keeper_type_34;
    PyObject *exception_keeper_value_34;
    PyTracebackObject *exception_keeper_tb_34;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_34;
    PyObject *exception_keeper_type_35;
    PyObject *exception_keeper_value_35;
    PyTracebackObject *exception_keeper_tb_35;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_35;
    PyObject *locals_cryptography$x509$extensions_697 = NULL;
    struct Nuitka_FrameObject *frame_adabafe8c246c11f4a4c9f6f68213ae2_15;
    NUITKA_MAY_BE_UNUSED char const *type_description_15 = NULL;
    static struct Nuitka_FrameObject *cache_frame_adabafe8c246c11f4a4c9f6f68213ae2_15 = NULL;
    PyObject *exception_keeper_type_36;
    PyObject *exception_keeper_value_36;
    PyTracebackObject *exception_keeper_tb_36;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_36;
    PyObject *exception_keeper_type_37;
    PyObject *exception_keeper_value_37;
    PyTracebackObject *exception_keeper_tb_37;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_37;
    PyObject *locals_cryptography$x509$extensions_747 = NULL;
    struct Nuitka_FrameObject *frame_284f196fc1cfe393c2e892de06b6804f_16;
    NUITKA_MAY_BE_UNUSED char const *type_description_16 = NULL;
    static struct Nuitka_FrameObject *cache_frame_284f196fc1cfe393c2e892de06b6804f_16 = NULL;
    PyObject *exception_keeper_type_38;
    PyObject *exception_keeper_value_38;
    PyTracebackObject *exception_keeper_tb_38;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_38;
    PyObject *exception_keeper_type_39;
    PyObject *exception_keeper_value_39;
    PyTracebackObject *exception_keeper_tb_39;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_39;
    PyObject *locals_cryptography$x509$extensions_784 = NULL;
    struct Nuitka_FrameObject *frame_131acb86ad21685798bdc6a84a886dee_17;
    NUITKA_MAY_BE_UNUSED char const *type_description_17 = NULL;
    static struct Nuitka_FrameObject *cache_frame_131acb86ad21685798bdc6a84a886dee_17 = NULL;
    PyObject *exception_keeper_type_40;
    PyObject *exception_keeper_value_40;
    PyTracebackObject *exception_keeper_tb_40;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_40;
    PyObject *exception_keeper_type_41;
    PyObject *exception_keeper_value_41;
    PyTracebackObject *exception_keeper_tb_41;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_41;
    PyObject *locals_cryptography$x509$extensions_821 = NULL;
    struct Nuitka_FrameObject *frame_d76b975938eb3793df08887e6a883dcc_18;
    NUITKA_MAY_BE_UNUSED char const *type_description_18 = NULL;
    static struct Nuitka_FrameObject *cache_frame_d76b975938eb3793df08887e6a883dcc_18 = NULL;
    PyObject *exception_keeper_type_42;
    PyObject *exception_keeper_value_42;
    PyTracebackObject *exception_keeper_tb_42;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_42;
    PyObject *exception_keeper_type_43;
    PyObject *exception_keeper_value_43;
    PyTracebackObject *exception_keeper_tb_43;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_43;
    PyObject *locals_cryptography$x509$extensions_856 = NULL;
    struct Nuitka_FrameObject *frame_14b4d327d26227dbeeaf8ac21d0eead5_19;
    NUITKA_MAY_BE_UNUSED char const *type_description_19 = NULL;
    static struct Nuitka_FrameObject *cache_frame_14b4d327d26227dbeeaf8ac21d0eead5_19 = NULL;
    PyObject *exception_keeper_type_44;
    PyObject *exception_keeper_value_44;
    PyTracebackObject *exception_keeper_tb_44;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_44;
    PyObject *exception_keeper_type_45;
    PyObject *exception_keeper_value_45;
    PyTracebackObject *exception_keeper_tb_45;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_45;
    PyObject *locals_cryptography$x509$extensions_861 = NULL;
    struct Nuitka_FrameObject *frame_5b0a6348dd417584c7f202513d6c4148_20;
    NUITKA_MAY_BE_UNUSED char const *type_description_20 = NULL;
    static struct Nuitka_FrameObject *cache_frame_5b0a6348dd417584c7f202513d6c4148_20 = NULL;
    PyObject *exception_keeper_type_46;
    PyObject *exception_keeper_value_46;
    PyTracebackObject *exception_keeper_tb_46;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_46;
    PyObject *exception_keeper_type_47;
    PyObject *exception_keeper_value_47;
    PyTracebackObject *exception_keeper_tb_47;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_47;
    PyObject *locals_cryptography$x509$extensions_866 = NULL;
    struct Nuitka_FrameObject *frame_31b0147aee22ba20318b32af38dd79aa_21;
    NUITKA_MAY_BE_UNUSED char const *type_description_21 = NULL;
    static struct Nuitka_FrameObject *cache_frame_31b0147aee22ba20318b32af38dd79aa_21 = NULL;
    PyObject *exception_keeper_type_48;
    PyObject *exception_keeper_value_48;
    PyTracebackObject *exception_keeper_tb_48;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_48;
    PyObject *exception_keeper_type_49;
    PyObject *exception_keeper_value_49;
    PyTracebackObject *exception_keeper_tb_49;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_49;
    PyObject *locals_cryptography$x509$extensions_907 = NULL;
    PyObject *exception_keeper_type_50;
    PyObject *exception_keeper_value_50;
    PyTracebackObject *exception_keeper_tb_50;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_50;
    PyObject *exception_keeper_type_51;
    PyObject *exception_keeper_value_51;
    PyTracebackObject *exception_keeper_tb_51;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_51;
    PyObject *locals_cryptography$x509$extensions_922 = NULL;
    struct Nuitka_FrameObject *frame_9cf8ad554dd9d3c4ef6ee538381ad390_22;
    NUITKA_MAY_BE_UNUSED char const *type_description_22 = NULL;
    static struct Nuitka_FrameObject *cache_frame_9cf8ad554dd9d3c4ef6ee538381ad390_22 = NULL;
    PyObject *exception_keeper_type_52;
    PyObject *exception_keeper_value_52;
    PyTracebackObject *exception_keeper_tb_52;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_52;
    PyObject *exception_keeper_type_53;
    PyObject *exception_keeper_value_53;
    PyTracebackObject *exception_keeper_tb_53;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_53;
    PyObject *locals_cryptography$x509$extensions_953 = NULL;
    struct Nuitka_FrameObject *frame_083e1fa26f5ab300d67d5d5e3552df7c_23;
    NUITKA_MAY_BE_UNUSED char const *type_description_23 = NULL;
    static struct Nuitka_FrameObject *cache_frame_083e1fa26f5ab300d67d5d5e3552df7c_23 = NULL;
    PyObject *exception_keeper_type_54;
    PyObject *exception_keeper_value_54;
    PyTracebackObject *exception_keeper_tb_54;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_54;
    PyObject *exception_keeper_type_55;
    PyObject *exception_keeper_value_55;
    PyTracebackObject *exception_keeper_tb_55;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_55;
    PyObject *locals_cryptography$x509$extensions_1048 = NULL;
    struct Nuitka_FrameObject *frame_88f6f5c3c797c731ba74a50683fe2b42_24;
    NUITKA_MAY_BE_UNUSED char const *type_description_24 = NULL;
    static struct Nuitka_FrameObject *cache_frame_88f6f5c3c797c731ba74a50683fe2b42_24 = NULL;
    PyObject *exception_keeper_type_56;
    PyObject *exception_keeper_value_56;
    PyTracebackObject *exception_keeper_tb_56;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_56;
    PyObject *exception_keeper_type_57;
    PyObject *exception_keeper_value_57;
    PyTracebackObject *exception_keeper_tb_57;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_57;
    PyObject *locals_cryptography$x509$extensions_1129 = NULL;
    struct Nuitka_FrameObject *frame_e04ffe5b900a4019b6788821593ab364_25;
    NUITKA_MAY_BE_UNUSED char const *type_description_25 = NULL;
    static struct Nuitka_FrameObject *cache_frame_e04ffe5b900a4019b6788821593ab364_25 = NULL;
    PyObject *exception_keeper_type_58;
    PyObject *exception_keeper_value_58;
    PyTracebackObject *exception_keeper_tb_58;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_58;
    PyObject *exception_keeper_type_59;
    PyObject *exception_keeper_value_59;
    PyTracebackObject *exception_keeper_tb_59;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_59;
    PyObject *exception_keeper_type_60;
    PyObject *exception_keeper_value_60;
    PyTracebackObject *exception_keeper_tb_60;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_60;
    PyObject *locals_cryptography$x509$extensions_1214 = NULL;
    struct Nuitka_FrameObject *frame_52c7e053ce661cd35566c3bb41cd02bd_26;
    NUITKA_MAY_BE_UNUSED char const *type_description_26 = NULL;
    static struct Nuitka_FrameObject *cache_frame_52c7e053ce661cd35566c3bb41cd02bd_26 = NULL;
    PyObject *exception_keeper_type_61;
    PyObject *exception_keeper_value_61;
    PyTracebackObject *exception_keeper_tb_61;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_61;
    PyObject *exception_keeper_type_62;
    PyObject *exception_keeper_value_62;
    PyTracebackObject *exception_keeper_tb_62;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_62;
    PyObject *locals_cryptography$x509$extensions_1249 = NULL;
    struct Nuitka_FrameObject *frame_046f51f4b030997d90f3cee22939d406_27;
    NUITKA_MAY_BE_UNUSED char const *type_description_27 = NULL;
    static struct Nuitka_FrameObject *cache_frame_046f51f4b030997d90f3cee22939d406_27 = NULL;
    PyObject *exception_keeper_type_63;
    PyObject *exception_keeper_value_63;
    PyTracebackObject *exception_keeper_tb_63;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_63;
    PyObject *exception_keeper_type_64;
    PyObject *exception_keeper_value_64;
    PyTracebackObject *exception_keeper_tb_64;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_64;
    PyObject *locals_cryptography$x509$extensions_1284 = NULL;
    struct Nuitka_FrameObject *frame_d613475f4bc9b1ec8ed0abba919aa767_28;
    NUITKA_MAY_BE_UNUSED char const *type_description_28 = NULL;
    static struct Nuitka_FrameObject *cache_frame_d613475f4bc9b1ec8ed0abba919aa767_28 = NULL;
    PyObject *exception_keeper_type_65;
    PyObject *exception_keeper_value_65;
    PyTracebackObject *exception_keeper_tb_65;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_65;
    PyObject *exception_keeper_type_66;
    PyObject *exception_keeper_value_66;
    PyTracebackObject *exception_keeper_tb_66;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_66;
    PyObject *locals_cryptography$x509$extensions_1319 = NULL;
    struct Nuitka_FrameObject *frame_f1fb71489cc684b7ee4d1e2902a82ad3_29;
    NUITKA_MAY_BE_UNUSED char const *type_description_29 = NULL;
    static struct Nuitka_FrameObject *cache_frame_f1fb71489cc684b7ee4d1e2902a82ad3_29 = NULL;
    PyObject *exception_keeper_type_67;
    PyObject *exception_keeper_value_67;
    PyTracebackObject *exception_keeper_tb_67;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_67;
    PyObject *exception_keeper_type_68;
    PyObject *exception_keeper_value_68;
    PyTracebackObject *exception_keeper_tb_68;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_68;
    PyObject *locals_cryptography$x509$extensions_1347 = NULL;
    struct Nuitka_FrameObject *frame_c1c2bb0918ddbcf5f075491c88a41e6d_30;
    NUITKA_MAY_BE_UNUSED char const *type_description_30 = NULL;
    static struct Nuitka_FrameObject *cache_frame_c1c2bb0918ddbcf5f075491c88a41e6d_30 = NULL;
    PyObject *exception_keeper_type_69;
    PyObject *exception_keeper_value_69;
    PyTracebackObject *exception_keeper_tb_69;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_69;
    PyObject *exception_keeper_type_70;
    PyObject *exception_keeper_value_70;
    PyTracebackObject *exception_keeper_tb_70;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_70;
    PyObject *locals_cryptography$x509$extensions_1377 = NULL;
    struct Nuitka_FrameObject *frame_34d3d5aa27da9c5dfcf667f6ff343fae_31;
    NUITKA_MAY_BE_UNUSED char const *type_description_31 = NULL;
    static struct Nuitka_FrameObject *cache_frame_34d3d5aa27da9c5dfcf667f6ff343fae_31 = NULL;
    PyObject *exception_keeper_type_71;
    PyObject *exception_keeper_value_71;
    PyTracebackObject *exception_keeper_tb_71;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_71;
    PyObject *exception_keeper_type_72;
    PyObject *exception_keeper_value_72;
    PyTracebackObject *exception_keeper_tb_72;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_72;
    PyObject *locals_cryptography$x509$extensions_1425 = NULL;
    struct Nuitka_FrameObject *frame_e1283683c51f59cb9a7eb7fe98cf8efa_32;
    NUITKA_MAY_BE_UNUSED char const *type_description_32 = NULL;
    static struct Nuitka_FrameObject *cache_frame_e1283683c51f59cb9a7eb7fe98cf8efa_32 = NULL;
    PyObject *exception_keeper_type_73;
    PyObject *exception_keeper_value_73;
    PyTracebackObject *exception_keeper_tb_73;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_73;
    PyObject *exception_keeper_type_74;
    PyObject *exception_keeper_value_74;
    PyTracebackObject *exception_keeper_tb_74;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_74;
    PyObject *locals_cryptography$x509$extensions_1453 = NULL;
    struct Nuitka_FrameObject *frame_49473bcf3743b34fde0906127568439e_33;
    NUITKA_MAY_BE_UNUSED char const *type_description_33 = NULL;
    static struct Nuitka_FrameObject *cache_frame_49473bcf3743b34fde0906127568439e_33 = NULL;
    PyObject *exception_keeper_type_75;
    PyObject *exception_keeper_value_75;
    PyTracebackObject *exception_keeper_tb_75;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_75;
    PyObject *exception_keeper_type_76;
    PyObject *exception_keeper_value_76;
    PyTracebackObject *exception_keeper_tb_76;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_76;
    PyObject *locals_cryptography$x509$extensions_1583 = NULL;
    struct Nuitka_FrameObject *frame_50a05b6f30ae622183421406fd266003_34;
    NUITKA_MAY_BE_UNUSED char const *type_description_34 = NULL;
    static struct Nuitka_FrameObject *cache_frame_50a05b6f30ae622183421406fd266003_34 = NULL;
    PyObject *exception_keeper_type_77;
    PyObject *exception_keeper_value_77;
    PyTracebackObject *exception_keeper_tb_77;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_77;
    PyObject *exception_keeper_type_78;
    PyObject *exception_keeper_value_78;
    PyTracebackObject *exception_keeper_tb_78;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_78;

    // Module code.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = Py_None;
        UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain___doc__, tmp_assign_source_1);
    }
    {
        PyObject *tmp_assign_source_2;
        tmp_assign_source_2 = module_filename_obj;
        UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain___file__, tmp_assign_source_2);
    }
    {
        PyObject *tmp_assign_source_3;
        tmp_assign_source_3 = PyImport_ImportModule("__future__");
        assert(!(tmp_assign_source_3 == NULL));
        assert(tmp_import_from_1__module == NULL);
        Py_INCREF(tmp_assign_source_3);
        tmp_import_from_1__module = tmp_assign_source_3;
    }
    // Frame without reuse.
    frame_43c1c6d969ff6899544b1cfb272ea433 = MAKE_MODULE_FRAME(codeobj_43c1c6d969ff6899544b1cfb272ea433, module_cryptography$x509$extensions);

    // Push the new frame as the currently active one, and we should be exclusively
    // owning it.
    pushFrameStack(frame_43c1c6d969ff6899544b1cfb272ea433);
    assert(Py_REFCNT(frame_43c1c6d969ff6899544b1cfb272ea433) == 2);

    // Framed code:
    // Tried code:
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_import_name_from_1;
        CHECK_OBJECT(tmp_import_from_1__module);
        tmp_import_name_from_1 = tmp_import_from_1__module;
        tmp_assign_source_4 = IMPORT_NAME(tmp_import_name_from_1, const_str_plain_absolute_import);
        if (tmp_assign_source_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 5;

            goto try_except_handler_1;
        }
        UPDATE_STRING_DICT1(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_absolute_import, tmp_assign_source_4);
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_import_name_from_2;
        CHECK_OBJECT(tmp_import_from_1__module);
        tmp_import_name_from_2 = tmp_import_from_1__module;
        tmp_assign_source_5 = IMPORT_NAME(tmp_import_name_from_2, const_str_plain_division);
        if (tmp_assign_source_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 5;

            goto try_except_handler_1;
        }
        UPDATE_STRING_DICT1(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_division, tmp_assign_source_5);
    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_import_name_from_3;
        CHECK_OBJECT(tmp_import_from_1__module);
        tmp_import_name_from_3 = tmp_import_from_1__module;
        tmp_assign_source_6 = IMPORT_NAME(tmp_import_name_from_3, const_str_plain_print_function);
        if (tmp_assign_source_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 5;

            goto try_except_handler_1;
        }
        UPDATE_STRING_DICT1(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_print_function, tmp_assign_source_6);
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)tmp_import_from_1__module);
    Py_DECREF(tmp_import_from_1__module);
    tmp_import_from_1__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    CHECK_OBJECT((PyObject *)tmp_import_from_1__module);
    Py_DECREF(tmp_import_from_1__module);
    tmp_import_from_1__module = NULL;

    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_name_name_1;
        PyObject *tmp_globals_name_1;
        PyObject *tmp_locals_name_1;
        PyObject *tmp_fromlist_name_1;
        PyObject *tmp_level_name_1;
        tmp_name_name_1 = const_str_plain_abc;
        tmp_globals_name_1 = (PyObject *)moduledict_cryptography$x509$extensions;
        tmp_locals_name_1 = Py_None;
        tmp_fromlist_name_1 = Py_None;
        tmp_level_name_1 = const_int_0;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 7;
        tmp_assign_source_7 = IMPORT_MODULE5(tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1, tmp_level_name_1);
        if (tmp_assign_source_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 7;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_abc, tmp_assign_source_7);
    }
    {
        PyObject *tmp_assign_source_8;
        PyObject *tmp_name_name_2;
        PyObject *tmp_globals_name_2;
        PyObject *tmp_locals_name_2;
        PyObject *tmp_fromlist_name_2;
        PyObject *tmp_level_name_2;
        tmp_name_name_2 = const_str_plain_datetime;
        tmp_globals_name_2 = (PyObject *)moduledict_cryptography$x509$extensions;
        tmp_locals_name_2 = Py_None;
        tmp_fromlist_name_2 = Py_None;
        tmp_level_name_2 = const_int_0;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 8;
        tmp_assign_source_8 = IMPORT_MODULE5(tmp_name_name_2, tmp_globals_name_2, tmp_locals_name_2, tmp_fromlist_name_2, tmp_level_name_2);
        assert(!(tmp_assign_source_8 == NULL));
        UPDATE_STRING_DICT1(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_datetime, tmp_assign_source_8);
    }
    {
        PyObject *tmp_assign_source_9;
        PyObject *tmp_name_name_3;
        PyObject *tmp_globals_name_3;
        PyObject *tmp_locals_name_3;
        PyObject *tmp_fromlist_name_3;
        PyObject *tmp_level_name_3;
        tmp_name_name_3 = const_str_plain_hashlib;
        tmp_globals_name_3 = (PyObject *)moduledict_cryptography$x509$extensions;
        tmp_locals_name_3 = Py_None;
        tmp_fromlist_name_3 = Py_None;
        tmp_level_name_3 = const_int_0;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 9;
        tmp_assign_source_9 = IMPORT_MODULE5(tmp_name_name_3, tmp_globals_name_3, tmp_locals_name_3, tmp_fromlist_name_3, tmp_level_name_3);
        if (tmp_assign_source_9 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 9;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_hashlib, tmp_assign_source_9);
    }
    {
        PyObject *tmp_assign_source_10;
        PyObject *tmp_name_name_4;
        PyObject *tmp_globals_name_4;
        PyObject *tmp_locals_name_4;
        PyObject *tmp_fromlist_name_4;
        PyObject *tmp_level_name_4;
        tmp_name_name_4 = const_str_plain_ipaddress;
        tmp_globals_name_4 = (PyObject *)moduledict_cryptography$x509$extensions;
        tmp_locals_name_4 = Py_None;
        tmp_fromlist_name_4 = Py_None;
        tmp_level_name_4 = const_int_0;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 10;
        tmp_assign_source_10 = IMPORT_MODULE5(tmp_name_name_4, tmp_globals_name_4, tmp_locals_name_4, tmp_fromlist_name_4, tmp_level_name_4);
        if (tmp_assign_source_10 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 10;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ipaddress, tmp_assign_source_10);
    }
    {
        PyObject *tmp_assign_source_11;
        PyObject *tmp_import_name_from_4;
        PyObject *tmp_name_name_5;
        PyObject *tmp_globals_name_5;
        PyObject *tmp_locals_name_5;
        PyObject *tmp_fromlist_name_5;
        PyObject *tmp_level_name_5;
        tmp_name_name_5 = const_str_plain_enum;
        tmp_globals_name_5 = (PyObject *)moduledict_cryptography$x509$extensions;
        tmp_locals_name_5 = Py_None;
        tmp_fromlist_name_5 = const_tuple_str_plain_Enum_tuple;
        tmp_level_name_5 = const_int_0;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 11;
        tmp_import_name_from_4 = IMPORT_MODULE5(tmp_name_name_5, tmp_globals_name_5, tmp_locals_name_5, tmp_fromlist_name_5, tmp_level_name_5);
        if (tmp_import_name_from_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 11;

            goto frame_exception_exit_1;
        }
        tmp_assign_source_11 = IMPORT_NAME(tmp_import_name_from_4, const_str_plain_Enum);
        Py_DECREF(tmp_import_name_from_4);
        if (tmp_assign_source_11 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 11;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_Enum, tmp_assign_source_11);
    }
    {
        PyObject *tmp_assign_source_12;
        PyObject *tmp_import_name_from_5;
        PyObject *tmp_name_name_6;
        PyObject *tmp_globals_name_6;
        PyObject *tmp_locals_name_6;
        PyObject *tmp_fromlist_name_6;
        PyObject *tmp_level_name_6;
        tmp_name_name_6 = const_str_digest_b76ace6e0c7782d7cadb4695052eca5a;
        tmp_globals_name_6 = (PyObject *)moduledict_cryptography$x509$extensions;
        tmp_locals_name_6 = Py_None;
        tmp_fromlist_name_6 = const_tuple_str_plain_PublicKeyInfo_tuple;
        tmp_level_name_6 = const_int_0;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 13;
        tmp_import_name_from_5 = IMPORT_MODULE5(tmp_name_name_6, tmp_globals_name_6, tmp_locals_name_6, tmp_fromlist_name_6, tmp_level_name_6);
        if (tmp_import_name_from_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 13;

            goto frame_exception_exit_1;
        }
        tmp_assign_source_12 = IMPORT_NAME(tmp_import_name_from_5, const_str_plain_PublicKeyInfo);
        Py_DECREF(tmp_import_name_from_5);
        if (tmp_assign_source_12 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 13;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_PublicKeyInfo, tmp_assign_source_12);
    }
    {
        PyObject *tmp_assign_source_13;
        PyObject *tmp_name_name_7;
        PyObject *tmp_globals_name_7;
        PyObject *tmp_locals_name_7;
        PyObject *tmp_fromlist_name_7;
        PyObject *tmp_level_name_7;
        tmp_name_name_7 = const_str_plain_six;
        tmp_globals_name_7 = (PyObject *)moduledict_cryptography$x509$extensions;
        tmp_locals_name_7 = Py_None;
        tmp_fromlist_name_7 = Py_None;
        tmp_level_name_7 = const_int_0;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 15;
        tmp_assign_source_13 = IMPORT_MODULE5(tmp_name_name_7, tmp_globals_name_7, tmp_locals_name_7, tmp_fromlist_name_7, tmp_level_name_7);
        if (tmp_assign_source_13 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 15;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_six, tmp_assign_source_13);
    }
    {
        PyObject *tmp_assign_source_14;
        PyObject *tmp_import_name_from_6;
        PyObject *tmp_name_name_8;
        PyObject *tmp_globals_name_8;
        PyObject *tmp_locals_name_8;
        PyObject *tmp_fromlist_name_8;
        PyObject *tmp_level_name_8;
        tmp_name_name_8 = const_str_plain_cryptography;
        tmp_globals_name_8 = (PyObject *)moduledict_cryptography$x509$extensions;
        tmp_locals_name_8 = Py_None;
        tmp_fromlist_name_8 = const_tuple_str_plain_utils_tuple;
        tmp_level_name_8 = const_int_0;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 17;
        tmp_import_name_from_6 = IMPORT_MODULE5(tmp_name_name_8, tmp_globals_name_8, tmp_locals_name_8, tmp_fromlist_name_8, tmp_level_name_8);
        if (tmp_import_name_from_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 17;

            goto frame_exception_exit_1;
        }
        tmp_assign_source_14 = IMPORT_NAME(tmp_import_name_from_6, const_str_plain_utils);
        Py_DECREF(tmp_import_name_from_6);
        if (tmp_assign_source_14 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 17;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils, tmp_assign_source_14);
    }
    {
        PyObject *tmp_assign_source_15;
        PyObject *tmp_name_name_9;
        PyObject *tmp_globals_name_9;
        PyObject *tmp_locals_name_9;
        PyObject *tmp_fromlist_name_9;
        PyObject *tmp_level_name_9;
        tmp_name_name_9 = const_str_digest_9db3cdd3cd765463b4eec6754eb8e087;
        tmp_globals_name_9 = (PyObject *)moduledict_cryptography$x509$extensions;
        tmp_locals_name_9 = Py_None;
        tmp_fromlist_name_9 = const_tuple_str_plain_constant_time_str_plain_serialization_tuple;
        tmp_level_name_9 = const_int_0;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 18;
        tmp_assign_source_15 = IMPORT_MODULE5(tmp_name_name_9, tmp_globals_name_9, tmp_locals_name_9, tmp_fromlist_name_9, tmp_level_name_9);
        if (tmp_assign_source_15 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 18;

            goto frame_exception_exit_1;
        }
        assert(tmp_import_from_2__module == NULL);
        tmp_import_from_2__module = tmp_assign_source_15;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_16;
        PyObject *tmp_import_name_from_7;
        CHECK_OBJECT(tmp_import_from_2__module);
        tmp_import_name_from_7 = tmp_import_from_2__module;
        tmp_assign_source_16 = IMPORT_NAME(tmp_import_name_from_7, const_str_plain_constant_time);
        if (tmp_assign_source_16 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 18;

            goto try_except_handler_2;
        }
        UPDATE_STRING_DICT1(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_constant_time, tmp_assign_source_16);
    }
    {
        PyObject *tmp_assign_source_17;
        PyObject *tmp_import_name_from_8;
        CHECK_OBJECT(tmp_import_from_2__module);
        tmp_import_name_from_8 = tmp_import_from_2__module;
        tmp_assign_source_17 = IMPORT_NAME(tmp_import_name_from_8, const_str_plain_serialization);
        if (tmp_assign_source_17 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 18;

            goto try_except_handler_2;
        }
        UPDATE_STRING_DICT1(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_serialization, tmp_assign_source_17);
    }
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)tmp_import_from_2__module);
    Py_DECREF(tmp_import_from_2__module);
    tmp_import_from_2__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    CHECK_OBJECT((PyObject *)tmp_import_from_2__module);
    Py_DECREF(tmp_import_from_2__module);
    tmp_import_from_2__module = NULL;

    {
        PyObject *tmp_assign_source_18;
        PyObject *tmp_import_name_from_9;
        PyObject *tmp_name_name_10;
        PyObject *tmp_globals_name_10;
        PyObject *tmp_locals_name_10;
        PyObject *tmp_fromlist_name_10;
        PyObject *tmp_level_name_10;
        tmp_name_name_10 = const_str_digest_bd71b5d9106eb6b876b65e57bcd30837;
        tmp_globals_name_10 = (PyObject *)moduledict_cryptography$x509$extensions;
        tmp_locals_name_10 = Py_None;
        tmp_fromlist_name_10 = const_tuple_str_plain_EllipticCurvePublicKey_tuple;
        tmp_level_name_10 = const_int_0;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 19;
        tmp_import_name_from_9 = IMPORT_MODULE5(tmp_name_name_10, tmp_globals_name_10, tmp_locals_name_10, tmp_fromlist_name_10, tmp_level_name_10);
        if (tmp_import_name_from_9 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 19;

            goto frame_exception_exit_1;
        }
        tmp_assign_source_18 = IMPORT_NAME(tmp_import_name_from_9, const_str_plain_EllipticCurvePublicKey);
        Py_DECREF(tmp_import_name_from_9);
        if (tmp_assign_source_18 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 19;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_EllipticCurvePublicKey, tmp_assign_source_18);
    }
    {
        PyObject *tmp_assign_source_19;
        PyObject *tmp_import_name_from_10;
        PyObject *tmp_name_name_11;
        PyObject *tmp_globals_name_11;
        PyObject *tmp_locals_name_11;
        PyObject *tmp_fromlist_name_11;
        PyObject *tmp_level_name_11;
        tmp_name_name_11 = const_str_digest_97cd6fd5c8579a7068d86fbfd40e2f84;
        tmp_globals_name_11 = (PyObject *)moduledict_cryptography$x509$extensions;
        tmp_locals_name_11 = Py_None;
        tmp_fromlist_name_11 = const_tuple_str_plain_RSAPublicKey_tuple;
        tmp_level_name_11 = const_int_0;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 20;
        tmp_import_name_from_10 = IMPORT_MODULE5(tmp_name_name_11, tmp_globals_name_11, tmp_locals_name_11, tmp_fromlist_name_11, tmp_level_name_11);
        if (tmp_import_name_from_10 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 20;

            goto frame_exception_exit_1;
        }
        tmp_assign_source_19 = IMPORT_NAME(tmp_import_name_from_10, const_str_plain_RSAPublicKey);
        Py_DECREF(tmp_import_name_from_10);
        if (tmp_assign_source_19 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 20;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_RSAPublicKey, tmp_assign_source_19);
    }
    {
        PyObject *tmp_assign_source_20;
        PyObject *tmp_import_name_from_11;
        PyObject *tmp_name_name_12;
        PyObject *tmp_globals_name_12;
        PyObject *tmp_locals_name_12;
        PyObject *tmp_fromlist_name_12;
        PyObject *tmp_level_name_12;
        tmp_name_name_12 = const_str_digest_9c4dcd45c628f51f60b0e74617698ea7;
        tmp_globals_name_12 = (PyObject *)moduledict_cryptography$x509$extensions;
        tmp_locals_name_12 = Py_None;
        tmp_fromlist_name_12 = const_tuple_str_plain_SignedCertificateTimestamp_tuple;
        tmp_level_name_12 = const_int_0;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 21;
        tmp_import_name_from_11 = IMPORT_MODULE5(tmp_name_name_12, tmp_globals_name_12, tmp_locals_name_12, tmp_fromlist_name_12, tmp_level_name_12);
        if (tmp_import_name_from_11 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 21;

            goto frame_exception_exit_1;
        }
        tmp_assign_source_20 = IMPORT_NAME(tmp_import_name_from_11, const_str_plain_SignedCertificateTimestamp);
        Py_DECREF(tmp_import_name_from_11);
        if (tmp_assign_source_20 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 21;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_SignedCertificateTimestamp, tmp_assign_source_20);
    }
    {
        PyObject *tmp_assign_source_21;
        PyObject *tmp_name_name_13;
        PyObject *tmp_globals_name_13;
        PyObject *tmp_locals_name_13;
        PyObject *tmp_fromlist_name_13;
        PyObject *tmp_level_name_13;
        tmp_name_name_13 = const_str_digest_becb7ddc5eba88bda421a9fc23a1539c;
        tmp_globals_name_13 = (PyObject *)moduledict_cryptography$x509$extensions;
        tmp_locals_name_13 = Py_None;
        tmp_fromlist_name_13 = const_tuple_b58c59c90f8b7ff71dbfd006f561c9fe_tuple;
        tmp_level_name_13 = const_int_0;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 24;
        tmp_assign_source_21 = IMPORT_MODULE5(tmp_name_name_13, tmp_globals_name_13, tmp_locals_name_13, tmp_fromlist_name_13, tmp_level_name_13);
        if (tmp_assign_source_21 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 24;

            goto frame_exception_exit_1;
        }
        assert(tmp_import_from_3__module == NULL);
        tmp_import_from_3__module = tmp_assign_source_21;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_22;
        PyObject *tmp_import_name_from_12;
        CHECK_OBJECT(tmp_import_from_3__module);
        tmp_import_name_from_12 = tmp_import_from_3__module;
        tmp_assign_source_22 = IMPORT_NAME(tmp_import_name_from_12, const_str_plain_GeneralName);
        if (tmp_assign_source_22 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 24;

            goto try_except_handler_3;
        }
        UPDATE_STRING_DICT1(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_GeneralName, tmp_assign_source_22);
    }
    {
        PyObject *tmp_assign_source_23;
        PyObject *tmp_import_name_from_13;
        CHECK_OBJECT(tmp_import_from_3__module);
        tmp_import_name_from_13 = tmp_import_from_3__module;
        tmp_assign_source_23 = IMPORT_NAME(tmp_import_name_from_13, const_str_plain_IPAddress);
        if (tmp_assign_source_23 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 24;

            goto try_except_handler_3;
        }
        UPDATE_STRING_DICT1(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_IPAddress, tmp_assign_source_23);
    }
    {
        PyObject *tmp_assign_source_24;
        PyObject *tmp_import_name_from_14;
        CHECK_OBJECT(tmp_import_from_3__module);
        tmp_import_name_from_14 = tmp_import_from_3__module;
        tmp_assign_source_24 = IMPORT_NAME(tmp_import_name_from_14, const_str_plain_OtherName);
        if (tmp_assign_source_24 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 24;

            goto try_except_handler_3;
        }
        UPDATE_STRING_DICT1(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_OtherName, tmp_assign_source_24);
    }
    goto try_end_3;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)tmp_import_from_3__module);
    Py_DECREF(tmp_import_from_3__module);
    tmp_import_from_3__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;
    CHECK_OBJECT((PyObject *)tmp_import_from_3__module);
    Py_DECREF(tmp_import_from_3__module);
    tmp_import_from_3__module = NULL;

    {
        PyObject *tmp_assign_source_25;
        PyObject *tmp_import_name_from_15;
        PyObject *tmp_name_name_14;
        PyObject *tmp_globals_name_14;
        PyObject *tmp_locals_name_14;
        PyObject *tmp_fromlist_name_14;
        PyObject *tmp_level_name_14;
        tmp_name_name_14 = const_str_digest_957c81bc7a15c28c0c453fa3270dbc10;
        tmp_globals_name_14 = (PyObject *)moduledict_cryptography$x509$extensions;
        tmp_locals_name_14 = Py_None;
        tmp_fromlist_name_14 = const_tuple_str_plain_RelativeDistinguishedName_tuple;
        tmp_level_name_14 = const_int_0;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 25;
        tmp_import_name_from_15 = IMPORT_MODULE5(tmp_name_name_14, tmp_globals_name_14, tmp_locals_name_14, tmp_fromlist_name_14, tmp_level_name_14);
        if (tmp_import_name_from_15 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 25;

            goto frame_exception_exit_1;
        }
        tmp_assign_source_25 = IMPORT_NAME(tmp_import_name_from_15, const_str_plain_RelativeDistinguishedName);
        Py_DECREF(tmp_import_name_from_15);
        if (tmp_assign_source_25 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 25;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_RelativeDistinguishedName, tmp_assign_source_25);
    }
    {
        PyObject *tmp_assign_source_26;
        PyObject *tmp_name_name_15;
        PyObject *tmp_globals_name_15;
        PyObject *tmp_locals_name_15;
        PyObject *tmp_fromlist_name_15;
        PyObject *tmp_level_name_15;
        tmp_name_name_15 = const_str_digest_0dcb6991fe0fe1dc113b1f3e65627e35;
        tmp_globals_name_15 = (PyObject *)moduledict_cryptography$x509$extensions;
        tmp_locals_name_15 = Py_None;
        tmp_fromlist_name_15 = const_tuple_2a50e9eb562974724a6432490d012463_tuple;
        tmp_level_name_15 = const_int_0;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 26;
        tmp_assign_source_26 = IMPORT_MODULE5(tmp_name_name_15, tmp_globals_name_15, tmp_locals_name_15, tmp_fromlist_name_15, tmp_level_name_15);
        if (tmp_assign_source_26 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 26;

            goto frame_exception_exit_1;
        }
        assert(tmp_import_from_4__module == NULL);
        tmp_import_from_4__module = tmp_assign_source_26;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_27;
        PyObject *tmp_import_name_from_16;
        CHECK_OBJECT(tmp_import_from_4__module);
        tmp_import_name_from_16 = tmp_import_from_4__module;
        tmp_assign_source_27 = IMPORT_NAME(tmp_import_name_from_16, const_str_plain_CRLEntryExtensionOID);
        if (tmp_assign_source_27 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 26;

            goto try_except_handler_4;
        }
        UPDATE_STRING_DICT1(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_CRLEntryExtensionOID, tmp_assign_source_27);
    }
    {
        PyObject *tmp_assign_source_28;
        PyObject *tmp_import_name_from_17;
        CHECK_OBJECT(tmp_import_from_4__module);
        tmp_import_name_from_17 = tmp_import_from_4__module;
        tmp_assign_source_28 = IMPORT_NAME(tmp_import_name_from_17, const_str_plain_ExtensionOID);
        if (tmp_assign_source_28 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 26;

            goto try_except_handler_4;
        }
        UPDATE_STRING_DICT1(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID, tmp_assign_source_28);
    }
    {
        PyObject *tmp_assign_source_29;
        PyObject *tmp_import_name_from_18;
        CHECK_OBJECT(tmp_import_from_4__module);
        tmp_import_name_from_18 = tmp_import_from_4__module;
        tmp_assign_source_29 = IMPORT_NAME(tmp_import_name_from_18, const_str_plain_OCSPExtensionOID);
        if (tmp_assign_source_29 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 26;

            goto try_except_handler_4;
        }
        UPDATE_STRING_DICT1(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_OCSPExtensionOID, tmp_assign_source_29);
    }
    {
        PyObject *tmp_assign_source_30;
        PyObject *tmp_import_name_from_19;
        CHECK_OBJECT(tmp_import_from_4__module);
        tmp_import_name_from_19 = tmp_import_from_4__module;
        tmp_assign_source_30 = IMPORT_NAME(tmp_import_name_from_19, const_str_plain_ObjectIdentifier);
        if (tmp_assign_source_30 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 26;

            goto try_except_handler_4;
        }
        UPDATE_STRING_DICT1(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ObjectIdentifier, tmp_assign_source_30);
    }
    goto try_end_4;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)tmp_import_from_4__module);
    Py_DECREF(tmp_import_from_4__module);
    tmp_import_from_4__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto frame_exception_exit_1;
    // End of try:
    try_end_4:;
    CHECK_OBJECT((PyObject *)tmp_import_from_4__module);
    Py_DECREF(tmp_import_from_4__module);
    tmp_import_from_4__module = NULL;

    {
        PyObject *tmp_assign_source_31;
        tmp_assign_source_31 = MAKE_FUNCTION_cryptography$x509$extensions$$$function_1__key_identifier_from_public_key();



        UPDATE_STRING_DICT1(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain__key_identifier_from_public_key, tmp_assign_source_31);
    }
    {
        PyObject *tmp_assign_source_32;
        {
            PyObject *tmp_assign_source_33;
            tmp_assign_source_33 = MAKE_FUNCTION_cryptography$x509$extensions$$$function_2___init__();



            assert(tmp_locals_cryptography$x509$extensions_54_key___init__ == NULL);
            tmp_locals_cryptography$x509$extensions_54_key___init__ = tmp_assign_source_33;
        }
        // Tried code:
        {
            PyObject *tmp_dict_key_1;
            PyObject *tmp_dict_value_1;
            PyObject *tmp_dict_key_2;
            PyObject *tmp_dict_value_2;
            tmp_dict_value_1 = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
            tmp_dict_key_1 = const_str_plain___module__;
            tmp_assign_source_32 = _PyDict_NewPresized( 2 );
            tmp_res = PyDict_SetItem(tmp_assign_source_32, tmp_dict_key_1, tmp_dict_value_1);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_cryptography$x509$extensions_54_key___init__);
            tmp_dict_value_2 = tmp_locals_cryptography$x509$extensions_54_key___init__;
            tmp_dict_key_2 = const_str_plain___init__;
            tmp_res = PyDict_SetItem(tmp_assign_source_32, tmp_dict_key_2, tmp_dict_value_2);
            assert(!(tmp_res != 0));
            goto try_return_handler_5;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Return handler code:
        try_return_handler_5:;
        CHECK_OBJECT((PyObject *)tmp_locals_cryptography$x509$extensions_54_key___init__);
        Py_DECREF(tmp_locals_cryptography$x509$extensions_54_key___init__);
        tmp_locals_cryptography$x509$extensions_54_key___init__ = NULL;

        goto outline_result_1;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        outline_result_1:;
        assert(tmp_class_creation_1__class_dict == NULL);
        tmp_class_creation_1__class_dict = tmp_assign_source_32;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_34;
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_key_name_1;
        PyObject *tmp_dict_name_1;
        PyObject *tmp_dict_name_2;
        PyObject *tmp_key_name_2;
        tmp_key_name_1 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_1__class_dict);
        tmp_dict_name_1 = tmp_class_creation_1__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_1, tmp_key_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 54;

            goto try_except_handler_6;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_1;
        } else {
            goto condexpr_false_1;
        }
        condexpr_true_1:;
        CHECK_OBJECT(tmp_class_creation_1__class_dict);
        tmp_dict_name_2 = tmp_class_creation_1__class_dict;
        tmp_key_name_2 = const_str_plain___metaclass__;
        tmp_assign_source_34 = DICT_GET_ITEM(tmp_dict_name_2, tmp_key_name_2);
        if (tmp_assign_source_34 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 54;

            goto try_except_handler_6;
        }
        goto condexpr_end_1;
        condexpr_false_1:;
        tmp_assign_source_34 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_34);
        condexpr_end_1:;
        assert(tmp_class_creation_1__metaclass == NULL);
        tmp_class_creation_1__metaclass = tmp_assign_source_34;
    }
    {
        PyObject *tmp_assign_source_35;
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        CHECK_OBJECT(tmp_class_creation_1__metaclass);
        tmp_called_name_1 = tmp_class_creation_1__metaclass;
        tmp_args_element_name_1 = const_str_plain_DuplicateExtension;
        tmp_args_element_name_2 = const_tuple_type_Exception_tuple;
        CHECK_OBJECT(tmp_class_creation_1__class_dict);
        tmp_args_element_name_3 = tmp_class_creation_1__class_dict;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 54;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_assign_source_35 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_1, call_args);
        }

        if (tmp_assign_source_35 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 54;

            goto try_except_handler_6;
        }
        assert(tmp_class_creation_1__class == NULL);
        tmp_class_creation_1__class = tmp_assign_source_35;
    }
    goto try_end_5;
    // Exception handler code:
    try_except_handler_6:;
    exception_keeper_type_5 = exception_type;
    exception_keeper_value_5 = exception_value;
    exception_keeper_tb_5 = exception_tb;
    exception_keeper_lineno_5 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)tmp_class_creation_1__class_dict);
    Py_DECREF(tmp_class_creation_1__class_dict);
    tmp_class_creation_1__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_1__metaclass);
    tmp_class_creation_1__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_5;
    exception_value = exception_keeper_value_5;
    exception_tb = exception_keeper_tb_5;
    exception_lineno = exception_keeper_lineno_5;

    goto frame_exception_exit_1;
    // End of try:
    try_end_5:;
    {
        PyObject *tmp_assign_source_36;
        CHECK_OBJECT(tmp_class_creation_1__class);
        tmp_assign_source_36 = tmp_class_creation_1__class;
        UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_DuplicateExtension, tmp_assign_source_36);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_1__class);
    Py_DECREF(tmp_class_creation_1__class);
    tmp_class_creation_1__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_1__class_dict);
    Py_DECREF(tmp_class_creation_1__class_dict);
    tmp_class_creation_1__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_1__metaclass);
    Py_DECREF(tmp_class_creation_1__metaclass);
    tmp_class_creation_1__metaclass = NULL;

    {
        PyObject *tmp_assign_source_37;
        {
            PyObject *tmp_assign_source_38;
            tmp_assign_source_38 = MAKE_FUNCTION_cryptography$x509$extensions$$$function_3___init__();



            assert(tmp_locals_cryptography$x509$extensions_60_key___init__ == NULL);
            tmp_locals_cryptography$x509$extensions_60_key___init__ = tmp_assign_source_38;
        }
        // Tried code:
        {
            PyObject *tmp_dict_key_3;
            PyObject *tmp_dict_value_3;
            PyObject *tmp_dict_key_4;
            PyObject *tmp_dict_value_4;
            tmp_dict_value_3 = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
            tmp_dict_key_3 = const_str_plain___module__;
            tmp_assign_source_37 = _PyDict_NewPresized( 2 );
            tmp_res = PyDict_SetItem(tmp_assign_source_37, tmp_dict_key_3, tmp_dict_value_3);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_cryptography$x509$extensions_60_key___init__);
            tmp_dict_value_4 = tmp_locals_cryptography$x509$extensions_60_key___init__;
            tmp_dict_key_4 = const_str_plain___init__;
            tmp_res = PyDict_SetItem(tmp_assign_source_37, tmp_dict_key_4, tmp_dict_value_4);
            assert(!(tmp_res != 0));
            goto try_return_handler_7;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Return handler code:
        try_return_handler_7:;
        CHECK_OBJECT((PyObject *)tmp_locals_cryptography$x509$extensions_60_key___init__);
        Py_DECREF(tmp_locals_cryptography$x509$extensions_60_key___init__);
        tmp_locals_cryptography$x509$extensions_60_key___init__ = NULL;

        goto outline_result_2;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        outline_result_2:;
        assert(tmp_class_creation_2__class_dict == NULL);
        tmp_class_creation_2__class_dict = tmp_assign_source_37;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_39;
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_key_name_3;
        PyObject *tmp_dict_name_3;
        PyObject *tmp_dict_name_4;
        PyObject *tmp_key_name_4;
        tmp_key_name_3 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_2__class_dict);
        tmp_dict_name_3 = tmp_class_creation_2__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_3, tmp_key_name_3);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 60;

            goto try_except_handler_8;
        }
        tmp_condition_result_2 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_2;
        } else {
            goto condexpr_false_2;
        }
        condexpr_true_2:;
        CHECK_OBJECT(tmp_class_creation_2__class_dict);
        tmp_dict_name_4 = tmp_class_creation_2__class_dict;
        tmp_key_name_4 = const_str_plain___metaclass__;
        tmp_assign_source_39 = DICT_GET_ITEM(tmp_dict_name_4, tmp_key_name_4);
        if (tmp_assign_source_39 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 60;

            goto try_except_handler_8;
        }
        goto condexpr_end_2;
        condexpr_false_2:;
        tmp_assign_source_39 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_39);
        condexpr_end_2:;
        assert(tmp_class_creation_2__metaclass == NULL);
        tmp_class_creation_2__metaclass = tmp_assign_source_39;
    }
    {
        PyObject *tmp_assign_source_40;
        PyObject *tmp_called_name_2;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_args_element_name_6;
        CHECK_OBJECT(tmp_class_creation_2__metaclass);
        tmp_called_name_2 = tmp_class_creation_2__metaclass;
        tmp_args_element_name_4 = const_str_plain_ExtensionNotFound;
        tmp_args_element_name_5 = const_tuple_type_Exception_tuple;
        CHECK_OBJECT(tmp_class_creation_2__class_dict);
        tmp_args_element_name_6 = tmp_class_creation_2__class_dict;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 60;
        {
            PyObject *call_args[] = {tmp_args_element_name_4, tmp_args_element_name_5, tmp_args_element_name_6};
            tmp_assign_source_40 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_2, call_args);
        }

        if (tmp_assign_source_40 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 60;

            goto try_except_handler_8;
        }
        assert(tmp_class_creation_2__class == NULL);
        tmp_class_creation_2__class = tmp_assign_source_40;
    }
    goto try_end_6;
    // Exception handler code:
    try_except_handler_8:;
    exception_keeper_type_6 = exception_type;
    exception_keeper_value_6 = exception_value;
    exception_keeper_tb_6 = exception_tb;
    exception_keeper_lineno_6 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)tmp_class_creation_2__class_dict);
    Py_DECREF(tmp_class_creation_2__class_dict);
    tmp_class_creation_2__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_2__metaclass);
    tmp_class_creation_2__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_6;
    exception_value = exception_keeper_value_6;
    exception_tb = exception_keeper_tb_6;
    exception_lineno = exception_keeper_lineno_6;

    goto frame_exception_exit_1;
    // End of try:
    try_end_6:;
    {
        PyObject *tmp_assign_source_41;
        CHECK_OBJECT(tmp_class_creation_2__class);
        tmp_assign_source_41 = tmp_class_creation_2__class;
        UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionNotFound, tmp_assign_source_41);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_2__class);
    Py_DECREF(tmp_class_creation_2__class);
    tmp_class_creation_2__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_2__class_dict);
    Py_DECREF(tmp_class_creation_2__class_dict);
    tmp_class_creation_2__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_2__metaclass);
    Py_DECREF(tmp_class_creation_2__metaclass);
    tmp_class_creation_2__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_42;
        {
            PyObject *tmp_set_locals_1;
            tmp_set_locals_1 = PyDict_New();
            locals_cryptography$x509$extensions_67 = tmp_set_locals_1;
        }
        tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_67, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_8e8c1d14cc1f43c40fb686c3c332d970_2, codeobj_8e8c1d14cc1f43c40fb686c3c332d970, module_cryptography$x509$extensions, 0);
        frame_8e8c1d14cc1f43c40fb686c3c332d970_2 = cache_frame_8e8c1d14cc1f43c40fb686c3c332d970_2;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_8e8c1d14cc1f43c40fb686c3c332d970_2);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_8e8c1d14cc1f43c40fb686c3c332d970_2) == 2); // Frame stack

        // Framed code:
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_mvar_value_1;
            PyObject *tmp_args_element_name_7;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_abc);

            if (unlikely(tmp_mvar_value_1 == NULL)) {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_abc);
            }

            if (tmp_mvar_value_1 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 18464 ], 25, 0);
                exception_tb = NULL;

                exception_lineno = 68;

                goto frame_exception_exit_2;
            }

            tmp_called_instance_1 = tmp_mvar_value_1;
            tmp_args_element_name_7 = MAKE_FUNCTION_cryptography$x509$extensions$$$function_4_oid();



            frame_8e8c1d14cc1f43c40fb686c3c332d970_2->m_frame.f_lineno = 68;
            {
                PyObject *call_args[] = {tmp_args_element_name_7};
                tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_abstractproperty, call_args);
            }

            Py_DECREF(tmp_args_element_name_7);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 68;

                goto frame_exception_exit_2;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_67, const_str_plain_oid, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 68;

                goto frame_exception_exit_2;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_8e8c1d14cc1f43c40fb686c3c332d970_2);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_1;

        frame_exception_exit_2:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_8e8c1d14cc1f43c40fb686c3c332d970_2);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_8e8c1d14cc1f43c40fb686c3c332d970_2, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_8e8c1d14cc1f43c40fb686c3c332d970_2->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_8e8c1d14cc1f43c40fb686c3c332d970_2, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_8e8c1d14cc1f43c40fb686c3c332d970_2,
            type_description_2
        );


        // Release cached frame.
        if (frame_8e8c1d14cc1f43c40fb686c3c332d970_2 == cache_frame_8e8c1d14cc1f43c40fb686c3c332d970_2) {
            Py_DECREF(frame_8e8c1d14cc1f43c40fb686c3c332d970_2);
        }
        cache_frame_8e8c1d14cc1f43c40fb686c3c332d970_2 = NULL;

        assertFrameObject(frame_8e8c1d14cc1f43c40fb686c3c332d970_2);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_1;

        frame_no_exception_1:;
        goto skip_nested_handling_1;
        nested_frame_exit_1:;

        goto try_except_handler_10;
        skip_nested_handling_1:;
        tmp_assign_source_42 = locals_cryptography$x509$extensions_67;
        Py_INCREF(tmp_assign_source_42);
        goto try_return_handler_10;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Return handler code:
        try_return_handler_10:;
        Py_DECREF(locals_cryptography$x509$extensions_67);
        locals_cryptography$x509$extensions_67 = NULL;
        goto outline_result_3;
        // Exception handler code:
        try_except_handler_10:;
        exception_keeper_type_7 = exception_type;
        exception_keeper_value_7 = exception_value;
        exception_keeper_tb_7 = exception_tb;
        exception_keeper_lineno_7 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_cryptography$x509$extensions_67);
        locals_cryptography$x509$extensions_67 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_7;
        exception_value = exception_keeper_value_7;
        exception_tb = exception_keeper_tb_7;
        exception_lineno = exception_keeper_lineno_7;

        goto outline_exception_1;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        outline_exception_1:;
        exception_lineno = 67;
        goto try_except_handler_9;
        outline_result_3:;
        assert(tmp_class_creation_3__class_dict == NULL);
        tmp_class_creation_3__class_dict = tmp_assign_source_42;
    }
    {
        PyObject *tmp_assign_source_43;
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_key_name_5;
        PyObject *tmp_dict_name_5;
        PyObject *tmp_dict_name_6;
        PyObject *tmp_key_name_6;
        tmp_key_name_5 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_3__class_dict);
        tmp_dict_name_5 = tmp_class_creation_3__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_5, tmp_key_name_5);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 67;

            goto try_except_handler_9;
        }
        tmp_condition_result_3 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_3;
        } else {
            goto condexpr_false_3;
        }
        condexpr_true_3:;
        CHECK_OBJECT(tmp_class_creation_3__class_dict);
        tmp_dict_name_6 = tmp_class_creation_3__class_dict;
        tmp_key_name_6 = const_str_plain___metaclass__;
        tmp_assign_source_43 = DICT_GET_ITEM(tmp_dict_name_6, tmp_key_name_6);
        if (tmp_assign_source_43 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 67;

            goto try_except_handler_9;
        }
        goto condexpr_end_3;
        condexpr_false_3:;
        tmp_assign_source_43 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_43);
        condexpr_end_3:;
        assert(tmp_class_creation_3__metaclass == NULL);
        tmp_class_creation_3__metaclass = tmp_assign_source_43;
    }
    {
        PyObject *tmp_assign_source_44;
        PyObject *tmp_called_name_3;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_args_element_name_10;
        CHECK_OBJECT(tmp_class_creation_3__metaclass);
        tmp_called_name_3 = tmp_class_creation_3__metaclass;
        tmp_args_element_name_8 = const_str_plain_ExtensionType;
        tmp_args_element_name_9 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_3__class_dict);
        tmp_args_element_name_10 = tmp_class_creation_3__class_dict;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 67;
        {
            PyObject *call_args[] = {tmp_args_element_name_8, tmp_args_element_name_9, tmp_args_element_name_10};
            tmp_assign_source_44 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_3, call_args);
        }

        if (tmp_assign_source_44 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 67;

            goto try_except_handler_9;
        }
        assert(tmp_class_creation_3__class == NULL);
        tmp_class_creation_3__class = tmp_assign_source_44;
    }
    {
        PyObject *tmp_assign_source_45;
        PyObject *tmp_called_name_4;
        PyObject *tmp_called_name_5;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_11;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_12;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_six);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_six);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 18489 ], 25, 0);
            exception_tb = NULL;

            exception_lineno = 66;

            goto try_except_handler_9;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_add_metaclass);
        if (tmp_called_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 66;

            goto try_except_handler_9;
        }
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_abc);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_abc);
        }

        if (tmp_mvar_value_3 == NULL) {
            Py_DECREF(tmp_called_name_5);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 18464 ], 25, 0);
            exception_tb = NULL;

            exception_lineno = 66;

            goto try_except_handler_9;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_args_element_name_11 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_ABCMeta);
        if (tmp_args_element_name_11 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_5);

            exception_lineno = 66;

            goto try_except_handler_9;
        }
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 66;
        tmp_called_name_4 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_5, tmp_args_element_name_11);
        Py_DECREF(tmp_called_name_5);
        Py_DECREF(tmp_args_element_name_11);
        if (tmp_called_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 66;

            goto try_except_handler_9;
        }
        CHECK_OBJECT(tmp_class_creation_3__class);
        tmp_args_element_name_12 = tmp_class_creation_3__class;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 66;
        tmp_assign_source_45 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_4, tmp_args_element_name_12);
        Py_DECREF(tmp_called_name_4);
        if (tmp_assign_source_45 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 66;

            goto try_except_handler_9;
        }
        {
            PyObject *old = tmp_class_creation_3__class;
            assert(old != NULL);
            tmp_class_creation_3__class = tmp_assign_source_45;
            Py_DECREF(old);
        }

    }
    goto try_end_7;
    // Exception handler code:
    try_except_handler_9:;
    exception_keeper_type_8 = exception_type;
    exception_keeper_value_8 = exception_value;
    exception_keeper_tb_8 = exception_tb;
    exception_keeper_lineno_8 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_3__class);
    tmp_class_creation_3__class = NULL;

    Py_XDECREF(tmp_class_creation_3__class_dict);
    tmp_class_creation_3__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_3__metaclass);
    tmp_class_creation_3__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_8;
    exception_value = exception_keeper_value_8;
    exception_tb = exception_keeper_tb_8;
    exception_lineno = exception_keeper_lineno_8;

    goto frame_exception_exit_1;
    // End of try:
    try_end_7:;
    {
        PyObject *tmp_assign_source_46;
        CHECK_OBJECT(tmp_class_creation_3__class);
        tmp_assign_source_46 = tmp_class_creation_3__class;
        UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType, tmp_assign_source_46);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_3__class);
    Py_DECREF(tmp_class_creation_3__class);
    tmp_class_creation_3__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_3__class_dict);
    Py_DECREF(tmp_class_creation_3__class_dict);
    tmp_class_creation_3__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_3__metaclass);
    Py_DECREF(tmp_class_creation_3__metaclass);
    tmp_class_creation_3__metaclass = NULL;

    {
        PyObject *tmp_assign_source_47;
        {
            PyObject *tmp_assign_source_48;
            tmp_assign_source_48 = MAKE_FUNCTION_cryptography$x509$extensions$$$function_5___init__();



            assert(tmp_locals_cryptography$x509$extensions_75_key___init__ == NULL);
            tmp_locals_cryptography$x509$extensions_75_key___init__ = tmp_assign_source_48;
        }
        {
            PyObject *tmp_assign_source_49;
            tmp_assign_source_49 = MAKE_FUNCTION_cryptography$x509$extensions$$$function_6_get_extension_for_oid();



            assert(tmp_locals_cryptography$x509$extensions_75_key_get_extension_for_oid == NULL);
            tmp_locals_cryptography$x509$extensions_75_key_get_extension_for_oid = tmp_assign_source_49;
        }
        {
            PyObject *tmp_assign_source_50;
            tmp_assign_source_50 = MAKE_FUNCTION_cryptography$x509$extensions$$$function_7_get_extension_for_class();



            assert(tmp_locals_cryptography$x509$extensions_75_key_get_extension_for_class == NULL);
            tmp_locals_cryptography$x509$extensions_75_key_get_extension_for_class = tmp_assign_source_50;
        }
        {
            PyObject *tmp_assign_source_51;
            tmp_assign_source_51 = MAKE_FUNCTION_cryptography$x509$extensions$$$function_8___iter__();



            assert(tmp_locals_cryptography$x509$extensions_75_key___iter__ == NULL);
            tmp_locals_cryptography$x509$extensions_75_key___iter__ = tmp_assign_source_51;
        }
        {
            PyObject *tmp_assign_source_52;
            tmp_assign_source_52 = MAKE_FUNCTION_cryptography$x509$extensions$$$function_9___len__();



            assert(tmp_locals_cryptography$x509$extensions_75_key___len__ == NULL);
            tmp_locals_cryptography$x509$extensions_75_key___len__ = tmp_assign_source_52;
        }
        {
            PyObject *tmp_assign_source_53;
            tmp_assign_source_53 = MAKE_FUNCTION_cryptography$x509$extensions$$$function_10___getitem__();



            assert(tmp_locals_cryptography$x509$extensions_75_key___getitem__ == NULL);
            tmp_locals_cryptography$x509$extensions_75_key___getitem__ = tmp_assign_source_53;
        }
        {
            PyObject *tmp_assign_source_54;
            tmp_assign_source_54 = MAKE_FUNCTION_cryptography$x509$extensions$$$function_11___repr__();



            assert(tmp_locals_cryptography$x509$extensions_75_key___repr__ == NULL);
            tmp_locals_cryptography$x509$extensions_75_key___repr__ = tmp_assign_source_54;
        }
        // Tried code:
        {
            PyObject *tmp_dict_key_5;
            PyObject *tmp_dict_value_5;
            PyObject *tmp_dict_key_6;
            PyObject *tmp_dict_value_6;
            PyObject *tmp_dict_key_7;
            PyObject *tmp_dict_value_7;
            PyObject *tmp_dict_key_8;
            PyObject *tmp_dict_value_8;
            PyObject *tmp_dict_key_9;
            PyObject *tmp_dict_value_9;
            PyObject *tmp_dict_key_10;
            PyObject *tmp_dict_value_10;
            PyObject *tmp_dict_key_11;
            PyObject *tmp_dict_value_11;
            PyObject *tmp_dict_key_12;
            PyObject *tmp_dict_value_12;
            tmp_dict_value_5 = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
            tmp_dict_key_5 = const_str_plain___module__;
            tmp_assign_source_47 = _PyDict_NewPresized( 8 );
            tmp_res = PyDict_SetItem(tmp_assign_source_47, tmp_dict_key_5, tmp_dict_value_5);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_cryptography$x509$extensions_75_key___init__);
            tmp_dict_value_6 = tmp_locals_cryptography$x509$extensions_75_key___init__;
            tmp_dict_key_6 = const_str_plain___init__;
            tmp_res = PyDict_SetItem(tmp_assign_source_47, tmp_dict_key_6, tmp_dict_value_6);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_cryptography$x509$extensions_75_key_get_extension_for_oid);
            tmp_dict_value_7 = tmp_locals_cryptography$x509$extensions_75_key_get_extension_for_oid;
            tmp_dict_key_7 = const_str_plain_get_extension_for_oid;
            tmp_res = PyDict_SetItem(tmp_assign_source_47, tmp_dict_key_7, tmp_dict_value_7);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_cryptography$x509$extensions_75_key_get_extension_for_class);
            tmp_dict_value_8 = tmp_locals_cryptography$x509$extensions_75_key_get_extension_for_class;
            tmp_dict_key_8 = const_str_plain_get_extension_for_class;
            tmp_res = PyDict_SetItem(tmp_assign_source_47, tmp_dict_key_8, tmp_dict_value_8);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_cryptography$x509$extensions_75_key___iter__);
            tmp_dict_value_9 = tmp_locals_cryptography$x509$extensions_75_key___iter__;
            tmp_dict_key_9 = const_str_plain___iter__;
            tmp_res = PyDict_SetItem(tmp_assign_source_47, tmp_dict_key_9, tmp_dict_value_9);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_cryptography$x509$extensions_75_key___len__);
            tmp_dict_value_10 = tmp_locals_cryptography$x509$extensions_75_key___len__;
            tmp_dict_key_10 = const_str_plain___len__;
            tmp_res = PyDict_SetItem(tmp_assign_source_47, tmp_dict_key_10, tmp_dict_value_10);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_cryptography$x509$extensions_75_key___getitem__);
            tmp_dict_value_11 = tmp_locals_cryptography$x509$extensions_75_key___getitem__;
            tmp_dict_key_11 = const_str_plain___getitem__;
            tmp_res = PyDict_SetItem(tmp_assign_source_47, tmp_dict_key_11, tmp_dict_value_11);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_cryptography$x509$extensions_75_key___repr__);
            tmp_dict_value_12 = tmp_locals_cryptography$x509$extensions_75_key___repr__;
            tmp_dict_key_12 = const_str_plain___repr__;
            tmp_res = PyDict_SetItem(tmp_assign_source_47, tmp_dict_key_12, tmp_dict_value_12);
            assert(!(tmp_res != 0));
            goto try_return_handler_11;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Return handler code:
        try_return_handler_11:;
        CHECK_OBJECT((PyObject *)tmp_locals_cryptography$x509$extensions_75_key___init__);
        Py_DECREF(tmp_locals_cryptography$x509$extensions_75_key___init__);
        tmp_locals_cryptography$x509$extensions_75_key___init__ = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_cryptography$x509$extensions_75_key_get_extension_for_oid);
        Py_DECREF(tmp_locals_cryptography$x509$extensions_75_key_get_extension_for_oid);
        tmp_locals_cryptography$x509$extensions_75_key_get_extension_for_oid = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_cryptography$x509$extensions_75_key_get_extension_for_class);
        Py_DECREF(tmp_locals_cryptography$x509$extensions_75_key_get_extension_for_class);
        tmp_locals_cryptography$x509$extensions_75_key_get_extension_for_class = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_cryptography$x509$extensions_75_key___iter__);
        Py_DECREF(tmp_locals_cryptography$x509$extensions_75_key___iter__);
        tmp_locals_cryptography$x509$extensions_75_key___iter__ = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_cryptography$x509$extensions_75_key___len__);
        Py_DECREF(tmp_locals_cryptography$x509$extensions_75_key___len__);
        tmp_locals_cryptography$x509$extensions_75_key___len__ = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_cryptography$x509$extensions_75_key___getitem__);
        Py_DECREF(tmp_locals_cryptography$x509$extensions_75_key___getitem__);
        tmp_locals_cryptography$x509$extensions_75_key___getitem__ = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_cryptography$x509$extensions_75_key___repr__);
        Py_DECREF(tmp_locals_cryptography$x509$extensions_75_key___repr__);
        tmp_locals_cryptography$x509$extensions_75_key___repr__ = NULL;

        goto outline_result_4;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        outline_result_4:;
        assert(tmp_class_creation_4__class_dict == NULL);
        tmp_class_creation_4__class_dict = tmp_assign_source_47;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_55;
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_key_name_7;
        PyObject *tmp_dict_name_7;
        PyObject *tmp_dict_name_8;
        PyObject *tmp_key_name_8;
        tmp_key_name_7 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_4__class_dict);
        tmp_dict_name_7 = tmp_class_creation_4__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_7, tmp_key_name_7);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 75;

            goto try_except_handler_12;
        }
        tmp_condition_result_4 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_4 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_4;
        } else {
            goto condexpr_false_4;
        }
        condexpr_true_4:;
        CHECK_OBJECT(tmp_class_creation_4__class_dict);
        tmp_dict_name_8 = tmp_class_creation_4__class_dict;
        tmp_key_name_8 = const_str_plain___metaclass__;
        tmp_assign_source_55 = DICT_GET_ITEM(tmp_dict_name_8, tmp_key_name_8);
        if (tmp_assign_source_55 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 75;

            goto try_except_handler_12;
        }
        goto condexpr_end_4;
        condexpr_false_4:;
        tmp_assign_source_55 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_55);
        condexpr_end_4:;
        assert(tmp_class_creation_4__metaclass == NULL);
        tmp_class_creation_4__metaclass = tmp_assign_source_55;
    }
    {
        PyObject *tmp_assign_source_56;
        PyObject *tmp_called_name_6;
        PyObject *tmp_args_element_name_13;
        PyObject *tmp_args_element_name_14;
        PyObject *tmp_args_element_name_15;
        CHECK_OBJECT(tmp_class_creation_4__metaclass);
        tmp_called_name_6 = tmp_class_creation_4__metaclass;
        tmp_args_element_name_13 = const_str_plain_Extensions;
        tmp_args_element_name_14 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_4__class_dict);
        tmp_args_element_name_15 = tmp_class_creation_4__class_dict;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 75;
        {
            PyObject *call_args[] = {tmp_args_element_name_13, tmp_args_element_name_14, tmp_args_element_name_15};
            tmp_assign_source_56 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_6, call_args);
        }

        if (tmp_assign_source_56 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 75;

            goto try_except_handler_12;
        }
        assert(tmp_class_creation_4__class == NULL);
        tmp_class_creation_4__class = tmp_assign_source_56;
    }
    goto try_end_8;
    // Exception handler code:
    try_except_handler_12:;
    exception_keeper_type_9 = exception_type;
    exception_keeper_value_9 = exception_value;
    exception_keeper_tb_9 = exception_tb;
    exception_keeper_lineno_9 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)tmp_class_creation_4__class_dict);
    Py_DECREF(tmp_class_creation_4__class_dict);
    tmp_class_creation_4__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_4__metaclass);
    tmp_class_creation_4__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_9;
    exception_value = exception_keeper_value_9;
    exception_tb = exception_keeper_tb_9;
    exception_lineno = exception_keeper_lineno_9;

    goto frame_exception_exit_1;
    // End of try:
    try_end_8:;
    {
        PyObject *tmp_assign_source_57;
        CHECK_OBJECT(tmp_class_creation_4__class);
        tmp_assign_source_57 = tmp_class_creation_4__class;
        UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_Extensions, tmp_assign_source_57);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_4__class);
    Py_DECREF(tmp_class_creation_4__class);
    tmp_class_creation_4__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_4__class_dict);
    Py_DECREF(tmp_class_creation_4__class_dict);
    tmp_class_creation_4__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_4__metaclass);
    Py_DECREF(tmp_class_creation_4__metaclass);
    tmp_class_creation_4__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_58;
        {
            PyObject *tmp_set_locals_2;
            tmp_set_locals_2 = PyDict_New();
            locals_cryptography$x509$extensions_118 = tmp_set_locals_2;
        }
        tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_118, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_9c95e9ba0408147c3cfcb22e4b1c91c9_3, codeobj_9c95e9ba0408147c3cfcb22e4b1c91c9, module_cryptography$x509$extensions, 0);
        frame_9c95e9ba0408147c3cfcb22e4b1c91c9_3 = cache_frame_9c95e9ba0408147c3cfcb22e4b1c91c9_3;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_9c95e9ba0408147c3cfcb22e4b1c91c9_3);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_9c95e9ba0408147c3cfcb22e4b1c91c9_3) == 2); // Frame stack

        // Framed code:
        {
            PyObject *tmp_source_name_3;
            PyObject *tmp_mvar_value_4;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionOID);
            }

            if (tmp_mvar_value_4 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 23410 ], 34, 0);
                exception_tb = NULL;

                exception_lineno = 119;

                goto frame_exception_exit_3;
            }

            tmp_source_name_3 = tmp_mvar_value_4;
            tmp_dictset_value = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_CRL_NUMBER);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 119;

                goto frame_exception_exit_3;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_118, const_str_plain_oid, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 119;

                goto frame_exception_exit_3;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_12___init__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_118, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_13___eq__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_118, const_str_plain___eq__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_14___ne__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_118, const_str_plain___ne__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_15___hash__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_118, const_str_plain___hash__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_16___repr__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_118, const_str_plain___repr__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_mvar_value_5;
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_5 == NULL)) {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_5 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 142;

                goto frame_exception_exit_3;
            }

            tmp_called_instance_2 = tmp_mvar_value_5;
            frame_9c95e9ba0408147c3cfcb22e4b1c91c9_3->m_frame.f_lineno = 142;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__crl_number_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 142;

                goto frame_exception_exit_3;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_118, const_str_plain_crl_number, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 142;

                goto frame_exception_exit_3;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_9c95e9ba0408147c3cfcb22e4b1c91c9_3);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_2;

        frame_exception_exit_3:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_9c95e9ba0408147c3cfcb22e4b1c91c9_3);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_9c95e9ba0408147c3cfcb22e4b1c91c9_3, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_9c95e9ba0408147c3cfcb22e4b1c91c9_3->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_9c95e9ba0408147c3cfcb22e4b1c91c9_3, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_9c95e9ba0408147c3cfcb22e4b1c91c9_3,
            type_description_2
        );


        // Release cached frame.
        if (frame_9c95e9ba0408147c3cfcb22e4b1c91c9_3 == cache_frame_9c95e9ba0408147c3cfcb22e4b1c91c9_3) {
            Py_DECREF(frame_9c95e9ba0408147c3cfcb22e4b1c91c9_3);
        }
        cache_frame_9c95e9ba0408147c3cfcb22e4b1c91c9_3 = NULL;

        assertFrameObject(frame_9c95e9ba0408147c3cfcb22e4b1c91c9_3);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_2;

        frame_no_exception_2:;
        goto skip_nested_handling_2;
        nested_frame_exit_2:;

        goto try_except_handler_14;
        skip_nested_handling_2:;
        tmp_assign_source_58 = locals_cryptography$x509$extensions_118;
        Py_INCREF(tmp_assign_source_58);
        goto try_return_handler_14;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Return handler code:
        try_return_handler_14:;
        Py_DECREF(locals_cryptography$x509$extensions_118);
        locals_cryptography$x509$extensions_118 = NULL;
        goto outline_result_5;
        // Exception handler code:
        try_except_handler_14:;
        exception_keeper_type_10 = exception_type;
        exception_keeper_value_10 = exception_value;
        exception_keeper_tb_10 = exception_tb;
        exception_keeper_lineno_10 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_cryptography$x509$extensions_118);
        locals_cryptography$x509$extensions_118 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_10;
        exception_value = exception_keeper_value_10;
        exception_tb = exception_keeper_tb_10;
        exception_lineno = exception_keeper_lineno_10;

        goto outline_exception_2;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        outline_exception_2:;
        exception_lineno = 118;
        goto try_except_handler_13;
        outline_result_5:;
        assert(tmp_class_creation_5__class_dict == NULL);
        tmp_class_creation_5__class_dict = tmp_assign_source_58;
    }
    {
        PyObject *tmp_assign_source_59;
        nuitka_bool tmp_condition_result_5;
        PyObject *tmp_key_name_9;
        PyObject *tmp_dict_name_9;
        PyObject *tmp_dict_name_10;
        PyObject *tmp_key_name_10;
        tmp_key_name_9 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_5__class_dict);
        tmp_dict_name_9 = tmp_class_creation_5__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_9, tmp_key_name_9);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 118;

            goto try_except_handler_13;
        }
        tmp_condition_result_5 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_5 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_5;
        } else {
            goto condexpr_false_5;
        }
        condexpr_true_5:;
        CHECK_OBJECT(tmp_class_creation_5__class_dict);
        tmp_dict_name_10 = tmp_class_creation_5__class_dict;
        tmp_key_name_10 = const_str_plain___metaclass__;
        tmp_assign_source_59 = DICT_GET_ITEM(tmp_dict_name_10, tmp_key_name_10);
        if (tmp_assign_source_59 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 118;

            goto try_except_handler_13;
        }
        goto condexpr_end_5;
        condexpr_false_5:;
        tmp_assign_source_59 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_59);
        condexpr_end_5:;
        assert(tmp_class_creation_5__metaclass == NULL);
        tmp_class_creation_5__metaclass = tmp_assign_source_59;
    }
    {
        PyObject *tmp_assign_source_60;
        PyObject *tmp_called_name_7;
        PyObject *tmp_args_element_name_16;
        PyObject *tmp_args_element_name_17;
        PyObject *tmp_args_element_name_18;
        CHECK_OBJECT(tmp_class_creation_5__metaclass);
        tmp_called_name_7 = tmp_class_creation_5__metaclass;
        tmp_args_element_name_16 = const_str_plain_CRLNumber;
        tmp_args_element_name_17 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_5__class_dict);
        tmp_args_element_name_18 = tmp_class_creation_5__class_dict;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 118;
        {
            PyObject *call_args[] = {tmp_args_element_name_16, tmp_args_element_name_17, tmp_args_element_name_18};
            tmp_assign_source_60 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_7, call_args);
        }

        if (tmp_assign_source_60 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 118;

            goto try_except_handler_13;
        }
        assert(tmp_class_creation_5__class == NULL);
        tmp_class_creation_5__class = tmp_assign_source_60;
    }
    {
        PyObject *tmp_assign_source_61;
        PyObject *tmp_called_name_8;
        PyObject *tmp_called_name_9;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_args_element_name_19;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_args_element_name_20;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
        }

        if (tmp_mvar_value_6 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
            exception_tb = NULL;

            exception_lineno = 117;

            goto try_except_handler_13;
        }

        tmp_source_name_4 = tmp_mvar_value_6;
        tmp_called_name_9 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_register_interface);
        if (tmp_called_name_9 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 117;

            goto try_except_handler_13;
        }
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType);

        if (unlikely(tmp_mvar_value_7 == NULL)) {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType);
        }

        if (tmp_mvar_value_7 == NULL) {
            Py_DECREF(tmp_called_name_9);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 35484 ], 35, 0);
            exception_tb = NULL;

            exception_lineno = 117;

            goto try_except_handler_13;
        }

        tmp_args_element_name_19 = tmp_mvar_value_7;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 117;
        tmp_called_name_8 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_9, tmp_args_element_name_19);
        Py_DECREF(tmp_called_name_9);
        if (tmp_called_name_8 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 117;

            goto try_except_handler_13;
        }
        CHECK_OBJECT(tmp_class_creation_5__class);
        tmp_args_element_name_20 = tmp_class_creation_5__class;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 117;
        tmp_assign_source_61 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_8, tmp_args_element_name_20);
        Py_DECREF(tmp_called_name_8);
        if (tmp_assign_source_61 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 117;

            goto try_except_handler_13;
        }
        {
            PyObject *old = tmp_class_creation_5__class;
            assert(old != NULL);
            tmp_class_creation_5__class = tmp_assign_source_61;
            Py_DECREF(old);
        }

    }
    goto try_end_9;
    // Exception handler code:
    try_except_handler_13:;
    exception_keeper_type_11 = exception_type;
    exception_keeper_value_11 = exception_value;
    exception_keeper_tb_11 = exception_tb;
    exception_keeper_lineno_11 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_5__class);
    tmp_class_creation_5__class = NULL;

    Py_XDECREF(tmp_class_creation_5__class_dict);
    tmp_class_creation_5__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_5__metaclass);
    tmp_class_creation_5__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_11;
    exception_value = exception_keeper_value_11;
    exception_tb = exception_keeper_tb_11;
    exception_lineno = exception_keeper_lineno_11;

    goto frame_exception_exit_1;
    // End of try:
    try_end_9:;
    {
        PyObject *tmp_assign_source_62;
        CHECK_OBJECT(tmp_class_creation_5__class);
        tmp_assign_source_62 = tmp_class_creation_5__class;
        UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_CRLNumber, tmp_assign_source_62);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_5__class);
    Py_DECREF(tmp_class_creation_5__class);
    tmp_class_creation_5__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_5__class_dict);
    Py_DECREF(tmp_class_creation_5__class_dict);
    tmp_class_creation_5__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_5__metaclass);
    Py_DECREF(tmp_class_creation_5__metaclass);
    tmp_class_creation_5__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_63;
        {
            PyObject *tmp_set_locals_3;
            tmp_set_locals_3 = PyDict_New();
            locals_cryptography$x509$extensions_146 = tmp_set_locals_3;
        }
        tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_146, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_8af375243c51a3b11b69e7c775faf530_4, codeobj_8af375243c51a3b11b69e7c775faf530, module_cryptography$x509$extensions, 0);
        frame_8af375243c51a3b11b69e7c775faf530_4 = cache_frame_8af375243c51a3b11b69e7c775faf530_4;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_8af375243c51a3b11b69e7c775faf530_4);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_8af375243c51a3b11b69e7c775faf530_4) == 2); // Frame stack

        // Framed code:
        {
            PyObject *tmp_source_name_5;
            PyObject *tmp_mvar_value_8;
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID);

            if (unlikely(tmp_mvar_value_8 == NULL)) {
                tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionOID);
            }

            if (tmp_mvar_value_8 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 23410 ], 34, 0);
                exception_tb = NULL;

                exception_lineno = 147;

                goto frame_exception_exit_4;
            }

            tmp_source_name_5 = tmp_mvar_value_8;
            tmp_dictset_value = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_AUTHORITY_KEY_IDENTIFIER);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 147;

                goto frame_exception_exit_4;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_146, const_str_plain_oid, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 147;

                goto frame_exception_exit_4;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_17___init__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_146, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        {
            PyObject *tmp_classmethod_arg_1;
            tmp_classmethod_arg_1 = MAKE_FUNCTION_cryptography$x509$extensions$$$function_18_from_issuer_public_key();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_1);
            Py_DECREF(tmp_classmethod_arg_1);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 180;

                goto frame_exception_exit_4;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_146, const_str_plain_from_issuer_public_key, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 180;

                goto frame_exception_exit_4;
            }
        }
        {
            PyObject *tmp_classmethod_arg_2;
            tmp_classmethod_arg_2 = MAKE_FUNCTION_cryptography$x509$extensions$$$function_19_from_issuer_subject_key_identifier();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_2);
            Py_DECREF(tmp_classmethod_arg_2);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 189;

                goto frame_exception_exit_4;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_146, const_str_plain_from_issuer_subject_key_identifier, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 189;

                goto frame_exception_exit_4;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_20___repr__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_146, const_str_plain___repr__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_21___eq__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_146, const_str_plain___eq__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_22___ne__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_146, const_str_plain___ne__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_23___hash__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_146, const_str_plain___hash__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        {
            PyObject *tmp_called_instance_3;
            PyObject *tmp_mvar_value_9;
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_9 == NULL)) {
                tmp_mvar_value_9 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_9 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 228;

                goto frame_exception_exit_4;
            }

            tmp_called_instance_3 = tmp_mvar_value_9;
            frame_8af375243c51a3b11b69e7c775faf530_4->m_frame.f_lineno = 228;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_3, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__key_identifier_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 228;

                goto frame_exception_exit_4;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_146, const_str_plain_key_identifier, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 228;

                goto frame_exception_exit_4;
            }
        }
        {
            PyObject *tmp_called_instance_4;
            PyObject *tmp_mvar_value_10;
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_10 == NULL)) {
                tmp_mvar_value_10 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_10 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 229;

                goto frame_exception_exit_4;
            }

            tmp_called_instance_4 = tmp_mvar_value_10;
            frame_8af375243c51a3b11b69e7c775faf530_4->m_frame.f_lineno = 229;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_4, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__authority_cert_issuer_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 229;

                goto frame_exception_exit_4;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_146, const_str_plain_authority_cert_issuer, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 229;

                goto frame_exception_exit_4;
            }
        }
        {
            PyObject *tmp_called_instance_5;
            PyObject *tmp_mvar_value_11;
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_11 == NULL)) {
                tmp_mvar_value_11 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_11 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 230;

                goto frame_exception_exit_4;
            }

            tmp_called_instance_5 = tmp_mvar_value_11;
            frame_8af375243c51a3b11b69e7c775faf530_4->m_frame.f_lineno = 230;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_5, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__authority_cert_serial_number_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 230;

                goto frame_exception_exit_4;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_146, const_str_plain_authority_cert_serial_number, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 230;

                goto frame_exception_exit_4;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_8af375243c51a3b11b69e7c775faf530_4);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_3;

        frame_exception_exit_4:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_8af375243c51a3b11b69e7c775faf530_4);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_8af375243c51a3b11b69e7c775faf530_4, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_8af375243c51a3b11b69e7c775faf530_4->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_8af375243c51a3b11b69e7c775faf530_4, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_8af375243c51a3b11b69e7c775faf530_4,
            type_description_2
        );


        // Release cached frame.
        if (frame_8af375243c51a3b11b69e7c775faf530_4 == cache_frame_8af375243c51a3b11b69e7c775faf530_4) {
            Py_DECREF(frame_8af375243c51a3b11b69e7c775faf530_4);
        }
        cache_frame_8af375243c51a3b11b69e7c775faf530_4 = NULL;

        assertFrameObject(frame_8af375243c51a3b11b69e7c775faf530_4);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_3;

        frame_no_exception_3:;
        goto skip_nested_handling_3;
        nested_frame_exit_3:;

        goto try_except_handler_16;
        skip_nested_handling_3:;
        tmp_assign_source_63 = locals_cryptography$x509$extensions_146;
        Py_INCREF(tmp_assign_source_63);
        goto try_return_handler_16;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Return handler code:
        try_return_handler_16:;
        Py_DECREF(locals_cryptography$x509$extensions_146);
        locals_cryptography$x509$extensions_146 = NULL;
        goto outline_result_6;
        // Exception handler code:
        try_except_handler_16:;
        exception_keeper_type_12 = exception_type;
        exception_keeper_value_12 = exception_value;
        exception_keeper_tb_12 = exception_tb;
        exception_keeper_lineno_12 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_cryptography$x509$extensions_146);
        locals_cryptography$x509$extensions_146 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_12;
        exception_value = exception_keeper_value_12;
        exception_tb = exception_keeper_tb_12;
        exception_lineno = exception_keeper_lineno_12;

        goto outline_exception_3;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        outline_exception_3:;
        exception_lineno = 146;
        goto try_except_handler_15;
        outline_result_6:;
        assert(tmp_class_creation_6__class_dict == NULL);
        tmp_class_creation_6__class_dict = tmp_assign_source_63;
    }
    {
        PyObject *tmp_assign_source_64;
        nuitka_bool tmp_condition_result_6;
        PyObject *tmp_key_name_11;
        PyObject *tmp_dict_name_11;
        PyObject *tmp_dict_name_12;
        PyObject *tmp_key_name_12;
        tmp_key_name_11 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_6__class_dict);
        tmp_dict_name_11 = tmp_class_creation_6__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_11, tmp_key_name_11);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 146;

            goto try_except_handler_15;
        }
        tmp_condition_result_6 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_6 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_6;
        } else {
            goto condexpr_false_6;
        }
        condexpr_true_6:;
        CHECK_OBJECT(tmp_class_creation_6__class_dict);
        tmp_dict_name_12 = tmp_class_creation_6__class_dict;
        tmp_key_name_12 = const_str_plain___metaclass__;
        tmp_assign_source_64 = DICT_GET_ITEM(tmp_dict_name_12, tmp_key_name_12);
        if (tmp_assign_source_64 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 146;

            goto try_except_handler_15;
        }
        goto condexpr_end_6;
        condexpr_false_6:;
        tmp_assign_source_64 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_64);
        condexpr_end_6:;
        assert(tmp_class_creation_6__metaclass == NULL);
        tmp_class_creation_6__metaclass = tmp_assign_source_64;
    }
    {
        PyObject *tmp_assign_source_65;
        PyObject *tmp_called_name_10;
        PyObject *tmp_args_element_name_21;
        PyObject *tmp_args_element_name_22;
        PyObject *tmp_args_element_name_23;
        CHECK_OBJECT(tmp_class_creation_6__metaclass);
        tmp_called_name_10 = tmp_class_creation_6__metaclass;
        tmp_args_element_name_21 = const_str_plain_AuthorityKeyIdentifier;
        tmp_args_element_name_22 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_6__class_dict);
        tmp_args_element_name_23 = tmp_class_creation_6__class_dict;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 146;
        {
            PyObject *call_args[] = {tmp_args_element_name_21, tmp_args_element_name_22, tmp_args_element_name_23};
            tmp_assign_source_65 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_10, call_args);
        }

        if (tmp_assign_source_65 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 146;

            goto try_except_handler_15;
        }
        assert(tmp_class_creation_6__class == NULL);
        tmp_class_creation_6__class = tmp_assign_source_65;
    }
    {
        PyObject *tmp_assign_source_66;
        PyObject *tmp_called_name_11;
        PyObject *tmp_called_name_12;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_12;
        PyObject *tmp_args_element_name_24;
        PyObject *tmp_mvar_value_13;
        PyObject *tmp_args_element_name_25;
        tmp_mvar_value_12 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

        if (unlikely(tmp_mvar_value_12 == NULL)) {
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
        }

        if (tmp_mvar_value_12 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
            exception_tb = NULL;

            exception_lineno = 145;

            goto try_except_handler_15;
        }

        tmp_source_name_6 = tmp_mvar_value_12;
        tmp_called_name_12 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_register_interface);
        if (tmp_called_name_12 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 145;

            goto try_except_handler_15;
        }
        tmp_mvar_value_13 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType);

        if (unlikely(tmp_mvar_value_13 == NULL)) {
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType);
        }

        if (tmp_mvar_value_13 == NULL) {
            Py_DECREF(tmp_called_name_12);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 35484 ], 35, 0);
            exception_tb = NULL;

            exception_lineno = 145;

            goto try_except_handler_15;
        }

        tmp_args_element_name_24 = tmp_mvar_value_13;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 145;
        tmp_called_name_11 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_12, tmp_args_element_name_24);
        Py_DECREF(tmp_called_name_12);
        if (tmp_called_name_11 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 145;

            goto try_except_handler_15;
        }
        CHECK_OBJECT(tmp_class_creation_6__class);
        tmp_args_element_name_25 = tmp_class_creation_6__class;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 145;
        tmp_assign_source_66 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_11, tmp_args_element_name_25);
        Py_DECREF(tmp_called_name_11);
        if (tmp_assign_source_66 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 145;

            goto try_except_handler_15;
        }
        {
            PyObject *old = tmp_class_creation_6__class;
            assert(old != NULL);
            tmp_class_creation_6__class = tmp_assign_source_66;
            Py_DECREF(old);
        }

    }
    goto try_end_10;
    // Exception handler code:
    try_except_handler_15:;
    exception_keeper_type_13 = exception_type;
    exception_keeper_value_13 = exception_value;
    exception_keeper_tb_13 = exception_tb;
    exception_keeper_lineno_13 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_6__class);
    tmp_class_creation_6__class = NULL;

    Py_XDECREF(tmp_class_creation_6__class_dict);
    tmp_class_creation_6__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_6__metaclass);
    tmp_class_creation_6__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_13;
    exception_value = exception_keeper_value_13;
    exception_tb = exception_keeper_tb_13;
    exception_lineno = exception_keeper_lineno_13;

    goto frame_exception_exit_1;
    // End of try:
    try_end_10:;
    {
        PyObject *tmp_assign_source_67;
        CHECK_OBJECT(tmp_class_creation_6__class);
        tmp_assign_source_67 = tmp_class_creation_6__class;
        UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_AuthorityKeyIdentifier, tmp_assign_source_67);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_6__class);
    Py_DECREF(tmp_class_creation_6__class);
    tmp_class_creation_6__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_6__class_dict);
    Py_DECREF(tmp_class_creation_6__class_dict);
    tmp_class_creation_6__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_6__metaclass);
    Py_DECREF(tmp_class_creation_6__metaclass);
    tmp_class_creation_6__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_68;
        {
            PyObject *tmp_set_locals_4;
            tmp_set_locals_4 = PyDict_New();
            locals_cryptography$x509$extensions_236 = tmp_set_locals_4;
        }
        tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_236, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_0bc1f437e02225d59bf32cb2d7a199ed_5, codeobj_0bc1f437e02225d59bf32cb2d7a199ed, module_cryptography$x509$extensions, 0);
        frame_0bc1f437e02225d59bf32cb2d7a199ed_5 = cache_frame_0bc1f437e02225d59bf32cb2d7a199ed_5;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_0bc1f437e02225d59bf32cb2d7a199ed_5);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_0bc1f437e02225d59bf32cb2d7a199ed_5) == 2); // Frame stack

        // Framed code:
        {
            PyObject *tmp_source_name_7;
            PyObject *tmp_mvar_value_14;
            tmp_mvar_value_14 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID);

            if (unlikely(tmp_mvar_value_14 == NULL)) {
                tmp_mvar_value_14 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionOID);
            }

            if (tmp_mvar_value_14 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 23410 ], 34, 0);
                exception_tb = NULL;

                exception_lineno = 237;

                goto frame_exception_exit_5;
            }

            tmp_source_name_7 = tmp_mvar_value_14;
            tmp_dictset_value = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain_SUBJECT_KEY_IDENTIFIER);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 237;

                goto frame_exception_exit_5;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_236, const_str_plain_oid, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 237;

                goto frame_exception_exit_5;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_24___init__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_236, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        {
            PyObject *tmp_classmethod_arg_3;
            tmp_classmethod_arg_3 = MAKE_FUNCTION_cryptography$x509$extensions$$$function_25_from_public_key();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_3);
            Py_DECREF(tmp_classmethod_arg_3);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 242;

                goto frame_exception_exit_5;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_236, const_str_plain_from_public_key, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 242;

                goto frame_exception_exit_5;
            }
        }
        {
            PyObject *tmp_called_instance_6;
            PyObject *tmp_mvar_value_15;
            tmp_mvar_value_15 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_15 == NULL)) {
                tmp_mvar_value_15 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_15 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 246;

                goto frame_exception_exit_5;
            }

            tmp_called_instance_6 = tmp_mvar_value_15;
            frame_0bc1f437e02225d59bf32cb2d7a199ed_5->m_frame.f_lineno = 246;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_6, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__digest_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 246;

                goto frame_exception_exit_5;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_236, const_str_plain_digest, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 246;

                goto frame_exception_exit_5;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_0bc1f437e02225d59bf32cb2d7a199ed_5);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_4;

        frame_exception_exit_5:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_0bc1f437e02225d59bf32cb2d7a199ed_5);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_0bc1f437e02225d59bf32cb2d7a199ed_5, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_0bc1f437e02225d59bf32cb2d7a199ed_5->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_0bc1f437e02225d59bf32cb2d7a199ed_5, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_0bc1f437e02225d59bf32cb2d7a199ed_5,
            type_description_2
        );


        // Release cached frame.
        if (frame_0bc1f437e02225d59bf32cb2d7a199ed_5 == cache_frame_0bc1f437e02225d59bf32cb2d7a199ed_5) {
            Py_DECREF(frame_0bc1f437e02225d59bf32cb2d7a199ed_5);
        }
        cache_frame_0bc1f437e02225d59bf32cb2d7a199ed_5 = NULL;

        assertFrameObject(frame_0bc1f437e02225d59bf32cb2d7a199ed_5);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_4;

        frame_no_exception_4:;
        goto skip_nested_handling_4;
        nested_frame_exit_4:;

        goto try_except_handler_18;
        skip_nested_handling_4:;
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_26___repr__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_236, const_str_plain___repr__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_27___eq__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_236, const_str_plain___eq__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_28___ne__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_236, const_str_plain___ne__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_29___hash__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_236, const_str_plain___hash__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_assign_source_68 = locals_cryptography$x509$extensions_236;
        Py_INCREF(tmp_assign_source_68);
        goto try_return_handler_18;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Return handler code:
        try_return_handler_18:;
        Py_DECREF(locals_cryptography$x509$extensions_236);
        locals_cryptography$x509$extensions_236 = NULL;
        goto outline_result_7;
        // Exception handler code:
        try_except_handler_18:;
        exception_keeper_type_14 = exception_type;
        exception_keeper_value_14 = exception_value;
        exception_keeper_tb_14 = exception_tb;
        exception_keeper_lineno_14 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_cryptography$x509$extensions_236);
        locals_cryptography$x509$extensions_236 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_14;
        exception_value = exception_keeper_value_14;
        exception_tb = exception_keeper_tb_14;
        exception_lineno = exception_keeper_lineno_14;

        goto outline_exception_4;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        outline_exception_4:;
        exception_lineno = 236;
        goto try_except_handler_17;
        outline_result_7:;
        assert(tmp_class_creation_7__class_dict == NULL);
        tmp_class_creation_7__class_dict = tmp_assign_source_68;
    }
    {
        PyObject *tmp_assign_source_69;
        nuitka_bool tmp_condition_result_7;
        PyObject *tmp_key_name_13;
        PyObject *tmp_dict_name_13;
        PyObject *tmp_dict_name_14;
        PyObject *tmp_key_name_14;
        tmp_key_name_13 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_7__class_dict);
        tmp_dict_name_13 = tmp_class_creation_7__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_13, tmp_key_name_13);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 236;

            goto try_except_handler_17;
        }
        tmp_condition_result_7 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_7 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_7;
        } else {
            goto condexpr_false_7;
        }
        condexpr_true_7:;
        CHECK_OBJECT(tmp_class_creation_7__class_dict);
        tmp_dict_name_14 = tmp_class_creation_7__class_dict;
        tmp_key_name_14 = const_str_plain___metaclass__;
        tmp_assign_source_69 = DICT_GET_ITEM(tmp_dict_name_14, tmp_key_name_14);
        if (tmp_assign_source_69 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 236;

            goto try_except_handler_17;
        }
        goto condexpr_end_7;
        condexpr_false_7:;
        tmp_assign_source_69 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_69);
        condexpr_end_7:;
        assert(tmp_class_creation_7__metaclass == NULL);
        tmp_class_creation_7__metaclass = tmp_assign_source_69;
    }
    {
        PyObject *tmp_assign_source_70;
        PyObject *tmp_called_name_13;
        PyObject *tmp_args_element_name_26;
        PyObject *tmp_args_element_name_27;
        PyObject *tmp_args_element_name_28;
        CHECK_OBJECT(tmp_class_creation_7__metaclass);
        tmp_called_name_13 = tmp_class_creation_7__metaclass;
        tmp_args_element_name_26 = const_str_plain_SubjectKeyIdentifier;
        tmp_args_element_name_27 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_7__class_dict);
        tmp_args_element_name_28 = tmp_class_creation_7__class_dict;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 236;
        {
            PyObject *call_args[] = {tmp_args_element_name_26, tmp_args_element_name_27, tmp_args_element_name_28};
            tmp_assign_source_70 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_13, call_args);
        }

        if (tmp_assign_source_70 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 236;

            goto try_except_handler_17;
        }
        assert(tmp_class_creation_7__class == NULL);
        tmp_class_creation_7__class = tmp_assign_source_70;
    }
    {
        PyObject *tmp_assign_source_71;
        PyObject *tmp_called_name_14;
        PyObject *tmp_called_name_15;
        PyObject *tmp_source_name_8;
        PyObject *tmp_mvar_value_16;
        PyObject *tmp_args_element_name_29;
        PyObject *tmp_mvar_value_17;
        PyObject *tmp_args_element_name_30;
        tmp_mvar_value_16 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

        if (unlikely(tmp_mvar_value_16 == NULL)) {
            tmp_mvar_value_16 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
        }

        if (tmp_mvar_value_16 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
            exception_tb = NULL;

            exception_lineno = 235;

            goto try_except_handler_17;
        }

        tmp_source_name_8 = tmp_mvar_value_16;
        tmp_called_name_15 = LOOKUP_ATTRIBUTE(tmp_source_name_8, const_str_plain_register_interface);
        if (tmp_called_name_15 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 235;

            goto try_except_handler_17;
        }
        tmp_mvar_value_17 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType);

        if (unlikely(tmp_mvar_value_17 == NULL)) {
            tmp_mvar_value_17 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType);
        }

        if (tmp_mvar_value_17 == NULL) {
            Py_DECREF(tmp_called_name_15);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 35484 ], 35, 0);
            exception_tb = NULL;

            exception_lineno = 235;

            goto try_except_handler_17;
        }

        tmp_args_element_name_29 = tmp_mvar_value_17;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 235;
        tmp_called_name_14 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_15, tmp_args_element_name_29);
        Py_DECREF(tmp_called_name_15);
        if (tmp_called_name_14 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 235;

            goto try_except_handler_17;
        }
        CHECK_OBJECT(tmp_class_creation_7__class);
        tmp_args_element_name_30 = tmp_class_creation_7__class;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 235;
        tmp_assign_source_71 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_14, tmp_args_element_name_30);
        Py_DECREF(tmp_called_name_14);
        if (tmp_assign_source_71 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 235;

            goto try_except_handler_17;
        }
        {
            PyObject *old = tmp_class_creation_7__class;
            assert(old != NULL);
            tmp_class_creation_7__class = tmp_assign_source_71;
            Py_DECREF(old);
        }

    }
    goto try_end_11;
    // Exception handler code:
    try_except_handler_17:;
    exception_keeper_type_15 = exception_type;
    exception_keeper_value_15 = exception_value;
    exception_keeper_tb_15 = exception_tb;
    exception_keeper_lineno_15 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_7__class);
    tmp_class_creation_7__class = NULL;

    Py_XDECREF(tmp_class_creation_7__class_dict);
    tmp_class_creation_7__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_7__metaclass);
    tmp_class_creation_7__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_15;
    exception_value = exception_keeper_value_15;
    exception_tb = exception_keeper_tb_15;
    exception_lineno = exception_keeper_lineno_15;

    goto frame_exception_exit_1;
    // End of try:
    try_end_11:;
    {
        PyObject *tmp_assign_source_72;
        CHECK_OBJECT(tmp_class_creation_7__class);
        tmp_assign_source_72 = tmp_class_creation_7__class;
        UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_SubjectKeyIdentifier, tmp_assign_source_72);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_7__class);
    Py_DECREF(tmp_class_creation_7__class);
    tmp_class_creation_7__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_7__class_dict);
    Py_DECREF(tmp_class_creation_7__class_dict);
    tmp_class_creation_7__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_7__metaclass);
    Py_DECREF(tmp_class_creation_7__metaclass);
    tmp_class_creation_7__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_73;
        {
            PyObject *tmp_set_locals_5;
            tmp_set_locals_5 = PyDict_New();
            locals_cryptography$x509$extensions_265 = tmp_set_locals_5;
        }
        tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_265, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_fdfe391b38b7f158ab41b6490db64d26_6, codeobj_fdfe391b38b7f158ab41b6490db64d26, module_cryptography$x509$extensions, 0);
        frame_fdfe391b38b7f158ab41b6490db64d26_6 = cache_frame_fdfe391b38b7f158ab41b6490db64d26_6;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_fdfe391b38b7f158ab41b6490db64d26_6);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_fdfe391b38b7f158ab41b6490db64d26_6) == 2); // Frame stack

        // Framed code:
        {
            PyObject *tmp_source_name_9;
            PyObject *tmp_mvar_value_18;
            tmp_mvar_value_18 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID);

            if (unlikely(tmp_mvar_value_18 == NULL)) {
                tmp_mvar_value_18 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionOID);
            }

            if (tmp_mvar_value_18 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 23410 ], 34, 0);
                exception_tb = NULL;

                exception_lineno = 266;

                goto frame_exception_exit_6;
            }

            tmp_source_name_9 = tmp_mvar_value_18;
            tmp_dictset_value = LOOKUP_ATTRIBUTE(tmp_source_name_9, const_str_plain_AUTHORITY_INFORMATION_ACCESS);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 266;

                goto frame_exception_exit_6;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_265, const_str_plain_oid, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 266;

                goto frame_exception_exit_6;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_fdfe391b38b7f158ab41b6490db64d26_6);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_5;

        frame_exception_exit_6:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_fdfe391b38b7f158ab41b6490db64d26_6);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_fdfe391b38b7f158ab41b6490db64d26_6, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_fdfe391b38b7f158ab41b6490db64d26_6->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_fdfe391b38b7f158ab41b6490db64d26_6, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_fdfe391b38b7f158ab41b6490db64d26_6,
            type_description_2
        );


        // Release cached frame.
        if (frame_fdfe391b38b7f158ab41b6490db64d26_6 == cache_frame_fdfe391b38b7f158ab41b6490db64d26_6) {
            Py_DECREF(frame_fdfe391b38b7f158ab41b6490db64d26_6);
        }
        cache_frame_fdfe391b38b7f158ab41b6490db64d26_6 = NULL;

        assertFrameObject(frame_fdfe391b38b7f158ab41b6490db64d26_6);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_5;

        frame_no_exception_5:;
        goto skip_nested_handling_5;
        nested_frame_exit_5:;

        goto try_except_handler_20;
        skip_nested_handling_5:;
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_30___init__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_265, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_31___iter__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_265, const_str_plain___iter__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_32___len__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_265, const_str_plain___len__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_33___repr__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_265, const_str_plain___repr__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_34___eq__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_265, const_str_plain___eq__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_35___ne__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_265, const_str_plain___ne__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_36___getitem__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_265, const_str_plain___getitem__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_37___hash__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_265, const_str_plain___hash__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_assign_source_73 = locals_cryptography$x509$extensions_265;
        Py_INCREF(tmp_assign_source_73);
        goto try_return_handler_20;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Return handler code:
        try_return_handler_20:;
        Py_DECREF(locals_cryptography$x509$extensions_265);
        locals_cryptography$x509$extensions_265 = NULL;
        goto outline_result_8;
        // Exception handler code:
        try_except_handler_20:;
        exception_keeper_type_16 = exception_type;
        exception_keeper_value_16 = exception_value;
        exception_keeper_tb_16 = exception_tb;
        exception_keeper_lineno_16 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_cryptography$x509$extensions_265);
        locals_cryptography$x509$extensions_265 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_16;
        exception_value = exception_keeper_value_16;
        exception_tb = exception_keeper_tb_16;
        exception_lineno = exception_keeper_lineno_16;

        goto outline_exception_5;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        outline_exception_5:;
        exception_lineno = 265;
        goto try_except_handler_19;
        outline_result_8:;
        assert(tmp_class_creation_8__class_dict == NULL);
        tmp_class_creation_8__class_dict = tmp_assign_source_73;
    }
    {
        PyObject *tmp_assign_source_74;
        nuitka_bool tmp_condition_result_8;
        PyObject *tmp_key_name_15;
        PyObject *tmp_dict_name_15;
        PyObject *tmp_dict_name_16;
        PyObject *tmp_key_name_16;
        tmp_key_name_15 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_8__class_dict);
        tmp_dict_name_15 = tmp_class_creation_8__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_15, tmp_key_name_15);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 265;

            goto try_except_handler_19;
        }
        tmp_condition_result_8 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_8 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_8;
        } else {
            goto condexpr_false_8;
        }
        condexpr_true_8:;
        CHECK_OBJECT(tmp_class_creation_8__class_dict);
        tmp_dict_name_16 = tmp_class_creation_8__class_dict;
        tmp_key_name_16 = const_str_plain___metaclass__;
        tmp_assign_source_74 = DICT_GET_ITEM(tmp_dict_name_16, tmp_key_name_16);
        if (tmp_assign_source_74 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 265;

            goto try_except_handler_19;
        }
        goto condexpr_end_8;
        condexpr_false_8:;
        tmp_assign_source_74 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_74);
        condexpr_end_8:;
        assert(tmp_class_creation_8__metaclass == NULL);
        tmp_class_creation_8__metaclass = tmp_assign_source_74;
    }
    {
        PyObject *tmp_assign_source_75;
        PyObject *tmp_called_name_16;
        PyObject *tmp_args_element_name_31;
        PyObject *tmp_args_element_name_32;
        PyObject *tmp_args_element_name_33;
        CHECK_OBJECT(tmp_class_creation_8__metaclass);
        tmp_called_name_16 = tmp_class_creation_8__metaclass;
        tmp_args_element_name_31 = const_str_plain_AuthorityInformationAccess;
        tmp_args_element_name_32 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_8__class_dict);
        tmp_args_element_name_33 = tmp_class_creation_8__class_dict;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 265;
        {
            PyObject *call_args[] = {tmp_args_element_name_31, tmp_args_element_name_32, tmp_args_element_name_33};
            tmp_assign_source_75 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_16, call_args);
        }

        if (tmp_assign_source_75 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 265;

            goto try_except_handler_19;
        }
        assert(tmp_class_creation_8__class == NULL);
        tmp_class_creation_8__class = tmp_assign_source_75;
    }
    {
        PyObject *tmp_assign_source_76;
        PyObject *tmp_called_name_17;
        PyObject *tmp_called_name_18;
        PyObject *tmp_source_name_10;
        PyObject *tmp_mvar_value_19;
        PyObject *tmp_args_element_name_34;
        PyObject *tmp_mvar_value_20;
        PyObject *tmp_args_element_name_35;
        tmp_mvar_value_19 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

        if (unlikely(tmp_mvar_value_19 == NULL)) {
            tmp_mvar_value_19 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
        }

        if (tmp_mvar_value_19 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
            exception_tb = NULL;

            exception_lineno = 264;

            goto try_except_handler_19;
        }

        tmp_source_name_10 = tmp_mvar_value_19;
        tmp_called_name_18 = LOOKUP_ATTRIBUTE(tmp_source_name_10, const_str_plain_register_interface);
        if (tmp_called_name_18 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 264;

            goto try_except_handler_19;
        }
        tmp_mvar_value_20 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType);

        if (unlikely(tmp_mvar_value_20 == NULL)) {
            tmp_mvar_value_20 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType);
        }

        if (tmp_mvar_value_20 == NULL) {
            Py_DECREF(tmp_called_name_18);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 35484 ], 35, 0);
            exception_tb = NULL;

            exception_lineno = 264;

            goto try_except_handler_19;
        }

        tmp_args_element_name_34 = tmp_mvar_value_20;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 264;
        tmp_called_name_17 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_18, tmp_args_element_name_34);
        Py_DECREF(tmp_called_name_18);
        if (tmp_called_name_17 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 264;

            goto try_except_handler_19;
        }
        CHECK_OBJECT(tmp_class_creation_8__class);
        tmp_args_element_name_35 = tmp_class_creation_8__class;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 264;
        tmp_assign_source_76 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_17, tmp_args_element_name_35);
        Py_DECREF(tmp_called_name_17);
        if (tmp_assign_source_76 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 264;

            goto try_except_handler_19;
        }
        {
            PyObject *old = tmp_class_creation_8__class;
            assert(old != NULL);
            tmp_class_creation_8__class = tmp_assign_source_76;
            Py_DECREF(old);
        }

    }
    goto try_end_12;
    // Exception handler code:
    try_except_handler_19:;
    exception_keeper_type_17 = exception_type;
    exception_keeper_value_17 = exception_value;
    exception_keeper_tb_17 = exception_tb;
    exception_keeper_lineno_17 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_8__class);
    tmp_class_creation_8__class = NULL;

    Py_XDECREF(tmp_class_creation_8__class_dict);
    tmp_class_creation_8__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_8__metaclass);
    tmp_class_creation_8__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_17;
    exception_value = exception_keeper_value_17;
    exception_tb = exception_keeper_tb_17;
    exception_lineno = exception_keeper_lineno_17;

    goto frame_exception_exit_1;
    // End of try:
    try_end_12:;
    {
        PyObject *tmp_assign_source_77;
        CHECK_OBJECT(tmp_class_creation_8__class);
        tmp_assign_source_77 = tmp_class_creation_8__class;
        UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_AuthorityInformationAccess, tmp_assign_source_77);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_8__class);
    Py_DECREF(tmp_class_creation_8__class);
    tmp_class_creation_8__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_8__class_dict);
    Py_DECREF(tmp_class_creation_8__class_dict);
    tmp_class_creation_8__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_8__metaclass);
    Py_DECREF(tmp_class_creation_8__metaclass);
    tmp_class_creation_8__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_78;
        {
            PyObject *tmp_set_locals_6;
            tmp_set_locals_6 = PyDict_New();
            locals_cryptography$x509$extensions_303 = tmp_set_locals_6;
        }
        tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_303, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_38___init__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_303, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_39___repr__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_303, const_str_plain___repr__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_40___eq__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_303, const_str_plain___eq__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_41___ne__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_303, const_str_plain___ne__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_42___hash__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_303, const_str_plain___hash__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_888390ddbc4bf33f48bfeea2ec680910_7, codeobj_888390ddbc4bf33f48bfeea2ec680910, module_cryptography$x509$extensions, 0);
        frame_888390ddbc4bf33f48bfeea2ec680910_7 = cache_frame_888390ddbc4bf33f48bfeea2ec680910_7;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_888390ddbc4bf33f48bfeea2ec680910_7);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_888390ddbc4bf33f48bfeea2ec680910_7) == 2); // Frame stack

        // Framed code:
        {
            PyObject *tmp_called_instance_7;
            PyObject *tmp_mvar_value_21;
            tmp_mvar_value_21 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_21 == NULL)) {
                tmp_mvar_value_21 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_21 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 335;

                goto frame_exception_exit_7;
            }

            tmp_called_instance_7 = tmp_mvar_value_21;
            frame_888390ddbc4bf33f48bfeea2ec680910_7->m_frame.f_lineno = 335;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_7, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__access_method_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 335;

                goto frame_exception_exit_7;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_303, const_str_plain_access_method, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 335;

                goto frame_exception_exit_7;
            }
        }
        {
            PyObject *tmp_called_instance_8;
            PyObject *tmp_mvar_value_22;
            tmp_mvar_value_22 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_22 == NULL)) {
                tmp_mvar_value_22 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_22 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 336;

                goto frame_exception_exit_7;
            }

            tmp_called_instance_8 = tmp_mvar_value_22;
            frame_888390ddbc4bf33f48bfeea2ec680910_7->m_frame.f_lineno = 336;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_8, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__access_location_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 336;

                goto frame_exception_exit_7;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_303, const_str_plain_access_location, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 336;

                goto frame_exception_exit_7;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_888390ddbc4bf33f48bfeea2ec680910_7);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_6;

        frame_exception_exit_7:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_888390ddbc4bf33f48bfeea2ec680910_7);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_888390ddbc4bf33f48bfeea2ec680910_7, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_888390ddbc4bf33f48bfeea2ec680910_7->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_888390ddbc4bf33f48bfeea2ec680910_7, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_888390ddbc4bf33f48bfeea2ec680910_7,
            type_description_2
        );


        // Release cached frame.
        if (frame_888390ddbc4bf33f48bfeea2ec680910_7 == cache_frame_888390ddbc4bf33f48bfeea2ec680910_7) {
            Py_DECREF(frame_888390ddbc4bf33f48bfeea2ec680910_7);
        }
        cache_frame_888390ddbc4bf33f48bfeea2ec680910_7 = NULL;

        assertFrameObject(frame_888390ddbc4bf33f48bfeea2ec680910_7);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_6;

        frame_no_exception_6:;
        goto skip_nested_handling_6;
        nested_frame_exit_6:;

        goto try_except_handler_22;
        skip_nested_handling_6:;
        tmp_assign_source_78 = locals_cryptography$x509$extensions_303;
        Py_INCREF(tmp_assign_source_78);
        goto try_return_handler_22;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Return handler code:
        try_return_handler_22:;
        Py_DECREF(locals_cryptography$x509$extensions_303);
        locals_cryptography$x509$extensions_303 = NULL;
        goto outline_result_9;
        // Exception handler code:
        try_except_handler_22:;
        exception_keeper_type_18 = exception_type;
        exception_keeper_value_18 = exception_value;
        exception_keeper_tb_18 = exception_tb;
        exception_keeper_lineno_18 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_cryptography$x509$extensions_303);
        locals_cryptography$x509$extensions_303 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_18;
        exception_value = exception_keeper_value_18;
        exception_tb = exception_keeper_tb_18;
        exception_lineno = exception_keeper_lineno_18;

        goto outline_exception_6;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        outline_exception_6:;
        exception_lineno = 303;
        goto try_except_handler_21;
        outline_result_9:;
        assert(tmp_class_creation_9__class_dict == NULL);
        tmp_class_creation_9__class_dict = tmp_assign_source_78;
    }
    {
        PyObject *tmp_assign_source_79;
        nuitka_bool tmp_condition_result_9;
        PyObject *tmp_key_name_17;
        PyObject *tmp_dict_name_17;
        PyObject *tmp_dict_name_18;
        PyObject *tmp_key_name_18;
        tmp_key_name_17 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_9__class_dict);
        tmp_dict_name_17 = tmp_class_creation_9__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_17, tmp_key_name_17);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 303;

            goto try_except_handler_21;
        }
        tmp_condition_result_9 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_9 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_9;
        } else {
            goto condexpr_false_9;
        }
        condexpr_true_9:;
        CHECK_OBJECT(tmp_class_creation_9__class_dict);
        tmp_dict_name_18 = tmp_class_creation_9__class_dict;
        tmp_key_name_18 = const_str_plain___metaclass__;
        tmp_assign_source_79 = DICT_GET_ITEM(tmp_dict_name_18, tmp_key_name_18);
        if (tmp_assign_source_79 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 303;

            goto try_except_handler_21;
        }
        goto condexpr_end_9;
        condexpr_false_9:;
        tmp_assign_source_79 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_79);
        condexpr_end_9:;
        assert(tmp_class_creation_9__metaclass == NULL);
        tmp_class_creation_9__metaclass = tmp_assign_source_79;
    }
    {
        PyObject *tmp_assign_source_80;
        PyObject *tmp_called_name_19;
        PyObject *tmp_args_element_name_36;
        PyObject *tmp_args_element_name_37;
        PyObject *tmp_args_element_name_38;
        CHECK_OBJECT(tmp_class_creation_9__metaclass);
        tmp_called_name_19 = tmp_class_creation_9__metaclass;
        tmp_args_element_name_36 = const_str_plain_AccessDescription;
        tmp_args_element_name_37 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_9__class_dict);
        tmp_args_element_name_38 = tmp_class_creation_9__class_dict;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 303;
        {
            PyObject *call_args[] = {tmp_args_element_name_36, tmp_args_element_name_37, tmp_args_element_name_38};
            tmp_assign_source_80 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_19, call_args);
        }

        if (tmp_assign_source_80 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 303;

            goto try_except_handler_21;
        }
        assert(tmp_class_creation_9__class == NULL);
        tmp_class_creation_9__class = tmp_assign_source_80;
    }
    goto try_end_13;
    // Exception handler code:
    try_except_handler_21:;
    exception_keeper_type_19 = exception_type;
    exception_keeper_value_19 = exception_value;
    exception_keeper_tb_19 = exception_tb;
    exception_keeper_lineno_19 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_9__class_dict);
    tmp_class_creation_9__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_9__metaclass);
    tmp_class_creation_9__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_19;
    exception_value = exception_keeper_value_19;
    exception_tb = exception_keeper_tb_19;
    exception_lineno = exception_keeper_lineno_19;

    goto frame_exception_exit_1;
    // End of try:
    try_end_13:;
    {
        PyObject *tmp_assign_source_81;
        CHECK_OBJECT(tmp_class_creation_9__class);
        tmp_assign_source_81 = tmp_class_creation_9__class;
        UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_AccessDescription, tmp_assign_source_81);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_9__class);
    Py_DECREF(tmp_class_creation_9__class);
    tmp_class_creation_9__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_9__class_dict);
    Py_DECREF(tmp_class_creation_9__class_dict);
    tmp_class_creation_9__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_9__metaclass);
    Py_DECREF(tmp_class_creation_9__metaclass);
    tmp_class_creation_9__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_82;
        {
            PyObject *tmp_set_locals_7;
            tmp_set_locals_7 = PyDict_New();
            locals_cryptography$x509$extensions_340 = tmp_set_locals_7;
        }
        tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_340, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_10cbbfd8fde45d6af5689d9068ecbd4d_8, codeobj_10cbbfd8fde45d6af5689d9068ecbd4d, module_cryptography$x509$extensions, 0);
        frame_10cbbfd8fde45d6af5689d9068ecbd4d_8 = cache_frame_10cbbfd8fde45d6af5689d9068ecbd4d_8;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_10cbbfd8fde45d6af5689d9068ecbd4d_8);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_10cbbfd8fde45d6af5689d9068ecbd4d_8) == 2); // Frame stack

        // Framed code:
        {
            PyObject *tmp_source_name_11;
            PyObject *tmp_mvar_value_23;
            tmp_mvar_value_23 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID);

            if (unlikely(tmp_mvar_value_23 == NULL)) {
                tmp_mvar_value_23 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionOID);
            }

            if (tmp_mvar_value_23 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 23410 ], 34, 0);
                exception_tb = NULL;

                exception_lineno = 341;

                goto frame_exception_exit_8;
            }

            tmp_source_name_11 = tmp_mvar_value_23;
            tmp_dictset_value = LOOKUP_ATTRIBUTE(tmp_source_name_11, const_str_plain_BASIC_CONSTRAINTS);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 341;

                goto frame_exception_exit_8;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_340, const_str_plain_oid, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 341;

                goto frame_exception_exit_8;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_43___init__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_340, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        {
            PyObject *tmp_called_instance_9;
            PyObject *tmp_mvar_value_24;
            tmp_mvar_value_24 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_24 == NULL)) {
                tmp_mvar_value_24 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_24 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 361;

                goto frame_exception_exit_8;
            }

            tmp_called_instance_9 = tmp_mvar_value_24;
            frame_10cbbfd8fde45d6af5689d9068ecbd4d_8->m_frame.f_lineno = 361;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_9, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__ca_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 361;

                goto frame_exception_exit_8;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_340, const_str_plain_ca, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 361;

                goto frame_exception_exit_8;
            }
        }
        {
            PyObject *tmp_called_instance_10;
            PyObject *tmp_mvar_value_25;
            tmp_mvar_value_25 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_25 == NULL)) {
                tmp_mvar_value_25 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_25 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 362;

                goto frame_exception_exit_8;
            }

            tmp_called_instance_10 = tmp_mvar_value_25;
            frame_10cbbfd8fde45d6af5689d9068ecbd4d_8->m_frame.f_lineno = 362;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_10, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__path_length_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 362;

                goto frame_exception_exit_8;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_340, const_str_plain_path_length, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 362;

                goto frame_exception_exit_8;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_10cbbfd8fde45d6af5689d9068ecbd4d_8);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_7;

        frame_exception_exit_8:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_10cbbfd8fde45d6af5689d9068ecbd4d_8);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_10cbbfd8fde45d6af5689d9068ecbd4d_8, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_10cbbfd8fde45d6af5689d9068ecbd4d_8->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_10cbbfd8fde45d6af5689d9068ecbd4d_8, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_10cbbfd8fde45d6af5689d9068ecbd4d_8,
            type_description_2
        );


        // Release cached frame.
        if (frame_10cbbfd8fde45d6af5689d9068ecbd4d_8 == cache_frame_10cbbfd8fde45d6af5689d9068ecbd4d_8) {
            Py_DECREF(frame_10cbbfd8fde45d6af5689d9068ecbd4d_8);
        }
        cache_frame_10cbbfd8fde45d6af5689d9068ecbd4d_8 = NULL;

        assertFrameObject(frame_10cbbfd8fde45d6af5689d9068ecbd4d_8);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_7;

        frame_no_exception_7:;
        goto skip_nested_handling_7;
        nested_frame_exit_7:;

        goto try_except_handler_24;
        skip_nested_handling_7:;
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_44___repr__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_340, const_str_plain___repr__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_45___eq__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_340, const_str_plain___eq__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_46___ne__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_340, const_str_plain___ne__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_47___hash__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_340, const_str_plain___hash__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_assign_source_82 = locals_cryptography$x509$extensions_340;
        Py_INCREF(tmp_assign_source_82);
        goto try_return_handler_24;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Return handler code:
        try_return_handler_24:;
        Py_DECREF(locals_cryptography$x509$extensions_340);
        locals_cryptography$x509$extensions_340 = NULL;
        goto outline_result_10;
        // Exception handler code:
        try_except_handler_24:;
        exception_keeper_type_20 = exception_type;
        exception_keeper_value_20 = exception_value;
        exception_keeper_tb_20 = exception_tb;
        exception_keeper_lineno_20 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_cryptography$x509$extensions_340);
        locals_cryptography$x509$extensions_340 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_20;
        exception_value = exception_keeper_value_20;
        exception_tb = exception_keeper_tb_20;
        exception_lineno = exception_keeper_lineno_20;

        goto outline_exception_7;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        outline_exception_7:;
        exception_lineno = 340;
        goto try_except_handler_23;
        outline_result_10:;
        assert(tmp_class_creation_10__class_dict == NULL);
        tmp_class_creation_10__class_dict = tmp_assign_source_82;
    }
    {
        PyObject *tmp_assign_source_83;
        nuitka_bool tmp_condition_result_10;
        PyObject *tmp_key_name_19;
        PyObject *tmp_dict_name_19;
        PyObject *tmp_dict_name_20;
        PyObject *tmp_key_name_20;
        tmp_key_name_19 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_10__class_dict);
        tmp_dict_name_19 = tmp_class_creation_10__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_19, tmp_key_name_19);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 340;

            goto try_except_handler_23;
        }
        tmp_condition_result_10 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_10 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_10;
        } else {
            goto condexpr_false_10;
        }
        condexpr_true_10:;
        CHECK_OBJECT(tmp_class_creation_10__class_dict);
        tmp_dict_name_20 = tmp_class_creation_10__class_dict;
        tmp_key_name_20 = const_str_plain___metaclass__;
        tmp_assign_source_83 = DICT_GET_ITEM(tmp_dict_name_20, tmp_key_name_20);
        if (tmp_assign_source_83 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 340;

            goto try_except_handler_23;
        }
        goto condexpr_end_10;
        condexpr_false_10:;
        tmp_assign_source_83 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_83);
        condexpr_end_10:;
        assert(tmp_class_creation_10__metaclass == NULL);
        tmp_class_creation_10__metaclass = tmp_assign_source_83;
    }
    {
        PyObject *tmp_assign_source_84;
        PyObject *tmp_called_name_20;
        PyObject *tmp_args_element_name_39;
        PyObject *tmp_args_element_name_40;
        PyObject *tmp_args_element_name_41;
        CHECK_OBJECT(tmp_class_creation_10__metaclass);
        tmp_called_name_20 = tmp_class_creation_10__metaclass;
        tmp_args_element_name_39 = const_str_plain_BasicConstraints;
        tmp_args_element_name_40 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_10__class_dict);
        tmp_args_element_name_41 = tmp_class_creation_10__class_dict;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 340;
        {
            PyObject *call_args[] = {tmp_args_element_name_39, tmp_args_element_name_40, tmp_args_element_name_41};
            tmp_assign_source_84 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_20, call_args);
        }

        if (tmp_assign_source_84 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 340;

            goto try_except_handler_23;
        }
        assert(tmp_class_creation_10__class == NULL);
        tmp_class_creation_10__class = tmp_assign_source_84;
    }
    {
        PyObject *tmp_assign_source_85;
        PyObject *tmp_called_name_21;
        PyObject *tmp_called_name_22;
        PyObject *tmp_source_name_12;
        PyObject *tmp_mvar_value_26;
        PyObject *tmp_args_element_name_42;
        PyObject *tmp_mvar_value_27;
        PyObject *tmp_args_element_name_43;
        tmp_mvar_value_26 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

        if (unlikely(tmp_mvar_value_26 == NULL)) {
            tmp_mvar_value_26 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
        }

        if (tmp_mvar_value_26 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
            exception_tb = NULL;

            exception_lineno = 339;

            goto try_except_handler_23;
        }

        tmp_source_name_12 = tmp_mvar_value_26;
        tmp_called_name_22 = LOOKUP_ATTRIBUTE(tmp_source_name_12, const_str_plain_register_interface);
        if (tmp_called_name_22 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 339;

            goto try_except_handler_23;
        }
        tmp_mvar_value_27 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType);

        if (unlikely(tmp_mvar_value_27 == NULL)) {
            tmp_mvar_value_27 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType);
        }

        if (tmp_mvar_value_27 == NULL) {
            Py_DECREF(tmp_called_name_22);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 35484 ], 35, 0);
            exception_tb = NULL;

            exception_lineno = 339;

            goto try_except_handler_23;
        }

        tmp_args_element_name_42 = tmp_mvar_value_27;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 339;
        tmp_called_name_21 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_22, tmp_args_element_name_42);
        Py_DECREF(tmp_called_name_22);
        if (tmp_called_name_21 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 339;

            goto try_except_handler_23;
        }
        CHECK_OBJECT(tmp_class_creation_10__class);
        tmp_args_element_name_43 = tmp_class_creation_10__class;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 339;
        tmp_assign_source_85 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_21, tmp_args_element_name_43);
        Py_DECREF(tmp_called_name_21);
        if (tmp_assign_source_85 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 339;

            goto try_except_handler_23;
        }
        {
            PyObject *old = tmp_class_creation_10__class;
            assert(old != NULL);
            tmp_class_creation_10__class = tmp_assign_source_85;
            Py_DECREF(old);
        }

    }
    goto try_end_14;
    // Exception handler code:
    try_except_handler_23:;
    exception_keeper_type_21 = exception_type;
    exception_keeper_value_21 = exception_value;
    exception_keeper_tb_21 = exception_tb;
    exception_keeper_lineno_21 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_10__class);
    tmp_class_creation_10__class = NULL;

    Py_XDECREF(tmp_class_creation_10__class_dict);
    tmp_class_creation_10__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_10__metaclass);
    tmp_class_creation_10__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_21;
    exception_value = exception_keeper_value_21;
    exception_tb = exception_keeper_tb_21;
    exception_lineno = exception_keeper_lineno_21;

    goto frame_exception_exit_1;
    // End of try:
    try_end_14:;
    {
        PyObject *tmp_assign_source_86;
        CHECK_OBJECT(tmp_class_creation_10__class);
        tmp_assign_source_86 = tmp_class_creation_10__class;
        UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_BasicConstraints, tmp_assign_source_86);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_10__class);
    Py_DECREF(tmp_class_creation_10__class);
    tmp_class_creation_10__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_10__class_dict);
    Py_DECREF(tmp_class_creation_10__class_dict);
    tmp_class_creation_10__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_10__metaclass);
    Py_DECREF(tmp_class_creation_10__metaclass);
    tmp_class_creation_10__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_87;
        {
            PyObject *tmp_set_locals_8;
            tmp_set_locals_8 = PyDict_New();
            locals_cryptography$x509$extensions_382 = tmp_set_locals_8;
        }
        tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_382, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_c40257bc666664b368a90a2bb591b69e_9, codeobj_c40257bc666664b368a90a2bb591b69e, module_cryptography$x509$extensions, 0);
        frame_c40257bc666664b368a90a2bb591b69e_9 = cache_frame_c40257bc666664b368a90a2bb591b69e_9;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_c40257bc666664b368a90a2bb591b69e_9);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_c40257bc666664b368a90a2bb591b69e_9) == 2); // Frame stack

        // Framed code:
        {
            PyObject *tmp_source_name_13;
            PyObject *tmp_mvar_value_28;
            tmp_mvar_value_28 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID);

            if (unlikely(tmp_mvar_value_28 == NULL)) {
                tmp_mvar_value_28 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionOID);
            }

            if (tmp_mvar_value_28 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 23410 ], 34, 0);
                exception_tb = NULL;

                exception_lineno = 383;

                goto frame_exception_exit_9;
            }

            tmp_source_name_13 = tmp_mvar_value_28;
            tmp_dictset_value = LOOKUP_ATTRIBUTE(tmp_source_name_13, const_str_plain_DELTA_CRL_INDICATOR);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 383;

                goto frame_exception_exit_9;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_382, const_str_plain_oid, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 383;

                goto frame_exception_exit_9;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_48___init__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_382, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        {
            PyObject *tmp_called_instance_11;
            PyObject *tmp_mvar_value_29;
            tmp_mvar_value_29 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_29 == NULL)) {
                tmp_mvar_value_29 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_29 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 391;

                goto frame_exception_exit_9;
            }

            tmp_called_instance_11 = tmp_mvar_value_29;
            frame_c40257bc666664b368a90a2bb591b69e_9->m_frame.f_lineno = 391;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_11, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__crl_number_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 391;

                goto frame_exception_exit_9;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_382, const_str_plain_crl_number, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 391;

                goto frame_exception_exit_9;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_c40257bc666664b368a90a2bb591b69e_9);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_8;

        frame_exception_exit_9:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_c40257bc666664b368a90a2bb591b69e_9);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_c40257bc666664b368a90a2bb591b69e_9, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_c40257bc666664b368a90a2bb591b69e_9->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_c40257bc666664b368a90a2bb591b69e_9, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_c40257bc666664b368a90a2bb591b69e_9,
            type_description_2
        );


        // Release cached frame.
        if (frame_c40257bc666664b368a90a2bb591b69e_9 == cache_frame_c40257bc666664b368a90a2bb591b69e_9) {
            Py_DECREF(frame_c40257bc666664b368a90a2bb591b69e_9);
        }
        cache_frame_c40257bc666664b368a90a2bb591b69e_9 = NULL;

        assertFrameObject(frame_c40257bc666664b368a90a2bb591b69e_9);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_8;

        frame_no_exception_8:;
        goto skip_nested_handling_8;
        nested_frame_exit_8:;

        goto try_except_handler_26;
        skip_nested_handling_8:;
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_49___eq__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_382, const_str_plain___eq__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_50___ne__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_382, const_str_plain___ne__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_51___hash__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_382, const_str_plain___hash__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_52___repr__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_382, const_str_plain___repr__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_assign_source_87 = locals_cryptography$x509$extensions_382;
        Py_INCREF(tmp_assign_source_87);
        goto try_return_handler_26;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Return handler code:
        try_return_handler_26:;
        Py_DECREF(locals_cryptography$x509$extensions_382);
        locals_cryptography$x509$extensions_382 = NULL;
        goto outline_result_11;
        // Exception handler code:
        try_except_handler_26:;
        exception_keeper_type_22 = exception_type;
        exception_keeper_value_22 = exception_value;
        exception_keeper_tb_22 = exception_tb;
        exception_keeper_lineno_22 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_cryptography$x509$extensions_382);
        locals_cryptography$x509$extensions_382 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_22;
        exception_value = exception_keeper_value_22;
        exception_tb = exception_keeper_tb_22;
        exception_lineno = exception_keeper_lineno_22;

        goto outline_exception_8;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        outline_exception_8:;
        exception_lineno = 382;
        goto try_except_handler_25;
        outline_result_11:;
        assert(tmp_class_creation_11__class_dict == NULL);
        tmp_class_creation_11__class_dict = tmp_assign_source_87;
    }
    {
        PyObject *tmp_assign_source_88;
        nuitka_bool tmp_condition_result_11;
        PyObject *tmp_key_name_21;
        PyObject *tmp_dict_name_21;
        PyObject *tmp_dict_name_22;
        PyObject *tmp_key_name_22;
        tmp_key_name_21 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_11__class_dict);
        tmp_dict_name_21 = tmp_class_creation_11__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_21, tmp_key_name_21);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 382;

            goto try_except_handler_25;
        }
        tmp_condition_result_11 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_11 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_11;
        } else {
            goto condexpr_false_11;
        }
        condexpr_true_11:;
        CHECK_OBJECT(tmp_class_creation_11__class_dict);
        tmp_dict_name_22 = tmp_class_creation_11__class_dict;
        tmp_key_name_22 = const_str_plain___metaclass__;
        tmp_assign_source_88 = DICT_GET_ITEM(tmp_dict_name_22, tmp_key_name_22);
        if (tmp_assign_source_88 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 382;

            goto try_except_handler_25;
        }
        goto condexpr_end_11;
        condexpr_false_11:;
        tmp_assign_source_88 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_88);
        condexpr_end_11:;
        assert(tmp_class_creation_11__metaclass == NULL);
        tmp_class_creation_11__metaclass = tmp_assign_source_88;
    }
    {
        PyObject *tmp_assign_source_89;
        PyObject *tmp_called_name_23;
        PyObject *tmp_args_element_name_44;
        PyObject *tmp_args_element_name_45;
        PyObject *tmp_args_element_name_46;
        CHECK_OBJECT(tmp_class_creation_11__metaclass);
        tmp_called_name_23 = tmp_class_creation_11__metaclass;
        tmp_args_element_name_44 = const_str_plain_DeltaCRLIndicator;
        tmp_args_element_name_45 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_11__class_dict);
        tmp_args_element_name_46 = tmp_class_creation_11__class_dict;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 382;
        {
            PyObject *call_args[] = {tmp_args_element_name_44, tmp_args_element_name_45, tmp_args_element_name_46};
            tmp_assign_source_89 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_23, call_args);
        }

        if (tmp_assign_source_89 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 382;

            goto try_except_handler_25;
        }
        assert(tmp_class_creation_11__class == NULL);
        tmp_class_creation_11__class = tmp_assign_source_89;
    }
    {
        PyObject *tmp_assign_source_90;
        PyObject *tmp_called_name_24;
        PyObject *tmp_called_name_25;
        PyObject *tmp_source_name_14;
        PyObject *tmp_mvar_value_30;
        PyObject *tmp_args_element_name_47;
        PyObject *tmp_mvar_value_31;
        PyObject *tmp_args_element_name_48;
        tmp_mvar_value_30 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

        if (unlikely(tmp_mvar_value_30 == NULL)) {
            tmp_mvar_value_30 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
        }

        if (tmp_mvar_value_30 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
            exception_tb = NULL;

            exception_lineno = 381;

            goto try_except_handler_25;
        }

        tmp_source_name_14 = tmp_mvar_value_30;
        tmp_called_name_25 = LOOKUP_ATTRIBUTE(tmp_source_name_14, const_str_plain_register_interface);
        if (tmp_called_name_25 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 381;

            goto try_except_handler_25;
        }
        tmp_mvar_value_31 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType);

        if (unlikely(tmp_mvar_value_31 == NULL)) {
            tmp_mvar_value_31 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType);
        }

        if (tmp_mvar_value_31 == NULL) {
            Py_DECREF(tmp_called_name_25);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 35484 ], 35, 0);
            exception_tb = NULL;

            exception_lineno = 381;

            goto try_except_handler_25;
        }

        tmp_args_element_name_47 = tmp_mvar_value_31;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 381;
        tmp_called_name_24 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_25, tmp_args_element_name_47);
        Py_DECREF(tmp_called_name_25);
        if (tmp_called_name_24 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 381;

            goto try_except_handler_25;
        }
        CHECK_OBJECT(tmp_class_creation_11__class);
        tmp_args_element_name_48 = tmp_class_creation_11__class;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 381;
        tmp_assign_source_90 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_24, tmp_args_element_name_48);
        Py_DECREF(tmp_called_name_24);
        if (tmp_assign_source_90 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 381;

            goto try_except_handler_25;
        }
        {
            PyObject *old = tmp_class_creation_11__class;
            assert(old != NULL);
            tmp_class_creation_11__class = tmp_assign_source_90;
            Py_DECREF(old);
        }

    }
    goto try_end_15;
    // Exception handler code:
    try_except_handler_25:;
    exception_keeper_type_23 = exception_type;
    exception_keeper_value_23 = exception_value;
    exception_keeper_tb_23 = exception_tb;
    exception_keeper_lineno_23 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_11__class);
    tmp_class_creation_11__class = NULL;

    Py_XDECREF(tmp_class_creation_11__class_dict);
    tmp_class_creation_11__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_11__metaclass);
    tmp_class_creation_11__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_23;
    exception_value = exception_keeper_value_23;
    exception_tb = exception_keeper_tb_23;
    exception_lineno = exception_keeper_lineno_23;

    goto frame_exception_exit_1;
    // End of try:
    try_end_15:;
    {
        PyObject *tmp_assign_source_91;
        CHECK_OBJECT(tmp_class_creation_11__class);
        tmp_assign_source_91 = tmp_class_creation_11__class;
        UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_DeltaCRLIndicator, tmp_assign_source_91);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_11__class);
    Py_DECREF(tmp_class_creation_11__class);
    tmp_class_creation_11__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_11__class_dict);
    Py_DECREF(tmp_class_creation_11__class_dict);
    tmp_class_creation_11__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_11__metaclass);
    Py_DECREF(tmp_class_creation_11__metaclass);
    tmp_class_creation_11__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_92;
        {
            PyObject *tmp_set_locals_9;
            tmp_set_locals_9 = PyDict_New();
            locals_cryptography$x509$extensions_410 = tmp_set_locals_9;
        }
        tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_410, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_8cf535c0875cf42bdef61b5101de9850_10, codeobj_8cf535c0875cf42bdef61b5101de9850, module_cryptography$x509$extensions, 0);
        frame_8cf535c0875cf42bdef61b5101de9850_10 = cache_frame_8cf535c0875cf42bdef61b5101de9850_10;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_8cf535c0875cf42bdef61b5101de9850_10);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_8cf535c0875cf42bdef61b5101de9850_10) == 2); // Frame stack

        // Framed code:
        {
            PyObject *tmp_source_name_15;
            PyObject *tmp_mvar_value_32;
            tmp_mvar_value_32 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID);

            if (unlikely(tmp_mvar_value_32 == NULL)) {
                tmp_mvar_value_32 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionOID);
            }

            if (tmp_mvar_value_32 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 23410 ], 34, 0);
                exception_tb = NULL;

                exception_lineno = 411;

                goto frame_exception_exit_10;
            }

            tmp_source_name_15 = tmp_mvar_value_32;
            tmp_dictset_value = LOOKUP_ATTRIBUTE(tmp_source_name_15, const_str_plain_CRL_DISTRIBUTION_POINTS);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 411;

                goto frame_exception_exit_10;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_410, const_str_plain_oid, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 411;

                goto frame_exception_exit_10;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_8cf535c0875cf42bdef61b5101de9850_10);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_9;

        frame_exception_exit_10:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_8cf535c0875cf42bdef61b5101de9850_10);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_8cf535c0875cf42bdef61b5101de9850_10, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_8cf535c0875cf42bdef61b5101de9850_10->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_8cf535c0875cf42bdef61b5101de9850_10, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_8cf535c0875cf42bdef61b5101de9850_10,
            type_description_2
        );


        // Release cached frame.
        if (frame_8cf535c0875cf42bdef61b5101de9850_10 == cache_frame_8cf535c0875cf42bdef61b5101de9850_10) {
            Py_DECREF(frame_8cf535c0875cf42bdef61b5101de9850_10);
        }
        cache_frame_8cf535c0875cf42bdef61b5101de9850_10 = NULL;

        assertFrameObject(frame_8cf535c0875cf42bdef61b5101de9850_10);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_9;

        frame_no_exception_9:;
        goto skip_nested_handling_9;
        nested_frame_exit_9:;

        goto try_except_handler_28;
        skip_nested_handling_9:;
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_53___init__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_410, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_54___iter__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_410, const_str_plain___iter__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_55___len__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_410, const_str_plain___len__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_56___repr__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_410, const_str_plain___repr__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_57___eq__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_410, const_str_plain___eq__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_58___ne__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_410, const_str_plain___ne__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_59___getitem__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_410, const_str_plain___getitem__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_60___hash__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_410, const_str_plain___hash__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_assign_source_92 = locals_cryptography$x509$extensions_410;
        Py_INCREF(tmp_assign_source_92);
        goto try_return_handler_28;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Return handler code:
        try_return_handler_28:;
        Py_DECREF(locals_cryptography$x509$extensions_410);
        locals_cryptography$x509$extensions_410 = NULL;
        goto outline_result_12;
        // Exception handler code:
        try_except_handler_28:;
        exception_keeper_type_24 = exception_type;
        exception_keeper_value_24 = exception_value;
        exception_keeper_tb_24 = exception_tb;
        exception_keeper_lineno_24 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_cryptography$x509$extensions_410);
        locals_cryptography$x509$extensions_410 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_24;
        exception_value = exception_keeper_value_24;
        exception_tb = exception_keeper_tb_24;
        exception_lineno = exception_keeper_lineno_24;

        goto outline_exception_9;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        outline_exception_9:;
        exception_lineno = 410;
        goto try_except_handler_27;
        outline_result_12:;
        assert(tmp_class_creation_12__class_dict == NULL);
        tmp_class_creation_12__class_dict = tmp_assign_source_92;
    }
    {
        PyObject *tmp_assign_source_93;
        nuitka_bool tmp_condition_result_12;
        PyObject *tmp_key_name_23;
        PyObject *tmp_dict_name_23;
        PyObject *tmp_dict_name_24;
        PyObject *tmp_key_name_24;
        tmp_key_name_23 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_12__class_dict);
        tmp_dict_name_23 = tmp_class_creation_12__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_23, tmp_key_name_23);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 410;

            goto try_except_handler_27;
        }
        tmp_condition_result_12 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_12 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_12;
        } else {
            goto condexpr_false_12;
        }
        condexpr_true_12:;
        CHECK_OBJECT(tmp_class_creation_12__class_dict);
        tmp_dict_name_24 = tmp_class_creation_12__class_dict;
        tmp_key_name_24 = const_str_plain___metaclass__;
        tmp_assign_source_93 = DICT_GET_ITEM(tmp_dict_name_24, tmp_key_name_24);
        if (tmp_assign_source_93 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 410;

            goto try_except_handler_27;
        }
        goto condexpr_end_12;
        condexpr_false_12:;
        tmp_assign_source_93 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_93);
        condexpr_end_12:;
        assert(tmp_class_creation_12__metaclass == NULL);
        tmp_class_creation_12__metaclass = tmp_assign_source_93;
    }
    {
        PyObject *tmp_assign_source_94;
        PyObject *tmp_called_name_26;
        PyObject *tmp_args_element_name_49;
        PyObject *tmp_args_element_name_50;
        PyObject *tmp_args_element_name_51;
        CHECK_OBJECT(tmp_class_creation_12__metaclass);
        tmp_called_name_26 = tmp_class_creation_12__metaclass;
        tmp_args_element_name_49 = const_str_plain_CRLDistributionPoints;
        tmp_args_element_name_50 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_12__class_dict);
        tmp_args_element_name_51 = tmp_class_creation_12__class_dict;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 410;
        {
            PyObject *call_args[] = {tmp_args_element_name_49, tmp_args_element_name_50, tmp_args_element_name_51};
            tmp_assign_source_94 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_26, call_args);
        }

        if (tmp_assign_source_94 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 410;

            goto try_except_handler_27;
        }
        assert(tmp_class_creation_12__class == NULL);
        tmp_class_creation_12__class = tmp_assign_source_94;
    }
    {
        PyObject *tmp_assign_source_95;
        PyObject *tmp_called_name_27;
        PyObject *tmp_called_name_28;
        PyObject *tmp_source_name_16;
        PyObject *tmp_mvar_value_33;
        PyObject *tmp_args_element_name_52;
        PyObject *tmp_mvar_value_34;
        PyObject *tmp_args_element_name_53;
        tmp_mvar_value_33 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

        if (unlikely(tmp_mvar_value_33 == NULL)) {
            tmp_mvar_value_33 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
        }

        if (tmp_mvar_value_33 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
            exception_tb = NULL;

            exception_lineno = 409;

            goto try_except_handler_27;
        }

        tmp_source_name_16 = tmp_mvar_value_33;
        tmp_called_name_28 = LOOKUP_ATTRIBUTE(tmp_source_name_16, const_str_plain_register_interface);
        if (tmp_called_name_28 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 409;

            goto try_except_handler_27;
        }
        tmp_mvar_value_34 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType);

        if (unlikely(tmp_mvar_value_34 == NULL)) {
            tmp_mvar_value_34 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType);
        }

        if (tmp_mvar_value_34 == NULL) {
            Py_DECREF(tmp_called_name_28);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 35484 ], 35, 0);
            exception_tb = NULL;

            exception_lineno = 409;

            goto try_except_handler_27;
        }

        tmp_args_element_name_52 = tmp_mvar_value_34;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 409;
        tmp_called_name_27 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_28, tmp_args_element_name_52);
        Py_DECREF(tmp_called_name_28);
        if (tmp_called_name_27 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 409;

            goto try_except_handler_27;
        }
        CHECK_OBJECT(tmp_class_creation_12__class);
        tmp_args_element_name_53 = tmp_class_creation_12__class;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 409;
        tmp_assign_source_95 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_27, tmp_args_element_name_53);
        Py_DECREF(tmp_called_name_27);
        if (tmp_assign_source_95 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 409;

            goto try_except_handler_27;
        }
        {
            PyObject *old = tmp_class_creation_12__class;
            assert(old != NULL);
            tmp_class_creation_12__class = tmp_assign_source_95;
            Py_DECREF(old);
        }

    }
    goto try_end_16;
    // Exception handler code:
    try_except_handler_27:;
    exception_keeper_type_25 = exception_type;
    exception_keeper_value_25 = exception_value;
    exception_keeper_tb_25 = exception_tb;
    exception_keeper_lineno_25 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_12__class);
    tmp_class_creation_12__class = NULL;

    Py_XDECREF(tmp_class_creation_12__class_dict);
    tmp_class_creation_12__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_12__metaclass);
    tmp_class_creation_12__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_25;
    exception_value = exception_keeper_value_25;
    exception_tb = exception_keeper_tb_25;
    exception_lineno = exception_keeper_lineno_25;

    goto frame_exception_exit_1;
    // End of try:
    try_end_16:;
    {
        PyObject *tmp_assign_source_96;
        CHECK_OBJECT(tmp_class_creation_12__class);
        tmp_assign_source_96 = tmp_class_creation_12__class;
        UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_CRLDistributionPoints, tmp_assign_source_96);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_12__class);
    Py_DECREF(tmp_class_creation_12__class);
    tmp_class_creation_12__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_12__class_dict);
    Py_DECREF(tmp_class_creation_12__class_dict);
    tmp_class_creation_12__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_12__metaclass);
    Py_DECREF(tmp_class_creation_12__metaclass);
    tmp_class_creation_12__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_97;
        {
            PyObject *tmp_set_locals_10;
            tmp_set_locals_10 = PyDict_New();
            locals_cryptography$x509$extensions_451 = tmp_set_locals_10;
        }
        tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_451, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_8be8c331db6797002bac5a779f59022d_11, codeobj_8be8c331db6797002bac5a779f59022d, module_cryptography$x509$extensions, 0);
        frame_8be8c331db6797002bac5a779f59022d_11 = cache_frame_8be8c331db6797002bac5a779f59022d_11;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_8be8c331db6797002bac5a779f59022d_11);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_8be8c331db6797002bac5a779f59022d_11) == 2); // Frame stack

        // Framed code:
        {
            PyObject *tmp_source_name_17;
            PyObject *tmp_mvar_value_35;
            tmp_mvar_value_35 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID);

            if (unlikely(tmp_mvar_value_35 == NULL)) {
                tmp_mvar_value_35 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionOID);
            }

            if (tmp_mvar_value_35 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 23410 ], 34, 0);
                exception_tb = NULL;

                exception_lineno = 452;

                goto frame_exception_exit_11;
            }

            tmp_source_name_17 = tmp_mvar_value_35;
            tmp_dictset_value = LOOKUP_ATTRIBUTE(tmp_source_name_17, const_str_plain_FRESHEST_CRL);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 452;

                goto frame_exception_exit_11;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_451, const_str_plain_oid, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 452;

                goto frame_exception_exit_11;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_8be8c331db6797002bac5a779f59022d_11);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_10;

        frame_exception_exit_11:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_8be8c331db6797002bac5a779f59022d_11);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_8be8c331db6797002bac5a779f59022d_11, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_8be8c331db6797002bac5a779f59022d_11->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_8be8c331db6797002bac5a779f59022d_11, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_8be8c331db6797002bac5a779f59022d_11,
            type_description_2
        );


        // Release cached frame.
        if (frame_8be8c331db6797002bac5a779f59022d_11 == cache_frame_8be8c331db6797002bac5a779f59022d_11) {
            Py_DECREF(frame_8be8c331db6797002bac5a779f59022d_11);
        }
        cache_frame_8be8c331db6797002bac5a779f59022d_11 = NULL;

        assertFrameObject(frame_8be8c331db6797002bac5a779f59022d_11);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_10;

        frame_no_exception_10:;
        goto skip_nested_handling_10;
        nested_frame_exit_10:;

        goto try_except_handler_30;
        skip_nested_handling_10:;
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_61___init__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_451, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_62___iter__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_451, const_str_plain___iter__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_63___len__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_451, const_str_plain___len__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_64___repr__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_451, const_str_plain___repr__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_65___eq__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_451, const_str_plain___eq__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_66___ne__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_451, const_str_plain___ne__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_67___getitem__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_451, const_str_plain___getitem__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_68___hash__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_451, const_str_plain___hash__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_assign_source_97 = locals_cryptography$x509$extensions_451;
        Py_INCREF(tmp_assign_source_97);
        goto try_return_handler_30;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Return handler code:
        try_return_handler_30:;
        Py_DECREF(locals_cryptography$x509$extensions_451);
        locals_cryptography$x509$extensions_451 = NULL;
        goto outline_result_13;
        // Exception handler code:
        try_except_handler_30:;
        exception_keeper_type_26 = exception_type;
        exception_keeper_value_26 = exception_value;
        exception_keeper_tb_26 = exception_tb;
        exception_keeper_lineno_26 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_cryptography$x509$extensions_451);
        locals_cryptography$x509$extensions_451 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_26;
        exception_value = exception_keeper_value_26;
        exception_tb = exception_keeper_tb_26;
        exception_lineno = exception_keeper_lineno_26;

        goto outline_exception_10;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        outline_exception_10:;
        exception_lineno = 451;
        goto try_except_handler_29;
        outline_result_13:;
        assert(tmp_class_creation_13__class_dict == NULL);
        tmp_class_creation_13__class_dict = tmp_assign_source_97;
    }
    {
        PyObject *tmp_assign_source_98;
        nuitka_bool tmp_condition_result_13;
        PyObject *tmp_key_name_25;
        PyObject *tmp_dict_name_25;
        PyObject *tmp_dict_name_26;
        PyObject *tmp_key_name_26;
        tmp_key_name_25 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_13__class_dict);
        tmp_dict_name_25 = tmp_class_creation_13__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_25, tmp_key_name_25);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 451;

            goto try_except_handler_29;
        }
        tmp_condition_result_13 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_13 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_13;
        } else {
            goto condexpr_false_13;
        }
        condexpr_true_13:;
        CHECK_OBJECT(tmp_class_creation_13__class_dict);
        tmp_dict_name_26 = tmp_class_creation_13__class_dict;
        tmp_key_name_26 = const_str_plain___metaclass__;
        tmp_assign_source_98 = DICT_GET_ITEM(tmp_dict_name_26, tmp_key_name_26);
        if (tmp_assign_source_98 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 451;

            goto try_except_handler_29;
        }
        goto condexpr_end_13;
        condexpr_false_13:;
        tmp_assign_source_98 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_98);
        condexpr_end_13:;
        assert(tmp_class_creation_13__metaclass == NULL);
        tmp_class_creation_13__metaclass = tmp_assign_source_98;
    }
    {
        PyObject *tmp_assign_source_99;
        PyObject *tmp_called_name_29;
        PyObject *tmp_args_element_name_54;
        PyObject *tmp_args_element_name_55;
        PyObject *tmp_args_element_name_56;
        CHECK_OBJECT(tmp_class_creation_13__metaclass);
        tmp_called_name_29 = tmp_class_creation_13__metaclass;
        tmp_args_element_name_54 = const_str_plain_FreshestCRL;
        tmp_args_element_name_55 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_13__class_dict);
        tmp_args_element_name_56 = tmp_class_creation_13__class_dict;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 451;
        {
            PyObject *call_args[] = {tmp_args_element_name_54, tmp_args_element_name_55, tmp_args_element_name_56};
            tmp_assign_source_99 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_29, call_args);
        }

        if (tmp_assign_source_99 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 451;

            goto try_except_handler_29;
        }
        assert(tmp_class_creation_13__class == NULL);
        tmp_class_creation_13__class = tmp_assign_source_99;
    }
    {
        PyObject *tmp_assign_source_100;
        PyObject *tmp_called_name_30;
        PyObject *tmp_called_name_31;
        PyObject *tmp_source_name_18;
        PyObject *tmp_mvar_value_36;
        PyObject *tmp_args_element_name_57;
        PyObject *tmp_mvar_value_37;
        PyObject *tmp_args_element_name_58;
        tmp_mvar_value_36 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

        if (unlikely(tmp_mvar_value_36 == NULL)) {
            tmp_mvar_value_36 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
        }

        if (tmp_mvar_value_36 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
            exception_tb = NULL;

            exception_lineno = 450;

            goto try_except_handler_29;
        }

        tmp_source_name_18 = tmp_mvar_value_36;
        tmp_called_name_31 = LOOKUP_ATTRIBUTE(tmp_source_name_18, const_str_plain_register_interface);
        if (tmp_called_name_31 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 450;

            goto try_except_handler_29;
        }
        tmp_mvar_value_37 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType);

        if (unlikely(tmp_mvar_value_37 == NULL)) {
            tmp_mvar_value_37 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType);
        }

        if (tmp_mvar_value_37 == NULL) {
            Py_DECREF(tmp_called_name_31);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 35484 ], 35, 0);
            exception_tb = NULL;

            exception_lineno = 450;

            goto try_except_handler_29;
        }

        tmp_args_element_name_57 = tmp_mvar_value_37;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 450;
        tmp_called_name_30 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_31, tmp_args_element_name_57);
        Py_DECREF(tmp_called_name_31);
        if (tmp_called_name_30 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 450;

            goto try_except_handler_29;
        }
        CHECK_OBJECT(tmp_class_creation_13__class);
        tmp_args_element_name_58 = tmp_class_creation_13__class;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 450;
        tmp_assign_source_100 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_30, tmp_args_element_name_58);
        Py_DECREF(tmp_called_name_30);
        if (tmp_assign_source_100 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 450;

            goto try_except_handler_29;
        }
        {
            PyObject *old = tmp_class_creation_13__class;
            assert(old != NULL);
            tmp_class_creation_13__class = tmp_assign_source_100;
            Py_DECREF(old);
        }

    }
    goto try_end_17;
    // Exception handler code:
    try_except_handler_29:;
    exception_keeper_type_27 = exception_type;
    exception_keeper_value_27 = exception_value;
    exception_keeper_tb_27 = exception_tb;
    exception_keeper_lineno_27 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_13__class);
    tmp_class_creation_13__class = NULL;

    Py_XDECREF(tmp_class_creation_13__class_dict);
    tmp_class_creation_13__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_13__metaclass);
    tmp_class_creation_13__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_27;
    exception_value = exception_keeper_value_27;
    exception_tb = exception_keeper_tb_27;
    exception_lineno = exception_keeper_lineno_27;

    goto frame_exception_exit_1;
    // End of try:
    try_end_17:;
    {
        PyObject *tmp_assign_source_101;
        CHECK_OBJECT(tmp_class_creation_13__class);
        tmp_assign_source_101 = tmp_class_creation_13__class;
        UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_FreshestCRL, tmp_assign_source_101);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_13__class);
    Py_DECREF(tmp_class_creation_13__class);
    tmp_class_creation_13__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_13__class_dict);
    Py_DECREF(tmp_class_creation_13__class_dict);
    tmp_class_creation_13__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_13__metaclass);
    Py_DECREF(tmp_class_creation_13__metaclass);
    tmp_class_creation_13__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_102;
        {
            PyObject *tmp_set_locals_11;
            tmp_set_locals_11 = PyDict_New();
            locals_cryptography$x509$extensions_491 = tmp_set_locals_11;
        }
        tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_491, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_69___init__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_491, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_70___repr__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_491, const_str_plain___repr__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_71___eq__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_491, const_str_plain___eq__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_72___ne__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_491, const_str_plain___ne__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_73___hash__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_491, const_str_plain___hash__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_d9bb56bd96dd7fc707029f25f9b9879f_12, codeobj_d9bb56bd96dd7fc707029f25f9b9879f, module_cryptography$x509$extensions, 0);
        frame_d9bb56bd96dd7fc707029f25f9b9879f_12 = cache_frame_d9bb56bd96dd7fc707029f25f9b9879f_12;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_d9bb56bd96dd7fc707029f25f9b9879f_12);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_d9bb56bd96dd7fc707029f25f9b9879f_12) == 2); // Frame stack

        // Framed code:
        {
            PyObject *tmp_called_instance_12;
            PyObject *tmp_mvar_value_38;
            tmp_mvar_value_38 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_38 == NULL)) {
                tmp_mvar_value_38 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_38 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 578;

                goto frame_exception_exit_12;
            }

            tmp_called_instance_12 = tmp_mvar_value_38;
            frame_d9bb56bd96dd7fc707029f25f9b9879f_12->m_frame.f_lineno = 578;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_12, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__full_name_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 578;

                goto frame_exception_exit_12;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_491, const_str_plain_full_name, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 578;

                goto frame_exception_exit_12;
            }
        }
        {
            PyObject *tmp_called_instance_13;
            PyObject *tmp_mvar_value_39;
            tmp_mvar_value_39 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_39 == NULL)) {
                tmp_mvar_value_39 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_39 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 579;

                goto frame_exception_exit_12;
            }

            tmp_called_instance_13 = tmp_mvar_value_39;
            frame_d9bb56bd96dd7fc707029f25f9b9879f_12->m_frame.f_lineno = 579;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_13, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__relative_name_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 579;

                goto frame_exception_exit_12;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_491, const_str_plain_relative_name, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 579;

                goto frame_exception_exit_12;
            }
        }
        {
            PyObject *tmp_called_instance_14;
            PyObject *tmp_mvar_value_40;
            tmp_mvar_value_40 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_40 == NULL)) {
                tmp_mvar_value_40 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_40 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 580;

                goto frame_exception_exit_12;
            }

            tmp_called_instance_14 = tmp_mvar_value_40;
            frame_d9bb56bd96dd7fc707029f25f9b9879f_12->m_frame.f_lineno = 580;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_14, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__reasons_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 580;

                goto frame_exception_exit_12;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_491, const_str_plain_reasons, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 580;

                goto frame_exception_exit_12;
            }
        }
        {
            PyObject *tmp_called_instance_15;
            PyObject *tmp_mvar_value_41;
            tmp_mvar_value_41 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_41 == NULL)) {
                tmp_mvar_value_41 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_41 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 581;

                goto frame_exception_exit_12;
            }

            tmp_called_instance_15 = tmp_mvar_value_41;
            frame_d9bb56bd96dd7fc707029f25f9b9879f_12->m_frame.f_lineno = 581;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_15, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__crl_issuer_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 581;

                goto frame_exception_exit_12;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_491, const_str_plain_crl_issuer, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 581;

                goto frame_exception_exit_12;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_d9bb56bd96dd7fc707029f25f9b9879f_12);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_11;

        frame_exception_exit_12:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_d9bb56bd96dd7fc707029f25f9b9879f_12);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_d9bb56bd96dd7fc707029f25f9b9879f_12, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_d9bb56bd96dd7fc707029f25f9b9879f_12->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_d9bb56bd96dd7fc707029f25f9b9879f_12, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_d9bb56bd96dd7fc707029f25f9b9879f_12,
            type_description_2
        );


        // Release cached frame.
        if (frame_d9bb56bd96dd7fc707029f25f9b9879f_12 == cache_frame_d9bb56bd96dd7fc707029f25f9b9879f_12) {
            Py_DECREF(frame_d9bb56bd96dd7fc707029f25f9b9879f_12);
        }
        cache_frame_d9bb56bd96dd7fc707029f25f9b9879f_12 = NULL;

        assertFrameObject(frame_d9bb56bd96dd7fc707029f25f9b9879f_12);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_11;

        frame_no_exception_11:;
        goto skip_nested_handling_11;
        nested_frame_exit_11:;

        goto try_except_handler_32;
        skip_nested_handling_11:;
        tmp_assign_source_102 = locals_cryptography$x509$extensions_491;
        Py_INCREF(tmp_assign_source_102);
        goto try_return_handler_32;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Return handler code:
        try_return_handler_32:;
        Py_DECREF(locals_cryptography$x509$extensions_491);
        locals_cryptography$x509$extensions_491 = NULL;
        goto outline_result_14;
        // Exception handler code:
        try_except_handler_32:;
        exception_keeper_type_28 = exception_type;
        exception_keeper_value_28 = exception_value;
        exception_keeper_tb_28 = exception_tb;
        exception_keeper_lineno_28 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_cryptography$x509$extensions_491);
        locals_cryptography$x509$extensions_491 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_28;
        exception_value = exception_keeper_value_28;
        exception_tb = exception_keeper_tb_28;
        exception_lineno = exception_keeper_lineno_28;

        goto outline_exception_11;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        outline_exception_11:;
        exception_lineno = 491;
        goto try_except_handler_31;
        outline_result_14:;
        assert(tmp_class_creation_14__class_dict == NULL);
        tmp_class_creation_14__class_dict = tmp_assign_source_102;
    }
    {
        PyObject *tmp_assign_source_103;
        nuitka_bool tmp_condition_result_14;
        PyObject *tmp_key_name_27;
        PyObject *tmp_dict_name_27;
        PyObject *tmp_dict_name_28;
        PyObject *tmp_key_name_28;
        tmp_key_name_27 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_14__class_dict);
        tmp_dict_name_27 = tmp_class_creation_14__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_27, tmp_key_name_27);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 491;

            goto try_except_handler_31;
        }
        tmp_condition_result_14 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_14 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_14;
        } else {
            goto condexpr_false_14;
        }
        condexpr_true_14:;
        CHECK_OBJECT(tmp_class_creation_14__class_dict);
        tmp_dict_name_28 = tmp_class_creation_14__class_dict;
        tmp_key_name_28 = const_str_plain___metaclass__;
        tmp_assign_source_103 = DICT_GET_ITEM(tmp_dict_name_28, tmp_key_name_28);
        if (tmp_assign_source_103 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 491;

            goto try_except_handler_31;
        }
        goto condexpr_end_14;
        condexpr_false_14:;
        tmp_assign_source_103 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_103);
        condexpr_end_14:;
        assert(tmp_class_creation_14__metaclass == NULL);
        tmp_class_creation_14__metaclass = tmp_assign_source_103;
    }
    {
        PyObject *tmp_assign_source_104;
        PyObject *tmp_called_name_32;
        PyObject *tmp_args_element_name_59;
        PyObject *tmp_args_element_name_60;
        PyObject *tmp_args_element_name_61;
        CHECK_OBJECT(tmp_class_creation_14__metaclass);
        tmp_called_name_32 = tmp_class_creation_14__metaclass;
        tmp_args_element_name_59 = const_str_plain_DistributionPoint;
        tmp_args_element_name_60 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_14__class_dict);
        tmp_args_element_name_61 = tmp_class_creation_14__class_dict;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 491;
        {
            PyObject *call_args[] = {tmp_args_element_name_59, tmp_args_element_name_60, tmp_args_element_name_61};
            tmp_assign_source_104 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_32, call_args);
        }

        if (tmp_assign_source_104 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 491;

            goto try_except_handler_31;
        }
        assert(tmp_class_creation_14__class == NULL);
        tmp_class_creation_14__class = tmp_assign_source_104;
    }
    goto try_end_18;
    // Exception handler code:
    try_except_handler_31:;
    exception_keeper_type_29 = exception_type;
    exception_keeper_value_29 = exception_value;
    exception_keeper_tb_29 = exception_tb;
    exception_keeper_lineno_29 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_14__class_dict);
    tmp_class_creation_14__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_14__metaclass);
    tmp_class_creation_14__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_29;
    exception_value = exception_keeper_value_29;
    exception_tb = exception_keeper_tb_29;
    exception_lineno = exception_keeper_lineno_29;

    goto frame_exception_exit_1;
    // End of try:
    try_end_18:;
    {
        PyObject *tmp_assign_source_105;
        CHECK_OBJECT(tmp_class_creation_14__class);
        tmp_assign_source_105 = tmp_class_creation_14__class;
        UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_DistributionPoint, tmp_assign_source_105);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_14__class);
    Py_DECREF(tmp_class_creation_14__class);
    tmp_class_creation_14__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_14__class_dict);
    Py_DECREF(tmp_class_creation_14__class_dict);
    tmp_class_creation_14__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_14__metaclass);
    Py_DECREF(tmp_class_creation_14__metaclass);
    tmp_class_creation_14__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_106;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_mvar_value_42;
        tmp_mvar_value_42 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_Enum);

        if (unlikely(tmp_mvar_value_42 == NULL)) {
            tmp_mvar_value_42 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_Enum);
        }

        if (tmp_mvar_value_42 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 34390 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 584;

            goto try_except_handler_33;
        }

        tmp_tuple_element_1 = tmp_mvar_value_42;
        tmp_assign_source_106 = PyTuple_New(1);
        Py_INCREF(tmp_tuple_element_1);
        PyTuple_SET_ITEM(tmp_assign_source_106, 0, tmp_tuple_element_1);
        assert(tmp_class_creation_15__bases == NULL);
        tmp_class_creation_15__bases = tmp_assign_source_106;
    }
    {
        PyObject *tmp_assign_source_107;
        {
            PyObject *tmp_set_locals_12;
            tmp_set_locals_12 = PyDict_New();
            locals_cryptography$x509$extensions_584 = tmp_set_locals_12;
        }
        tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_584, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = const_str_plain_unspecified;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_584, const_str_plain_unspecified, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = const_str_plain_keyCompromise;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_584, const_str_plain_key_compromise, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = const_str_plain_cACompromise;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_584, const_str_plain_ca_compromise, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = const_str_plain_affiliationChanged;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_584, const_str_plain_affiliation_changed, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = const_str_plain_superseded;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_584, const_str_plain_superseded, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = const_str_plain_cessationOfOperation;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_584, const_str_plain_cessation_of_operation, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = const_str_plain_certificateHold;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_584, const_str_plain_certificate_hold, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = const_str_plain_privilegeWithdrawn;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_584, const_str_plain_privilege_withdrawn, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = const_str_plain_aACompromise;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_584, const_str_plain_aa_compromise, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = const_str_plain_removeFromCRL;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_584, const_str_plain_remove_from_crl, tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        tmp_assign_source_107 = locals_cryptography$x509$extensions_584;
        Py_INCREF(tmp_assign_source_107);
        goto try_return_handler_34;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Return handler code:
        try_return_handler_34:;
        Py_DECREF(locals_cryptography$x509$extensions_584);
        locals_cryptography$x509$extensions_584 = NULL;
        goto outline_result_15;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        outline_result_15:;
        assert(tmp_class_creation_15__class_dict == NULL);
        tmp_class_creation_15__class_dict = tmp_assign_source_107;
    }
    {
        PyObject *tmp_assign_source_108;
        nuitka_bool tmp_condition_result_15;
        PyObject *tmp_key_name_29;
        PyObject *tmp_dict_name_29;
        PyObject *tmp_dict_name_30;
        PyObject *tmp_key_name_30;
        tmp_key_name_29 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_15__class_dict);
        tmp_dict_name_29 = tmp_class_creation_15__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_29, tmp_key_name_29);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 584;

            goto try_except_handler_33;
        }
        tmp_condition_result_15 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_15 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_15;
        } else {
            goto condexpr_false_15;
        }
        condexpr_true_15:;
        CHECK_OBJECT(tmp_class_creation_15__class_dict);
        tmp_dict_name_30 = tmp_class_creation_15__class_dict;
        tmp_key_name_30 = const_str_plain___metaclass__;
        tmp_assign_source_108 = DICT_GET_ITEM(tmp_dict_name_30, tmp_key_name_30);
        if (tmp_assign_source_108 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 584;

            goto try_except_handler_33;
        }
        goto condexpr_end_15;
        condexpr_false_15:;
        {
            PyObject *tmp_assign_source_109;
            PyObject *tmp_subscribed_name_1;
            PyObject *tmp_subscript_name_1;
            CHECK_OBJECT(tmp_class_creation_15__bases);
            tmp_subscribed_name_1 = tmp_class_creation_15__bases;
            tmp_subscript_name_1 = const_int_0;
            tmp_assign_source_109 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_1, tmp_subscript_name_1, 0);
            if (tmp_assign_source_109 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 584;

                goto try_except_handler_33;
            }
            assert(tmp_select_metaclass_15__base == NULL);
            tmp_select_metaclass_15__base = tmp_assign_source_109;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_19;
            CHECK_OBJECT(tmp_select_metaclass_15__base);
            tmp_source_name_19 = tmp_select_metaclass_15__base;
            tmp_assign_source_108 = LOOKUP_ATTRIBUTE_CLASS_SLOT(tmp_source_name_19);
            if (tmp_assign_source_108 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 584;

                goto try_except_handler_36;
            }
            goto try_return_handler_35;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Exception handler code:
        try_except_handler_36:;
        exception_keeper_type_30 = exception_type;
        exception_keeper_value_30 = exception_value;
        exception_keeper_tb_30 = exception_tb;
        exception_keeper_lineno_30 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_1;
            Py_DECREF(exception_keeper_type_30);
            Py_XDECREF(exception_keeper_value_30);
            Py_XDECREF(exception_keeper_tb_30);
            CHECK_OBJECT(tmp_select_metaclass_15__base);
            tmp_type_arg_1 = tmp_select_metaclass_15__base;
            tmp_assign_source_108 = BUILTIN_TYPE1(tmp_type_arg_1);
            assert(!(tmp_assign_source_108 == NULL));
            goto try_return_handler_35;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Return handler code:
        try_return_handler_35:;
        CHECK_OBJECT((PyObject *)tmp_select_metaclass_15__base);
        Py_DECREF(tmp_select_metaclass_15__base);
        tmp_select_metaclass_15__base = NULL;

        goto outline_result_16;
        // End of try:
        CHECK_OBJECT((PyObject *)tmp_select_metaclass_15__base);
        Py_DECREF(tmp_select_metaclass_15__base);
        tmp_select_metaclass_15__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        outline_result_16:;
        condexpr_end_15:;
        assert(tmp_class_creation_15__metaclass == NULL);
        tmp_class_creation_15__metaclass = tmp_assign_source_108;
    }
    {
        PyObject *tmp_assign_source_110;
        PyObject *tmp_called_name_33;
        PyObject *tmp_args_element_name_62;
        PyObject *tmp_args_element_name_63;
        PyObject *tmp_args_element_name_64;
        CHECK_OBJECT(tmp_class_creation_15__metaclass);
        tmp_called_name_33 = tmp_class_creation_15__metaclass;
        tmp_args_element_name_62 = const_str_plain_ReasonFlags;
        CHECK_OBJECT(tmp_class_creation_15__bases);
        tmp_args_element_name_63 = tmp_class_creation_15__bases;
        CHECK_OBJECT(tmp_class_creation_15__class_dict);
        tmp_args_element_name_64 = tmp_class_creation_15__class_dict;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 584;
        {
            PyObject *call_args[] = {tmp_args_element_name_62, tmp_args_element_name_63, tmp_args_element_name_64};
            tmp_assign_source_110 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_33, call_args);
        }

        if (tmp_assign_source_110 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 584;

            goto try_except_handler_33;
        }
        assert(tmp_class_creation_15__class == NULL);
        tmp_class_creation_15__class = tmp_assign_source_110;
    }
    goto try_end_19;
    // Exception handler code:
    try_except_handler_33:;
    exception_keeper_type_31 = exception_type;
    exception_keeper_value_31 = exception_value;
    exception_keeper_tb_31 = exception_tb;
    exception_keeper_lineno_31 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_15__bases);
    tmp_class_creation_15__bases = NULL;

    Py_XDECREF(tmp_class_creation_15__class_dict);
    tmp_class_creation_15__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_15__metaclass);
    tmp_class_creation_15__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_31;
    exception_value = exception_keeper_value_31;
    exception_tb = exception_keeper_tb_31;
    exception_lineno = exception_keeper_lineno_31;

    goto frame_exception_exit_1;
    // End of try:
    try_end_19:;
    {
        PyObject *tmp_assign_source_111;
        CHECK_OBJECT(tmp_class_creation_15__class);
        tmp_assign_source_111 = tmp_class_creation_15__class;
        UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ReasonFlags, tmp_assign_source_111);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_15__class);
    Py_DECREF(tmp_class_creation_15__class);
    tmp_class_creation_15__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_15__bases);
    Py_DECREF(tmp_class_creation_15__bases);
    tmp_class_creation_15__bases = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_15__class_dict);
    Py_DECREF(tmp_class_creation_15__class_dict);
    tmp_class_creation_15__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_15__metaclass);
    Py_DECREF(tmp_class_creation_15__metaclass);
    tmp_class_creation_15__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_112;
        {
            PyObject *tmp_set_locals_13;
            tmp_set_locals_13 = PyDict_New();
            locals_cryptography$x509$extensions_598 = tmp_set_locals_13;
        }
        tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_598, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_4db2c46a45695eb12bac9cef5aa0180e_13, codeobj_4db2c46a45695eb12bac9cef5aa0180e, module_cryptography$x509$extensions, 0);
        frame_4db2c46a45695eb12bac9cef5aa0180e_13 = cache_frame_4db2c46a45695eb12bac9cef5aa0180e_13;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_4db2c46a45695eb12bac9cef5aa0180e_13);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_4db2c46a45695eb12bac9cef5aa0180e_13) == 2); // Frame stack

        // Framed code:
        {
            PyObject *tmp_source_name_20;
            PyObject *tmp_mvar_value_43;
            tmp_mvar_value_43 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID);

            if (unlikely(tmp_mvar_value_43 == NULL)) {
                tmp_mvar_value_43 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionOID);
            }

            if (tmp_mvar_value_43 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 23410 ], 34, 0);
                exception_tb = NULL;

                exception_lineno = 599;

                goto frame_exception_exit_13;
            }

            tmp_source_name_20 = tmp_mvar_value_43;
            tmp_dictset_value = LOOKUP_ATTRIBUTE(tmp_source_name_20, const_str_plain_POLICY_CONSTRAINTS);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 599;

                goto frame_exception_exit_13;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_598, const_str_plain_oid, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 599;

                goto frame_exception_exit_13;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_74___init__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_598, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_75___repr__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_598, const_str_plain___repr__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_76___eq__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_598, const_str_plain___eq__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_77___ne__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_598, const_str_plain___ne__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_78___hash__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_598, const_str_plain___hash__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        {
            PyObject *tmp_called_instance_16;
            PyObject *tmp_mvar_value_44;
            tmp_mvar_value_44 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_44 == NULL)) {
                tmp_mvar_value_44 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_44 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 650;

                goto frame_exception_exit_13;
            }

            tmp_called_instance_16 = tmp_mvar_value_44;
            frame_4db2c46a45695eb12bac9cef5aa0180e_13->m_frame.f_lineno = 650;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_16, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__require_explicit_policy_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 650;

                goto frame_exception_exit_13;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_598, const_str_plain_require_explicit_policy, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 650;

                goto frame_exception_exit_13;
            }
        }
        {
            PyObject *tmp_called_instance_17;
            PyObject *tmp_mvar_value_45;
            tmp_mvar_value_45 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_45 == NULL)) {
                tmp_mvar_value_45 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_45 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 653;

                goto frame_exception_exit_13;
            }

            tmp_called_instance_17 = tmp_mvar_value_45;
            frame_4db2c46a45695eb12bac9cef5aa0180e_13->m_frame.f_lineno = 653;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_17, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__inhibit_policy_mapping_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 653;

                goto frame_exception_exit_13;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_598, const_str_plain_inhibit_policy_mapping, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 653;

                goto frame_exception_exit_13;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_4db2c46a45695eb12bac9cef5aa0180e_13);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_12;

        frame_exception_exit_13:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_4db2c46a45695eb12bac9cef5aa0180e_13);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_4db2c46a45695eb12bac9cef5aa0180e_13, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_4db2c46a45695eb12bac9cef5aa0180e_13->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_4db2c46a45695eb12bac9cef5aa0180e_13, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_4db2c46a45695eb12bac9cef5aa0180e_13,
            type_description_2
        );


        // Release cached frame.
        if (frame_4db2c46a45695eb12bac9cef5aa0180e_13 == cache_frame_4db2c46a45695eb12bac9cef5aa0180e_13) {
            Py_DECREF(frame_4db2c46a45695eb12bac9cef5aa0180e_13);
        }
        cache_frame_4db2c46a45695eb12bac9cef5aa0180e_13 = NULL;

        assertFrameObject(frame_4db2c46a45695eb12bac9cef5aa0180e_13);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_12;

        frame_no_exception_12:;
        goto skip_nested_handling_12;
        nested_frame_exit_12:;

        goto try_except_handler_38;
        skip_nested_handling_12:;
        tmp_assign_source_112 = locals_cryptography$x509$extensions_598;
        Py_INCREF(tmp_assign_source_112);
        goto try_return_handler_38;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Return handler code:
        try_return_handler_38:;
        Py_DECREF(locals_cryptography$x509$extensions_598);
        locals_cryptography$x509$extensions_598 = NULL;
        goto outline_result_17;
        // Exception handler code:
        try_except_handler_38:;
        exception_keeper_type_32 = exception_type;
        exception_keeper_value_32 = exception_value;
        exception_keeper_tb_32 = exception_tb;
        exception_keeper_lineno_32 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_cryptography$x509$extensions_598);
        locals_cryptography$x509$extensions_598 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_32;
        exception_value = exception_keeper_value_32;
        exception_tb = exception_keeper_tb_32;
        exception_lineno = exception_keeper_lineno_32;

        goto outline_exception_12;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        outline_exception_12:;
        exception_lineno = 598;
        goto try_except_handler_37;
        outline_result_17:;
        assert(tmp_class_creation_16__class_dict == NULL);
        tmp_class_creation_16__class_dict = tmp_assign_source_112;
    }
    {
        PyObject *tmp_assign_source_113;
        nuitka_bool tmp_condition_result_16;
        PyObject *tmp_key_name_31;
        PyObject *tmp_dict_name_31;
        PyObject *tmp_dict_name_32;
        PyObject *tmp_key_name_32;
        tmp_key_name_31 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_16__class_dict);
        tmp_dict_name_31 = tmp_class_creation_16__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_31, tmp_key_name_31);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 598;

            goto try_except_handler_37;
        }
        tmp_condition_result_16 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_16 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_16;
        } else {
            goto condexpr_false_16;
        }
        condexpr_true_16:;
        CHECK_OBJECT(tmp_class_creation_16__class_dict);
        tmp_dict_name_32 = tmp_class_creation_16__class_dict;
        tmp_key_name_32 = const_str_plain___metaclass__;
        tmp_assign_source_113 = DICT_GET_ITEM(tmp_dict_name_32, tmp_key_name_32);
        if (tmp_assign_source_113 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 598;

            goto try_except_handler_37;
        }
        goto condexpr_end_16;
        condexpr_false_16:;
        tmp_assign_source_113 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_113);
        condexpr_end_16:;
        assert(tmp_class_creation_16__metaclass == NULL);
        tmp_class_creation_16__metaclass = tmp_assign_source_113;
    }
    {
        PyObject *tmp_assign_source_114;
        PyObject *tmp_called_name_34;
        PyObject *tmp_args_element_name_65;
        PyObject *tmp_args_element_name_66;
        PyObject *tmp_args_element_name_67;
        CHECK_OBJECT(tmp_class_creation_16__metaclass);
        tmp_called_name_34 = tmp_class_creation_16__metaclass;
        tmp_args_element_name_65 = const_str_plain_PolicyConstraints;
        tmp_args_element_name_66 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_16__class_dict);
        tmp_args_element_name_67 = tmp_class_creation_16__class_dict;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 598;
        {
            PyObject *call_args[] = {tmp_args_element_name_65, tmp_args_element_name_66, tmp_args_element_name_67};
            tmp_assign_source_114 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_34, call_args);
        }

        if (tmp_assign_source_114 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 598;

            goto try_except_handler_37;
        }
        assert(tmp_class_creation_16__class == NULL);
        tmp_class_creation_16__class = tmp_assign_source_114;
    }
    {
        PyObject *tmp_assign_source_115;
        PyObject *tmp_called_name_35;
        PyObject *tmp_called_name_36;
        PyObject *tmp_source_name_21;
        PyObject *tmp_mvar_value_46;
        PyObject *tmp_args_element_name_68;
        PyObject *tmp_mvar_value_47;
        PyObject *tmp_args_element_name_69;
        tmp_mvar_value_46 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

        if (unlikely(tmp_mvar_value_46 == NULL)) {
            tmp_mvar_value_46 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
        }

        if (tmp_mvar_value_46 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
            exception_tb = NULL;

            exception_lineno = 597;

            goto try_except_handler_37;
        }

        tmp_source_name_21 = tmp_mvar_value_46;
        tmp_called_name_36 = LOOKUP_ATTRIBUTE(tmp_source_name_21, const_str_plain_register_interface);
        if (tmp_called_name_36 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 597;

            goto try_except_handler_37;
        }
        tmp_mvar_value_47 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType);

        if (unlikely(tmp_mvar_value_47 == NULL)) {
            tmp_mvar_value_47 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType);
        }

        if (tmp_mvar_value_47 == NULL) {
            Py_DECREF(tmp_called_name_36);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 35484 ], 35, 0);
            exception_tb = NULL;

            exception_lineno = 597;

            goto try_except_handler_37;
        }

        tmp_args_element_name_68 = tmp_mvar_value_47;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 597;
        tmp_called_name_35 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_36, tmp_args_element_name_68);
        Py_DECREF(tmp_called_name_36);
        if (tmp_called_name_35 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 597;

            goto try_except_handler_37;
        }
        CHECK_OBJECT(tmp_class_creation_16__class);
        tmp_args_element_name_69 = tmp_class_creation_16__class;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 597;
        tmp_assign_source_115 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_35, tmp_args_element_name_69);
        Py_DECREF(tmp_called_name_35);
        if (tmp_assign_source_115 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 597;

            goto try_except_handler_37;
        }
        {
            PyObject *old = tmp_class_creation_16__class;
            assert(old != NULL);
            tmp_class_creation_16__class = tmp_assign_source_115;
            Py_DECREF(old);
        }

    }
    goto try_end_20;
    // Exception handler code:
    try_except_handler_37:;
    exception_keeper_type_33 = exception_type;
    exception_keeper_value_33 = exception_value;
    exception_keeper_tb_33 = exception_tb;
    exception_keeper_lineno_33 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_16__class);
    tmp_class_creation_16__class = NULL;

    Py_XDECREF(tmp_class_creation_16__class_dict);
    tmp_class_creation_16__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_16__metaclass);
    tmp_class_creation_16__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_33;
    exception_value = exception_keeper_value_33;
    exception_tb = exception_keeper_tb_33;
    exception_lineno = exception_keeper_lineno_33;

    goto frame_exception_exit_1;
    // End of try:
    try_end_20:;
    {
        PyObject *tmp_assign_source_116;
        CHECK_OBJECT(tmp_class_creation_16__class);
        tmp_assign_source_116 = tmp_class_creation_16__class;
        UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_PolicyConstraints, tmp_assign_source_116);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_16__class);
    Py_DECREF(tmp_class_creation_16__class);
    tmp_class_creation_16__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_16__class_dict);
    Py_DECREF(tmp_class_creation_16__class_dict);
    tmp_class_creation_16__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_16__metaclass);
    Py_DECREF(tmp_class_creation_16__metaclass);
    tmp_class_creation_16__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_117;
        {
            PyObject *tmp_set_locals_14;
            tmp_set_locals_14 = PyDict_New();
            locals_cryptography$x509$extensions_659 = tmp_set_locals_14;
        }
        tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_659, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_6a2ac24867d838ebbfada582b800ac84_14, codeobj_6a2ac24867d838ebbfada582b800ac84, module_cryptography$x509$extensions, 0);
        frame_6a2ac24867d838ebbfada582b800ac84_14 = cache_frame_6a2ac24867d838ebbfada582b800ac84_14;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_6a2ac24867d838ebbfada582b800ac84_14);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_6a2ac24867d838ebbfada582b800ac84_14) == 2); // Frame stack

        // Framed code:
        {
            PyObject *tmp_source_name_22;
            PyObject *tmp_mvar_value_48;
            tmp_mvar_value_48 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID);

            if (unlikely(tmp_mvar_value_48 == NULL)) {
                tmp_mvar_value_48 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionOID);
            }

            if (tmp_mvar_value_48 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 23410 ], 34, 0);
                exception_tb = NULL;

                exception_lineno = 660;

                goto frame_exception_exit_14;
            }

            tmp_source_name_22 = tmp_mvar_value_48;
            tmp_dictset_value = LOOKUP_ATTRIBUTE(tmp_source_name_22, const_str_plain_CERTIFICATE_POLICIES);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 660;

                goto frame_exception_exit_14;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_659, const_str_plain_oid, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 660;

                goto frame_exception_exit_14;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_6a2ac24867d838ebbfada582b800ac84_14);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_13;

        frame_exception_exit_14:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_6a2ac24867d838ebbfada582b800ac84_14);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_6a2ac24867d838ebbfada582b800ac84_14, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_6a2ac24867d838ebbfada582b800ac84_14->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_6a2ac24867d838ebbfada582b800ac84_14, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_6a2ac24867d838ebbfada582b800ac84_14,
            type_description_2
        );


        // Release cached frame.
        if (frame_6a2ac24867d838ebbfada582b800ac84_14 == cache_frame_6a2ac24867d838ebbfada582b800ac84_14) {
            Py_DECREF(frame_6a2ac24867d838ebbfada582b800ac84_14);
        }
        cache_frame_6a2ac24867d838ebbfada582b800ac84_14 = NULL;

        assertFrameObject(frame_6a2ac24867d838ebbfada582b800ac84_14);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_13;

        frame_no_exception_13:;
        goto skip_nested_handling_13;
        nested_frame_exit_13:;

        goto try_except_handler_40;
        skip_nested_handling_13:;
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_79___init__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_659, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_80___iter__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_659, const_str_plain___iter__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_81___len__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_659, const_str_plain___len__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_82___repr__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_659, const_str_plain___repr__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_83___eq__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_659, const_str_plain___eq__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_84___ne__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_659, const_str_plain___ne__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_85___getitem__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_659, const_str_plain___getitem__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_86___hash__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_659, const_str_plain___hash__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_assign_source_117 = locals_cryptography$x509$extensions_659;
        Py_INCREF(tmp_assign_source_117);
        goto try_return_handler_40;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Return handler code:
        try_return_handler_40:;
        Py_DECREF(locals_cryptography$x509$extensions_659);
        locals_cryptography$x509$extensions_659 = NULL;
        goto outline_result_18;
        // Exception handler code:
        try_except_handler_40:;
        exception_keeper_type_34 = exception_type;
        exception_keeper_value_34 = exception_value;
        exception_keeper_tb_34 = exception_tb;
        exception_keeper_lineno_34 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_cryptography$x509$extensions_659);
        locals_cryptography$x509$extensions_659 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_34;
        exception_value = exception_keeper_value_34;
        exception_tb = exception_keeper_tb_34;
        exception_lineno = exception_keeper_lineno_34;

        goto outline_exception_13;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        outline_exception_13:;
        exception_lineno = 659;
        goto try_except_handler_39;
        outline_result_18:;
        assert(tmp_class_creation_17__class_dict == NULL);
        tmp_class_creation_17__class_dict = tmp_assign_source_117;
    }
    {
        PyObject *tmp_assign_source_118;
        nuitka_bool tmp_condition_result_17;
        PyObject *tmp_key_name_33;
        PyObject *tmp_dict_name_33;
        PyObject *tmp_dict_name_34;
        PyObject *tmp_key_name_34;
        tmp_key_name_33 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_17__class_dict);
        tmp_dict_name_33 = tmp_class_creation_17__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_33, tmp_key_name_33);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 659;

            goto try_except_handler_39;
        }
        tmp_condition_result_17 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_17 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_17;
        } else {
            goto condexpr_false_17;
        }
        condexpr_true_17:;
        CHECK_OBJECT(tmp_class_creation_17__class_dict);
        tmp_dict_name_34 = tmp_class_creation_17__class_dict;
        tmp_key_name_34 = const_str_plain___metaclass__;
        tmp_assign_source_118 = DICT_GET_ITEM(tmp_dict_name_34, tmp_key_name_34);
        if (tmp_assign_source_118 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 659;

            goto try_except_handler_39;
        }
        goto condexpr_end_17;
        condexpr_false_17:;
        tmp_assign_source_118 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_118);
        condexpr_end_17:;
        assert(tmp_class_creation_17__metaclass == NULL);
        tmp_class_creation_17__metaclass = tmp_assign_source_118;
    }
    {
        PyObject *tmp_assign_source_119;
        PyObject *tmp_called_name_37;
        PyObject *tmp_args_element_name_70;
        PyObject *tmp_args_element_name_71;
        PyObject *tmp_args_element_name_72;
        CHECK_OBJECT(tmp_class_creation_17__metaclass);
        tmp_called_name_37 = tmp_class_creation_17__metaclass;
        tmp_args_element_name_70 = const_str_plain_CertificatePolicies;
        tmp_args_element_name_71 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_17__class_dict);
        tmp_args_element_name_72 = tmp_class_creation_17__class_dict;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 659;
        {
            PyObject *call_args[] = {tmp_args_element_name_70, tmp_args_element_name_71, tmp_args_element_name_72};
            tmp_assign_source_119 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_37, call_args);
        }

        if (tmp_assign_source_119 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 659;

            goto try_except_handler_39;
        }
        assert(tmp_class_creation_17__class == NULL);
        tmp_class_creation_17__class = tmp_assign_source_119;
    }
    {
        PyObject *tmp_assign_source_120;
        PyObject *tmp_called_name_38;
        PyObject *tmp_called_name_39;
        PyObject *tmp_source_name_23;
        PyObject *tmp_mvar_value_49;
        PyObject *tmp_args_element_name_73;
        PyObject *tmp_mvar_value_50;
        PyObject *tmp_args_element_name_74;
        tmp_mvar_value_49 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

        if (unlikely(tmp_mvar_value_49 == NULL)) {
            tmp_mvar_value_49 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
        }

        if (tmp_mvar_value_49 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
            exception_tb = NULL;

            exception_lineno = 658;

            goto try_except_handler_39;
        }

        tmp_source_name_23 = tmp_mvar_value_49;
        tmp_called_name_39 = LOOKUP_ATTRIBUTE(tmp_source_name_23, const_str_plain_register_interface);
        if (tmp_called_name_39 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 658;

            goto try_except_handler_39;
        }
        tmp_mvar_value_50 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType);

        if (unlikely(tmp_mvar_value_50 == NULL)) {
            tmp_mvar_value_50 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType);
        }

        if (tmp_mvar_value_50 == NULL) {
            Py_DECREF(tmp_called_name_39);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 35484 ], 35, 0);
            exception_tb = NULL;

            exception_lineno = 658;

            goto try_except_handler_39;
        }

        tmp_args_element_name_73 = tmp_mvar_value_50;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 658;
        tmp_called_name_38 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_39, tmp_args_element_name_73);
        Py_DECREF(tmp_called_name_39);
        if (tmp_called_name_38 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 658;

            goto try_except_handler_39;
        }
        CHECK_OBJECT(tmp_class_creation_17__class);
        tmp_args_element_name_74 = tmp_class_creation_17__class;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 658;
        tmp_assign_source_120 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_38, tmp_args_element_name_74);
        Py_DECREF(tmp_called_name_38);
        if (tmp_assign_source_120 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 658;

            goto try_except_handler_39;
        }
        {
            PyObject *old = tmp_class_creation_17__class;
            assert(old != NULL);
            tmp_class_creation_17__class = tmp_assign_source_120;
            Py_DECREF(old);
        }

    }
    goto try_end_21;
    // Exception handler code:
    try_except_handler_39:;
    exception_keeper_type_35 = exception_type;
    exception_keeper_value_35 = exception_value;
    exception_keeper_tb_35 = exception_tb;
    exception_keeper_lineno_35 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_17__class);
    tmp_class_creation_17__class = NULL;

    Py_XDECREF(tmp_class_creation_17__class_dict);
    tmp_class_creation_17__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_17__metaclass);
    tmp_class_creation_17__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_35;
    exception_value = exception_keeper_value_35;
    exception_tb = exception_keeper_tb_35;
    exception_lineno = exception_keeper_lineno_35;

    goto frame_exception_exit_1;
    // End of try:
    try_end_21:;
    {
        PyObject *tmp_assign_source_121;
        CHECK_OBJECT(tmp_class_creation_17__class);
        tmp_assign_source_121 = tmp_class_creation_17__class;
        UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_CertificatePolicies, tmp_assign_source_121);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_17__class);
    Py_DECREF(tmp_class_creation_17__class);
    tmp_class_creation_17__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_17__class_dict);
    Py_DECREF(tmp_class_creation_17__class_dict);
    tmp_class_creation_17__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_17__metaclass);
    Py_DECREF(tmp_class_creation_17__metaclass);
    tmp_class_creation_17__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_122;
        {
            PyObject *tmp_set_locals_15;
            tmp_set_locals_15 = PyDict_New();
            locals_cryptography$x509$extensions_697 = tmp_set_locals_15;
        }
        tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_697, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_87___init__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_697, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_88___repr__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_697, const_str_plain___repr__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_89___eq__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_697, const_str_plain___eq__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_90___ne__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_697, const_str_plain___ne__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_91___hash__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_697, const_str_plain___hash__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_adabafe8c246c11f4a4c9f6f68213ae2_15, codeobj_adabafe8c246c11f4a4c9f6f68213ae2, module_cryptography$x509$extensions, 0);
        frame_adabafe8c246c11f4a4c9f6f68213ae2_15 = cache_frame_adabafe8c246c11f4a4c9f6f68213ae2_15;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_adabafe8c246c11f4a4c9f6f68213ae2_15);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_adabafe8c246c11f4a4c9f6f68213ae2_15) == 2); // Frame stack

        // Framed code:
        {
            PyObject *tmp_called_instance_18;
            PyObject *tmp_mvar_value_51;
            tmp_mvar_value_51 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_51 == NULL)) {
                tmp_mvar_value_51 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_51 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 743;

                goto frame_exception_exit_15;
            }

            tmp_called_instance_18 = tmp_mvar_value_51;
            frame_adabafe8c246c11f4a4c9f6f68213ae2_15->m_frame.f_lineno = 743;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_18, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__policy_identifier_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 743;

                goto frame_exception_exit_15;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_697, const_str_plain_policy_identifier, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 743;

                goto frame_exception_exit_15;
            }
        }
        {
            PyObject *tmp_called_instance_19;
            PyObject *tmp_mvar_value_52;
            tmp_mvar_value_52 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_52 == NULL)) {
                tmp_mvar_value_52 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_52 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 744;

                goto frame_exception_exit_15;
            }

            tmp_called_instance_19 = tmp_mvar_value_52;
            frame_adabafe8c246c11f4a4c9f6f68213ae2_15->m_frame.f_lineno = 744;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_19, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__policy_qualifiers_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 744;

                goto frame_exception_exit_15;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_697, const_str_plain_policy_qualifiers, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 744;

                goto frame_exception_exit_15;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_adabafe8c246c11f4a4c9f6f68213ae2_15);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_14;

        frame_exception_exit_15:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_adabafe8c246c11f4a4c9f6f68213ae2_15);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_adabafe8c246c11f4a4c9f6f68213ae2_15, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_adabafe8c246c11f4a4c9f6f68213ae2_15->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_adabafe8c246c11f4a4c9f6f68213ae2_15, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_adabafe8c246c11f4a4c9f6f68213ae2_15,
            type_description_2
        );


        // Release cached frame.
        if (frame_adabafe8c246c11f4a4c9f6f68213ae2_15 == cache_frame_adabafe8c246c11f4a4c9f6f68213ae2_15) {
            Py_DECREF(frame_adabafe8c246c11f4a4c9f6f68213ae2_15);
        }
        cache_frame_adabafe8c246c11f4a4c9f6f68213ae2_15 = NULL;

        assertFrameObject(frame_adabafe8c246c11f4a4c9f6f68213ae2_15);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_14;

        frame_no_exception_14:;
        goto skip_nested_handling_14;
        nested_frame_exit_14:;

        goto try_except_handler_42;
        skip_nested_handling_14:;
        tmp_assign_source_122 = locals_cryptography$x509$extensions_697;
        Py_INCREF(tmp_assign_source_122);
        goto try_return_handler_42;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Return handler code:
        try_return_handler_42:;
        Py_DECREF(locals_cryptography$x509$extensions_697);
        locals_cryptography$x509$extensions_697 = NULL;
        goto outline_result_19;
        // Exception handler code:
        try_except_handler_42:;
        exception_keeper_type_36 = exception_type;
        exception_keeper_value_36 = exception_value;
        exception_keeper_tb_36 = exception_tb;
        exception_keeper_lineno_36 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_cryptography$x509$extensions_697);
        locals_cryptography$x509$extensions_697 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_36;
        exception_value = exception_keeper_value_36;
        exception_tb = exception_keeper_tb_36;
        exception_lineno = exception_keeper_lineno_36;

        goto outline_exception_14;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        outline_exception_14:;
        exception_lineno = 697;
        goto try_except_handler_41;
        outline_result_19:;
        assert(tmp_class_creation_18__class_dict == NULL);
        tmp_class_creation_18__class_dict = tmp_assign_source_122;
    }
    {
        PyObject *tmp_assign_source_123;
        nuitka_bool tmp_condition_result_18;
        PyObject *tmp_key_name_35;
        PyObject *tmp_dict_name_35;
        PyObject *tmp_dict_name_36;
        PyObject *tmp_key_name_36;
        tmp_key_name_35 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_18__class_dict);
        tmp_dict_name_35 = tmp_class_creation_18__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_35, tmp_key_name_35);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 697;

            goto try_except_handler_41;
        }
        tmp_condition_result_18 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_18 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_18;
        } else {
            goto condexpr_false_18;
        }
        condexpr_true_18:;
        CHECK_OBJECT(tmp_class_creation_18__class_dict);
        tmp_dict_name_36 = tmp_class_creation_18__class_dict;
        tmp_key_name_36 = const_str_plain___metaclass__;
        tmp_assign_source_123 = DICT_GET_ITEM(tmp_dict_name_36, tmp_key_name_36);
        if (tmp_assign_source_123 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 697;

            goto try_except_handler_41;
        }
        goto condexpr_end_18;
        condexpr_false_18:;
        tmp_assign_source_123 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_123);
        condexpr_end_18:;
        assert(tmp_class_creation_18__metaclass == NULL);
        tmp_class_creation_18__metaclass = tmp_assign_source_123;
    }
    {
        PyObject *tmp_assign_source_124;
        PyObject *tmp_called_name_40;
        PyObject *tmp_args_element_name_75;
        PyObject *tmp_args_element_name_76;
        PyObject *tmp_args_element_name_77;
        CHECK_OBJECT(tmp_class_creation_18__metaclass);
        tmp_called_name_40 = tmp_class_creation_18__metaclass;
        tmp_args_element_name_75 = const_str_plain_PolicyInformation;
        tmp_args_element_name_76 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_18__class_dict);
        tmp_args_element_name_77 = tmp_class_creation_18__class_dict;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 697;
        {
            PyObject *call_args[] = {tmp_args_element_name_75, tmp_args_element_name_76, tmp_args_element_name_77};
            tmp_assign_source_124 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_40, call_args);
        }

        if (tmp_assign_source_124 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 697;

            goto try_except_handler_41;
        }
        assert(tmp_class_creation_18__class == NULL);
        tmp_class_creation_18__class = tmp_assign_source_124;
    }
    goto try_end_22;
    // Exception handler code:
    try_except_handler_41:;
    exception_keeper_type_37 = exception_type;
    exception_keeper_value_37 = exception_value;
    exception_keeper_tb_37 = exception_tb;
    exception_keeper_lineno_37 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_18__class_dict);
    tmp_class_creation_18__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_18__metaclass);
    tmp_class_creation_18__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_37;
    exception_value = exception_keeper_value_37;
    exception_tb = exception_keeper_tb_37;
    exception_lineno = exception_keeper_lineno_37;

    goto frame_exception_exit_1;
    // End of try:
    try_end_22:;
    {
        PyObject *tmp_assign_source_125;
        CHECK_OBJECT(tmp_class_creation_18__class);
        tmp_assign_source_125 = tmp_class_creation_18__class;
        UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_PolicyInformation, tmp_assign_source_125);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_18__class);
    Py_DECREF(tmp_class_creation_18__class);
    tmp_class_creation_18__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_18__class_dict);
    Py_DECREF(tmp_class_creation_18__class_dict);
    tmp_class_creation_18__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_18__metaclass);
    Py_DECREF(tmp_class_creation_18__metaclass);
    tmp_class_creation_18__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_126;
        {
            PyObject *tmp_set_locals_16;
            tmp_set_locals_16 = PyDict_New();
            locals_cryptography$x509$extensions_747 = tmp_set_locals_16;
        }
        tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_747, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_92___init__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_747, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_93___repr__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_747, const_str_plain___repr__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_94___eq__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_747, const_str_plain___eq__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_95___ne__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_747, const_str_plain___ne__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_96___hash__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_747, const_str_plain___hash__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_284f196fc1cfe393c2e892de06b6804f_16, codeobj_284f196fc1cfe393c2e892de06b6804f, module_cryptography$x509$extensions, 0);
        frame_284f196fc1cfe393c2e892de06b6804f_16 = cache_frame_284f196fc1cfe393c2e892de06b6804f_16;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_284f196fc1cfe393c2e892de06b6804f_16);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_284f196fc1cfe393c2e892de06b6804f_16) == 2); // Frame stack

        // Framed code:
        {
            PyObject *tmp_called_instance_20;
            PyObject *tmp_mvar_value_53;
            tmp_mvar_value_53 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_53 == NULL)) {
                tmp_mvar_value_53 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_53 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 780;

                goto frame_exception_exit_16;
            }

            tmp_called_instance_20 = tmp_mvar_value_53;
            frame_284f196fc1cfe393c2e892de06b6804f_16->m_frame.f_lineno = 780;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_20, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__notice_reference_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 780;

                goto frame_exception_exit_16;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_747, const_str_plain_notice_reference, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 780;

                goto frame_exception_exit_16;
            }
        }
        {
            PyObject *tmp_called_instance_21;
            PyObject *tmp_mvar_value_54;
            tmp_mvar_value_54 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_54 == NULL)) {
                tmp_mvar_value_54 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_54 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 781;

                goto frame_exception_exit_16;
            }

            tmp_called_instance_21 = tmp_mvar_value_54;
            frame_284f196fc1cfe393c2e892de06b6804f_16->m_frame.f_lineno = 781;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_21, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__explicit_text_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 781;

                goto frame_exception_exit_16;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_747, const_str_plain_explicit_text, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 781;

                goto frame_exception_exit_16;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_284f196fc1cfe393c2e892de06b6804f_16);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_15;

        frame_exception_exit_16:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_284f196fc1cfe393c2e892de06b6804f_16);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_284f196fc1cfe393c2e892de06b6804f_16, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_284f196fc1cfe393c2e892de06b6804f_16->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_284f196fc1cfe393c2e892de06b6804f_16, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_284f196fc1cfe393c2e892de06b6804f_16,
            type_description_2
        );


        // Release cached frame.
        if (frame_284f196fc1cfe393c2e892de06b6804f_16 == cache_frame_284f196fc1cfe393c2e892de06b6804f_16) {
            Py_DECREF(frame_284f196fc1cfe393c2e892de06b6804f_16);
        }
        cache_frame_284f196fc1cfe393c2e892de06b6804f_16 = NULL;

        assertFrameObject(frame_284f196fc1cfe393c2e892de06b6804f_16);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_15;

        frame_no_exception_15:;
        goto skip_nested_handling_15;
        nested_frame_exit_15:;

        goto try_except_handler_44;
        skip_nested_handling_15:;
        tmp_assign_source_126 = locals_cryptography$x509$extensions_747;
        Py_INCREF(tmp_assign_source_126);
        goto try_return_handler_44;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Return handler code:
        try_return_handler_44:;
        Py_DECREF(locals_cryptography$x509$extensions_747);
        locals_cryptography$x509$extensions_747 = NULL;
        goto outline_result_20;
        // Exception handler code:
        try_except_handler_44:;
        exception_keeper_type_38 = exception_type;
        exception_keeper_value_38 = exception_value;
        exception_keeper_tb_38 = exception_tb;
        exception_keeper_lineno_38 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_cryptography$x509$extensions_747);
        locals_cryptography$x509$extensions_747 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_38;
        exception_value = exception_keeper_value_38;
        exception_tb = exception_keeper_tb_38;
        exception_lineno = exception_keeper_lineno_38;

        goto outline_exception_15;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        outline_exception_15:;
        exception_lineno = 747;
        goto try_except_handler_43;
        outline_result_20:;
        assert(tmp_class_creation_19__class_dict == NULL);
        tmp_class_creation_19__class_dict = tmp_assign_source_126;
    }
    {
        PyObject *tmp_assign_source_127;
        nuitka_bool tmp_condition_result_19;
        PyObject *tmp_key_name_37;
        PyObject *tmp_dict_name_37;
        PyObject *tmp_dict_name_38;
        PyObject *tmp_key_name_38;
        tmp_key_name_37 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_19__class_dict);
        tmp_dict_name_37 = tmp_class_creation_19__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_37, tmp_key_name_37);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 747;

            goto try_except_handler_43;
        }
        tmp_condition_result_19 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_19 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_19;
        } else {
            goto condexpr_false_19;
        }
        condexpr_true_19:;
        CHECK_OBJECT(tmp_class_creation_19__class_dict);
        tmp_dict_name_38 = tmp_class_creation_19__class_dict;
        tmp_key_name_38 = const_str_plain___metaclass__;
        tmp_assign_source_127 = DICT_GET_ITEM(tmp_dict_name_38, tmp_key_name_38);
        if (tmp_assign_source_127 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 747;

            goto try_except_handler_43;
        }
        goto condexpr_end_19;
        condexpr_false_19:;
        tmp_assign_source_127 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_127);
        condexpr_end_19:;
        assert(tmp_class_creation_19__metaclass == NULL);
        tmp_class_creation_19__metaclass = tmp_assign_source_127;
    }
    {
        PyObject *tmp_assign_source_128;
        PyObject *tmp_called_name_41;
        PyObject *tmp_args_element_name_78;
        PyObject *tmp_args_element_name_79;
        PyObject *tmp_args_element_name_80;
        CHECK_OBJECT(tmp_class_creation_19__metaclass);
        tmp_called_name_41 = tmp_class_creation_19__metaclass;
        tmp_args_element_name_78 = const_str_plain_UserNotice;
        tmp_args_element_name_79 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_19__class_dict);
        tmp_args_element_name_80 = tmp_class_creation_19__class_dict;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 747;
        {
            PyObject *call_args[] = {tmp_args_element_name_78, tmp_args_element_name_79, tmp_args_element_name_80};
            tmp_assign_source_128 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_41, call_args);
        }

        if (tmp_assign_source_128 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 747;

            goto try_except_handler_43;
        }
        assert(tmp_class_creation_19__class == NULL);
        tmp_class_creation_19__class = tmp_assign_source_128;
    }
    goto try_end_23;
    // Exception handler code:
    try_except_handler_43:;
    exception_keeper_type_39 = exception_type;
    exception_keeper_value_39 = exception_value;
    exception_keeper_tb_39 = exception_tb;
    exception_keeper_lineno_39 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_19__class_dict);
    tmp_class_creation_19__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_19__metaclass);
    tmp_class_creation_19__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_39;
    exception_value = exception_keeper_value_39;
    exception_tb = exception_keeper_tb_39;
    exception_lineno = exception_keeper_lineno_39;

    goto frame_exception_exit_1;
    // End of try:
    try_end_23:;
    {
        PyObject *tmp_assign_source_129;
        CHECK_OBJECT(tmp_class_creation_19__class);
        tmp_assign_source_129 = tmp_class_creation_19__class;
        UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_UserNotice, tmp_assign_source_129);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_19__class);
    Py_DECREF(tmp_class_creation_19__class);
    tmp_class_creation_19__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_19__class_dict);
    Py_DECREF(tmp_class_creation_19__class_dict);
    tmp_class_creation_19__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_19__metaclass);
    Py_DECREF(tmp_class_creation_19__metaclass);
    tmp_class_creation_19__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_130;
        {
            PyObject *tmp_set_locals_17;
            tmp_set_locals_17 = PyDict_New();
            locals_cryptography$x509$extensions_784 = tmp_set_locals_17;
        }
        tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_784, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_97___init__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_784, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_98___repr__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_784, const_str_plain___repr__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_99___eq__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_784, const_str_plain___eq__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_100___ne__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_784, const_str_plain___ne__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_101___hash__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_784, const_str_plain___hash__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_131acb86ad21685798bdc6a84a886dee_17, codeobj_131acb86ad21685798bdc6a84a886dee, module_cryptography$x509$extensions, 0);
        frame_131acb86ad21685798bdc6a84a886dee_17 = cache_frame_131acb86ad21685798bdc6a84a886dee_17;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_131acb86ad21685798bdc6a84a886dee_17);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_131acb86ad21685798bdc6a84a886dee_17) == 2); // Frame stack

        // Framed code:
        {
            PyObject *tmp_called_instance_22;
            PyObject *tmp_mvar_value_55;
            tmp_mvar_value_55 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_55 == NULL)) {
                tmp_mvar_value_55 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_55 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 816;

                goto frame_exception_exit_17;
            }

            tmp_called_instance_22 = tmp_mvar_value_55;
            frame_131acb86ad21685798bdc6a84a886dee_17->m_frame.f_lineno = 816;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_22, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__organization_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 816;

                goto frame_exception_exit_17;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_784, const_str_plain_organization, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 816;

                goto frame_exception_exit_17;
            }
        }
        {
            PyObject *tmp_called_instance_23;
            PyObject *tmp_mvar_value_56;
            tmp_mvar_value_56 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_56 == NULL)) {
                tmp_mvar_value_56 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_56 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 817;

                goto frame_exception_exit_17;
            }

            tmp_called_instance_23 = tmp_mvar_value_56;
            frame_131acb86ad21685798bdc6a84a886dee_17->m_frame.f_lineno = 817;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_23, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__notice_numbers_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 817;

                goto frame_exception_exit_17;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_784, const_str_plain_notice_numbers, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 817;

                goto frame_exception_exit_17;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_131acb86ad21685798bdc6a84a886dee_17);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_16;

        frame_exception_exit_17:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_131acb86ad21685798bdc6a84a886dee_17);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_131acb86ad21685798bdc6a84a886dee_17, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_131acb86ad21685798bdc6a84a886dee_17->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_131acb86ad21685798bdc6a84a886dee_17, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_131acb86ad21685798bdc6a84a886dee_17,
            type_description_2
        );


        // Release cached frame.
        if (frame_131acb86ad21685798bdc6a84a886dee_17 == cache_frame_131acb86ad21685798bdc6a84a886dee_17) {
            Py_DECREF(frame_131acb86ad21685798bdc6a84a886dee_17);
        }
        cache_frame_131acb86ad21685798bdc6a84a886dee_17 = NULL;

        assertFrameObject(frame_131acb86ad21685798bdc6a84a886dee_17);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_16;

        frame_no_exception_16:;
        goto skip_nested_handling_16;
        nested_frame_exit_16:;

        goto try_except_handler_46;
        skip_nested_handling_16:;
        tmp_assign_source_130 = locals_cryptography$x509$extensions_784;
        Py_INCREF(tmp_assign_source_130);
        goto try_return_handler_46;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Return handler code:
        try_return_handler_46:;
        Py_DECREF(locals_cryptography$x509$extensions_784);
        locals_cryptography$x509$extensions_784 = NULL;
        goto outline_result_21;
        // Exception handler code:
        try_except_handler_46:;
        exception_keeper_type_40 = exception_type;
        exception_keeper_value_40 = exception_value;
        exception_keeper_tb_40 = exception_tb;
        exception_keeper_lineno_40 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_cryptography$x509$extensions_784);
        locals_cryptography$x509$extensions_784 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_40;
        exception_value = exception_keeper_value_40;
        exception_tb = exception_keeper_tb_40;
        exception_lineno = exception_keeper_lineno_40;

        goto outline_exception_16;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        outline_exception_16:;
        exception_lineno = 784;
        goto try_except_handler_45;
        outline_result_21:;
        assert(tmp_class_creation_20__class_dict == NULL);
        tmp_class_creation_20__class_dict = tmp_assign_source_130;
    }
    {
        PyObject *tmp_assign_source_131;
        nuitka_bool tmp_condition_result_20;
        PyObject *tmp_key_name_39;
        PyObject *tmp_dict_name_39;
        PyObject *tmp_dict_name_40;
        PyObject *tmp_key_name_40;
        tmp_key_name_39 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_20__class_dict);
        tmp_dict_name_39 = tmp_class_creation_20__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_39, tmp_key_name_39);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 784;

            goto try_except_handler_45;
        }
        tmp_condition_result_20 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_20 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_20;
        } else {
            goto condexpr_false_20;
        }
        condexpr_true_20:;
        CHECK_OBJECT(tmp_class_creation_20__class_dict);
        tmp_dict_name_40 = tmp_class_creation_20__class_dict;
        tmp_key_name_40 = const_str_plain___metaclass__;
        tmp_assign_source_131 = DICT_GET_ITEM(tmp_dict_name_40, tmp_key_name_40);
        if (tmp_assign_source_131 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 784;

            goto try_except_handler_45;
        }
        goto condexpr_end_20;
        condexpr_false_20:;
        tmp_assign_source_131 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_131);
        condexpr_end_20:;
        assert(tmp_class_creation_20__metaclass == NULL);
        tmp_class_creation_20__metaclass = tmp_assign_source_131;
    }
    {
        PyObject *tmp_assign_source_132;
        PyObject *tmp_called_name_42;
        PyObject *tmp_args_element_name_81;
        PyObject *tmp_args_element_name_82;
        PyObject *tmp_args_element_name_83;
        CHECK_OBJECT(tmp_class_creation_20__metaclass);
        tmp_called_name_42 = tmp_class_creation_20__metaclass;
        tmp_args_element_name_81 = const_str_plain_NoticeReference;
        tmp_args_element_name_82 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_20__class_dict);
        tmp_args_element_name_83 = tmp_class_creation_20__class_dict;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 784;
        {
            PyObject *call_args[] = {tmp_args_element_name_81, tmp_args_element_name_82, tmp_args_element_name_83};
            tmp_assign_source_132 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_42, call_args);
        }

        if (tmp_assign_source_132 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 784;

            goto try_except_handler_45;
        }
        assert(tmp_class_creation_20__class == NULL);
        tmp_class_creation_20__class = tmp_assign_source_132;
    }
    goto try_end_24;
    // Exception handler code:
    try_except_handler_45:;
    exception_keeper_type_41 = exception_type;
    exception_keeper_value_41 = exception_value;
    exception_keeper_tb_41 = exception_tb;
    exception_keeper_lineno_41 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_20__class_dict);
    tmp_class_creation_20__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_20__metaclass);
    tmp_class_creation_20__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_41;
    exception_value = exception_keeper_value_41;
    exception_tb = exception_keeper_tb_41;
    exception_lineno = exception_keeper_lineno_41;

    goto frame_exception_exit_1;
    // End of try:
    try_end_24:;
    {
        PyObject *tmp_assign_source_133;
        CHECK_OBJECT(tmp_class_creation_20__class);
        tmp_assign_source_133 = tmp_class_creation_20__class;
        UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_NoticeReference, tmp_assign_source_133);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_20__class);
    Py_DECREF(tmp_class_creation_20__class);
    tmp_class_creation_20__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_20__class_dict);
    Py_DECREF(tmp_class_creation_20__class_dict);
    tmp_class_creation_20__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_20__metaclass);
    Py_DECREF(tmp_class_creation_20__metaclass);
    tmp_class_creation_20__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_134;
        {
            PyObject *tmp_set_locals_18;
            tmp_set_locals_18 = PyDict_New();
            locals_cryptography$x509$extensions_821 = tmp_set_locals_18;
        }
        tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_821, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_d76b975938eb3793df08887e6a883dcc_18, codeobj_d76b975938eb3793df08887e6a883dcc, module_cryptography$x509$extensions, 0);
        frame_d76b975938eb3793df08887e6a883dcc_18 = cache_frame_d76b975938eb3793df08887e6a883dcc_18;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_d76b975938eb3793df08887e6a883dcc_18);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_d76b975938eb3793df08887e6a883dcc_18) == 2); // Frame stack

        // Framed code:
        {
            PyObject *tmp_source_name_24;
            PyObject *tmp_mvar_value_57;
            tmp_mvar_value_57 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID);

            if (unlikely(tmp_mvar_value_57 == NULL)) {
                tmp_mvar_value_57 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionOID);
            }

            if (tmp_mvar_value_57 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 23410 ], 34, 0);
                exception_tb = NULL;

                exception_lineno = 822;

                goto frame_exception_exit_18;
            }

            tmp_source_name_24 = tmp_mvar_value_57;
            tmp_dictset_value = LOOKUP_ATTRIBUTE(tmp_source_name_24, const_str_plain_EXTENDED_KEY_USAGE);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 822;

                goto frame_exception_exit_18;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_821, const_str_plain_oid, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 822;

                goto frame_exception_exit_18;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_d76b975938eb3793df08887e6a883dcc_18);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_17;

        frame_exception_exit_18:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_d76b975938eb3793df08887e6a883dcc_18);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_d76b975938eb3793df08887e6a883dcc_18, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_d76b975938eb3793df08887e6a883dcc_18->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_d76b975938eb3793df08887e6a883dcc_18, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_d76b975938eb3793df08887e6a883dcc_18,
            type_description_2
        );


        // Release cached frame.
        if (frame_d76b975938eb3793df08887e6a883dcc_18 == cache_frame_d76b975938eb3793df08887e6a883dcc_18) {
            Py_DECREF(frame_d76b975938eb3793df08887e6a883dcc_18);
        }
        cache_frame_d76b975938eb3793df08887e6a883dcc_18 = NULL;

        assertFrameObject(frame_d76b975938eb3793df08887e6a883dcc_18);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_17;

        frame_no_exception_17:;
        goto skip_nested_handling_17;
        nested_frame_exit_17:;

        goto try_except_handler_48;
        skip_nested_handling_17:;
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_102___init__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_821, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_103___iter__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_821, const_str_plain___iter__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_104___len__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_821, const_str_plain___len__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_105___repr__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_821, const_str_plain___repr__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_106___eq__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_821, const_str_plain___eq__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_107___ne__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_821, const_str_plain___ne__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_108___hash__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_821, const_str_plain___hash__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_assign_source_134 = locals_cryptography$x509$extensions_821;
        Py_INCREF(tmp_assign_source_134);
        goto try_return_handler_48;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Return handler code:
        try_return_handler_48:;
        Py_DECREF(locals_cryptography$x509$extensions_821);
        locals_cryptography$x509$extensions_821 = NULL;
        goto outline_result_22;
        // Exception handler code:
        try_except_handler_48:;
        exception_keeper_type_42 = exception_type;
        exception_keeper_value_42 = exception_value;
        exception_keeper_tb_42 = exception_tb;
        exception_keeper_lineno_42 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_cryptography$x509$extensions_821);
        locals_cryptography$x509$extensions_821 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_42;
        exception_value = exception_keeper_value_42;
        exception_tb = exception_keeper_tb_42;
        exception_lineno = exception_keeper_lineno_42;

        goto outline_exception_17;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        outline_exception_17:;
        exception_lineno = 821;
        goto try_except_handler_47;
        outline_result_22:;
        assert(tmp_class_creation_21__class_dict == NULL);
        tmp_class_creation_21__class_dict = tmp_assign_source_134;
    }
    {
        PyObject *tmp_assign_source_135;
        nuitka_bool tmp_condition_result_21;
        PyObject *tmp_key_name_41;
        PyObject *tmp_dict_name_41;
        PyObject *tmp_dict_name_42;
        PyObject *tmp_key_name_42;
        tmp_key_name_41 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_21__class_dict);
        tmp_dict_name_41 = tmp_class_creation_21__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_41, tmp_key_name_41);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 821;

            goto try_except_handler_47;
        }
        tmp_condition_result_21 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_21 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_21;
        } else {
            goto condexpr_false_21;
        }
        condexpr_true_21:;
        CHECK_OBJECT(tmp_class_creation_21__class_dict);
        tmp_dict_name_42 = tmp_class_creation_21__class_dict;
        tmp_key_name_42 = const_str_plain___metaclass__;
        tmp_assign_source_135 = DICT_GET_ITEM(tmp_dict_name_42, tmp_key_name_42);
        if (tmp_assign_source_135 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 821;

            goto try_except_handler_47;
        }
        goto condexpr_end_21;
        condexpr_false_21:;
        tmp_assign_source_135 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_135);
        condexpr_end_21:;
        assert(tmp_class_creation_21__metaclass == NULL);
        tmp_class_creation_21__metaclass = tmp_assign_source_135;
    }
    {
        PyObject *tmp_assign_source_136;
        PyObject *tmp_called_name_43;
        PyObject *tmp_args_element_name_84;
        PyObject *tmp_args_element_name_85;
        PyObject *tmp_args_element_name_86;
        CHECK_OBJECT(tmp_class_creation_21__metaclass);
        tmp_called_name_43 = tmp_class_creation_21__metaclass;
        tmp_args_element_name_84 = const_str_plain_ExtendedKeyUsage;
        tmp_args_element_name_85 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_21__class_dict);
        tmp_args_element_name_86 = tmp_class_creation_21__class_dict;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 821;
        {
            PyObject *call_args[] = {tmp_args_element_name_84, tmp_args_element_name_85, tmp_args_element_name_86};
            tmp_assign_source_136 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_43, call_args);
        }

        if (tmp_assign_source_136 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 821;

            goto try_except_handler_47;
        }
        assert(tmp_class_creation_21__class == NULL);
        tmp_class_creation_21__class = tmp_assign_source_136;
    }
    {
        PyObject *tmp_assign_source_137;
        PyObject *tmp_called_name_44;
        PyObject *tmp_called_name_45;
        PyObject *tmp_source_name_25;
        PyObject *tmp_mvar_value_58;
        PyObject *tmp_args_element_name_87;
        PyObject *tmp_mvar_value_59;
        PyObject *tmp_args_element_name_88;
        tmp_mvar_value_58 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

        if (unlikely(tmp_mvar_value_58 == NULL)) {
            tmp_mvar_value_58 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
        }

        if (tmp_mvar_value_58 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
            exception_tb = NULL;

            exception_lineno = 820;

            goto try_except_handler_47;
        }

        tmp_source_name_25 = tmp_mvar_value_58;
        tmp_called_name_45 = LOOKUP_ATTRIBUTE(tmp_source_name_25, const_str_plain_register_interface);
        if (tmp_called_name_45 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 820;

            goto try_except_handler_47;
        }
        tmp_mvar_value_59 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType);

        if (unlikely(tmp_mvar_value_59 == NULL)) {
            tmp_mvar_value_59 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType);
        }

        if (tmp_mvar_value_59 == NULL) {
            Py_DECREF(tmp_called_name_45);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 35484 ], 35, 0);
            exception_tb = NULL;

            exception_lineno = 820;

            goto try_except_handler_47;
        }

        tmp_args_element_name_87 = tmp_mvar_value_59;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 820;
        tmp_called_name_44 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_45, tmp_args_element_name_87);
        Py_DECREF(tmp_called_name_45);
        if (tmp_called_name_44 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 820;

            goto try_except_handler_47;
        }
        CHECK_OBJECT(tmp_class_creation_21__class);
        tmp_args_element_name_88 = tmp_class_creation_21__class;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 820;
        tmp_assign_source_137 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_44, tmp_args_element_name_88);
        Py_DECREF(tmp_called_name_44);
        if (tmp_assign_source_137 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 820;

            goto try_except_handler_47;
        }
        {
            PyObject *old = tmp_class_creation_21__class;
            assert(old != NULL);
            tmp_class_creation_21__class = tmp_assign_source_137;
            Py_DECREF(old);
        }

    }
    goto try_end_25;
    // Exception handler code:
    try_except_handler_47:;
    exception_keeper_type_43 = exception_type;
    exception_keeper_value_43 = exception_value;
    exception_keeper_tb_43 = exception_tb;
    exception_keeper_lineno_43 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_21__class);
    tmp_class_creation_21__class = NULL;

    Py_XDECREF(tmp_class_creation_21__class_dict);
    tmp_class_creation_21__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_21__metaclass);
    tmp_class_creation_21__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_43;
    exception_value = exception_keeper_value_43;
    exception_tb = exception_keeper_tb_43;
    exception_lineno = exception_keeper_lineno_43;

    goto frame_exception_exit_1;
    // End of try:
    try_end_25:;
    {
        PyObject *tmp_assign_source_138;
        CHECK_OBJECT(tmp_class_creation_21__class);
        tmp_assign_source_138 = tmp_class_creation_21__class;
        UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtendedKeyUsage, tmp_assign_source_138);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_21__class);
    Py_DECREF(tmp_class_creation_21__class);
    tmp_class_creation_21__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_21__class_dict);
    Py_DECREF(tmp_class_creation_21__class_dict);
    tmp_class_creation_21__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_21__metaclass);
    Py_DECREF(tmp_class_creation_21__metaclass);
    tmp_class_creation_21__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_139;
        {
            PyObject *tmp_set_locals_19;
            tmp_set_locals_19 = PyDict_New();
            locals_cryptography$x509$extensions_856 = tmp_set_locals_19;
        }
        tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_856, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_14b4d327d26227dbeeaf8ac21d0eead5_19, codeobj_14b4d327d26227dbeeaf8ac21d0eead5, module_cryptography$x509$extensions, 0);
        frame_14b4d327d26227dbeeaf8ac21d0eead5_19 = cache_frame_14b4d327d26227dbeeaf8ac21d0eead5_19;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_14b4d327d26227dbeeaf8ac21d0eead5_19);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_14b4d327d26227dbeeaf8ac21d0eead5_19) == 2); // Frame stack

        // Framed code:
        {
            PyObject *tmp_source_name_26;
            PyObject *tmp_mvar_value_60;
            tmp_mvar_value_60 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID);

            if (unlikely(tmp_mvar_value_60 == NULL)) {
                tmp_mvar_value_60 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionOID);
            }

            if (tmp_mvar_value_60 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 23410 ], 34, 0);
                exception_tb = NULL;

                exception_lineno = 857;

                goto frame_exception_exit_19;
            }

            tmp_source_name_26 = tmp_mvar_value_60;
            tmp_dictset_value = LOOKUP_ATTRIBUTE(tmp_source_name_26, const_str_plain_OCSP_NO_CHECK);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 857;

                goto frame_exception_exit_19;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_856, const_str_plain_oid, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 857;

                goto frame_exception_exit_19;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_14b4d327d26227dbeeaf8ac21d0eead5_19);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_18;

        frame_exception_exit_19:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_14b4d327d26227dbeeaf8ac21d0eead5_19);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_14b4d327d26227dbeeaf8ac21d0eead5_19, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_14b4d327d26227dbeeaf8ac21d0eead5_19->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_14b4d327d26227dbeeaf8ac21d0eead5_19, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_14b4d327d26227dbeeaf8ac21d0eead5_19,
            type_description_2
        );


        // Release cached frame.
        if (frame_14b4d327d26227dbeeaf8ac21d0eead5_19 == cache_frame_14b4d327d26227dbeeaf8ac21d0eead5_19) {
            Py_DECREF(frame_14b4d327d26227dbeeaf8ac21d0eead5_19);
        }
        cache_frame_14b4d327d26227dbeeaf8ac21d0eead5_19 = NULL;

        assertFrameObject(frame_14b4d327d26227dbeeaf8ac21d0eead5_19);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_18;

        frame_no_exception_18:;
        goto skip_nested_handling_18;
        nested_frame_exit_18:;

        goto try_except_handler_50;
        skip_nested_handling_18:;
        tmp_assign_source_139 = locals_cryptography$x509$extensions_856;
        Py_INCREF(tmp_assign_source_139);
        goto try_return_handler_50;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Return handler code:
        try_return_handler_50:;
        Py_DECREF(locals_cryptography$x509$extensions_856);
        locals_cryptography$x509$extensions_856 = NULL;
        goto outline_result_23;
        // Exception handler code:
        try_except_handler_50:;
        exception_keeper_type_44 = exception_type;
        exception_keeper_value_44 = exception_value;
        exception_keeper_tb_44 = exception_tb;
        exception_keeper_lineno_44 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_cryptography$x509$extensions_856);
        locals_cryptography$x509$extensions_856 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_44;
        exception_value = exception_keeper_value_44;
        exception_tb = exception_keeper_tb_44;
        exception_lineno = exception_keeper_lineno_44;

        goto outline_exception_18;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        outline_exception_18:;
        exception_lineno = 856;
        goto try_except_handler_49;
        outline_result_23:;
        assert(tmp_class_creation_22__class_dict == NULL);
        tmp_class_creation_22__class_dict = tmp_assign_source_139;
    }
    {
        PyObject *tmp_assign_source_140;
        nuitka_bool tmp_condition_result_22;
        PyObject *tmp_key_name_43;
        PyObject *tmp_dict_name_43;
        PyObject *tmp_dict_name_44;
        PyObject *tmp_key_name_44;
        tmp_key_name_43 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_22__class_dict);
        tmp_dict_name_43 = tmp_class_creation_22__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_43, tmp_key_name_43);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 856;

            goto try_except_handler_49;
        }
        tmp_condition_result_22 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_22 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_22;
        } else {
            goto condexpr_false_22;
        }
        condexpr_true_22:;
        CHECK_OBJECT(tmp_class_creation_22__class_dict);
        tmp_dict_name_44 = tmp_class_creation_22__class_dict;
        tmp_key_name_44 = const_str_plain___metaclass__;
        tmp_assign_source_140 = DICT_GET_ITEM(tmp_dict_name_44, tmp_key_name_44);
        if (tmp_assign_source_140 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 856;

            goto try_except_handler_49;
        }
        goto condexpr_end_22;
        condexpr_false_22:;
        tmp_assign_source_140 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_140);
        condexpr_end_22:;
        assert(tmp_class_creation_22__metaclass == NULL);
        tmp_class_creation_22__metaclass = tmp_assign_source_140;
    }
    {
        PyObject *tmp_assign_source_141;
        PyObject *tmp_called_name_46;
        PyObject *tmp_args_element_name_89;
        PyObject *tmp_args_element_name_90;
        PyObject *tmp_args_element_name_91;
        CHECK_OBJECT(tmp_class_creation_22__metaclass);
        tmp_called_name_46 = tmp_class_creation_22__metaclass;
        tmp_args_element_name_89 = const_str_plain_OCSPNoCheck;
        tmp_args_element_name_90 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_22__class_dict);
        tmp_args_element_name_91 = tmp_class_creation_22__class_dict;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 856;
        {
            PyObject *call_args[] = {tmp_args_element_name_89, tmp_args_element_name_90, tmp_args_element_name_91};
            tmp_assign_source_141 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_46, call_args);
        }

        if (tmp_assign_source_141 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 856;

            goto try_except_handler_49;
        }
        assert(tmp_class_creation_22__class == NULL);
        tmp_class_creation_22__class = tmp_assign_source_141;
    }
    {
        PyObject *tmp_assign_source_142;
        PyObject *tmp_called_name_47;
        PyObject *tmp_called_name_48;
        PyObject *tmp_source_name_27;
        PyObject *tmp_mvar_value_61;
        PyObject *tmp_args_element_name_92;
        PyObject *tmp_mvar_value_62;
        PyObject *tmp_args_element_name_93;
        tmp_mvar_value_61 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

        if (unlikely(tmp_mvar_value_61 == NULL)) {
            tmp_mvar_value_61 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
        }

        if (tmp_mvar_value_61 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
            exception_tb = NULL;

            exception_lineno = 855;

            goto try_except_handler_49;
        }

        tmp_source_name_27 = tmp_mvar_value_61;
        tmp_called_name_48 = LOOKUP_ATTRIBUTE(tmp_source_name_27, const_str_plain_register_interface);
        if (tmp_called_name_48 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 855;

            goto try_except_handler_49;
        }
        tmp_mvar_value_62 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType);

        if (unlikely(tmp_mvar_value_62 == NULL)) {
            tmp_mvar_value_62 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType);
        }

        if (tmp_mvar_value_62 == NULL) {
            Py_DECREF(tmp_called_name_48);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 35484 ], 35, 0);
            exception_tb = NULL;

            exception_lineno = 855;

            goto try_except_handler_49;
        }

        tmp_args_element_name_92 = tmp_mvar_value_62;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 855;
        tmp_called_name_47 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_48, tmp_args_element_name_92);
        Py_DECREF(tmp_called_name_48);
        if (tmp_called_name_47 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 855;

            goto try_except_handler_49;
        }
        CHECK_OBJECT(tmp_class_creation_22__class);
        tmp_args_element_name_93 = tmp_class_creation_22__class;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 855;
        tmp_assign_source_142 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_47, tmp_args_element_name_93);
        Py_DECREF(tmp_called_name_47);
        if (tmp_assign_source_142 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 855;

            goto try_except_handler_49;
        }
        {
            PyObject *old = tmp_class_creation_22__class;
            assert(old != NULL);
            tmp_class_creation_22__class = tmp_assign_source_142;
            Py_DECREF(old);
        }

    }
    goto try_end_26;
    // Exception handler code:
    try_except_handler_49:;
    exception_keeper_type_45 = exception_type;
    exception_keeper_value_45 = exception_value;
    exception_keeper_tb_45 = exception_tb;
    exception_keeper_lineno_45 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_22__class);
    tmp_class_creation_22__class = NULL;

    Py_XDECREF(tmp_class_creation_22__class_dict);
    tmp_class_creation_22__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_22__metaclass);
    tmp_class_creation_22__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_45;
    exception_value = exception_keeper_value_45;
    exception_tb = exception_keeper_tb_45;
    exception_lineno = exception_keeper_lineno_45;

    goto frame_exception_exit_1;
    // End of try:
    try_end_26:;
    {
        PyObject *tmp_assign_source_143;
        CHECK_OBJECT(tmp_class_creation_22__class);
        tmp_assign_source_143 = tmp_class_creation_22__class;
        UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_OCSPNoCheck, tmp_assign_source_143);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_22__class);
    Py_DECREF(tmp_class_creation_22__class);
    tmp_class_creation_22__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_22__class_dict);
    Py_DECREF(tmp_class_creation_22__class_dict);
    tmp_class_creation_22__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_22__metaclass);
    Py_DECREF(tmp_class_creation_22__metaclass);
    tmp_class_creation_22__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_144;
        {
            PyObject *tmp_set_locals_20;
            tmp_set_locals_20 = PyDict_New();
            locals_cryptography$x509$extensions_861 = tmp_set_locals_20;
        }
        tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_861, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_5b0a6348dd417584c7f202513d6c4148_20, codeobj_5b0a6348dd417584c7f202513d6c4148, module_cryptography$x509$extensions, 0);
        frame_5b0a6348dd417584c7f202513d6c4148_20 = cache_frame_5b0a6348dd417584c7f202513d6c4148_20;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_5b0a6348dd417584c7f202513d6c4148_20);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_5b0a6348dd417584c7f202513d6c4148_20) == 2); // Frame stack

        // Framed code:
        {
            PyObject *tmp_source_name_28;
            PyObject *tmp_mvar_value_63;
            tmp_mvar_value_63 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID);

            if (unlikely(tmp_mvar_value_63 == NULL)) {
                tmp_mvar_value_63 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionOID);
            }

            if (tmp_mvar_value_63 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 23410 ], 34, 0);
                exception_tb = NULL;

                exception_lineno = 862;

                goto frame_exception_exit_20;
            }

            tmp_source_name_28 = tmp_mvar_value_63;
            tmp_dictset_value = LOOKUP_ATTRIBUTE(tmp_source_name_28, const_str_plain_PRECERT_POISON);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 862;

                goto frame_exception_exit_20;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_861, const_str_plain_oid, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 862;

                goto frame_exception_exit_20;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_5b0a6348dd417584c7f202513d6c4148_20);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_19;

        frame_exception_exit_20:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_5b0a6348dd417584c7f202513d6c4148_20);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_5b0a6348dd417584c7f202513d6c4148_20, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_5b0a6348dd417584c7f202513d6c4148_20->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_5b0a6348dd417584c7f202513d6c4148_20, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_5b0a6348dd417584c7f202513d6c4148_20,
            type_description_2
        );


        // Release cached frame.
        if (frame_5b0a6348dd417584c7f202513d6c4148_20 == cache_frame_5b0a6348dd417584c7f202513d6c4148_20) {
            Py_DECREF(frame_5b0a6348dd417584c7f202513d6c4148_20);
        }
        cache_frame_5b0a6348dd417584c7f202513d6c4148_20 = NULL;

        assertFrameObject(frame_5b0a6348dd417584c7f202513d6c4148_20);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_19;

        frame_no_exception_19:;
        goto skip_nested_handling_19;
        nested_frame_exit_19:;

        goto try_except_handler_52;
        skip_nested_handling_19:;
        tmp_assign_source_144 = locals_cryptography$x509$extensions_861;
        Py_INCREF(tmp_assign_source_144);
        goto try_return_handler_52;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Return handler code:
        try_return_handler_52:;
        Py_DECREF(locals_cryptography$x509$extensions_861);
        locals_cryptography$x509$extensions_861 = NULL;
        goto outline_result_24;
        // Exception handler code:
        try_except_handler_52:;
        exception_keeper_type_46 = exception_type;
        exception_keeper_value_46 = exception_value;
        exception_keeper_tb_46 = exception_tb;
        exception_keeper_lineno_46 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_cryptography$x509$extensions_861);
        locals_cryptography$x509$extensions_861 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_46;
        exception_value = exception_keeper_value_46;
        exception_tb = exception_keeper_tb_46;
        exception_lineno = exception_keeper_lineno_46;

        goto outline_exception_19;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        outline_exception_19:;
        exception_lineno = 861;
        goto try_except_handler_51;
        outline_result_24:;
        assert(tmp_class_creation_23__class_dict == NULL);
        tmp_class_creation_23__class_dict = tmp_assign_source_144;
    }
    {
        PyObject *tmp_assign_source_145;
        nuitka_bool tmp_condition_result_23;
        PyObject *tmp_key_name_45;
        PyObject *tmp_dict_name_45;
        PyObject *tmp_dict_name_46;
        PyObject *tmp_key_name_46;
        tmp_key_name_45 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_23__class_dict);
        tmp_dict_name_45 = tmp_class_creation_23__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_45, tmp_key_name_45);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 861;

            goto try_except_handler_51;
        }
        tmp_condition_result_23 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_23 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_23;
        } else {
            goto condexpr_false_23;
        }
        condexpr_true_23:;
        CHECK_OBJECT(tmp_class_creation_23__class_dict);
        tmp_dict_name_46 = tmp_class_creation_23__class_dict;
        tmp_key_name_46 = const_str_plain___metaclass__;
        tmp_assign_source_145 = DICT_GET_ITEM(tmp_dict_name_46, tmp_key_name_46);
        if (tmp_assign_source_145 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 861;

            goto try_except_handler_51;
        }
        goto condexpr_end_23;
        condexpr_false_23:;
        tmp_assign_source_145 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_145);
        condexpr_end_23:;
        assert(tmp_class_creation_23__metaclass == NULL);
        tmp_class_creation_23__metaclass = tmp_assign_source_145;
    }
    {
        PyObject *tmp_assign_source_146;
        PyObject *tmp_called_name_49;
        PyObject *tmp_args_element_name_94;
        PyObject *tmp_args_element_name_95;
        PyObject *tmp_args_element_name_96;
        CHECK_OBJECT(tmp_class_creation_23__metaclass);
        tmp_called_name_49 = tmp_class_creation_23__metaclass;
        tmp_args_element_name_94 = const_str_plain_PrecertPoison;
        tmp_args_element_name_95 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_23__class_dict);
        tmp_args_element_name_96 = tmp_class_creation_23__class_dict;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 861;
        {
            PyObject *call_args[] = {tmp_args_element_name_94, tmp_args_element_name_95, tmp_args_element_name_96};
            tmp_assign_source_146 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_49, call_args);
        }

        if (tmp_assign_source_146 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 861;

            goto try_except_handler_51;
        }
        assert(tmp_class_creation_23__class == NULL);
        tmp_class_creation_23__class = tmp_assign_source_146;
    }
    {
        PyObject *tmp_assign_source_147;
        PyObject *tmp_called_name_50;
        PyObject *tmp_called_name_51;
        PyObject *tmp_source_name_29;
        PyObject *tmp_mvar_value_64;
        PyObject *tmp_args_element_name_97;
        PyObject *tmp_mvar_value_65;
        PyObject *tmp_args_element_name_98;
        tmp_mvar_value_64 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

        if (unlikely(tmp_mvar_value_64 == NULL)) {
            tmp_mvar_value_64 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
        }

        if (tmp_mvar_value_64 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
            exception_tb = NULL;

            exception_lineno = 860;

            goto try_except_handler_51;
        }

        tmp_source_name_29 = tmp_mvar_value_64;
        tmp_called_name_51 = LOOKUP_ATTRIBUTE(tmp_source_name_29, const_str_plain_register_interface);
        if (tmp_called_name_51 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 860;

            goto try_except_handler_51;
        }
        tmp_mvar_value_65 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType);

        if (unlikely(tmp_mvar_value_65 == NULL)) {
            tmp_mvar_value_65 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType);
        }

        if (tmp_mvar_value_65 == NULL) {
            Py_DECREF(tmp_called_name_51);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 35484 ], 35, 0);
            exception_tb = NULL;

            exception_lineno = 860;

            goto try_except_handler_51;
        }

        tmp_args_element_name_97 = tmp_mvar_value_65;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 860;
        tmp_called_name_50 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_51, tmp_args_element_name_97);
        Py_DECREF(tmp_called_name_51);
        if (tmp_called_name_50 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 860;

            goto try_except_handler_51;
        }
        CHECK_OBJECT(tmp_class_creation_23__class);
        tmp_args_element_name_98 = tmp_class_creation_23__class;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 860;
        tmp_assign_source_147 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_50, tmp_args_element_name_98);
        Py_DECREF(tmp_called_name_50);
        if (tmp_assign_source_147 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 860;

            goto try_except_handler_51;
        }
        {
            PyObject *old = tmp_class_creation_23__class;
            assert(old != NULL);
            tmp_class_creation_23__class = tmp_assign_source_147;
            Py_DECREF(old);
        }

    }
    goto try_end_27;
    // Exception handler code:
    try_except_handler_51:;
    exception_keeper_type_47 = exception_type;
    exception_keeper_value_47 = exception_value;
    exception_keeper_tb_47 = exception_tb;
    exception_keeper_lineno_47 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_23__class);
    tmp_class_creation_23__class = NULL;

    Py_XDECREF(tmp_class_creation_23__class_dict);
    tmp_class_creation_23__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_23__metaclass);
    tmp_class_creation_23__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_47;
    exception_value = exception_keeper_value_47;
    exception_tb = exception_keeper_tb_47;
    exception_lineno = exception_keeper_lineno_47;

    goto frame_exception_exit_1;
    // End of try:
    try_end_27:;
    {
        PyObject *tmp_assign_source_148;
        CHECK_OBJECT(tmp_class_creation_23__class);
        tmp_assign_source_148 = tmp_class_creation_23__class;
        UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_PrecertPoison, tmp_assign_source_148);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_23__class);
    Py_DECREF(tmp_class_creation_23__class);
    tmp_class_creation_23__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_23__class_dict);
    Py_DECREF(tmp_class_creation_23__class_dict);
    tmp_class_creation_23__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_23__metaclass);
    Py_DECREF(tmp_class_creation_23__metaclass);
    tmp_class_creation_23__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_149;
        {
            PyObject *tmp_set_locals_21;
            tmp_set_locals_21 = PyDict_New();
            locals_cryptography$x509$extensions_866 = tmp_set_locals_21;
        }
        tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_866, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_31b0147aee22ba20318b32af38dd79aa_21, codeobj_31b0147aee22ba20318b32af38dd79aa, module_cryptography$x509$extensions, 0);
        frame_31b0147aee22ba20318b32af38dd79aa_21 = cache_frame_31b0147aee22ba20318b32af38dd79aa_21;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_31b0147aee22ba20318b32af38dd79aa_21);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_31b0147aee22ba20318b32af38dd79aa_21) == 2); // Frame stack

        // Framed code:
        {
            PyObject *tmp_source_name_30;
            PyObject *tmp_mvar_value_66;
            tmp_mvar_value_66 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID);

            if (unlikely(tmp_mvar_value_66 == NULL)) {
                tmp_mvar_value_66 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionOID);
            }

            if (tmp_mvar_value_66 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 23410 ], 34, 0);
                exception_tb = NULL;

                exception_lineno = 867;

                goto frame_exception_exit_21;
            }

            tmp_source_name_30 = tmp_mvar_value_66;
            tmp_dictset_value = LOOKUP_ATTRIBUTE(tmp_source_name_30, const_str_plain_TLS_FEATURE);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 867;

                goto frame_exception_exit_21;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_866, const_str_plain_oid, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 867;

                goto frame_exception_exit_21;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_31b0147aee22ba20318b32af38dd79aa_21);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_20;

        frame_exception_exit_21:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_31b0147aee22ba20318b32af38dd79aa_21);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_31b0147aee22ba20318b32af38dd79aa_21, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_31b0147aee22ba20318b32af38dd79aa_21->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_31b0147aee22ba20318b32af38dd79aa_21, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_31b0147aee22ba20318b32af38dd79aa_21,
            type_description_2
        );


        // Release cached frame.
        if (frame_31b0147aee22ba20318b32af38dd79aa_21 == cache_frame_31b0147aee22ba20318b32af38dd79aa_21) {
            Py_DECREF(frame_31b0147aee22ba20318b32af38dd79aa_21);
        }
        cache_frame_31b0147aee22ba20318b32af38dd79aa_21 = NULL;

        assertFrameObject(frame_31b0147aee22ba20318b32af38dd79aa_21);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_20;

        frame_no_exception_20:;
        goto skip_nested_handling_20;
        nested_frame_exit_20:;

        goto try_except_handler_54;
        skip_nested_handling_20:;
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_109___init__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_866, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_110___iter__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_866, const_str_plain___iter__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_111___len__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_866, const_str_plain___len__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_112___repr__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_866, const_str_plain___repr__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_113___eq__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_866, const_str_plain___eq__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_114___getitem__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_866, const_str_plain___getitem__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_115___ne__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_866, const_str_plain___ne__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_116___hash__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_866, const_str_plain___hash__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_assign_source_149 = locals_cryptography$x509$extensions_866;
        Py_INCREF(tmp_assign_source_149);
        goto try_return_handler_54;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Return handler code:
        try_return_handler_54:;
        Py_DECREF(locals_cryptography$x509$extensions_866);
        locals_cryptography$x509$extensions_866 = NULL;
        goto outline_result_25;
        // Exception handler code:
        try_except_handler_54:;
        exception_keeper_type_48 = exception_type;
        exception_keeper_value_48 = exception_value;
        exception_keeper_tb_48 = exception_tb;
        exception_keeper_lineno_48 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_cryptography$x509$extensions_866);
        locals_cryptography$x509$extensions_866 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_48;
        exception_value = exception_keeper_value_48;
        exception_tb = exception_keeper_tb_48;
        exception_lineno = exception_keeper_lineno_48;

        goto outline_exception_20;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        outline_exception_20:;
        exception_lineno = 866;
        goto try_except_handler_53;
        outline_result_25:;
        assert(tmp_class_creation_24__class_dict == NULL);
        tmp_class_creation_24__class_dict = tmp_assign_source_149;
    }
    {
        PyObject *tmp_assign_source_150;
        nuitka_bool tmp_condition_result_24;
        PyObject *tmp_key_name_47;
        PyObject *tmp_dict_name_47;
        PyObject *tmp_dict_name_48;
        PyObject *tmp_key_name_48;
        tmp_key_name_47 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_24__class_dict);
        tmp_dict_name_47 = tmp_class_creation_24__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_47, tmp_key_name_47);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 866;

            goto try_except_handler_53;
        }
        tmp_condition_result_24 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_24 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_24;
        } else {
            goto condexpr_false_24;
        }
        condexpr_true_24:;
        CHECK_OBJECT(tmp_class_creation_24__class_dict);
        tmp_dict_name_48 = tmp_class_creation_24__class_dict;
        tmp_key_name_48 = const_str_plain___metaclass__;
        tmp_assign_source_150 = DICT_GET_ITEM(tmp_dict_name_48, tmp_key_name_48);
        if (tmp_assign_source_150 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 866;

            goto try_except_handler_53;
        }
        goto condexpr_end_24;
        condexpr_false_24:;
        tmp_assign_source_150 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_150);
        condexpr_end_24:;
        assert(tmp_class_creation_24__metaclass == NULL);
        tmp_class_creation_24__metaclass = tmp_assign_source_150;
    }
    {
        PyObject *tmp_assign_source_151;
        PyObject *tmp_called_name_52;
        PyObject *tmp_args_element_name_99;
        PyObject *tmp_args_element_name_100;
        PyObject *tmp_args_element_name_101;
        CHECK_OBJECT(tmp_class_creation_24__metaclass);
        tmp_called_name_52 = tmp_class_creation_24__metaclass;
        tmp_args_element_name_99 = const_str_plain_TLSFeature;
        tmp_args_element_name_100 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_24__class_dict);
        tmp_args_element_name_101 = tmp_class_creation_24__class_dict;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 866;
        {
            PyObject *call_args[] = {tmp_args_element_name_99, tmp_args_element_name_100, tmp_args_element_name_101};
            tmp_assign_source_151 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_52, call_args);
        }

        if (tmp_assign_source_151 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 866;

            goto try_except_handler_53;
        }
        assert(tmp_class_creation_24__class == NULL);
        tmp_class_creation_24__class = tmp_assign_source_151;
    }
    {
        PyObject *tmp_assign_source_152;
        PyObject *tmp_called_name_53;
        PyObject *tmp_called_name_54;
        PyObject *tmp_source_name_31;
        PyObject *tmp_mvar_value_67;
        PyObject *tmp_args_element_name_102;
        PyObject *tmp_mvar_value_68;
        PyObject *tmp_args_element_name_103;
        tmp_mvar_value_67 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

        if (unlikely(tmp_mvar_value_67 == NULL)) {
            tmp_mvar_value_67 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
        }

        if (tmp_mvar_value_67 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
            exception_tb = NULL;

            exception_lineno = 865;

            goto try_except_handler_53;
        }

        tmp_source_name_31 = tmp_mvar_value_67;
        tmp_called_name_54 = LOOKUP_ATTRIBUTE(tmp_source_name_31, const_str_plain_register_interface);
        if (tmp_called_name_54 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 865;

            goto try_except_handler_53;
        }
        tmp_mvar_value_68 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType);

        if (unlikely(tmp_mvar_value_68 == NULL)) {
            tmp_mvar_value_68 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType);
        }

        if (tmp_mvar_value_68 == NULL) {
            Py_DECREF(tmp_called_name_54);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 35484 ], 35, 0);
            exception_tb = NULL;

            exception_lineno = 865;

            goto try_except_handler_53;
        }

        tmp_args_element_name_102 = tmp_mvar_value_68;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 865;
        tmp_called_name_53 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_54, tmp_args_element_name_102);
        Py_DECREF(tmp_called_name_54);
        if (tmp_called_name_53 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 865;

            goto try_except_handler_53;
        }
        CHECK_OBJECT(tmp_class_creation_24__class);
        tmp_args_element_name_103 = tmp_class_creation_24__class;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 865;
        tmp_assign_source_152 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_53, tmp_args_element_name_103);
        Py_DECREF(tmp_called_name_53);
        if (tmp_assign_source_152 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 865;

            goto try_except_handler_53;
        }
        {
            PyObject *old = tmp_class_creation_24__class;
            assert(old != NULL);
            tmp_class_creation_24__class = tmp_assign_source_152;
            Py_DECREF(old);
        }

    }
    goto try_end_28;
    // Exception handler code:
    try_except_handler_53:;
    exception_keeper_type_49 = exception_type;
    exception_keeper_value_49 = exception_value;
    exception_keeper_tb_49 = exception_tb;
    exception_keeper_lineno_49 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_24__class);
    tmp_class_creation_24__class = NULL;

    Py_XDECREF(tmp_class_creation_24__class_dict);
    tmp_class_creation_24__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_24__metaclass);
    tmp_class_creation_24__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_49;
    exception_value = exception_keeper_value_49;
    exception_tb = exception_keeper_tb_49;
    exception_lineno = exception_keeper_lineno_49;

    goto frame_exception_exit_1;
    // End of try:
    try_end_28:;
    {
        PyObject *tmp_assign_source_153;
        CHECK_OBJECT(tmp_class_creation_24__class);
        tmp_assign_source_153 = tmp_class_creation_24__class;
        UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_TLSFeature, tmp_assign_source_153);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_24__class);
    Py_DECREF(tmp_class_creation_24__class);
    tmp_class_creation_24__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_24__class_dict);
    Py_DECREF(tmp_class_creation_24__class_dict);
    tmp_class_creation_24__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_24__metaclass);
    Py_DECREF(tmp_class_creation_24__metaclass);
    tmp_class_creation_24__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_154;
        PyObject *tmp_tuple_element_2;
        PyObject *tmp_mvar_value_69;
        tmp_mvar_value_69 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_Enum);

        if (unlikely(tmp_mvar_value_69 == NULL)) {
            tmp_mvar_value_69 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_Enum);
        }

        if (tmp_mvar_value_69 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 34390 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 907;

            goto try_except_handler_55;
        }

        tmp_tuple_element_2 = tmp_mvar_value_69;
        tmp_assign_source_154 = PyTuple_New(1);
        Py_INCREF(tmp_tuple_element_2);
        PyTuple_SET_ITEM(tmp_assign_source_154, 0, tmp_tuple_element_2);
        assert(tmp_class_creation_25__bases == NULL);
        tmp_class_creation_25__bases = tmp_assign_source_154;
    }
    {
        PyObject *tmp_assign_source_155;
        {
            PyObject *tmp_set_locals_22;
            tmp_set_locals_22 = PyDict_New();
            locals_cryptography$x509$extensions_907 = tmp_set_locals_22;
        }
        tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_907, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = const_int_pos_5;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_907, const_str_plain_status_request, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = const_int_pos_17;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_907, const_str_plain_status_request_v2, tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        tmp_assign_source_155 = locals_cryptography$x509$extensions_907;
        Py_INCREF(tmp_assign_source_155);
        goto try_return_handler_56;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Return handler code:
        try_return_handler_56:;
        Py_DECREF(locals_cryptography$x509$extensions_907);
        locals_cryptography$x509$extensions_907 = NULL;
        goto outline_result_26;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        outline_result_26:;
        assert(tmp_class_creation_25__class_dict == NULL);
        tmp_class_creation_25__class_dict = tmp_assign_source_155;
    }
    {
        PyObject *tmp_assign_source_156;
        nuitka_bool tmp_condition_result_25;
        PyObject *tmp_key_name_49;
        PyObject *tmp_dict_name_49;
        PyObject *tmp_dict_name_50;
        PyObject *tmp_key_name_50;
        tmp_key_name_49 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_25__class_dict);
        tmp_dict_name_49 = tmp_class_creation_25__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_49, tmp_key_name_49);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 907;

            goto try_except_handler_55;
        }
        tmp_condition_result_25 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_25 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_25;
        } else {
            goto condexpr_false_25;
        }
        condexpr_true_25:;
        CHECK_OBJECT(tmp_class_creation_25__class_dict);
        tmp_dict_name_50 = tmp_class_creation_25__class_dict;
        tmp_key_name_50 = const_str_plain___metaclass__;
        tmp_assign_source_156 = DICT_GET_ITEM(tmp_dict_name_50, tmp_key_name_50);
        if (tmp_assign_source_156 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 907;

            goto try_except_handler_55;
        }
        goto condexpr_end_25;
        condexpr_false_25:;
        {
            PyObject *tmp_assign_source_157;
            PyObject *tmp_subscribed_name_2;
            PyObject *tmp_subscript_name_2;
            CHECK_OBJECT(tmp_class_creation_25__bases);
            tmp_subscribed_name_2 = tmp_class_creation_25__bases;
            tmp_subscript_name_2 = const_int_0;
            tmp_assign_source_157 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_2, tmp_subscript_name_2, 0);
            if (tmp_assign_source_157 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 907;

                goto try_except_handler_55;
            }
            assert(tmp_select_metaclass_25__base == NULL);
            tmp_select_metaclass_25__base = tmp_assign_source_157;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_32;
            CHECK_OBJECT(tmp_select_metaclass_25__base);
            tmp_source_name_32 = tmp_select_metaclass_25__base;
            tmp_assign_source_156 = LOOKUP_ATTRIBUTE_CLASS_SLOT(tmp_source_name_32);
            if (tmp_assign_source_156 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 907;

                goto try_except_handler_58;
            }
            goto try_return_handler_57;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Exception handler code:
        try_except_handler_58:;
        exception_keeper_type_50 = exception_type;
        exception_keeper_value_50 = exception_value;
        exception_keeper_tb_50 = exception_tb;
        exception_keeper_lineno_50 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_2;
            Py_DECREF(exception_keeper_type_50);
            Py_XDECREF(exception_keeper_value_50);
            Py_XDECREF(exception_keeper_tb_50);
            CHECK_OBJECT(tmp_select_metaclass_25__base);
            tmp_type_arg_2 = tmp_select_metaclass_25__base;
            tmp_assign_source_156 = BUILTIN_TYPE1(tmp_type_arg_2);
            assert(!(tmp_assign_source_156 == NULL));
            goto try_return_handler_57;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Return handler code:
        try_return_handler_57:;
        CHECK_OBJECT((PyObject *)tmp_select_metaclass_25__base);
        Py_DECREF(tmp_select_metaclass_25__base);
        tmp_select_metaclass_25__base = NULL;

        goto outline_result_27;
        // End of try:
        CHECK_OBJECT((PyObject *)tmp_select_metaclass_25__base);
        Py_DECREF(tmp_select_metaclass_25__base);
        tmp_select_metaclass_25__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        outline_result_27:;
        condexpr_end_25:;
        assert(tmp_class_creation_25__metaclass == NULL);
        tmp_class_creation_25__metaclass = tmp_assign_source_156;
    }
    {
        PyObject *tmp_assign_source_158;
        PyObject *tmp_called_name_55;
        PyObject *tmp_args_element_name_104;
        PyObject *tmp_args_element_name_105;
        PyObject *tmp_args_element_name_106;
        CHECK_OBJECT(tmp_class_creation_25__metaclass);
        tmp_called_name_55 = tmp_class_creation_25__metaclass;
        tmp_args_element_name_104 = const_str_plain_TLSFeatureType;
        CHECK_OBJECT(tmp_class_creation_25__bases);
        tmp_args_element_name_105 = tmp_class_creation_25__bases;
        CHECK_OBJECT(tmp_class_creation_25__class_dict);
        tmp_args_element_name_106 = tmp_class_creation_25__class_dict;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 907;
        {
            PyObject *call_args[] = {tmp_args_element_name_104, tmp_args_element_name_105, tmp_args_element_name_106};
            tmp_assign_source_158 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_55, call_args);
        }

        if (tmp_assign_source_158 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 907;

            goto try_except_handler_55;
        }
        assert(tmp_class_creation_25__class == NULL);
        tmp_class_creation_25__class = tmp_assign_source_158;
    }
    goto try_end_29;
    // Exception handler code:
    try_except_handler_55:;
    exception_keeper_type_51 = exception_type;
    exception_keeper_value_51 = exception_value;
    exception_keeper_tb_51 = exception_tb;
    exception_keeper_lineno_51 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_25__bases);
    tmp_class_creation_25__bases = NULL;

    Py_XDECREF(tmp_class_creation_25__class_dict);
    tmp_class_creation_25__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_25__metaclass);
    tmp_class_creation_25__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_51;
    exception_value = exception_keeper_value_51;
    exception_tb = exception_keeper_tb_51;
    exception_lineno = exception_keeper_lineno_51;

    goto frame_exception_exit_1;
    // End of try:
    try_end_29:;
    {
        PyObject *tmp_assign_source_159;
        CHECK_OBJECT(tmp_class_creation_25__class);
        tmp_assign_source_159 = tmp_class_creation_25__class;
        UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_TLSFeatureType, tmp_assign_source_159);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_25__class);
    Py_DECREF(tmp_class_creation_25__class);
    tmp_class_creation_25__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_25__bases);
    Py_DECREF(tmp_class_creation_25__bases);
    tmp_class_creation_25__bases = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_25__class_dict);
    Py_DECREF(tmp_class_creation_25__class_dict);
    tmp_class_creation_25__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_25__metaclass);
    Py_DECREF(tmp_class_creation_25__metaclass);
    tmp_class_creation_25__metaclass = NULL;

    {
        PyObject *tmp_assign_source_160;
        PyObject *tmp_dict_seq_1;
        {
            PyObject *tmp_assign_source_161;
            PyObject *tmp_iter_arg_1;
            PyObject *tmp_mvar_value_70;
            tmp_mvar_value_70 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_TLSFeatureType);

            if (unlikely(tmp_mvar_value_70 == NULL)) {
                tmp_mvar_value_70 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_TLSFeatureType);
            }

            if (tmp_mvar_value_70 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 37089 ], 36, 0);
                exception_tb = NULL;

                exception_lineno = 918;

                goto frame_exception_exit_1;
            }

            tmp_iter_arg_1 = tmp_mvar_value_70;
            tmp_assign_source_161 = MAKE_ITERATOR(tmp_iter_arg_1);
            if (tmp_assign_source_161 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 918;

                goto frame_exception_exit_1;
            }
            assert(tmp_genexpr_1__$0 == NULL);
            tmp_genexpr_1__$0 = tmp_assign_source_161;
        }
        // Tried code:
        tmp_dict_seq_1 = cryptography$x509$extensions$$$genexpr_1_genexpr_maker();

        ((struct Nuitka_GeneratorObject *)tmp_dict_seq_1)->m_closure[0] = PyCell_NEW0(tmp_genexpr_1__$0);


        goto try_return_handler_59;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Return handler code:
        try_return_handler_59:;
        CHECK_OBJECT((PyObject *)tmp_genexpr_1__$0);
        Py_DECREF(tmp_genexpr_1__$0);
        tmp_genexpr_1__$0 = NULL;

        goto outline_result_28;
        // End of try:
        CHECK_OBJECT((PyObject *)tmp_genexpr_1__$0);
        Py_DECREF(tmp_genexpr_1__$0);
        tmp_genexpr_1__$0 = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        outline_result_28:;
        tmp_assign_source_160 = TO_DICT(tmp_dict_seq_1, NULL);
        Py_DECREF(tmp_dict_seq_1);
        if (tmp_assign_source_160 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 918;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain__TLS_FEATURE_TYPE_TO_ENUM, tmp_assign_source_160);
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_162;
        {
            PyObject *tmp_set_locals_23;
            tmp_set_locals_23 = PyDict_New();
            locals_cryptography$x509$extensions_922 = tmp_set_locals_23;
        }
        tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_922, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_9cf8ad554dd9d3c4ef6ee538381ad390_22, codeobj_9cf8ad554dd9d3c4ef6ee538381ad390, module_cryptography$x509$extensions, 0);
        frame_9cf8ad554dd9d3c4ef6ee538381ad390_22 = cache_frame_9cf8ad554dd9d3c4ef6ee538381ad390_22;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_9cf8ad554dd9d3c4ef6ee538381ad390_22);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_9cf8ad554dd9d3c4ef6ee538381ad390_22) == 2); // Frame stack

        // Framed code:
        {
            PyObject *tmp_source_name_33;
            PyObject *tmp_mvar_value_71;
            tmp_mvar_value_71 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID);

            if (unlikely(tmp_mvar_value_71 == NULL)) {
                tmp_mvar_value_71 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionOID);
            }

            if (tmp_mvar_value_71 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 23410 ], 34, 0);
                exception_tb = NULL;

                exception_lineno = 923;

                goto frame_exception_exit_22;
            }

            tmp_source_name_33 = tmp_mvar_value_71;
            tmp_dictset_value = LOOKUP_ATTRIBUTE(tmp_source_name_33, const_str_plain_INHIBIT_ANY_POLICY);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 923;

                goto frame_exception_exit_22;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_922, const_str_plain_oid, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 923;

                goto frame_exception_exit_22;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_117___init__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_922, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_118___repr__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_922, const_str_plain___repr__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_119___eq__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_922, const_str_plain___eq__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_120___ne__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_922, const_str_plain___ne__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_121___hash__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_922, const_str_plain___hash__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        {
            PyObject *tmp_called_instance_24;
            PyObject *tmp_mvar_value_72;
            tmp_mvar_value_72 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_72 == NULL)) {
                tmp_mvar_value_72 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_72 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 949;

                goto frame_exception_exit_22;
            }

            tmp_called_instance_24 = tmp_mvar_value_72;
            frame_9cf8ad554dd9d3c4ef6ee538381ad390_22->m_frame.f_lineno = 949;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_24, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__skip_certs_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 949;

                goto frame_exception_exit_22;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_922, const_str_plain_skip_certs, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 949;

                goto frame_exception_exit_22;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_9cf8ad554dd9d3c4ef6ee538381ad390_22);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_21;

        frame_exception_exit_22:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_9cf8ad554dd9d3c4ef6ee538381ad390_22);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_9cf8ad554dd9d3c4ef6ee538381ad390_22, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_9cf8ad554dd9d3c4ef6ee538381ad390_22->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_9cf8ad554dd9d3c4ef6ee538381ad390_22, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_9cf8ad554dd9d3c4ef6ee538381ad390_22,
            type_description_2
        );


        // Release cached frame.
        if (frame_9cf8ad554dd9d3c4ef6ee538381ad390_22 == cache_frame_9cf8ad554dd9d3c4ef6ee538381ad390_22) {
            Py_DECREF(frame_9cf8ad554dd9d3c4ef6ee538381ad390_22);
        }
        cache_frame_9cf8ad554dd9d3c4ef6ee538381ad390_22 = NULL;

        assertFrameObject(frame_9cf8ad554dd9d3c4ef6ee538381ad390_22);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_21;

        frame_no_exception_21:;
        goto skip_nested_handling_21;
        nested_frame_exit_21:;

        goto try_except_handler_61;
        skip_nested_handling_21:;
        tmp_assign_source_162 = locals_cryptography$x509$extensions_922;
        Py_INCREF(tmp_assign_source_162);
        goto try_return_handler_61;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Return handler code:
        try_return_handler_61:;
        Py_DECREF(locals_cryptography$x509$extensions_922);
        locals_cryptography$x509$extensions_922 = NULL;
        goto outline_result_29;
        // Exception handler code:
        try_except_handler_61:;
        exception_keeper_type_52 = exception_type;
        exception_keeper_value_52 = exception_value;
        exception_keeper_tb_52 = exception_tb;
        exception_keeper_lineno_52 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_cryptography$x509$extensions_922);
        locals_cryptography$x509$extensions_922 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_52;
        exception_value = exception_keeper_value_52;
        exception_tb = exception_keeper_tb_52;
        exception_lineno = exception_keeper_lineno_52;

        goto outline_exception_21;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        outline_exception_21:;
        exception_lineno = 922;
        goto try_except_handler_60;
        outline_result_29:;
        assert(tmp_class_creation_26__class_dict == NULL);
        tmp_class_creation_26__class_dict = tmp_assign_source_162;
    }
    {
        PyObject *tmp_assign_source_163;
        nuitka_bool tmp_condition_result_26;
        PyObject *tmp_key_name_51;
        PyObject *tmp_dict_name_51;
        PyObject *tmp_dict_name_52;
        PyObject *tmp_key_name_52;
        tmp_key_name_51 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_26__class_dict);
        tmp_dict_name_51 = tmp_class_creation_26__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_51, tmp_key_name_51);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 922;

            goto try_except_handler_60;
        }
        tmp_condition_result_26 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_26 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_26;
        } else {
            goto condexpr_false_26;
        }
        condexpr_true_26:;
        CHECK_OBJECT(tmp_class_creation_26__class_dict);
        tmp_dict_name_52 = tmp_class_creation_26__class_dict;
        tmp_key_name_52 = const_str_plain___metaclass__;
        tmp_assign_source_163 = DICT_GET_ITEM(tmp_dict_name_52, tmp_key_name_52);
        if (tmp_assign_source_163 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 922;

            goto try_except_handler_60;
        }
        goto condexpr_end_26;
        condexpr_false_26:;
        tmp_assign_source_163 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_163);
        condexpr_end_26:;
        assert(tmp_class_creation_26__metaclass == NULL);
        tmp_class_creation_26__metaclass = tmp_assign_source_163;
    }
    {
        PyObject *tmp_assign_source_164;
        PyObject *tmp_called_name_56;
        PyObject *tmp_args_element_name_107;
        PyObject *tmp_args_element_name_108;
        PyObject *tmp_args_element_name_109;
        CHECK_OBJECT(tmp_class_creation_26__metaclass);
        tmp_called_name_56 = tmp_class_creation_26__metaclass;
        tmp_args_element_name_107 = const_str_plain_InhibitAnyPolicy;
        tmp_args_element_name_108 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_26__class_dict);
        tmp_args_element_name_109 = tmp_class_creation_26__class_dict;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 922;
        {
            PyObject *call_args[] = {tmp_args_element_name_107, tmp_args_element_name_108, tmp_args_element_name_109};
            tmp_assign_source_164 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_56, call_args);
        }

        if (tmp_assign_source_164 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 922;

            goto try_except_handler_60;
        }
        assert(tmp_class_creation_26__class == NULL);
        tmp_class_creation_26__class = tmp_assign_source_164;
    }
    {
        PyObject *tmp_assign_source_165;
        PyObject *tmp_called_name_57;
        PyObject *tmp_called_name_58;
        PyObject *tmp_source_name_34;
        PyObject *tmp_mvar_value_73;
        PyObject *tmp_args_element_name_110;
        PyObject *tmp_mvar_value_74;
        PyObject *tmp_args_element_name_111;
        tmp_mvar_value_73 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

        if (unlikely(tmp_mvar_value_73 == NULL)) {
            tmp_mvar_value_73 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
        }

        if (tmp_mvar_value_73 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
            exception_tb = NULL;

            exception_lineno = 921;

            goto try_except_handler_60;
        }

        tmp_source_name_34 = tmp_mvar_value_73;
        tmp_called_name_58 = LOOKUP_ATTRIBUTE(tmp_source_name_34, const_str_plain_register_interface);
        if (tmp_called_name_58 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 921;

            goto try_except_handler_60;
        }
        tmp_mvar_value_74 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType);

        if (unlikely(tmp_mvar_value_74 == NULL)) {
            tmp_mvar_value_74 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType);
        }

        if (tmp_mvar_value_74 == NULL) {
            Py_DECREF(tmp_called_name_58);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 35484 ], 35, 0);
            exception_tb = NULL;

            exception_lineno = 921;

            goto try_except_handler_60;
        }

        tmp_args_element_name_110 = tmp_mvar_value_74;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 921;
        tmp_called_name_57 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_58, tmp_args_element_name_110);
        Py_DECREF(tmp_called_name_58);
        if (tmp_called_name_57 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 921;

            goto try_except_handler_60;
        }
        CHECK_OBJECT(tmp_class_creation_26__class);
        tmp_args_element_name_111 = tmp_class_creation_26__class;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 921;
        tmp_assign_source_165 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_57, tmp_args_element_name_111);
        Py_DECREF(tmp_called_name_57);
        if (tmp_assign_source_165 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 921;

            goto try_except_handler_60;
        }
        {
            PyObject *old = tmp_class_creation_26__class;
            assert(old != NULL);
            tmp_class_creation_26__class = tmp_assign_source_165;
            Py_DECREF(old);
        }

    }
    goto try_end_30;
    // Exception handler code:
    try_except_handler_60:;
    exception_keeper_type_53 = exception_type;
    exception_keeper_value_53 = exception_value;
    exception_keeper_tb_53 = exception_tb;
    exception_keeper_lineno_53 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_26__class);
    tmp_class_creation_26__class = NULL;

    Py_XDECREF(tmp_class_creation_26__class_dict);
    tmp_class_creation_26__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_26__metaclass);
    tmp_class_creation_26__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_53;
    exception_value = exception_keeper_value_53;
    exception_tb = exception_keeper_tb_53;
    exception_lineno = exception_keeper_lineno_53;

    goto frame_exception_exit_1;
    // End of try:
    try_end_30:;
    {
        PyObject *tmp_assign_source_166;
        CHECK_OBJECT(tmp_class_creation_26__class);
        tmp_assign_source_166 = tmp_class_creation_26__class;
        UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_InhibitAnyPolicy, tmp_assign_source_166);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_26__class);
    Py_DECREF(tmp_class_creation_26__class);
    tmp_class_creation_26__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_26__class_dict);
    Py_DECREF(tmp_class_creation_26__class_dict);
    tmp_class_creation_26__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_26__metaclass);
    Py_DECREF(tmp_class_creation_26__metaclass);
    tmp_class_creation_26__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_167;
        {
            PyObject *tmp_set_locals_24;
            tmp_set_locals_24 = PyDict_New();
            locals_cryptography$x509$extensions_953 = tmp_set_locals_24;
        }
        tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_953, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_083e1fa26f5ab300d67d5d5e3552df7c_23, codeobj_083e1fa26f5ab300d67d5d5e3552df7c, module_cryptography$x509$extensions, 0);
        frame_083e1fa26f5ab300d67d5d5e3552df7c_23 = cache_frame_083e1fa26f5ab300d67d5d5e3552df7c_23;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_083e1fa26f5ab300d67d5d5e3552df7c_23);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_083e1fa26f5ab300d67d5d5e3552df7c_23) == 2); // Frame stack

        // Framed code:
        {
            PyObject *tmp_source_name_35;
            PyObject *tmp_mvar_value_75;
            tmp_mvar_value_75 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID);

            if (unlikely(tmp_mvar_value_75 == NULL)) {
                tmp_mvar_value_75 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionOID);
            }

            if (tmp_mvar_value_75 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 23410 ], 34, 0);
                exception_tb = NULL;

                exception_lineno = 954;

                goto frame_exception_exit_23;
            }

            tmp_source_name_35 = tmp_mvar_value_75;
            tmp_dictset_value = LOOKUP_ATTRIBUTE(tmp_source_name_35, const_str_plain_KEY_USAGE);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 954;

                goto frame_exception_exit_23;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_953, const_str_plain_oid, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 954;

                goto frame_exception_exit_23;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_122___init__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_953, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        {
            PyObject *tmp_called_instance_25;
            PyObject *tmp_mvar_value_76;
            tmp_mvar_value_76 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_76 == NULL)) {
                tmp_mvar_value_76 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_76 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 975;

                goto frame_exception_exit_23;
            }

            tmp_called_instance_25 = tmp_mvar_value_76;
            frame_083e1fa26f5ab300d67d5d5e3552df7c_23->m_frame.f_lineno = 975;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_25, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__digital_signature_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 975;

                goto frame_exception_exit_23;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_953, const_str_plain_digital_signature, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 975;

                goto frame_exception_exit_23;
            }
        }
        {
            PyObject *tmp_called_instance_26;
            PyObject *tmp_mvar_value_77;
            tmp_mvar_value_77 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_77 == NULL)) {
                tmp_mvar_value_77 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_77 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 976;

                goto frame_exception_exit_23;
            }

            tmp_called_instance_26 = tmp_mvar_value_77;
            frame_083e1fa26f5ab300d67d5d5e3552df7c_23->m_frame.f_lineno = 976;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_26, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__content_commitment_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 976;

                goto frame_exception_exit_23;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_953, const_str_plain_content_commitment, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 976;

                goto frame_exception_exit_23;
            }
        }
        {
            PyObject *tmp_called_instance_27;
            PyObject *tmp_mvar_value_78;
            tmp_mvar_value_78 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_78 == NULL)) {
                tmp_mvar_value_78 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_78 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 977;

                goto frame_exception_exit_23;
            }

            tmp_called_instance_27 = tmp_mvar_value_78;
            frame_083e1fa26f5ab300d67d5d5e3552df7c_23->m_frame.f_lineno = 977;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_27, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__key_encipherment_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 977;

                goto frame_exception_exit_23;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_953, const_str_plain_key_encipherment, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 977;

                goto frame_exception_exit_23;
            }
        }
        {
            PyObject *tmp_called_instance_28;
            PyObject *tmp_mvar_value_79;
            tmp_mvar_value_79 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_79 == NULL)) {
                tmp_mvar_value_79 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_79 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 978;

                goto frame_exception_exit_23;
            }

            tmp_called_instance_28 = tmp_mvar_value_79;
            frame_083e1fa26f5ab300d67d5d5e3552df7c_23->m_frame.f_lineno = 978;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_28, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__data_encipherment_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 978;

                goto frame_exception_exit_23;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_953, const_str_plain_data_encipherment, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 978;

                goto frame_exception_exit_23;
            }
        }
        {
            PyObject *tmp_called_instance_29;
            PyObject *tmp_mvar_value_80;
            tmp_mvar_value_80 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_80 == NULL)) {
                tmp_mvar_value_80 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_80 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 979;

                goto frame_exception_exit_23;
            }

            tmp_called_instance_29 = tmp_mvar_value_80;
            frame_083e1fa26f5ab300d67d5d5e3552df7c_23->m_frame.f_lineno = 979;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_29, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__key_agreement_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 979;

                goto frame_exception_exit_23;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_953, const_str_plain_key_agreement, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 979;

                goto frame_exception_exit_23;
            }
        }
        {
            PyObject *tmp_called_instance_30;
            PyObject *tmp_mvar_value_81;
            tmp_mvar_value_81 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_81 == NULL)) {
                tmp_mvar_value_81 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_81 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 980;

                goto frame_exception_exit_23;
            }

            tmp_called_instance_30 = tmp_mvar_value_81;
            frame_083e1fa26f5ab300d67d5d5e3552df7c_23->m_frame.f_lineno = 980;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_30, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__key_cert_sign_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 980;

                goto frame_exception_exit_23;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_953, const_str_plain_key_cert_sign, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 980;

                goto frame_exception_exit_23;
            }
        }
        {
            PyObject *tmp_called_instance_31;
            PyObject *tmp_mvar_value_82;
            tmp_mvar_value_82 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_82 == NULL)) {
                tmp_mvar_value_82 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_82 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 981;

                goto frame_exception_exit_23;
            }

            tmp_called_instance_31 = tmp_mvar_value_82;
            frame_083e1fa26f5ab300d67d5d5e3552df7c_23->m_frame.f_lineno = 981;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_31, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__crl_sign_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 981;

                goto frame_exception_exit_23;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_953, const_str_plain_crl_sign, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 981;

                goto frame_exception_exit_23;
            }
        }
        {
            PyObject *tmp_called_name_59;
            PyObject *tmp_args_element_name_112;
            tmp_called_name_59 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_112 = MAKE_FUNCTION_cryptography$x509$extensions$$$function_123_encipher_only();



            frame_083e1fa26f5ab300d67d5d5e3552df7c_23->m_frame.f_lineno = 983;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_59, tmp_args_element_name_112);
            Py_DECREF(tmp_args_element_name_112);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 983;

                goto frame_exception_exit_23;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_953, const_str_plain_encipher_only, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 983;

                goto frame_exception_exit_23;
            }
        }
        {
            PyObject *tmp_called_name_60;
            PyObject *tmp_args_element_name_113;
            tmp_called_name_60 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_113 = MAKE_FUNCTION_cryptography$x509$extensions$$$function_124_decipher_only();



            frame_083e1fa26f5ab300d67d5d5e3552df7c_23->m_frame.f_lineno = 992;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_60, tmp_args_element_name_113);
            Py_DECREF(tmp_args_element_name_113);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 992;

                goto frame_exception_exit_23;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_953, const_str_plain_decipher_only, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 992;

                goto frame_exception_exit_23;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_083e1fa26f5ab300d67d5d5e3552df7c_23);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_22;

        frame_exception_exit_23:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_083e1fa26f5ab300d67d5d5e3552df7c_23);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_083e1fa26f5ab300d67d5d5e3552df7c_23, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_083e1fa26f5ab300d67d5d5e3552df7c_23->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_083e1fa26f5ab300d67d5d5e3552df7c_23, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_083e1fa26f5ab300d67d5d5e3552df7c_23,
            type_description_2
        );


        // Release cached frame.
        if (frame_083e1fa26f5ab300d67d5d5e3552df7c_23 == cache_frame_083e1fa26f5ab300d67d5d5e3552df7c_23) {
            Py_DECREF(frame_083e1fa26f5ab300d67d5d5e3552df7c_23);
        }
        cache_frame_083e1fa26f5ab300d67d5d5e3552df7c_23 = NULL;

        assertFrameObject(frame_083e1fa26f5ab300d67d5d5e3552df7c_23);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_22;

        frame_no_exception_22:;
        goto skip_nested_handling_22;
        nested_frame_exit_22:;

        goto try_except_handler_63;
        skip_nested_handling_22:;
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_125___repr__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_953, const_str_plain___repr__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_126___eq__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_953, const_str_plain___eq__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_127___ne__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_953, const_str_plain___ne__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_128___hash__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_953, const_str_plain___hash__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_assign_source_167 = locals_cryptography$x509$extensions_953;
        Py_INCREF(tmp_assign_source_167);
        goto try_return_handler_63;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Return handler code:
        try_return_handler_63:;
        Py_DECREF(locals_cryptography$x509$extensions_953);
        locals_cryptography$x509$extensions_953 = NULL;
        goto outline_result_30;
        // Exception handler code:
        try_except_handler_63:;
        exception_keeper_type_54 = exception_type;
        exception_keeper_value_54 = exception_value;
        exception_keeper_tb_54 = exception_tb;
        exception_keeper_lineno_54 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_cryptography$x509$extensions_953);
        locals_cryptography$x509$extensions_953 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_54;
        exception_value = exception_keeper_value_54;
        exception_tb = exception_keeper_tb_54;
        exception_lineno = exception_keeper_lineno_54;

        goto outline_exception_22;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        outline_exception_22:;
        exception_lineno = 953;
        goto try_except_handler_62;
        outline_result_30:;
        assert(tmp_class_creation_27__class_dict == NULL);
        tmp_class_creation_27__class_dict = tmp_assign_source_167;
    }
    {
        PyObject *tmp_assign_source_168;
        nuitka_bool tmp_condition_result_27;
        PyObject *tmp_key_name_53;
        PyObject *tmp_dict_name_53;
        PyObject *tmp_dict_name_54;
        PyObject *tmp_key_name_54;
        tmp_key_name_53 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_27__class_dict);
        tmp_dict_name_53 = tmp_class_creation_27__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_53, tmp_key_name_53);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 953;

            goto try_except_handler_62;
        }
        tmp_condition_result_27 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_27 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_27;
        } else {
            goto condexpr_false_27;
        }
        condexpr_true_27:;
        CHECK_OBJECT(tmp_class_creation_27__class_dict);
        tmp_dict_name_54 = tmp_class_creation_27__class_dict;
        tmp_key_name_54 = const_str_plain___metaclass__;
        tmp_assign_source_168 = DICT_GET_ITEM(tmp_dict_name_54, tmp_key_name_54);
        if (tmp_assign_source_168 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 953;

            goto try_except_handler_62;
        }
        goto condexpr_end_27;
        condexpr_false_27:;
        tmp_assign_source_168 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_168);
        condexpr_end_27:;
        assert(tmp_class_creation_27__metaclass == NULL);
        tmp_class_creation_27__metaclass = tmp_assign_source_168;
    }
    {
        PyObject *tmp_assign_source_169;
        PyObject *tmp_called_name_61;
        PyObject *tmp_args_element_name_114;
        PyObject *tmp_args_element_name_115;
        PyObject *tmp_args_element_name_116;
        CHECK_OBJECT(tmp_class_creation_27__metaclass);
        tmp_called_name_61 = tmp_class_creation_27__metaclass;
        tmp_args_element_name_114 = const_str_plain_KeyUsage;
        tmp_args_element_name_115 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_27__class_dict);
        tmp_args_element_name_116 = tmp_class_creation_27__class_dict;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 953;
        {
            PyObject *call_args[] = {tmp_args_element_name_114, tmp_args_element_name_115, tmp_args_element_name_116};
            tmp_assign_source_169 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_61, call_args);
        }

        if (tmp_assign_source_169 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 953;

            goto try_except_handler_62;
        }
        assert(tmp_class_creation_27__class == NULL);
        tmp_class_creation_27__class = tmp_assign_source_169;
    }
    {
        PyObject *tmp_assign_source_170;
        PyObject *tmp_called_name_62;
        PyObject *tmp_called_name_63;
        PyObject *tmp_source_name_36;
        PyObject *tmp_mvar_value_83;
        PyObject *tmp_args_element_name_117;
        PyObject *tmp_mvar_value_84;
        PyObject *tmp_args_element_name_118;
        tmp_mvar_value_83 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

        if (unlikely(tmp_mvar_value_83 == NULL)) {
            tmp_mvar_value_83 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
        }

        if (tmp_mvar_value_83 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
            exception_tb = NULL;

            exception_lineno = 952;

            goto try_except_handler_62;
        }

        tmp_source_name_36 = tmp_mvar_value_83;
        tmp_called_name_63 = LOOKUP_ATTRIBUTE(tmp_source_name_36, const_str_plain_register_interface);
        if (tmp_called_name_63 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 952;

            goto try_except_handler_62;
        }
        tmp_mvar_value_84 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType);

        if (unlikely(tmp_mvar_value_84 == NULL)) {
            tmp_mvar_value_84 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType);
        }

        if (tmp_mvar_value_84 == NULL) {
            Py_DECREF(tmp_called_name_63);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 35484 ], 35, 0);
            exception_tb = NULL;

            exception_lineno = 952;

            goto try_except_handler_62;
        }

        tmp_args_element_name_117 = tmp_mvar_value_84;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 952;
        tmp_called_name_62 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_63, tmp_args_element_name_117);
        Py_DECREF(tmp_called_name_63);
        if (tmp_called_name_62 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 952;

            goto try_except_handler_62;
        }
        CHECK_OBJECT(tmp_class_creation_27__class);
        tmp_args_element_name_118 = tmp_class_creation_27__class;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 952;
        tmp_assign_source_170 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_62, tmp_args_element_name_118);
        Py_DECREF(tmp_called_name_62);
        if (tmp_assign_source_170 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 952;

            goto try_except_handler_62;
        }
        {
            PyObject *old = tmp_class_creation_27__class;
            assert(old != NULL);
            tmp_class_creation_27__class = tmp_assign_source_170;
            Py_DECREF(old);
        }

    }
    goto try_end_31;
    // Exception handler code:
    try_except_handler_62:;
    exception_keeper_type_55 = exception_type;
    exception_keeper_value_55 = exception_value;
    exception_keeper_tb_55 = exception_tb;
    exception_keeper_lineno_55 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_27__class);
    tmp_class_creation_27__class = NULL;

    Py_XDECREF(tmp_class_creation_27__class_dict);
    tmp_class_creation_27__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_27__metaclass);
    tmp_class_creation_27__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_55;
    exception_value = exception_keeper_value_55;
    exception_tb = exception_keeper_tb_55;
    exception_lineno = exception_keeper_lineno_55;

    goto frame_exception_exit_1;
    // End of try:
    try_end_31:;
    {
        PyObject *tmp_assign_source_171;
        CHECK_OBJECT(tmp_class_creation_27__class);
        tmp_assign_source_171 = tmp_class_creation_27__class;
        UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_KeyUsage, tmp_assign_source_171);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_27__class);
    Py_DECREF(tmp_class_creation_27__class);
    tmp_class_creation_27__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_27__class_dict);
    Py_DECREF(tmp_class_creation_27__class_dict);
    tmp_class_creation_27__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_27__metaclass);
    Py_DECREF(tmp_class_creation_27__metaclass);
    tmp_class_creation_27__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_172;
        {
            PyObject *tmp_set_locals_25;
            tmp_set_locals_25 = PyDict_New();
            locals_cryptography$x509$extensions_1048 = tmp_set_locals_25;
        }
        tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1048, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_88f6f5c3c797c731ba74a50683fe2b42_24, codeobj_88f6f5c3c797c731ba74a50683fe2b42, module_cryptography$x509$extensions, 0);
        frame_88f6f5c3c797c731ba74a50683fe2b42_24 = cache_frame_88f6f5c3c797c731ba74a50683fe2b42_24;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_88f6f5c3c797c731ba74a50683fe2b42_24);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_88f6f5c3c797c731ba74a50683fe2b42_24) == 2); // Frame stack

        // Framed code:
        {
            PyObject *tmp_source_name_37;
            PyObject *tmp_mvar_value_85;
            tmp_mvar_value_85 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID);

            if (unlikely(tmp_mvar_value_85 == NULL)) {
                tmp_mvar_value_85 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionOID);
            }

            if (tmp_mvar_value_85 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 23410 ], 34, 0);
                exception_tb = NULL;

                exception_lineno = 1049;

                goto frame_exception_exit_24;
            }

            tmp_source_name_37 = tmp_mvar_value_85;
            tmp_dictset_value = LOOKUP_ATTRIBUTE(tmp_source_name_37, const_str_plain_NAME_CONSTRAINTS);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1049;

                goto frame_exception_exit_24;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1048, const_str_plain_oid, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1049;

                goto frame_exception_exit_24;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_129___init__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1048, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_130___eq__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1048, const_str_plain___eq__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_131___ne__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1048, const_str_plain___ne__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_132__validate_ip_name();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1048, const_str_plain__validate_ip_name, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_133___repr__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1048, const_str_plain___repr__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_134___hash__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1048, const_str_plain___hash__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        {
            PyObject *tmp_called_instance_32;
            PyObject *tmp_mvar_value_86;
            tmp_mvar_value_86 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_86 == NULL)) {
                tmp_mvar_value_86 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_86 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 1125;

                goto frame_exception_exit_24;
            }

            tmp_called_instance_32 = tmp_mvar_value_86;
            frame_88f6f5c3c797c731ba74a50683fe2b42_24->m_frame.f_lineno = 1125;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_32, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__permitted_subtrees_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1125;

                goto frame_exception_exit_24;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1048, const_str_plain_permitted_subtrees, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1125;

                goto frame_exception_exit_24;
            }
        }
        {
            PyObject *tmp_called_instance_33;
            PyObject *tmp_mvar_value_87;
            tmp_mvar_value_87 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_87 == NULL)) {
                tmp_mvar_value_87 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_87 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 1126;

                goto frame_exception_exit_24;
            }

            tmp_called_instance_33 = tmp_mvar_value_87;
            frame_88f6f5c3c797c731ba74a50683fe2b42_24->m_frame.f_lineno = 1126;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_33, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__excluded_subtrees_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1126;

                goto frame_exception_exit_24;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1048, const_str_plain_excluded_subtrees, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1126;

                goto frame_exception_exit_24;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_88f6f5c3c797c731ba74a50683fe2b42_24);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_23;

        frame_exception_exit_24:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_88f6f5c3c797c731ba74a50683fe2b42_24);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_88f6f5c3c797c731ba74a50683fe2b42_24, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_88f6f5c3c797c731ba74a50683fe2b42_24->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_88f6f5c3c797c731ba74a50683fe2b42_24, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_88f6f5c3c797c731ba74a50683fe2b42_24,
            type_description_2
        );


        // Release cached frame.
        if (frame_88f6f5c3c797c731ba74a50683fe2b42_24 == cache_frame_88f6f5c3c797c731ba74a50683fe2b42_24) {
            Py_DECREF(frame_88f6f5c3c797c731ba74a50683fe2b42_24);
        }
        cache_frame_88f6f5c3c797c731ba74a50683fe2b42_24 = NULL;

        assertFrameObject(frame_88f6f5c3c797c731ba74a50683fe2b42_24);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_23;

        frame_no_exception_23:;
        goto skip_nested_handling_23;
        nested_frame_exit_23:;

        goto try_except_handler_65;
        skip_nested_handling_23:;
        tmp_assign_source_172 = locals_cryptography$x509$extensions_1048;
        Py_INCREF(tmp_assign_source_172);
        goto try_return_handler_65;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Return handler code:
        try_return_handler_65:;
        Py_DECREF(locals_cryptography$x509$extensions_1048);
        locals_cryptography$x509$extensions_1048 = NULL;
        goto outline_result_31;
        // Exception handler code:
        try_except_handler_65:;
        exception_keeper_type_56 = exception_type;
        exception_keeper_value_56 = exception_value;
        exception_keeper_tb_56 = exception_tb;
        exception_keeper_lineno_56 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_cryptography$x509$extensions_1048);
        locals_cryptography$x509$extensions_1048 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_56;
        exception_value = exception_keeper_value_56;
        exception_tb = exception_keeper_tb_56;
        exception_lineno = exception_keeper_lineno_56;

        goto outline_exception_23;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        outline_exception_23:;
        exception_lineno = 1048;
        goto try_except_handler_64;
        outline_result_31:;
        assert(tmp_class_creation_28__class_dict == NULL);
        tmp_class_creation_28__class_dict = tmp_assign_source_172;
    }
    {
        PyObject *tmp_assign_source_173;
        nuitka_bool tmp_condition_result_28;
        PyObject *tmp_key_name_55;
        PyObject *tmp_dict_name_55;
        PyObject *tmp_dict_name_56;
        PyObject *tmp_key_name_56;
        tmp_key_name_55 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_28__class_dict);
        tmp_dict_name_55 = tmp_class_creation_28__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_55, tmp_key_name_55);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1048;

            goto try_except_handler_64;
        }
        tmp_condition_result_28 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_28 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_28;
        } else {
            goto condexpr_false_28;
        }
        condexpr_true_28:;
        CHECK_OBJECT(tmp_class_creation_28__class_dict);
        tmp_dict_name_56 = tmp_class_creation_28__class_dict;
        tmp_key_name_56 = const_str_plain___metaclass__;
        tmp_assign_source_173 = DICT_GET_ITEM(tmp_dict_name_56, tmp_key_name_56);
        if (tmp_assign_source_173 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1048;

            goto try_except_handler_64;
        }
        goto condexpr_end_28;
        condexpr_false_28:;
        tmp_assign_source_173 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_173);
        condexpr_end_28:;
        assert(tmp_class_creation_28__metaclass == NULL);
        tmp_class_creation_28__metaclass = tmp_assign_source_173;
    }
    {
        PyObject *tmp_assign_source_174;
        PyObject *tmp_called_name_64;
        PyObject *tmp_args_element_name_119;
        PyObject *tmp_args_element_name_120;
        PyObject *tmp_args_element_name_121;
        CHECK_OBJECT(tmp_class_creation_28__metaclass);
        tmp_called_name_64 = tmp_class_creation_28__metaclass;
        tmp_args_element_name_119 = const_str_plain_NameConstraints;
        tmp_args_element_name_120 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_28__class_dict);
        tmp_args_element_name_121 = tmp_class_creation_28__class_dict;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 1048;
        {
            PyObject *call_args[] = {tmp_args_element_name_119, tmp_args_element_name_120, tmp_args_element_name_121};
            tmp_assign_source_174 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_64, call_args);
        }

        if (tmp_assign_source_174 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1048;

            goto try_except_handler_64;
        }
        assert(tmp_class_creation_28__class == NULL);
        tmp_class_creation_28__class = tmp_assign_source_174;
    }
    {
        PyObject *tmp_assign_source_175;
        PyObject *tmp_called_name_65;
        PyObject *tmp_called_name_66;
        PyObject *tmp_source_name_38;
        PyObject *tmp_mvar_value_88;
        PyObject *tmp_args_element_name_122;
        PyObject *tmp_mvar_value_89;
        PyObject *tmp_args_element_name_123;
        tmp_mvar_value_88 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

        if (unlikely(tmp_mvar_value_88 == NULL)) {
            tmp_mvar_value_88 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
        }

        if (tmp_mvar_value_88 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
            exception_tb = NULL;

            exception_lineno = 1047;

            goto try_except_handler_64;
        }

        tmp_source_name_38 = tmp_mvar_value_88;
        tmp_called_name_66 = LOOKUP_ATTRIBUTE(tmp_source_name_38, const_str_plain_register_interface);
        if (tmp_called_name_66 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1047;

            goto try_except_handler_64;
        }
        tmp_mvar_value_89 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType);

        if (unlikely(tmp_mvar_value_89 == NULL)) {
            tmp_mvar_value_89 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType);
        }

        if (tmp_mvar_value_89 == NULL) {
            Py_DECREF(tmp_called_name_66);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 35484 ], 35, 0);
            exception_tb = NULL;

            exception_lineno = 1047;

            goto try_except_handler_64;
        }

        tmp_args_element_name_122 = tmp_mvar_value_89;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 1047;
        tmp_called_name_65 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_66, tmp_args_element_name_122);
        Py_DECREF(tmp_called_name_66);
        if (tmp_called_name_65 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1047;

            goto try_except_handler_64;
        }
        CHECK_OBJECT(tmp_class_creation_28__class);
        tmp_args_element_name_123 = tmp_class_creation_28__class;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 1047;
        tmp_assign_source_175 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_65, tmp_args_element_name_123);
        Py_DECREF(tmp_called_name_65);
        if (tmp_assign_source_175 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1047;

            goto try_except_handler_64;
        }
        {
            PyObject *old = tmp_class_creation_28__class;
            assert(old != NULL);
            tmp_class_creation_28__class = tmp_assign_source_175;
            Py_DECREF(old);
        }

    }
    goto try_end_32;
    // Exception handler code:
    try_except_handler_64:;
    exception_keeper_type_57 = exception_type;
    exception_keeper_value_57 = exception_value;
    exception_keeper_tb_57 = exception_tb;
    exception_keeper_lineno_57 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_28__class);
    tmp_class_creation_28__class = NULL;

    Py_XDECREF(tmp_class_creation_28__class_dict);
    tmp_class_creation_28__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_28__metaclass);
    tmp_class_creation_28__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_57;
    exception_value = exception_keeper_value_57;
    exception_tb = exception_keeper_tb_57;
    exception_lineno = exception_keeper_lineno_57;

    goto frame_exception_exit_1;
    // End of try:
    try_end_32:;
    {
        PyObject *tmp_assign_source_176;
        CHECK_OBJECT(tmp_class_creation_28__class);
        tmp_assign_source_176 = tmp_class_creation_28__class;
        UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_NameConstraints, tmp_assign_source_176);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_28__class);
    Py_DECREF(tmp_class_creation_28__class);
    tmp_class_creation_28__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_28__class_dict);
    Py_DECREF(tmp_class_creation_28__class_dict);
    tmp_class_creation_28__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_28__metaclass);
    Py_DECREF(tmp_class_creation_28__metaclass);
    tmp_class_creation_28__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_177;
        {
            PyObject *tmp_set_locals_26;
            tmp_set_locals_26 = PyDict_New();
            locals_cryptography$x509$extensions_1129 = tmp_set_locals_26;
        }
        tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1129, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_135___init__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1129, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_e04ffe5b900a4019b6788821593ab364_25, codeobj_e04ffe5b900a4019b6788821593ab364, module_cryptography$x509$extensions, 0);
        frame_e04ffe5b900a4019b6788821593ab364_25 = cache_frame_e04ffe5b900a4019b6788821593ab364_25;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_e04ffe5b900a4019b6788821593ab364_25);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_e04ffe5b900a4019b6788821593ab364_25) == 2); // Frame stack

        // Framed code:
        {
            PyObject *tmp_called_instance_34;
            PyObject *tmp_mvar_value_90;
            tmp_mvar_value_90 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_90 == NULL)) {
                tmp_mvar_value_90 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_90 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 1143;

                goto frame_exception_exit_25;
            }

            tmp_called_instance_34 = tmp_mvar_value_90;
            frame_e04ffe5b900a4019b6788821593ab364_25->m_frame.f_lineno = 1143;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_34, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__oid_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1143;

                goto frame_exception_exit_25;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1129, const_str_plain_oid, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1143;

                goto frame_exception_exit_25;
            }
        }
        {
            PyObject *tmp_called_instance_35;
            PyObject *tmp_mvar_value_91;
            tmp_mvar_value_91 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_91 == NULL)) {
                tmp_mvar_value_91 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_91 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 1144;

                goto frame_exception_exit_25;
            }

            tmp_called_instance_35 = tmp_mvar_value_91;
            frame_e04ffe5b900a4019b6788821593ab364_25->m_frame.f_lineno = 1144;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_35, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__critical_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1144;

                goto frame_exception_exit_25;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1129, const_str_plain_critical, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1144;

                goto frame_exception_exit_25;
            }
        }
        {
            PyObject *tmp_called_instance_36;
            PyObject *tmp_mvar_value_92;
            tmp_mvar_value_92 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_92 == NULL)) {
                tmp_mvar_value_92 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_92 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 1145;

                goto frame_exception_exit_25;
            }

            tmp_called_instance_36 = tmp_mvar_value_92;
            frame_e04ffe5b900a4019b6788821593ab364_25->m_frame.f_lineno = 1145;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_36, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__value_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1145;

                goto frame_exception_exit_25;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1129, const_str_plain_value, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1145;

                goto frame_exception_exit_25;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_e04ffe5b900a4019b6788821593ab364_25);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_24;

        frame_exception_exit_25:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_e04ffe5b900a4019b6788821593ab364_25);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_e04ffe5b900a4019b6788821593ab364_25, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_e04ffe5b900a4019b6788821593ab364_25->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_e04ffe5b900a4019b6788821593ab364_25, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_e04ffe5b900a4019b6788821593ab364_25,
            type_description_2
        );


        // Release cached frame.
        if (frame_e04ffe5b900a4019b6788821593ab364_25 == cache_frame_e04ffe5b900a4019b6788821593ab364_25) {
            Py_DECREF(frame_e04ffe5b900a4019b6788821593ab364_25);
        }
        cache_frame_e04ffe5b900a4019b6788821593ab364_25 = NULL;

        assertFrameObject(frame_e04ffe5b900a4019b6788821593ab364_25);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_24;

        frame_no_exception_24:;
        goto skip_nested_handling_24;
        nested_frame_exit_24:;

        goto try_except_handler_67;
        skip_nested_handling_24:;
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_136___repr__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1129, const_str_plain___repr__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_137___eq__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1129, const_str_plain___eq__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_138___ne__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1129, const_str_plain___ne__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_139___hash__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1129, const_str_plain___hash__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_assign_source_177 = locals_cryptography$x509$extensions_1129;
        Py_INCREF(tmp_assign_source_177);
        goto try_return_handler_67;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Return handler code:
        try_return_handler_67:;
        Py_DECREF(locals_cryptography$x509$extensions_1129);
        locals_cryptography$x509$extensions_1129 = NULL;
        goto outline_result_32;
        // Exception handler code:
        try_except_handler_67:;
        exception_keeper_type_58 = exception_type;
        exception_keeper_value_58 = exception_value;
        exception_keeper_tb_58 = exception_tb;
        exception_keeper_lineno_58 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_cryptography$x509$extensions_1129);
        locals_cryptography$x509$extensions_1129 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_58;
        exception_value = exception_keeper_value_58;
        exception_tb = exception_keeper_tb_58;
        exception_lineno = exception_keeper_lineno_58;

        goto outline_exception_24;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        outline_exception_24:;
        exception_lineno = 1129;
        goto try_except_handler_66;
        outline_result_32:;
        assert(tmp_class_creation_29__class_dict == NULL);
        tmp_class_creation_29__class_dict = tmp_assign_source_177;
    }
    {
        PyObject *tmp_assign_source_178;
        nuitka_bool tmp_condition_result_29;
        PyObject *tmp_key_name_57;
        PyObject *tmp_dict_name_57;
        PyObject *tmp_dict_name_58;
        PyObject *tmp_key_name_58;
        tmp_key_name_57 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_29__class_dict);
        tmp_dict_name_57 = tmp_class_creation_29__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_57, tmp_key_name_57);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1129;

            goto try_except_handler_66;
        }
        tmp_condition_result_29 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_29 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_29;
        } else {
            goto condexpr_false_29;
        }
        condexpr_true_29:;
        CHECK_OBJECT(tmp_class_creation_29__class_dict);
        tmp_dict_name_58 = tmp_class_creation_29__class_dict;
        tmp_key_name_58 = const_str_plain___metaclass__;
        tmp_assign_source_178 = DICT_GET_ITEM(tmp_dict_name_58, tmp_key_name_58);
        if (tmp_assign_source_178 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1129;

            goto try_except_handler_66;
        }
        goto condexpr_end_29;
        condexpr_false_29:;
        tmp_assign_source_178 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_178);
        condexpr_end_29:;
        assert(tmp_class_creation_29__metaclass == NULL);
        tmp_class_creation_29__metaclass = tmp_assign_source_178;
    }
    {
        PyObject *tmp_assign_source_179;
        PyObject *tmp_called_name_67;
        PyObject *tmp_args_element_name_124;
        PyObject *tmp_args_element_name_125;
        PyObject *tmp_args_element_name_126;
        CHECK_OBJECT(tmp_class_creation_29__metaclass);
        tmp_called_name_67 = tmp_class_creation_29__metaclass;
        tmp_args_element_name_124 = const_str_plain_Extension;
        tmp_args_element_name_125 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_29__class_dict);
        tmp_args_element_name_126 = tmp_class_creation_29__class_dict;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 1129;
        {
            PyObject *call_args[] = {tmp_args_element_name_124, tmp_args_element_name_125, tmp_args_element_name_126};
            tmp_assign_source_179 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_67, call_args);
        }

        if (tmp_assign_source_179 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1129;

            goto try_except_handler_66;
        }
        assert(tmp_class_creation_29__class == NULL);
        tmp_class_creation_29__class = tmp_assign_source_179;
    }
    goto try_end_33;
    // Exception handler code:
    try_except_handler_66:;
    exception_keeper_type_59 = exception_type;
    exception_keeper_value_59 = exception_value;
    exception_keeper_tb_59 = exception_tb;
    exception_keeper_lineno_59 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_29__class_dict);
    tmp_class_creation_29__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_29__metaclass);
    tmp_class_creation_29__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_59;
    exception_value = exception_keeper_value_59;
    exception_tb = exception_keeper_tb_59;
    exception_lineno = exception_keeper_lineno_59;

    goto frame_exception_exit_1;
    // End of try:
    try_end_33:;
    {
        PyObject *tmp_assign_source_180;
        CHECK_OBJECT(tmp_class_creation_29__class);
        tmp_assign_source_180 = tmp_class_creation_29__class;
        UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_Extension, tmp_assign_source_180);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_29__class);
    Py_DECREF(tmp_class_creation_29__class);
    tmp_class_creation_29__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_29__class_dict);
    Py_DECREF(tmp_class_creation_29__class_dict);
    tmp_class_creation_29__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_29__metaclass);
    Py_DECREF(tmp_class_creation_29__metaclass);
    tmp_class_creation_29__metaclass = NULL;

    {
        PyObject *tmp_assign_source_181;
        {
            PyObject *tmp_assign_source_182;
            tmp_assign_source_182 = MAKE_FUNCTION_cryptography$x509$extensions$$$function_140___init__();



            assert(tmp_locals_cryptography$x509$extensions_1168_key___init__ == NULL);
            tmp_locals_cryptography$x509$extensions_1168_key___init__ = tmp_assign_source_182;
        }
        {
            PyObject *tmp_assign_source_183;
            tmp_assign_source_183 = MAKE_FUNCTION_cryptography$x509$extensions$$$function_141___iter__();



            assert(tmp_locals_cryptography$x509$extensions_1168_key___iter__ == NULL);
            tmp_locals_cryptography$x509$extensions_1168_key___iter__ = tmp_assign_source_183;
        }
        {
            PyObject *tmp_assign_source_184;
            tmp_assign_source_184 = MAKE_FUNCTION_cryptography$x509$extensions$$$function_142___len__();



            assert(tmp_locals_cryptography$x509$extensions_1168_key___len__ == NULL);
            tmp_locals_cryptography$x509$extensions_1168_key___len__ = tmp_assign_source_184;
        }
        {
            PyObject *tmp_assign_source_185;
            tmp_assign_source_185 = MAKE_FUNCTION_cryptography$x509$extensions$$$function_143_get_values_for_type();



            assert(tmp_locals_cryptography$x509$extensions_1168_key_get_values_for_type == NULL);
            tmp_locals_cryptography$x509$extensions_1168_key_get_values_for_type = tmp_assign_source_185;
        }
        {
            PyObject *tmp_assign_source_186;
            tmp_assign_source_186 = MAKE_FUNCTION_cryptography$x509$extensions$$$function_144___repr__();



            assert(tmp_locals_cryptography$x509$extensions_1168_key___repr__ == NULL);
            tmp_locals_cryptography$x509$extensions_1168_key___repr__ = tmp_assign_source_186;
        }
        {
            PyObject *tmp_assign_source_187;
            tmp_assign_source_187 = MAKE_FUNCTION_cryptography$x509$extensions$$$function_145___eq__();



            assert(tmp_locals_cryptography$x509$extensions_1168_key___eq__ == NULL);
            tmp_locals_cryptography$x509$extensions_1168_key___eq__ = tmp_assign_source_187;
        }
        {
            PyObject *tmp_assign_source_188;
            tmp_assign_source_188 = MAKE_FUNCTION_cryptography$x509$extensions$$$function_146___ne__();



            assert(tmp_locals_cryptography$x509$extensions_1168_key___ne__ == NULL);
            tmp_locals_cryptography$x509$extensions_1168_key___ne__ = tmp_assign_source_188;
        }
        {
            PyObject *tmp_assign_source_189;
            tmp_assign_source_189 = MAKE_FUNCTION_cryptography$x509$extensions$$$function_147___getitem__();



            assert(tmp_locals_cryptography$x509$extensions_1168_key___getitem__ == NULL);
            tmp_locals_cryptography$x509$extensions_1168_key___getitem__ = tmp_assign_source_189;
        }
        {
            PyObject *tmp_assign_source_190;
            tmp_assign_source_190 = MAKE_FUNCTION_cryptography$x509$extensions$$$function_148___hash__();



            assert(tmp_locals_cryptography$x509$extensions_1168_key___hash__ == NULL);
            tmp_locals_cryptography$x509$extensions_1168_key___hash__ = tmp_assign_source_190;
        }
        // Tried code:
        {
            PyObject *tmp_dict_key_13;
            PyObject *tmp_dict_value_13;
            PyObject *tmp_dict_key_14;
            PyObject *tmp_dict_value_14;
            PyObject *tmp_dict_key_15;
            PyObject *tmp_dict_value_15;
            PyObject *tmp_dict_key_16;
            PyObject *tmp_dict_value_16;
            PyObject *tmp_dict_key_17;
            PyObject *tmp_dict_value_17;
            PyObject *tmp_dict_key_18;
            PyObject *tmp_dict_value_18;
            PyObject *tmp_dict_key_19;
            PyObject *tmp_dict_value_19;
            PyObject *tmp_dict_key_20;
            PyObject *tmp_dict_value_20;
            PyObject *tmp_dict_key_21;
            PyObject *tmp_dict_value_21;
            PyObject *tmp_dict_key_22;
            PyObject *tmp_dict_value_22;
            tmp_dict_value_13 = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
            tmp_dict_key_13 = const_str_plain___module__;
            tmp_assign_source_181 = _PyDict_NewPresized( 10 );
            tmp_res = PyDict_SetItem(tmp_assign_source_181, tmp_dict_key_13, tmp_dict_value_13);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_cryptography$x509$extensions_1168_key___init__);
            tmp_dict_value_14 = tmp_locals_cryptography$x509$extensions_1168_key___init__;
            tmp_dict_key_14 = const_str_plain___init__;
            tmp_res = PyDict_SetItem(tmp_assign_source_181, tmp_dict_key_14, tmp_dict_value_14);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_cryptography$x509$extensions_1168_key___iter__);
            tmp_dict_value_15 = tmp_locals_cryptography$x509$extensions_1168_key___iter__;
            tmp_dict_key_15 = const_str_plain___iter__;
            tmp_res = PyDict_SetItem(tmp_assign_source_181, tmp_dict_key_15, tmp_dict_value_15);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_cryptography$x509$extensions_1168_key___len__);
            tmp_dict_value_16 = tmp_locals_cryptography$x509$extensions_1168_key___len__;
            tmp_dict_key_16 = const_str_plain___len__;
            tmp_res = PyDict_SetItem(tmp_assign_source_181, tmp_dict_key_16, tmp_dict_value_16);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_cryptography$x509$extensions_1168_key_get_values_for_type);
            tmp_dict_value_17 = tmp_locals_cryptography$x509$extensions_1168_key_get_values_for_type;
            tmp_dict_key_17 = const_str_plain_get_values_for_type;
            tmp_res = PyDict_SetItem(tmp_assign_source_181, tmp_dict_key_17, tmp_dict_value_17);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_cryptography$x509$extensions_1168_key___repr__);
            tmp_dict_value_18 = tmp_locals_cryptography$x509$extensions_1168_key___repr__;
            tmp_dict_key_18 = const_str_plain___repr__;
            tmp_res = PyDict_SetItem(tmp_assign_source_181, tmp_dict_key_18, tmp_dict_value_18);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_cryptography$x509$extensions_1168_key___eq__);
            tmp_dict_value_19 = tmp_locals_cryptography$x509$extensions_1168_key___eq__;
            tmp_dict_key_19 = const_str_plain___eq__;
            tmp_res = PyDict_SetItem(tmp_assign_source_181, tmp_dict_key_19, tmp_dict_value_19);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_cryptography$x509$extensions_1168_key___ne__);
            tmp_dict_value_20 = tmp_locals_cryptography$x509$extensions_1168_key___ne__;
            tmp_dict_key_20 = const_str_plain___ne__;
            tmp_res = PyDict_SetItem(tmp_assign_source_181, tmp_dict_key_20, tmp_dict_value_20);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_cryptography$x509$extensions_1168_key___getitem__);
            tmp_dict_value_21 = tmp_locals_cryptography$x509$extensions_1168_key___getitem__;
            tmp_dict_key_21 = const_str_plain___getitem__;
            tmp_res = PyDict_SetItem(tmp_assign_source_181, tmp_dict_key_21, tmp_dict_value_21);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_cryptography$x509$extensions_1168_key___hash__);
            tmp_dict_value_22 = tmp_locals_cryptography$x509$extensions_1168_key___hash__;
            tmp_dict_key_22 = const_str_plain___hash__;
            tmp_res = PyDict_SetItem(tmp_assign_source_181, tmp_dict_key_22, tmp_dict_value_22);
            assert(!(tmp_res != 0));
            goto try_return_handler_68;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Return handler code:
        try_return_handler_68:;
        CHECK_OBJECT((PyObject *)tmp_locals_cryptography$x509$extensions_1168_key___init__);
        Py_DECREF(tmp_locals_cryptography$x509$extensions_1168_key___init__);
        tmp_locals_cryptography$x509$extensions_1168_key___init__ = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_cryptography$x509$extensions_1168_key___iter__);
        Py_DECREF(tmp_locals_cryptography$x509$extensions_1168_key___iter__);
        tmp_locals_cryptography$x509$extensions_1168_key___iter__ = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_cryptography$x509$extensions_1168_key___len__);
        Py_DECREF(tmp_locals_cryptography$x509$extensions_1168_key___len__);
        tmp_locals_cryptography$x509$extensions_1168_key___len__ = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_cryptography$x509$extensions_1168_key_get_values_for_type);
        Py_DECREF(tmp_locals_cryptography$x509$extensions_1168_key_get_values_for_type);
        tmp_locals_cryptography$x509$extensions_1168_key_get_values_for_type = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_cryptography$x509$extensions_1168_key___repr__);
        Py_DECREF(tmp_locals_cryptography$x509$extensions_1168_key___repr__);
        tmp_locals_cryptography$x509$extensions_1168_key___repr__ = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_cryptography$x509$extensions_1168_key___eq__);
        Py_DECREF(tmp_locals_cryptography$x509$extensions_1168_key___eq__);
        tmp_locals_cryptography$x509$extensions_1168_key___eq__ = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_cryptography$x509$extensions_1168_key___ne__);
        Py_DECREF(tmp_locals_cryptography$x509$extensions_1168_key___ne__);
        tmp_locals_cryptography$x509$extensions_1168_key___ne__ = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_cryptography$x509$extensions_1168_key___getitem__);
        Py_DECREF(tmp_locals_cryptography$x509$extensions_1168_key___getitem__);
        tmp_locals_cryptography$x509$extensions_1168_key___getitem__ = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_cryptography$x509$extensions_1168_key___hash__);
        Py_DECREF(tmp_locals_cryptography$x509$extensions_1168_key___hash__);
        tmp_locals_cryptography$x509$extensions_1168_key___hash__ = NULL;

        goto outline_result_33;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        outline_result_33:;
        assert(tmp_class_creation_30__class_dict == NULL);
        tmp_class_creation_30__class_dict = tmp_assign_source_181;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_191;
        nuitka_bool tmp_condition_result_30;
        PyObject *tmp_key_name_59;
        PyObject *tmp_dict_name_59;
        PyObject *tmp_dict_name_60;
        PyObject *tmp_key_name_60;
        tmp_key_name_59 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_30__class_dict);
        tmp_dict_name_59 = tmp_class_creation_30__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_59, tmp_key_name_59);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1168;

            goto try_except_handler_69;
        }
        tmp_condition_result_30 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_30 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_30;
        } else {
            goto condexpr_false_30;
        }
        condexpr_true_30:;
        CHECK_OBJECT(tmp_class_creation_30__class_dict);
        tmp_dict_name_60 = tmp_class_creation_30__class_dict;
        tmp_key_name_60 = const_str_plain___metaclass__;
        tmp_assign_source_191 = DICT_GET_ITEM(tmp_dict_name_60, tmp_key_name_60);
        if (tmp_assign_source_191 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1168;

            goto try_except_handler_69;
        }
        goto condexpr_end_30;
        condexpr_false_30:;
        tmp_assign_source_191 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_191);
        condexpr_end_30:;
        assert(tmp_class_creation_30__metaclass == NULL);
        tmp_class_creation_30__metaclass = tmp_assign_source_191;
    }
    {
        PyObject *tmp_assign_source_192;
        PyObject *tmp_called_name_68;
        PyObject *tmp_args_element_name_127;
        PyObject *tmp_args_element_name_128;
        PyObject *tmp_args_element_name_129;
        CHECK_OBJECT(tmp_class_creation_30__metaclass);
        tmp_called_name_68 = tmp_class_creation_30__metaclass;
        tmp_args_element_name_127 = const_str_plain_GeneralNames;
        tmp_args_element_name_128 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_30__class_dict);
        tmp_args_element_name_129 = tmp_class_creation_30__class_dict;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 1168;
        {
            PyObject *call_args[] = {tmp_args_element_name_127, tmp_args_element_name_128, tmp_args_element_name_129};
            tmp_assign_source_192 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_68, call_args);
        }

        if (tmp_assign_source_192 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1168;

            goto try_except_handler_69;
        }
        assert(tmp_class_creation_30__class == NULL);
        tmp_class_creation_30__class = tmp_assign_source_192;
    }
    goto try_end_34;
    // Exception handler code:
    try_except_handler_69:;
    exception_keeper_type_60 = exception_type;
    exception_keeper_value_60 = exception_value;
    exception_keeper_tb_60 = exception_tb;
    exception_keeper_lineno_60 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)tmp_class_creation_30__class_dict);
    Py_DECREF(tmp_class_creation_30__class_dict);
    tmp_class_creation_30__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_30__metaclass);
    tmp_class_creation_30__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_60;
    exception_value = exception_keeper_value_60;
    exception_tb = exception_keeper_tb_60;
    exception_lineno = exception_keeper_lineno_60;

    goto frame_exception_exit_1;
    // End of try:
    try_end_34:;
    {
        PyObject *tmp_assign_source_193;
        CHECK_OBJECT(tmp_class_creation_30__class);
        tmp_assign_source_193 = tmp_class_creation_30__class;
        UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_GeneralNames, tmp_assign_source_193);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_30__class);
    Py_DECREF(tmp_class_creation_30__class);
    tmp_class_creation_30__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_30__class_dict);
    Py_DECREF(tmp_class_creation_30__class_dict);
    tmp_class_creation_30__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_30__metaclass);
    Py_DECREF(tmp_class_creation_30__metaclass);
    tmp_class_creation_30__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_194;
        {
            PyObject *tmp_set_locals_27;
            tmp_set_locals_27 = PyDict_New();
            locals_cryptography$x509$extensions_1214 = tmp_set_locals_27;
        }
        tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1214, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_52c7e053ce661cd35566c3bb41cd02bd_26, codeobj_52c7e053ce661cd35566c3bb41cd02bd, module_cryptography$x509$extensions, 0);
        frame_52c7e053ce661cd35566c3bb41cd02bd_26 = cache_frame_52c7e053ce661cd35566c3bb41cd02bd_26;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_52c7e053ce661cd35566c3bb41cd02bd_26);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_52c7e053ce661cd35566c3bb41cd02bd_26) == 2); // Frame stack

        // Framed code:
        {
            PyObject *tmp_source_name_39;
            PyObject *tmp_mvar_value_93;
            tmp_mvar_value_93 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID);

            if (unlikely(tmp_mvar_value_93 == NULL)) {
                tmp_mvar_value_93 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionOID);
            }

            if (tmp_mvar_value_93 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 23410 ], 34, 0);
                exception_tb = NULL;

                exception_lineno = 1215;

                goto frame_exception_exit_26;
            }

            tmp_source_name_39 = tmp_mvar_value_93;
            tmp_dictset_value = LOOKUP_ATTRIBUTE(tmp_source_name_39, const_str_plain_SUBJECT_ALTERNATIVE_NAME);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1215;

                goto frame_exception_exit_26;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1214, const_str_plain_oid, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1215;

                goto frame_exception_exit_26;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_52c7e053ce661cd35566c3bb41cd02bd_26);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_25;

        frame_exception_exit_26:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_52c7e053ce661cd35566c3bb41cd02bd_26);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_52c7e053ce661cd35566c3bb41cd02bd_26, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_52c7e053ce661cd35566c3bb41cd02bd_26->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_52c7e053ce661cd35566c3bb41cd02bd_26, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_52c7e053ce661cd35566c3bb41cd02bd_26,
            type_description_2
        );


        // Release cached frame.
        if (frame_52c7e053ce661cd35566c3bb41cd02bd_26 == cache_frame_52c7e053ce661cd35566c3bb41cd02bd_26) {
            Py_DECREF(frame_52c7e053ce661cd35566c3bb41cd02bd_26);
        }
        cache_frame_52c7e053ce661cd35566c3bb41cd02bd_26 = NULL;

        assertFrameObject(frame_52c7e053ce661cd35566c3bb41cd02bd_26);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_25;

        frame_no_exception_25:;
        goto skip_nested_handling_25;
        nested_frame_exit_25:;

        goto try_except_handler_71;
        skip_nested_handling_25:;
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_149___init__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1214, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_150___iter__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1214, const_str_plain___iter__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_151___len__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1214, const_str_plain___len__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_152_get_values_for_type();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1214, const_str_plain_get_values_for_type, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_153___repr__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1214, const_str_plain___repr__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_154___eq__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1214, const_str_plain___eq__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_155___getitem__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1214, const_str_plain___getitem__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_156___ne__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1214, const_str_plain___ne__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_157___hash__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1214, const_str_plain___hash__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_assign_source_194 = locals_cryptography$x509$extensions_1214;
        Py_INCREF(tmp_assign_source_194);
        goto try_return_handler_71;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Return handler code:
        try_return_handler_71:;
        Py_DECREF(locals_cryptography$x509$extensions_1214);
        locals_cryptography$x509$extensions_1214 = NULL;
        goto outline_result_34;
        // Exception handler code:
        try_except_handler_71:;
        exception_keeper_type_61 = exception_type;
        exception_keeper_value_61 = exception_value;
        exception_keeper_tb_61 = exception_tb;
        exception_keeper_lineno_61 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_cryptography$x509$extensions_1214);
        locals_cryptography$x509$extensions_1214 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_61;
        exception_value = exception_keeper_value_61;
        exception_tb = exception_keeper_tb_61;
        exception_lineno = exception_keeper_lineno_61;

        goto outline_exception_25;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        outline_exception_25:;
        exception_lineno = 1214;
        goto try_except_handler_70;
        outline_result_34:;
        assert(tmp_class_creation_31__class_dict == NULL);
        tmp_class_creation_31__class_dict = tmp_assign_source_194;
    }
    {
        PyObject *tmp_assign_source_195;
        nuitka_bool tmp_condition_result_31;
        PyObject *tmp_key_name_61;
        PyObject *tmp_dict_name_61;
        PyObject *tmp_dict_name_62;
        PyObject *tmp_key_name_62;
        tmp_key_name_61 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_31__class_dict);
        tmp_dict_name_61 = tmp_class_creation_31__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_61, tmp_key_name_61);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1214;

            goto try_except_handler_70;
        }
        tmp_condition_result_31 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_31 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_31;
        } else {
            goto condexpr_false_31;
        }
        condexpr_true_31:;
        CHECK_OBJECT(tmp_class_creation_31__class_dict);
        tmp_dict_name_62 = tmp_class_creation_31__class_dict;
        tmp_key_name_62 = const_str_plain___metaclass__;
        tmp_assign_source_195 = DICT_GET_ITEM(tmp_dict_name_62, tmp_key_name_62);
        if (tmp_assign_source_195 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1214;

            goto try_except_handler_70;
        }
        goto condexpr_end_31;
        condexpr_false_31:;
        tmp_assign_source_195 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_195);
        condexpr_end_31:;
        assert(tmp_class_creation_31__metaclass == NULL);
        tmp_class_creation_31__metaclass = tmp_assign_source_195;
    }
    {
        PyObject *tmp_assign_source_196;
        PyObject *tmp_called_name_69;
        PyObject *tmp_args_element_name_130;
        PyObject *tmp_args_element_name_131;
        PyObject *tmp_args_element_name_132;
        CHECK_OBJECT(tmp_class_creation_31__metaclass);
        tmp_called_name_69 = tmp_class_creation_31__metaclass;
        tmp_args_element_name_130 = const_str_plain_SubjectAlternativeName;
        tmp_args_element_name_131 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_31__class_dict);
        tmp_args_element_name_132 = tmp_class_creation_31__class_dict;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 1214;
        {
            PyObject *call_args[] = {tmp_args_element_name_130, tmp_args_element_name_131, tmp_args_element_name_132};
            tmp_assign_source_196 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_69, call_args);
        }

        if (tmp_assign_source_196 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1214;

            goto try_except_handler_70;
        }
        assert(tmp_class_creation_31__class == NULL);
        tmp_class_creation_31__class = tmp_assign_source_196;
    }
    {
        PyObject *tmp_assign_source_197;
        PyObject *tmp_called_name_70;
        PyObject *tmp_called_name_71;
        PyObject *tmp_source_name_40;
        PyObject *tmp_mvar_value_94;
        PyObject *tmp_args_element_name_133;
        PyObject *tmp_mvar_value_95;
        PyObject *tmp_args_element_name_134;
        tmp_mvar_value_94 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

        if (unlikely(tmp_mvar_value_94 == NULL)) {
            tmp_mvar_value_94 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
        }

        if (tmp_mvar_value_94 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
            exception_tb = NULL;

            exception_lineno = 1213;

            goto try_except_handler_70;
        }

        tmp_source_name_40 = tmp_mvar_value_94;
        tmp_called_name_71 = LOOKUP_ATTRIBUTE(tmp_source_name_40, const_str_plain_register_interface);
        if (tmp_called_name_71 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1213;

            goto try_except_handler_70;
        }
        tmp_mvar_value_95 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType);

        if (unlikely(tmp_mvar_value_95 == NULL)) {
            tmp_mvar_value_95 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType);
        }

        if (tmp_mvar_value_95 == NULL) {
            Py_DECREF(tmp_called_name_71);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 35484 ], 35, 0);
            exception_tb = NULL;

            exception_lineno = 1213;

            goto try_except_handler_70;
        }

        tmp_args_element_name_133 = tmp_mvar_value_95;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 1213;
        tmp_called_name_70 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_71, tmp_args_element_name_133);
        Py_DECREF(tmp_called_name_71);
        if (tmp_called_name_70 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1213;

            goto try_except_handler_70;
        }
        CHECK_OBJECT(tmp_class_creation_31__class);
        tmp_args_element_name_134 = tmp_class_creation_31__class;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 1213;
        tmp_assign_source_197 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_70, tmp_args_element_name_134);
        Py_DECREF(tmp_called_name_70);
        if (tmp_assign_source_197 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1213;

            goto try_except_handler_70;
        }
        {
            PyObject *old = tmp_class_creation_31__class;
            assert(old != NULL);
            tmp_class_creation_31__class = tmp_assign_source_197;
            Py_DECREF(old);
        }

    }
    goto try_end_35;
    // Exception handler code:
    try_except_handler_70:;
    exception_keeper_type_62 = exception_type;
    exception_keeper_value_62 = exception_value;
    exception_keeper_tb_62 = exception_tb;
    exception_keeper_lineno_62 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_31__class);
    tmp_class_creation_31__class = NULL;

    Py_XDECREF(tmp_class_creation_31__class_dict);
    tmp_class_creation_31__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_31__metaclass);
    tmp_class_creation_31__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_62;
    exception_value = exception_keeper_value_62;
    exception_tb = exception_keeper_tb_62;
    exception_lineno = exception_keeper_lineno_62;

    goto frame_exception_exit_1;
    // End of try:
    try_end_35:;
    {
        PyObject *tmp_assign_source_198;
        CHECK_OBJECT(tmp_class_creation_31__class);
        tmp_assign_source_198 = tmp_class_creation_31__class;
        UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_SubjectAlternativeName, tmp_assign_source_198);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_31__class);
    Py_DECREF(tmp_class_creation_31__class);
    tmp_class_creation_31__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_31__class_dict);
    Py_DECREF(tmp_class_creation_31__class_dict);
    tmp_class_creation_31__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_31__metaclass);
    Py_DECREF(tmp_class_creation_31__metaclass);
    tmp_class_creation_31__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_199;
        {
            PyObject *tmp_set_locals_28;
            tmp_set_locals_28 = PyDict_New();
            locals_cryptography$x509$extensions_1249 = tmp_set_locals_28;
        }
        tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1249, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_046f51f4b030997d90f3cee22939d406_27, codeobj_046f51f4b030997d90f3cee22939d406, module_cryptography$x509$extensions, 0);
        frame_046f51f4b030997d90f3cee22939d406_27 = cache_frame_046f51f4b030997d90f3cee22939d406_27;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_046f51f4b030997d90f3cee22939d406_27);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_046f51f4b030997d90f3cee22939d406_27) == 2); // Frame stack

        // Framed code:
        {
            PyObject *tmp_source_name_41;
            PyObject *tmp_mvar_value_96;
            tmp_mvar_value_96 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID);

            if (unlikely(tmp_mvar_value_96 == NULL)) {
                tmp_mvar_value_96 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionOID);
            }

            if (tmp_mvar_value_96 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 23410 ], 34, 0);
                exception_tb = NULL;

                exception_lineno = 1250;

                goto frame_exception_exit_27;
            }

            tmp_source_name_41 = tmp_mvar_value_96;
            tmp_dictset_value = LOOKUP_ATTRIBUTE(tmp_source_name_41, const_str_plain_ISSUER_ALTERNATIVE_NAME);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1250;

                goto frame_exception_exit_27;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1249, const_str_plain_oid, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1250;

                goto frame_exception_exit_27;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_046f51f4b030997d90f3cee22939d406_27);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_26;

        frame_exception_exit_27:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_046f51f4b030997d90f3cee22939d406_27);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_046f51f4b030997d90f3cee22939d406_27, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_046f51f4b030997d90f3cee22939d406_27->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_046f51f4b030997d90f3cee22939d406_27, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_046f51f4b030997d90f3cee22939d406_27,
            type_description_2
        );


        // Release cached frame.
        if (frame_046f51f4b030997d90f3cee22939d406_27 == cache_frame_046f51f4b030997d90f3cee22939d406_27) {
            Py_DECREF(frame_046f51f4b030997d90f3cee22939d406_27);
        }
        cache_frame_046f51f4b030997d90f3cee22939d406_27 = NULL;

        assertFrameObject(frame_046f51f4b030997d90f3cee22939d406_27);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_26;

        frame_no_exception_26:;
        goto skip_nested_handling_26;
        nested_frame_exit_26:;

        goto try_except_handler_73;
        skip_nested_handling_26:;
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_158___init__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1249, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_159___iter__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1249, const_str_plain___iter__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_160___len__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1249, const_str_plain___len__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_161_get_values_for_type();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1249, const_str_plain_get_values_for_type, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_162___repr__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1249, const_str_plain___repr__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_163___eq__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1249, const_str_plain___eq__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_164___ne__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1249, const_str_plain___ne__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_165___getitem__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1249, const_str_plain___getitem__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_166___hash__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1249, const_str_plain___hash__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_assign_source_199 = locals_cryptography$x509$extensions_1249;
        Py_INCREF(tmp_assign_source_199);
        goto try_return_handler_73;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Return handler code:
        try_return_handler_73:;
        Py_DECREF(locals_cryptography$x509$extensions_1249);
        locals_cryptography$x509$extensions_1249 = NULL;
        goto outline_result_35;
        // Exception handler code:
        try_except_handler_73:;
        exception_keeper_type_63 = exception_type;
        exception_keeper_value_63 = exception_value;
        exception_keeper_tb_63 = exception_tb;
        exception_keeper_lineno_63 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_cryptography$x509$extensions_1249);
        locals_cryptography$x509$extensions_1249 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_63;
        exception_value = exception_keeper_value_63;
        exception_tb = exception_keeper_tb_63;
        exception_lineno = exception_keeper_lineno_63;

        goto outline_exception_26;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        outline_exception_26:;
        exception_lineno = 1249;
        goto try_except_handler_72;
        outline_result_35:;
        assert(tmp_class_creation_32__class_dict == NULL);
        tmp_class_creation_32__class_dict = tmp_assign_source_199;
    }
    {
        PyObject *tmp_assign_source_200;
        nuitka_bool tmp_condition_result_32;
        PyObject *tmp_key_name_63;
        PyObject *tmp_dict_name_63;
        PyObject *tmp_dict_name_64;
        PyObject *tmp_key_name_64;
        tmp_key_name_63 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_32__class_dict);
        tmp_dict_name_63 = tmp_class_creation_32__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_63, tmp_key_name_63);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1249;

            goto try_except_handler_72;
        }
        tmp_condition_result_32 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_32 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_32;
        } else {
            goto condexpr_false_32;
        }
        condexpr_true_32:;
        CHECK_OBJECT(tmp_class_creation_32__class_dict);
        tmp_dict_name_64 = tmp_class_creation_32__class_dict;
        tmp_key_name_64 = const_str_plain___metaclass__;
        tmp_assign_source_200 = DICT_GET_ITEM(tmp_dict_name_64, tmp_key_name_64);
        if (tmp_assign_source_200 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1249;

            goto try_except_handler_72;
        }
        goto condexpr_end_32;
        condexpr_false_32:;
        tmp_assign_source_200 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_200);
        condexpr_end_32:;
        assert(tmp_class_creation_32__metaclass == NULL);
        tmp_class_creation_32__metaclass = tmp_assign_source_200;
    }
    {
        PyObject *tmp_assign_source_201;
        PyObject *tmp_called_name_72;
        PyObject *tmp_args_element_name_135;
        PyObject *tmp_args_element_name_136;
        PyObject *tmp_args_element_name_137;
        CHECK_OBJECT(tmp_class_creation_32__metaclass);
        tmp_called_name_72 = tmp_class_creation_32__metaclass;
        tmp_args_element_name_135 = const_str_plain_IssuerAlternativeName;
        tmp_args_element_name_136 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_32__class_dict);
        tmp_args_element_name_137 = tmp_class_creation_32__class_dict;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 1249;
        {
            PyObject *call_args[] = {tmp_args_element_name_135, tmp_args_element_name_136, tmp_args_element_name_137};
            tmp_assign_source_201 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_72, call_args);
        }

        if (tmp_assign_source_201 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1249;

            goto try_except_handler_72;
        }
        assert(tmp_class_creation_32__class == NULL);
        tmp_class_creation_32__class = tmp_assign_source_201;
    }
    {
        PyObject *tmp_assign_source_202;
        PyObject *tmp_called_name_73;
        PyObject *tmp_called_name_74;
        PyObject *tmp_source_name_42;
        PyObject *tmp_mvar_value_97;
        PyObject *tmp_args_element_name_138;
        PyObject *tmp_mvar_value_98;
        PyObject *tmp_args_element_name_139;
        tmp_mvar_value_97 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

        if (unlikely(tmp_mvar_value_97 == NULL)) {
            tmp_mvar_value_97 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
        }

        if (tmp_mvar_value_97 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
            exception_tb = NULL;

            exception_lineno = 1248;

            goto try_except_handler_72;
        }

        tmp_source_name_42 = tmp_mvar_value_97;
        tmp_called_name_74 = LOOKUP_ATTRIBUTE(tmp_source_name_42, const_str_plain_register_interface);
        if (tmp_called_name_74 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1248;

            goto try_except_handler_72;
        }
        tmp_mvar_value_98 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType);

        if (unlikely(tmp_mvar_value_98 == NULL)) {
            tmp_mvar_value_98 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType);
        }

        if (tmp_mvar_value_98 == NULL) {
            Py_DECREF(tmp_called_name_74);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 35484 ], 35, 0);
            exception_tb = NULL;

            exception_lineno = 1248;

            goto try_except_handler_72;
        }

        tmp_args_element_name_138 = tmp_mvar_value_98;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 1248;
        tmp_called_name_73 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_74, tmp_args_element_name_138);
        Py_DECREF(tmp_called_name_74);
        if (tmp_called_name_73 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1248;

            goto try_except_handler_72;
        }
        CHECK_OBJECT(tmp_class_creation_32__class);
        tmp_args_element_name_139 = tmp_class_creation_32__class;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 1248;
        tmp_assign_source_202 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_73, tmp_args_element_name_139);
        Py_DECREF(tmp_called_name_73);
        if (tmp_assign_source_202 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1248;

            goto try_except_handler_72;
        }
        {
            PyObject *old = tmp_class_creation_32__class;
            assert(old != NULL);
            tmp_class_creation_32__class = tmp_assign_source_202;
            Py_DECREF(old);
        }

    }
    goto try_end_36;
    // Exception handler code:
    try_except_handler_72:;
    exception_keeper_type_64 = exception_type;
    exception_keeper_value_64 = exception_value;
    exception_keeper_tb_64 = exception_tb;
    exception_keeper_lineno_64 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_32__class);
    tmp_class_creation_32__class = NULL;

    Py_XDECREF(tmp_class_creation_32__class_dict);
    tmp_class_creation_32__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_32__metaclass);
    tmp_class_creation_32__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_64;
    exception_value = exception_keeper_value_64;
    exception_tb = exception_keeper_tb_64;
    exception_lineno = exception_keeper_lineno_64;

    goto frame_exception_exit_1;
    // End of try:
    try_end_36:;
    {
        PyObject *tmp_assign_source_203;
        CHECK_OBJECT(tmp_class_creation_32__class);
        tmp_assign_source_203 = tmp_class_creation_32__class;
        UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_IssuerAlternativeName, tmp_assign_source_203);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_32__class);
    Py_DECREF(tmp_class_creation_32__class);
    tmp_class_creation_32__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_32__class_dict);
    Py_DECREF(tmp_class_creation_32__class_dict);
    tmp_class_creation_32__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_32__metaclass);
    Py_DECREF(tmp_class_creation_32__metaclass);
    tmp_class_creation_32__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_204;
        {
            PyObject *tmp_set_locals_29;
            tmp_set_locals_29 = PyDict_New();
            locals_cryptography$x509$extensions_1284 = tmp_set_locals_29;
        }
        tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1284, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_d613475f4bc9b1ec8ed0abba919aa767_28, codeobj_d613475f4bc9b1ec8ed0abba919aa767, module_cryptography$x509$extensions, 0);
        frame_d613475f4bc9b1ec8ed0abba919aa767_28 = cache_frame_d613475f4bc9b1ec8ed0abba919aa767_28;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_d613475f4bc9b1ec8ed0abba919aa767_28);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_d613475f4bc9b1ec8ed0abba919aa767_28) == 2); // Frame stack

        // Framed code:
        {
            PyObject *tmp_source_name_43;
            PyObject *tmp_mvar_value_99;
            tmp_mvar_value_99 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_CRLEntryExtensionOID);

            if (unlikely(tmp_mvar_value_99 == NULL)) {
                tmp_mvar_value_99 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_CRLEntryExtensionOID);
            }

            if (tmp_mvar_value_99 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 25048 ], 42, 0);
                exception_tb = NULL;

                exception_lineno = 1285;

                goto frame_exception_exit_28;
            }

            tmp_source_name_43 = tmp_mvar_value_99;
            tmp_dictset_value = LOOKUP_ATTRIBUTE(tmp_source_name_43, const_str_plain_CERTIFICATE_ISSUER);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1285;

                goto frame_exception_exit_28;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1284, const_str_plain_oid, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1285;

                goto frame_exception_exit_28;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_d613475f4bc9b1ec8ed0abba919aa767_28);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_27;

        frame_exception_exit_28:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_d613475f4bc9b1ec8ed0abba919aa767_28);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_d613475f4bc9b1ec8ed0abba919aa767_28, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_d613475f4bc9b1ec8ed0abba919aa767_28->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_d613475f4bc9b1ec8ed0abba919aa767_28, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_d613475f4bc9b1ec8ed0abba919aa767_28,
            type_description_2
        );


        // Release cached frame.
        if (frame_d613475f4bc9b1ec8ed0abba919aa767_28 == cache_frame_d613475f4bc9b1ec8ed0abba919aa767_28) {
            Py_DECREF(frame_d613475f4bc9b1ec8ed0abba919aa767_28);
        }
        cache_frame_d613475f4bc9b1ec8ed0abba919aa767_28 = NULL;

        assertFrameObject(frame_d613475f4bc9b1ec8ed0abba919aa767_28);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_27;

        frame_no_exception_27:;
        goto skip_nested_handling_27;
        nested_frame_exit_27:;

        goto try_except_handler_75;
        skip_nested_handling_27:;
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_167___init__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1284, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_168___iter__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1284, const_str_plain___iter__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_169___len__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1284, const_str_plain___len__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_170_get_values_for_type();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1284, const_str_plain_get_values_for_type, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_171___repr__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1284, const_str_plain___repr__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_172___eq__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1284, const_str_plain___eq__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_173___ne__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1284, const_str_plain___ne__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_174___getitem__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1284, const_str_plain___getitem__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_175___hash__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1284, const_str_plain___hash__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_assign_source_204 = locals_cryptography$x509$extensions_1284;
        Py_INCREF(tmp_assign_source_204);
        goto try_return_handler_75;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Return handler code:
        try_return_handler_75:;
        Py_DECREF(locals_cryptography$x509$extensions_1284);
        locals_cryptography$x509$extensions_1284 = NULL;
        goto outline_result_36;
        // Exception handler code:
        try_except_handler_75:;
        exception_keeper_type_65 = exception_type;
        exception_keeper_value_65 = exception_value;
        exception_keeper_tb_65 = exception_tb;
        exception_keeper_lineno_65 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_cryptography$x509$extensions_1284);
        locals_cryptography$x509$extensions_1284 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_65;
        exception_value = exception_keeper_value_65;
        exception_tb = exception_keeper_tb_65;
        exception_lineno = exception_keeper_lineno_65;

        goto outline_exception_27;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        outline_exception_27:;
        exception_lineno = 1284;
        goto try_except_handler_74;
        outline_result_36:;
        assert(tmp_class_creation_33__class_dict == NULL);
        tmp_class_creation_33__class_dict = tmp_assign_source_204;
    }
    {
        PyObject *tmp_assign_source_205;
        nuitka_bool tmp_condition_result_33;
        PyObject *tmp_key_name_65;
        PyObject *tmp_dict_name_65;
        PyObject *tmp_dict_name_66;
        PyObject *tmp_key_name_66;
        tmp_key_name_65 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_33__class_dict);
        tmp_dict_name_65 = tmp_class_creation_33__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_65, tmp_key_name_65);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1284;

            goto try_except_handler_74;
        }
        tmp_condition_result_33 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_33 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_33;
        } else {
            goto condexpr_false_33;
        }
        condexpr_true_33:;
        CHECK_OBJECT(tmp_class_creation_33__class_dict);
        tmp_dict_name_66 = tmp_class_creation_33__class_dict;
        tmp_key_name_66 = const_str_plain___metaclass__;
        tmp_assign_source_205 = DICT_GET_ITEM(tmp_dict_name_66, tmp_key_name_66);
        if (tmp_assign_source_205 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1284;

            goto try_except_handler_74;
        }
        goto condexpr_end_33;
        condexpr_false_33:;
        tmp_assign_source_205 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_205);
        condexpr_end_33:;
        assert(tmp_class_creation_33__metaclass == NULL);
        tmp_class_creation_33__metaclass = tmp_assign_source_205;
    }
    {
        PyObject *tmp_assign_source_206;
        PyObject *tmp_called_name_75;
        PyObject *tmp_args_element_name_140;
        PyObject *tmp_args_element_name_141;
        PyObject *tmp_args_element_name_142;
        CHECK_OBJECT(tmp_class_creation_33__metaclass);
        tmp_called_name_75 = tmp_class_creation_33__metaclass;
        tmp_args_element_name_140 = const_str_plain_CertificateIssuer;
        tmp_args_element_name_141 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_33__class_dict);
        tmp_args_element_name_142 = tmp_class_creation_33__class_dict;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 1284;
        {
            PyObject *call_args[] = {tmp_args_element_name_140, tmp_args_element_name_141, tmp_args_element_name_142};
            tmp_assign_source_206 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_75, call_args);
        }

        if (tmp_assign_source_206 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1284;

            goto try_except_handler_74;
        }
        assert(tmp_class_creation_33__class == NULL);
        tmp_class_creation_33__class = tmp_assign_source_206;
    }
    {
        PyObject *tmp_assign_source_207;
        PyObject *tmp_called_name_76;
        PyObject *tmp_called_name_77;
        PyObject *tmp_source_name_44;
        PyObject *tmp_mvar_value_100;
        PyObject *tmp_args_element_name_143;
        PyObject *tmp_mvar_value_101;
        PyObject *tmp_args_element_name_144;
        tmp_mvar_value_100 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

        if (unlikely(tmp_mvar_value_100 == NULL)) {
            tmp_mvar_value_100 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
        }

        if (tmp_mvar_value_100 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
            exception_tb = NULL;

            exception_lineno = 1283;

            goto try_except_handler_74;
        }

        tmp_source_name_44 = tmp_mvar_value_100;
        tmp_called_name_77 = LOOKUP_ATTRIBUTE(tmp_source_name_44, const_str_plain_register_interface);
        if (tmp_called_name_77 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1283;

            goto try_except_handler_74;
        }
        tmp_mvar_value_101 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType);

        if (unlikely(tmp_mvar_value_101 == NULL)) {
            tmp_mvar_value_101 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType);
        }

        if (tmp_mvar_value_101 == NULL) {
            Py_DECREF(tmp_called_name_77);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 35484 ], 35, 0);
            exception_tb = NULL;

            exception_lineno = 1283;

            goto try_except_handler_74;
        }

        tmp_args_element_name_143 = tmp_mvar_value_101;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 1283;
        tmp_called_name_76 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_77, tmp_args_element_name_143);
        Py_DECREF(tmp_called_name_77);
        if (tmp_called_name_76 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1283;

            goto try_except_handler_74;
        }
        CHECK_OBJECT(tmp_class_creation_33__class);
        tmp_args_element_name_144 = tmp_class_creation_33__class;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 1283;
        tmp_assign_source_207 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_76, tmp_args_element_name_144);
        Py_DECREF(tmp_called_name_76);
        if (tmp_assign_source_207 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1283;

            goto try_except_handler_74;
        }
        {
            PyObject *old = tmp_class_creation_33__class;
            assert(old != NULL);
            tmp_class_creation_33__class = tmp_assign_source_207;
            Py_DECREF(old);
        }

    }
    goto try_end_37;
    // Exception handler code:
    try_except_handler_74:;
    exception_keeper_type_66 = exception_type;
    exception_keeper_value_66 = exception_value;
    exception_keeper_tb_66 = exception_tb;
    exception_keeper_lineno_66 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_33__class);
    tmp_class_creation_33__class = NULL;

    Py_XDECREF(tmp_class_creation_33__class_dict);
    tmp_class_creation_33__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_33__metaclass);
    tmp_class_creation_33__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_66;
    exception_value = exception_keeper_value_66;
    exception_tb = exception_keeper_tb_66;
    exception_lineno = exception_keeper_lineno_66;

    goto frame_exception_exit_1;
    // End of try:
    try_end_37:;
    {
        PyObject *tmp_assign_source_208;
        CHECK_OBJECT(tmp_class_creation_33__class);
        tmp_assign_source_208 = tmp_class_creation_33__class;
        UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_CertificateIssuer, tmp_assign_source_208);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_33__class);
    Py_DECREF(tmp_class_creation_33__class);
    tmp_class_creation_33__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_33__class_dict);
    Py_DECREF(tmp_class_creation_33__class_dict);
    tmp_class_creation_33__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_33__metaclass);
    Py_DECREF(tmp_class_creation_33__metaclass);
    tmp_class_creation_33__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_209;
        {
            PyObject *tmp_set_locals_30;
            tmp_set_locals_30 = PyDict_New();
            locals_cryptography$x509$extensions_1319 = tmp_set_locals_30;
        }
        tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1319, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_f1fb71489cc684b7ee4d1e2902a82ad3_29, codeobj_f1fb71489cc684b7ee4d1e2902a82ad3, module_cryptography$x509$extensions, 0);
        frame_f1fb71489cc684b7ee4d1e2902a82ad3_29 = cache_frame_f1fb71489cc684b7ee4d1e2902a82ad3_29;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_f1fb71489cc684b7ee4d1e2902a82ad3_29);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_f1fb71489cc684b7ee4d1e2902a82ad3_29) == 2); // Frame stack

        // Framed code:
        {
            PyObject *tmp_source_name_45;
            PyObject *tmp_mvar_value_102;
            tmp_mvar_value_102 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_CRLEntryExtensionOID);

            if (unlikely(tmp_mvar_value_102 == NULL)) {
                tmp_mvar_value_102 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_CRLEntryExtensionOID);
            }

            if (tmp_mvar_value_102 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 25048 ], 42, 0);
                exception_tb = NULL;

                exception_lineno = 1320;

                goto frame_exception_exit_29;
            }

            tmp_source_name_45 = tmp_mvar_value_102;
            tmp_dictset_value = LOOKUP_ATTRIBUTE(tmp_source_name_45, const_str_plain_CRL_REASON);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1320;

                goto frame_exception_exit_29;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1319, const_str_plain_oid, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1320;

                goto frame_exception_exit_29;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_176___init__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1319, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_177___repr__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1319, const_str_plain___repr__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_178___eq__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1319, const_str_plain___eq__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_179___ne__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1319, const_str_plain___ne__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_180___hash__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1319, const_str_plain___hash__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        {
            PyObject *tmp_called_instance_37;
            PyObject *tmp_mvar_value_103;
            tmp_mvar_value_103 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_103 == NULL)) {
                tmp_mvar_value_103 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_103 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 1343;

                goto frame_exception_exit_29;
            }

            tmp_called_instance_37 = tmp_mvar_value_103;
            frame_f1fb71489cc684b7ee4d1e2902a82ad3_29->m_frame.f_lineno = 1343;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_37, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__reason_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1343;

                goto frame_exception_exit_29;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1319, const_str_plain_reason, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1343;

                goto frame_exception_exit_29;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_f1fb71489cc684b7ee4d1e2902a82ad3_29);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_28;

        frame_exception_exit_29:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_f1fb71489cc684b7ee4d1e2902a82ad3_29);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_f1fb71489cc684b7ee4d1e2902a82ad3_29, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_f1fb71489cc684b7ee4d1e2902a82ad3_29->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_f1fb71489cc684b7ee4d1e2902a82ad3_29, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_f1fb71489cc684b7ee4d1e2902a82ad3_29,
            type_description_2
        );


        // Release cached frame.
        if (frame_f1fb71489cc684b7ee4d1e2902a82ad3_29 == cache_frame_f1fb71489cc684b7ee4d1e2902a82ad3_29) {
            Py_DECREF(frame_f1fb71489cc684b7ee4d1e2902a82ad3_29);
        }
        cache_frame_f1fb71489cc684b7ee4d1e2902a82ad3_29 = NULL;

        assertFrameObject(frame_f1fb71489cc684b7ee4d1e2902a82ad3_29);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_28;

        frame_no_exception_28:;
        goto skip_nested_handling_28;
        nested_frame_exit_28:;

        goto try_except_handler_77;
        skip_nested_handling_28:;
        tmp_assign_source_209 = locals_cryptography$x509$extensions_1319;
        Py_INCREF(tmp_assign_source_209);
        goto try_return_handler_77;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Return handler code:
        try_return_handler_77:;
        Py_DECREF(locals_cryptography$x509$extensions_1319);
        locals_cryptography$x509$extensions_1319 = NULL;
        goto outline_result_37;
        // Exception handler code:
        try_except_handler_77:;
        exception_keeper_type_67 = exception_type;
        exception_keeper_value_67 = exception_value;
        exception_keeper_tb_67 = exception_tb;
        exception_keeper_lineno_67 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_cryptography$x509$extensions_1319);
        locals_cryptography$x509$extensions_1319 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_67;
        exception_value = exception_keeper_value_67;
        exception_tb = exception_keeper_tb_67;
        exception_lineno = exception_keeper_lineno_67;

        goto outline_exception_28;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        outline_exception_28:;
        exception_lineno = 1319;
        goto try_except_handler_76;
        outline_result_37:;
        assert(tmp_class_creation_34__class_dict == NULL);
        tmp_class_creation_34__class_dict = tmp_assign_source_209;
    }
    {
        PyObject *tmp_assign_source_210;
        nuitka_bool tmp_condition_result_34;
        PyObject *tmp_key_name_67;
        PyObject *tmp_dict_name_67;
        PyObject *tmp_dict_name_68;
        PyObject *tmp_key_name_68;
        tmp_key_name_67 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_34__class_dict);
        tmp_dict_name_67 = tmp_class_creation_34__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_67, tmp_key_name_67);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1319;

            goto try_except_handler_76;
        }
        tmp_condition_result_34 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_34 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_34;
        } else {
            goto condexpr_false_34;
        }
        condexpr_true_34:;
        CHECK_OBJECT(tmp_class_creation_34__class_dict);
        tmp_dict_name_68 = tmp_class_creation_34__class_dict;
        tmp_key_name_68 = const_str_plain___metaclass__;
        tmp_assign_source_210 = DICT_GET_ITEM(tmp_dict_name_68, tmp_key_name_68);
        if (tmp_assign_source_210 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1319;

            goto try_except_handler_76;
        }
        goto condexpr_end_34;
        condexpr_false_34:;
        tmp_assign_source_210 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_210);
        condexpr_end_34:;
        assert(tmp_class_creation_34__metaclass == NULL);
        tmp_class_creation_34__metaclass = tmp_assign_source_210;
    }
    {
        PyObject *tmp_assign_source_211;
        PyObject *tmp_called_name_78;
        PyObject *tmp_args_element_name_145;
        PyObject *tmp_args_element_name_146;
        PyObject *tmp_args_element_name_147;
        CHECK_OBJECT(tmp_class_creation_34__metaclass);
        tmp_called_name_78 = tmp_class_creation_34__metaclass;
        tmp_args_element_name_145 = const_str_plain_CRLReason;
        tmp_args_element_name_146 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_34__class_dict);
        tmp_args_element_name_147 = tmp_class_creation_34__class_dict;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 1319;
        {
            PyObject *call_args[] = {tmp_args_element_name_145, tmp_args_element_name_146, tmp_args_element_name_147};
            tmp_assign_source_211 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_78, call_args);
        }

        if (tmp_assign_source_211 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1319;

            goto try_except_handler_76;
        }
        assert(tmp_class_creation_34__class == NULL);
        tmp_class_creation_34__class = tmp_assign_source_211;
    }
    {
        PyObject *tmp_assign_source_212;
        PyObject *tmp_called_name_79;
        PyObject *tmp_called_name_80;
        PyObject *tmp_source_name_46;
        PyObject *tmp_mvar_value_104;
        PyObject *tmp_args_element_name_148;
        PyObject *tmp_mvar_value_105;
        PyObject *tmp_args_element_name_149;
        tmp_mvar_value_104 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

        if (unlikely(tmp_mvar_value_104 == NULL)) {
            tmp_mvar_value_104 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
        }

        if (tmp_mvar_value_104 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
            exception_tb = NULL;

            exception_lineno = 1318;

            goto try_except_handler_76;
        }

        tmp_source_name_46 = tmp_mvar_value_104;
        tmp_called_name_80 = LOOKUP_ATTRIBUTE(tmp_source_name_46, const_str_plain_register_interface);
        if (tmp_called_name_80 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1318;

            goto try_except_handler_76;
        }
        tmp_mvar_value_105 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType);

        if (unlikely(tmp_mvar_value_105 == NULL)) {
            tmp_mvar_value_105 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType);
        }

        if (tmp_mvar_value_105 == NULL) {
            Py_DECREF(tmp_called_name_80);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 35484 ], 35, 0);
            exception_tb = NULL;

            exception_lineno = 1318;

            goto try_except_handler_76;
        }

        tmp_args_element_name_148 = tmp_mvar_value_105;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 1318;
        tmp_called_name_79 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_80, tmp_args_element_name_148);
        Py_DECREF(tmp_called_name_80);
        if (tmp_called_name_79 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1318;

            goto try_except_handler_76;
        }
        CHECK_OBJECT(tmp_class_creation_34__class);
        tmp_args_element_name_149 = tmp_class_creation_34__class;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 1318;
        tmp_assign_source_212 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_79, tmp_args_element_name_149);
        Py_DECREF(tmp_called_name_79);
        if (tmp_assign_source_212 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1318;

            goto try_except_handler_76;
        }
        {
            PyObject *old = tmp_class_creation_34__class;
            assert(old != NULL);
            tmp_class_creation_34__class = tmp_assign_source_212;
            Py_DECREF(old);
        }

    }
    goto try_end_38;
    // Exception handler code:
    try_except_handler_76:;
    exception_keeper_type_68 = exception_type;
    exception_keeper_value_68 = exception_value;
    exception_keeper_tb_68 = exception_tb;
    exception_keeper_lineno_68 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_34__class);
    tmp_class_creation_34__class = NULL;

    Py_XDECREF(tmp_class_creation_34__class_dict);
    tmp_class_creation_34__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_34__metaclass);
    tmp_class_creation_34__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_68;
    exception_value = exception_keeper_value_68;
    exception_tb = exception_keeper_tb_68;
    exception_lineno = exception_keeper_lineno_68;

    goto frame_exception_exit_1;
    // End of try:
    try_end_38:;
    {
        PyObject *tmp_assign_source_213;
        CHECK_OBJECT(tmp_class_creation_34__class);
        tmp_assign_source_213 = tmp_class_creation_34__class;
        UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_CRLReason, tmp_assign_source_213);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_34__class);
    Py_DECREF(tmp_class_creation_34__class);
    tmp_class_creation_34__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_34__class_dict);
    Py_DECREF(tmp_class_creation_34__class_dict);
    tmp_class_creation_34__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_34__metaclass);
    Py_DECREF(tmp_class_creation_34__metaclass);
    tmp_class_creation_34__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_214;
        {
            PyObject *tmp_set_locals_31;
            tmp_set_locals_31 = PyDict_New();
            locals_cryptography$x509$extensions_1347 = tmp_set_locals_31;
        }
        tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1347, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_c1c2bb0918ddbcf5f075491c88a41e6d_30, codeobj_c1c2bb0918ddbcf5f075491c88a41e6d, module_cryptography$x509$extensions, 0);
        frame_c1c2bb0918ddbcf5f075491c88a41e6d_30 = cache_frame_c1c2bb0918ddbcf5f075491c88a41e6d_30;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_c1c2bb0918ddbcf5f075491c88a41e6d_30);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_c1c2bb0918ddbcf5f075491c88a41e6d_30) == 2); // Frame stack

        // Framed code:
        {
            PyObject *tmp_source_name_47;
            PyObject *tmp_mvar_value_106;
            tmp_mvar_value_106 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_CRLEntryExtensionOID);

            if (unlikely(tmp_mvar_value_106 == NULL)) {
                tmp_mvar_value_106 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_CRLEntryExtensionOID);
            }

            if (tmp_mvar_value_106 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 25048 ], 42, 0);
                exception_tb = NULL;

                exception_lineno = 1348;

                goto frame_exception_exit_30;
            }

            tmp_source_name_47 = tmp_mvar_value_106;
            tmp_dictset_value = LOOKUP_ATTRIBUTE(tmp_source_name_47, const_str_plain_INVALIDITY_DATE);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1348;

                goto frame_exception_exit_30;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1347, const_str_plain_oid, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1348;

                goto frame_exception_exit_30;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_181___init__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1347, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_182___repr__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1347, const_str_plain___repr__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_183___eq__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1347, const_str_plain___eq__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_184___ne__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1347, const_str_plain___ne__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_185___hash__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1347, const_str_plain___hash__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        {
            PyObject *tmp_called_instance_38;
            PyObject *tmp_mvar_value_107;
            tmp_mvar_value_107 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_107 == NULL)) {
                tmp_mvar_value_107 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_107 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 1373;

                goto frame_exception_exit_30;
            }

            tmp_called_instance_38 = tmp_mvar_value_107;
            frame_c1c2bb0918ddbcf5f075491c88a41e6d_30->m_frame.f_lineno = 1373;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_38, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__invalidity_date_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1373;

                goto frame_exception_exit_30;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1347, const_str_plain_invalidity_date, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1373;

                goto frame_exception_exit_30;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_c1c2bb0918ddbcf5f075491c88a41e6d_30);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_29;

        frame_exception_exit_30:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_c1c2bb0918ddbcf5f075491c88a41e6d_30);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_c1c2bb0918ddbcf5f075491c88a41e6d_30, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_c1c2bb0918ddbcf5f075491c88a41e6d_30->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_c1c2bb0918ddbcf5f075491c88a41e6d_30, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_c1c2bb0918ddbcf5f075491c88a41e6d_30,
            type_description_2
        );


        // Release cached frame.
        if (frame_c1c2bb0918ddbcf5f075491c88a41e6d_30 == cache_frame_c1c2bb0918ddbcf5f075491c88a41e6d_30) {
            Py_DECREF(frame_c1c2bb0918ddbcf5f075491c88a41e6d_30);
        }
        cache_frame_c1c2bb0918ddbcf5f075491c88a41e6d_30 = NULL;

        assertFrameObject(frame_c1c2bb0918ddbcf5f075491c88a41e6d_30);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_29;

        frame_no_exception_29:;
        goto skip_nested_handling_29;
        nested_frame_exit_29:;

        goto try_except_handler_79;
        skip_nested_handling_29:;
        tmp_assign_source_214 = locals_cryptography$x509$extensions_1347;
        Py_INCREF(tmp_assign_source_214);
        goto try_return_handler_79;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Return handler code:
        try_return_handler_79:;
        Py_DECREF(locals_cryptography$x509$extensions_1347);
        locals_cryptography$x509$extensions_1347 = NULL;
        goto outline_result_38;
        // Exception handler code:
        try_except_handler_79:;
        exception_keeper_type_69 = exception_type;
        exception_keeper_value_69 = exception_value;
        exception_keeper_tb_69 = exception_tb;
        exception_keeper_lineno_69 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_cryptography$x509$extensions_1347);
        locals_cryptography$x509$extensions_1347 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_69;
        exception_value = exception_keeper_value_69;
        exception_tb = exception_keeper_tb_69;
        exception_lineno = exception_keeper_lineno_69;

        goto outline_exception_29;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        outline_exception_29:;
        exception_lineno = 1347;
        goto try_except_handler_78;
        outline_result_38:;
        assert(tmp_class_creation_35__class_dict == NULL);
        tmp_class_creation_35__class_dict = tmp_assign_source_214;
    }
    {
        PyObject *tmp_assign_source_215;
        nuitka_bool tmp_condition_result_35;
        PyObject *tmp_key_name_69;
        PyObject *tmp_dict_name_69;
        PyObject *tmp_dict_name_70;
        PyObject *tmp_key_name_70;
        tmp_key_name_69 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_35__class_dict);
        tmp_dict_name_69 = tmp_class_creation_35__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_69, tmp_key_name_69);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1347;

            goto try_except_handler_78;
        }
        tmp_condition_result_35 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_35 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_35;
        } else {
            goto condexpr_false_35;
        }
        condexpr_true_35:;
        CHECK_OBJECT(tmp_class_creation_35__class_dict);
        tmp_dict_name_70 = tmp_class_creation_35__class_dict;
        tmp_key_name_70 = const_str_plain___metaclass__;
        tmp_assign_source_215 = DICT_GET_ITEM(tmp_dict_name_70, tmp_key_name_70);
        if (tmp_assign_source_215 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1347;

            goto try_except_handler_78;
        }
        goto condexpr_end_35;
        condexpr_false_35:;
        tmp_assign_source_215 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_215);
        condexpr_end_35:;
        assert(tmp_class_creation_35__metaclass == NULL);
        tmp_class_creation_35__metaclass = tmp_assign_source_215;
    }
    {
        PyObject *tmp_assign_source_216;
        PyObject *tmp_called_name_81;
        PyObject *tmp_args_element_name_150;
        PyObject *tmp_args_element_name_151;
        PyObject *tmp_args_element_name_152;
        CHECK_OBJECT(tmp_class_creation_35__metaclass);
        tmp_called_name_81 = tmp_class_creation_35__metaclass;
        tmp_args_element_name_150 = const_str_plain_InvalidityDate;
        tmp_args_element_name_151 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_35__class_dict);
        tmp_args_element_name_152 = tmp_class_creation_35__class_dict;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 1347;
        {
            PyObject *call_args[] = {tmp_args_element_name_150, tmp_args_element_name_151, tmp_args_element_name_152};
            tmp_assign_source_216 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_81, call_args);
        }

        if (tmp_assign_source_216 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1347;

            goto try_except_handler_78;
        }
        assert(tmp_class_creation_35__class == NULL);
        tmp_class_creation_35__class = tmp_assign_source_216;
    }
    {
        PyObject *tmp_assign_source_217;
        PyObject *tmp_called_name_82;
        PyObject *tmp_called_name_83;
        PyObject *tmp_source_name_48;
        PyObject *tmp_mvar_value_108;
        PyObject *tmp_args_element_name_153;
        PyObject *tmp_mvar_value_109;
        PyObject *tmp_args_element_name_154;
        tmp_mvar_value_108 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

        if (unlikely(tmp_mvar_value_108 == NULL)) {
            tmp_mvar_value_108 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
        }

        if (tmp_mvar_value_108 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
            exception_tb = NULL;

            exception_lineno = 1346;

            goto try_except_handler_78;
        }

        tmp_source_name_48 = tmp_mvar_value_108;
        tmp_called_name_83 = LOOKUP_ATTRIBUTE(tmp_source_name_48, const_str_plain_register_interface);
        if (tmp_called_name_83 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1346;

            goto try_except_handler_78;
        }
        tmp_mvar_value_109 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType);

        if (unlikely(tmp_mvar_value_109 == NULL)) {
            tmp_mvar_value_109 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType);
        }

        if (tmp_mvar_value_109 == NULL) {
            Py_DECREF(tmp_called_name_83);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 35484 ], 35, 0);
            exception_tb = NULL;

            exception_lineno = 1346;

            goto try_except_handler_78;
        }

        tmp_args_element_name_153 = tmp_mvar_value_109;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 1346;
        tmp_called_name_82 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_83, tmp_args_element_name_153);
        Py_DECREF(tmp_called_name_83);
        if (tmp_called_name_82 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1346;

            goto try_except_handler_78;
        }
        CHECK_OBJECT(tmp_class_creation_35__class);
        tmp_args_element_name_154 = tmp_class_creation_35__class;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 1346;
        tmp_assign_source_217 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_82, tmp_args_element_name_154);
        Py_DECREF(tmp_called_name_82);
        if (tmp_assign_source_217 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1346;

            goto try_except_handler_78;
        }
        {
            PyObject *old = tmp_class_creation_35__class;
            assert(old != NULL);
            tmp_class_creation_35__class = tmp_assign_source_217;
            Py_DECREF(old);
        }

    }
    goto try_end_39;
    // Exception handler code:
    try_except_handler_78:;
    exception_keeper_type_70 = exception_type;
    exception_keeper_value_70 = exception_value;
    exception_keeper_tb_70 = exception_tb;
    exception_keeper_lineno_70 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_35__class);
    tmp_class_creation_35__class = NULL;

    Py_XDECREF(tmp_class_creation_35__class_dict);
    tmp_class_creation_35__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_35__metaclass);
    tmp_class_creation_35__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_70;
    exception_value = exception_keeper_value_70;
    exception_tb = exception_keeper_tb_70;
    exception_lineno = exception_keeper_lineno_70;

    goto frame_exception_exit_1;
    // End of try:
    try_end_39:;
    {
        PyObject *tmp_assign_source_218;
        CHECK_OBJECT(tmp_class_creation_35__class);
        tmp_assign_source_218 = tmp_class_creation_35__class;
        UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_InvalidityDate, tmp_assign_source_218);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_35__class);
    Py_DECREF(tmp_class_creation_35__class);
    tmp_class_creation_35__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_35__class_dict);
    Py_DECREF(tmp_class_creation_35__class_dict);
    tmp_class_creation_35__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_35__metaclass);
    Py_DECREF(tmp_class_creation_35__metaclass);
    tmp_class_creation_35__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_219;
        {
            PyObject *tmp_set_locals_32;
            tmp_set_locals_32 = PyDict_New();
            locals_cryptography$x509$extensions_1377 = tmp_set_locals_32;
        }
        tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1377, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_34d3d5aa27da9c5dfcf667f6ff343fae_31, codeobj_34d3d5aa27da9c5dfcf667f6ff343fae, module_cryptography$x509$extensions, 0);
        frame_34d3d5aa27da9c5dfcf667f6ff343fae_31 = cache_frame_34d3d5aa27da9c5dfcf667f6ff343fae_31;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_34d3d5aa27da9c5dfcf667f6ff343fae_31);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_34d3d5aa27da9c5dfcf667f6ff343fae_31) == 2); // Frame stack

        // Framed code:
        {
            PyObject *tmp_source_name_49;
            PyObject *tmp_mvar_value_110;
            tmp_mvar_value_110 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID);

            if (unlikely(tmp_mvar_value_110 == NULL)) {
                tmp_mvar_value_110 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionOID);
            }

            if (tmp_mvar_value_110 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 23410 ], 34, 0);
                exception_tb = NULL;

                exception_lineno = 1378;

                goto frame_exception_exit_31;
            }

            tmp_source_name_49 = tmp_mvar_value_110;
            tmp_dictset_value = LOOKUP_ATTRIBUTE(tmp_source_name_49, const_str_plain_PRECERT_SIGNED_CERTIFICATE_TIMESTAMPS);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1378;

                goto frame_exception_exit_31;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1377, const_str_plain_oid, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1378;

                goto frame_exception_exit_31;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_34d3d5aa27da9c5dfcf667f6ff343fae_31);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_30;

        frame_exception_exit_31:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_34d3d5aa27da9c5dfcf667f6ff343fae_31);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_34d3d5aa27da9c5dfcf667f6ff343fae_31, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_34d3d5aa27da9c5dfcf667f6ff343fae_31->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_34d3d5aa27da9c5dfcf667f6ff343fae_31, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_34d3d5aa27da9c5dfcf667f6ff343fae_31,
            type_description_2
        );


        // Release cached frame.
        if (frame_34d3d5aa27da9c5dfcf667f6ff343fae_31 == cache_frame_34d3d5aa27da9c5dfcf667f6ff343fae_31) {
            Py_DECREF(frame_34d3d5aa27da9c5dfcf667f6ff343fae_31);
        }
        cache_frame_34d3d5aa27da9c5dfcf667f6ff343fae_31 = NULL;

        assertFrameObject(frame_34d3d5aa27da9c5dfcf667f6ff343fae_31);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_30;

        frame_no_exception_30:;
        goto skip_nested_handling_30;
        nested_frame_exit_30:;

        goto try_except_handler_81;
        skip_nested_handling_30:;
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_186___init__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1377, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_187___iter__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1377, const_str_plain___iter__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_188___len__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1377, const_str_plain___len__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_189___getitem__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1377, const_str_plain___getitem__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_190___repr__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1377, const_str_plain___repr__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_191___hash__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1377, const_str_plain___hash__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_192___eq__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1377, const_str_plain___eq__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_193___ne__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1377, const_str_plain___ne__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_assign_source_219 = locals_cryptography$x509$extensions_1377;
        Py_INCREF(tmp_assign_source_219);
        goto try_return_handler_81;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Return handler code:
        try_return_handler_81:;
        Py_DECREF(locals_cryptography$x509$extensions_1377);
        locals_cryptography$x509$extensions_1377 = NULL;
        goto outline_result_39;
        // Exception handler code:
        try_except_handler_81:;
        exception_keeper_type_71 = exception_type;
        exception_keeper_value_71 = exception_value;
        exception_keeper_tb_71 = exception_tb;
        exception_keeper_lineno_71 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_cryptography$x509$extensions_1377);
        locals_cryptography$x509$extensions_1377 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_71;
        exception_value = exception_keeper_value_71;
        exception_tb = exception_keeper_tb_71;
        exception_lineno = exception_keeper_lineno_71;

        goto outline_exception_30;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        outline_exception_30:;
        exception_lineno = 1377;
        goto try_except_handler_80;
        outline_result_39:;
        assert(tmp_class_creation_36__class_dict == NULL);
        tmp_class_creation_36__class_dict = tmp_assign_source_219;
    }
    {
        PyObject *tmp_assign_source_220;
        nuitka_bool tmp_condition_result_36;
        PyObject *tmp_key_name_71;
        PyObject *tmp_dict_name_71;
        PyObject *tmp_dict_name_72;
        PyObject *tmp_key_name_72;
        tmp_key_name_71 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_36__class_dict);
        tmp_dict_name_71 = tmp_class_creation_36__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_71, tmp_key_name_71);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1377;

            goto try_except_handler_80;
        }
        tmp_condition_result_36 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_36 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_36;
        } else {
            goto condexpr_false_36;
        }
        condexpr_true_36:;
        CHECK_OBJECT(tmp_class_creation_36__class_dict);
        tmp_dict_name_72 = tmp_class_creation_36__class_dict;
        tmp_key_name_72 = const_str_plain___metaclass__;
        tmp_assign_source_220 = DICT_GET_ITEM(tmp_dict_name_72, tmp_key_name_72);
        if (tmp_assign_source_220 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1377;

            goto try_except_handler_80;
        }
        goto condexpr_end_36;
        condexpr_false_36:;
        tmp_assign_source_220 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_220);
        condexpr_end_36:;
        assert(tmp_class_creation_36__metaclass == NULL);
        tmp_class_creation_36__metaclass = tmp_assign_source_220;
    }
    {
        PyObject *tmp_assign_source_221;
        PyObject *tmp_called_name_84;
        PyObject *tmp_args_element_name_155;
        PyObject *tmp_args_element_name_156;
        PyObject *tmp_args_element_name_157;
        CHECK_OBJECT(tmp_class_creation_36__metaclass);
        tmp_called_name_84 = tmp_class_creation_36__metaclass;
        tmp_args_element_name_155 = const_str_digest_97ac982b098bfd0facb64df38773c335;
        tmp_args_element_name_156 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_36__class_dict);
        tmp_args_element_name_157 = tmp_class_creation_36__class_dict;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 1377;
        {
            PyObject *call_args[] = {tmp_args_element_name_155, tmp_args_element_name_156, tmp_args_element_name_157};
            tmp_assign_source_221 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_84, call_args);
        }

        if (tmp_assign_source_221 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1377;

            goto try_except_handler_80;
        }
        assert(tmp_class_creation_36__class == NULL);
        tmp_class_creation_36__class = tmp_assign_source_221;
    }
    {
        PyObject *tmp_assign_source_222;
        PyObject *tmp_called_name_85;
        PyObject *tmp_called_name_86;
        PyObject *tmp_source_name_50;
        PyObject *tmp_mvar_value_111;
        PyObject *tmp_args_element_name_158;
        PyObject *tmp_mvar_value_112;
        PyObject *tmp_args_element_name_159;
        tmp_mvar_value_111 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

        if (unlikely(tmp_mvar_value_111 == NULL)) {
            tmp_mvar_value_111 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
        }

        if (tmp_mvar_value_111 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
            exception_tb = NULL;

            exception_lineno = 1376;

            goto try_except_handler_80;
        }

        tmp_source_name_50 = tmp_mvar_value_111;
        tmp_called_name_86 = LOOKUP_ATTRIBUTE(tmp_source_name_50, const_str_plain_register_interface);
        if (tmp_called_name_86 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1376;

            goto try_except_handler_80;
        }
        tmp_mvar_value_112 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType);

        if (unlikely(tmp_mvar_value_112 == NULL)) {
            tmp_mvar_value_112 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType);
        }

        if (tmp_mvar_value_112 == NULL) {
            Py_DECREF(tmp_called_name_86);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 35484 ], 35, 0);
            exception_tb = NULL;

            exception_lineno = 1376;

            goto try_except_handler_80;
        }

        tmp_args_element_name_158 = tmp_mvar_value_112;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 1376;
        tmp_called_name_85 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_86, tmp_args_element_name_158);
        Py_DECREF(tmp_called_name_86);
        if (tmp_called_name_85 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1376;

            goto try_except_handler_80;
        }
        CHECK_OBJECT(tmp_class_creation_36__class);
        tmp_args_element_name_159 = tmp_class_creation_36__class;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 1376;
        tmp_assign_source_222 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_85, tmp_args_element_name_159);
        Py_DECREF(tmp_called_name_85);
        if (tmp_assign_source_222 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1376;

            goto try_except_handler_80;
        }
        {
            PyObject *old = tmp_class_creation_36__class;
            assert(old != NULL);
            tmp_class_creation_36__class = tmp_assign_source_222;
            Py_DECREF(old);
        }

    }
    goto try_end_40;
    // Exception handler code:
    try_except_handler_80:;
    exception_keeper_type_72 = exception_type;
    exception_keeper_value_72 = exception_value;
    exception_keeper_tb_72 = exception_tb;
    exception_keeper_lineno_72 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_36__class);
    tmp_class_creation_36__class = NULL;

    Py_XDECREF(tmp_class_creation_36__class_dict);
    tmp_class_creation_36__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_36__metaclass);
    tmp_class_creation_36__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_72;
    exception_value = exception_keeper_value_72;
    exception_tb = exception_keeper_tb_72;
    exception_lineno = exception_keeper_lineno_72;

    goto frame_exception_exit_1;
    // End of try:
    try_end_40:;
    {
        PyObject *tmp_assign_source_223;
        CHECK_OBJECT(tmp_class_creation_36__class);
        tmp_assign_source_223 = tmp_class_creation_36__class;
        UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_digest_97ac982b098bfd0facb64df38773c335, tmp_assign_source_223);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_36__class);
    Py_DECREF(tmp_class_creation_36__class);
    tmp_class_creation_36__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_36__class_dict);
    Py_DECREF(tmp_class_creation_36__class_dict);
    tmp_class_creation_36__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_36__metaclass);
    Py_DECREF(tmp_class_creation_36__metaclass);
    tmp_class_creation_36__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_224;
        {
            PyObject *tmp_set_locals_33;
            tmp_set_locals_33 = PyDict_New();
            locals_cryptography$x509$extensions_1425 = tmp_set_locals_33;
        }
        tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1425, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_e1283683c51f59cb9a7eb7fe98cf8efa_32, codeobj_e1283683c51f59cb9a7eb7fe98cf8efa, module_cryptography$x509$extensions, 0);
        frame_e1283683c51f59cb9a7eb7fe98cf8efa_32 = cache_frame_e1283683c51f59cb9a7eb7fe98cf8efa_32;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_e1283683c51f59cb9a7eb7fe98cf8efa_32);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_e1283683c51f59cb9a7eb7fe98cf8efa_32) == 2); // Frame stack

        // Framed code:
        {
            PyObject *tmp_source_name_51;
            PyObject *tmp_mvar_value_113;
            tmp_mvar_value_113 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_OCSPExtensionOID);

            if (unlikely(tmp_mvar_value_113 == NULL)) {
                tmp_mvar_value_113 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_OCSPExtensionOID);
            }

            if (tmp_mvar_value_113 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 25348 ], 38, 0);
                exception_tb = NULL;

                exception_lineno = 1426;

                goto frame_exception_exit_32;
            }

            tmp_source_name_51 = tmp_mvar_value_113;
            tmp_dictset_value = LOOKUP_ATTRIBUTE(tmp_source_name_51, const_str_plain_NONCE);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1426;

                goto frame_exception_exit_32;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1425, const_str_plain_oid, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1426;

                goto frame_exception_exit_32;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_194___init__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1425, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_195___eq__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1425, const_str_plain___eq__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_196___ne__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1425, const_str_plain___ne__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_197___hash__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1425, const_str_plain___hash__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_198___repr__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1425, const_str_plain___repr__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        {
            PyObject *tmp_called_instance_39;
            PyObject *tmp_mvar_value_114;
            tmp_mvar_value_114 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_114 == NULL)) {
                tmp_mvar_value_114 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_114 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 1449;

                goto frame_exception_exit_32;
            }

            tmp_called_instance_39 = tmp_mvar_value_114;
            frame_e1283683c51f59cb9a7eb7fe98cf8efa_32->m_frame.f_lineno = 1449;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_39, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__nonce_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1449;

                goto frame_exception_exit_32;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1425, const_str_plain_nonce, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1449;

                goto frame_exception_exit_32;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_e1283683c51f59cb9a7eb7fe98cf8efa_32);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_31;

        frame_exception_exit_32:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_e1283683c51f59cb9a7eb7fe98cf8efa_32);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_e1283683c51f59cb9a7eb7fe98cf8efa_32, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_e1283683c51f59cb9a7eb7fe98cf8efa_32->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_e1283683c51f59cb9a7eb7fe98cf8efa_32, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_e1283683c51f59cb9a7eb7fe98cf8efa_32,
            type_description_2
        );


        // Release cached frame.
        if (frame_e1283683c51f59cb9a7eb7fe98cf8efa_32 == cache_frame_e1283683c51f59cb9a7eb7fe98cf8efa_32) {
            Py_DECREF(frame_e1283683c51f59cb9a7eb7fe98cf8efa_32);
        }
        cache_frame_e1283683c51f59cb9a7eb7fe98cf8efa_32 = NULL;

        assertFrameObject(frame_e1283683c51f59cb9a7eb7fe98cf8efa_32);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_31;

        frame_no_exception_31:;
        goto skip_nested_handling_31;
        nested_frame_exit_31:;

        goto try_except_handler_83;
        skip_nested_handling_31:;
        tmp_assign_source_224 = locals_cryptography$x509$extensions_1425;
        Py_INCREF(tmp_assign_source_224);
        goto try_return_handler_83;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Return handler code:
        try_return_handler_83:;
        Py_DECREF(locals_cryptography$x509$extensions_1425);
        locals_cryptography$x509$extensions_1425 = NULL;
        goto outline_result_40;
        // Exception handler code:
        try_except_handler_83:;
        exception_keeper_type_73 = exception_type;
        exception_keeper_value_73 = exception_value;
        exception_keeper_tb_73 = exception_tb;
        exception_keeper_lineno_73 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_cryptography$x509$extensions_1425);
        locals_cryptography$x509$extensions_1425 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_73;
        exception_value = exception_keeper_value_73;
        exception_tb = exception_keeper_tb_73;
        exception_lineno = exception_keeper_lineno_73;

        goto outline_exception_31;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        outline_exception_31:;
        exception_lineno = 1425;
        goto try_except_handler_82;
        outline_result_40:;
        assert(tmp_class_creation_37__class_dict == NULL);
        tmp_class_creation_37__class_dict = tmp_assign_source_224;
    }
    {
        PyObject *tmp_assign_source_225;
        nuitka_bool tmp_condition_result_37;
        PyObject *tmp_key_name_73;
        PyObject *tmp_dict_name_73;
        PyObject *tmp_dict_name_74;
        PyObject *tmp_key_name_74;
        tmp_key_name_73 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_37__class_dict);
        tmp_dict_name_73 = tmp_class_creation_37__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_73, tmp_key_name_73);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1425;

            goto try_except_handler_82;
        }
        tmp_condition_result_37 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_37 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_37;
        } else {
            goto condexpr_false_37;
        }
        condexpr_true_37:;
        CHECK_OBJECT(tmp_class_creation_37__class_dict);
        tmp_dict_name_74 = tmp_class_creation_37__class_dict;
        tmp_key_name_74 = const_str_plain___metaclass__;
        tmp_assign_source_225 = DICT_GET_ITEM(tmp_dict_name_74, tmp_key_name_74);
        if (tmp_assign_source_225 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1425;

            goto try_except_handler_82;
        }
        goto condexpr_end_37;
        condexpr_false_37:;
        tmp_assign_source_225 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_225);
        condexpr_end_37:;
        assert(tmp_class_creation_37__metaclass == NULL);
        tmp_class_creation_37__metaclass = tmp_assign_source_225;
    }
    {
        PyObject *tmp_assign_source_226;
        PyObject *tmp_called_name_87;
        PyObject *tmp_args_element_name_160;
        PyObject *tmp_args_element_name_161;
        PyObject *tmp_args_element_name_162;
        CHECK_OBJECT(tmp_class_creation_37__metaclass);
        tmp_called_name_87 = tmp_class_creation_37__metaclass;
        tmp_args_element_name_160 = const_str_plain_OCSPNonce;
        tmp_args_element_name_161 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_37__class_dict);
        tmp_args_element_name_162 = tmp_class_creation_37__class_dict;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 1425;
        {
            PyObject *call_args[] = {tmp_args_element_name_160, tmp_args_element_name_161, tmp_args_element_name_162};
            tmp_assign_source_226 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_87, call_args);
        }

        if (tmp_assign_source_226 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1425;

            goto try_except_handler_82;
        }
        assert(tmp_class_creation_37__class == NULL);
        tmp_class_creation_37__class = tmp_assign_source_226;
    }
    {
        PyObject *tmp_assign_source_227;
        PyObject *tmp_called_name_88;
        PyObject *tmp_called_name_89;
        PyObject *tmp_source_name_52;
        PyObject *tmp_mvar_value_115;
        PyObject *tmp_args_element_name_163;
        PyObject *tmp_mvar_value_116;
        PyObject *tmp_args_element_name_164;
        tmp_mvar_value_115 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

        if (unlikely(tmp_mvar_value_115 == NULL)) {
            tmp_mvar_value_115 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
        }

        if (tmp_mvar_value_115 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
            exception_tb = NULL;

            exception_lineno = 1424;

            goto try_except_handler_82;
        }

        tmp_source_name_52 = tmp_mvar_value_115;
        tmp_called_name_89 = LOOKUP_ATTRIBUTE(tmp_source_name_52, const_str_plain_register_interface);
        if (tmp_called_name_89 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1424;

            goto try_except_handler_82;
        }
        tmp_mvar_value_116 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType);

        if (unlikely(tmp_mvar_value_116 == NULL)) {
            tmp_mvar_value_116 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType);
        }

        if (tmp_mvar_value_116 == NULL) {
            Py_DECREF(tmp_called_name_89);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 35484 ], 35, 0);
            exception_tb = NULL;

            exception_lineno = 1424;

            goto try_except_handler_82;
        }

        tmp_args_element_name_163 = tmp_mvar_value_116;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 1424;
        tmp_called_name_88 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_89, tmp_args_element_name_163);
        Py_DECREF(tmp_called_name_89);
        if (tmp_called_name_88 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1424;

            goto try_except_handler_82;
        }
        CHECK_OBJECT(tmp_class_creation_37__class);
        tmp_args_element_name_164 = tmp_class_creation_37__class;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 1424;
        tmp_assign_source_227 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_88, tmp_args_element_name_164);
        Py_DECREF(tmp_called_name_88);
        if (tmp_assign_source_227 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1424;

            goto try_except_handler_82;
        }
        {
            PyObject *old = tmp_class_creation_37__class;
            assert(old != NULL);
            tmp_class_creation_37__class = tmp_assign_source_227;
            Py_DECREF(old);
        }

    }
    goto try_end_41;
    // Exception handler code:
    try_except_handler_82:;
    exception_keeper_type_74 = exception_type;
    exception_keeper_value_74 = exception_value;
    exception_keeper_tb_74 = exception_tb;
    exception_keeper_lineno_74 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_37__class);
    tmp_class_creation_37__class = NULL;

    Py_XDECREF(tmp_class_creation_37__class_dict);
    tmp_class_creation_37__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_37__metaclass);
    tmp_class_creation_37__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_74;
    exception_value = exception_keeper_value_74;
    exception_tb = exception_keeper_tb_74;
    exception_lineno = exception_keeper_lineno_74;

    goto frame_exception_exit_1;
    // End of try:
    try_end_41:;
    {
        PyObject *tmp_assign_source_228;
        CHECK_OBJECT(tmp_class_creation_37__class);
        tmp_assign_source_228 = tmp_class_creation_37__class;
        UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_OCSPNonce, tmp_assign_source_228);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_37__class);
    Py_DECREF(tmp_class_creation_37__class);
    tmp_class_creation_37__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_37__class_dict);
    Py_DECREF(tmp_class_creation_37__class_dict);
    tmp_class_creation_37__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_37__metaclass);
    Py_DECREF(tmp_class_creation_37__metaclass);
    tmp_class_creation_37__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_229;
        {
            PyObject *tmp_set_locals_34;
            tmp_set_locals_34 = PyDict_New();
            locals_cryptography$x509$extensions_1453 = tmp_set_locals_34;
        }
        tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1453, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_49473bcf3743b34fde0906127568439e_33, codeobj_49473bcf3743b34fde0906127568439e, module_cryptography$x509$extensions, 0);
        frame_49473bcf3743b34fde0906127568439e_33 = cache_frame_49473bcf3743b34fde0906127568439e_33;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_49473bcf3743b34fde0906127568439e_33);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_49473bcf3743b34fde0906127568439e_33) == 2); // Frame stack

        // Framed code:
        {
            PyObject *tmp_source_name_53;
            PyObject *tmp_mvar_value_117;
            tmp_mvar_value_117 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionOID);

            if (unlikely(tmp_mvar_value_117 == NULL)) {
                tmp_mvar_value_117 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionOID);
            }

            if (tmp_mvar_value_117 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 23410 ], 34, 0);
                exception_tb = NULL;

                exception_lineno = 1454;

                goto frame_exception_exit_33;
            }

            tmp_source_name_53 = tmp_mvar_value_117;
            tmp_dictset_value = LOOKUP_ATTRIBUTE(tmp_source_name_53, const_str_plain_ISSUING_DISTRIBUTION_POINT);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1454;

                goto frame_exception_exit_33;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1453, const_str_plain_oid, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1454;

                goto frame_exception_exit_33;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_199___init__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1453, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_200___repr__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1453, const_str_plain___repr__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_201___eq__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1453, const_str_plain___eq__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_202___ne__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1453, const_str_plain___ne__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_203___hash__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1453, const_str_plain___hash__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        {
            PyObject *tmp_called_instance_40;
            PyObject *tmp_mvar_value_118;
            tmp_mvar_value_118 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_118 == NULL)) {
                tmp_mvar_value_118 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_118 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 1567;

                goto frame_exception_exit_33;
            }

            tmp_called_instance_40 = tmp_mvar_value_118;
            frame_49473bcf3743b34fde0906127568439e_33->m_frame.f_lineno = 1567;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_40, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__full_name_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1567;

                goto frame_exception_exit_33;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1453, const_str_plain_full_name, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1567;

                goto frame_exception_exit_33;
            }
        }
        {
            PyObject *tmp_called_instance_41;
            PyObject *tmp_mvar_value_119;
            tmp_mvar_value_119 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_119 == NULL)) {
                tmp_mvar_value_119 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_119 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 1568;

                goto frame_exception_exit_33;
            }

            tmp_called_instance_41 = tmp_mvar_value_119;
            frame_49473bcf3743b34fde0906127568439e_33->m_frame.f_lineno = 1568;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_41, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__relative_name_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1568;

                goto frame_exception_exit_33;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1453, const_str_plain_relative_name, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1568;

                goto frame_exception_exit_33;
            }
        }
        {
            PyObject *tmp_called_instance_42;
            PyObject *tmp_mvar_value_120;
            tmp_mvar_value_120 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_120 == NULL)) {
                tmp_mvar_value_120 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_120 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 1569;

                goto frame_exception_exit_33;
            }

            tmp_called_instance_42 = tmp_mvar_value_120;
            frame_49473bcf3743b34fde0906127568439e_33->m_frame.f_lineno = 1569;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_42, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__only_contains_user_certs_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1569;

                goto frame_exception_exit_33;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1453, const_str_plain_only_contains_user_certs, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1569;

                goto frame_exception_exit_33;
            }
        }
        {
            PyObject *tmp_called_instance_43;
            PyObject *tmp_mvar_value_121;
            tmp_mvar_value_121 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_121 == NULL)) {
                tmp_mvar_value_121 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_121 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 1572;

                goto frame_exception_exit_33;
            }

            tmp_called_instance_43 = tmp_mvar_value_121;
            frame_49473bcf3743b34fde0906127568439e_33->m_frame.f_lineno = 1572;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_43, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__only_contains_ca_certs_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1572;

                goto frame_exception_exit_33;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1453, const_str_plain_only_contains_ca_certs, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1572;

                goto frame_exception_exit_33;
            }
        }
        {
            PyObject *tmp_called_instance_44;
            PyObject *tmp_mvar_value_122;
            tmp_mvar_value_122 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_122 == NULL)) {
                tmp_mvar_value_122 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_122 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 1575;

                goto frame_exception_exit_33;
            }

            tmp_called_instance_44 = tmp_mvar_value_122;
            frame_49473bcf3743b34fde0906127568439e_33->m_frame.f_lineno = 1575;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_44, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__only_some_reasons_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1575;

                goto frame_exception_exit_33;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1453, const_str_plain_only_some_reasons, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1575;

                goto frame_exception_exit_33;
            }
        }
        {
            PyObject *tmp_called_instance_45;
            PyObject *tmp_mvar_value_123;
            tmp_mvar_value_123 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_123 == NULL)) {
                tmp_mvar_value_123 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_123 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 1576;

                goto frame_exception_exit_33;
            }

            tmp_called_instance_45 = tmp_mvar_value_123;
            frame_49473bcf3743b34fde0906127568439e_33->m_frame.f_lineno = 1576;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_45, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__indirect_crl_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1576;

                goto frame_exception_exit_33;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1453, const_str_plain_indirect_crl, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1576;

                goto frame_exception_exit_33;
            }
        }
        {
            PyObject *tmp_called_instance_46;
            PyObject *tmp_mvar_value_124;
            tmp_mvar_value_124 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_124 == NULL)) {
                tmp_mvar_value_124 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_124 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 1577;

                goto frame_exception_exit_33;
            }

            tmp_called_instance_46 = tmp_mvar_value_124;
            frame_49473bcf3743b34fde0906127568439e_33->m_frame.f_lineno = 1577;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_46, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__only_contains_attribute_certs_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1577;

                goto frame_exception_exit_33;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1453, const_str_plain_only_contains_attribute_certs, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1577;

                goto frame_exception_exit_33;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_49473bcf3743b34fde0906127568439e_33);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_32;

        frame_exception_exit_33:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_49473bcf3743b34fde0906127568439e_33);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_49473bcf3743b34fde0906127568439e_33, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_49473bcf3743b34fde0906127568439e_33->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_49473bcf3743b34fde0906127568439e_33, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_49473bcf3743b34fde0906127568439e_33,
            type_description_2
        );


        // Release cached frame.
        if (frame_49473bcf3743b34fde0906127568439e_33 == cache_frame_49473bcf3743b34fde0906127568439e_33) {
            Py_DECREF(frame_49473bcf3743b34fde0906127568439e_33);
        }
        cache_frame_49473bcf3743b34fde0906127568439e_33 = NULL;

        assertFrameObject(frame_49473bcf3743b34fde0906127568439e_33);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_32;

        frame_no_exception_32:;
        goto skip_nested_handling_32;
        nested_frame_exit_32:;

        goto try_except_handler_85;
        skip_nested_handling_32:;
        tmp_assign_source_229 = locals_cryptography$x509$extensions_1453;
        Py_INCREF(tmp_assign_source_229);
        goto try_return_handler_85;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Return handler code:
        try_return_handler_85:;
        Py_DECREF(locals_cryptography$x509$extensions_1453);
        locals_cryptography$x509$extensions_1453 = NULL;
        goto outline_result_41;
        // Exception handler code:
        try_except_handler_85:;
        exception_keeper_type_75 = exception_type;
        exception_keeper_value_75 = exception_value;
        exception_keeper_tb_75 = exception_tb;
        exception_keeper_lineno_75 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_cryptography$x509$extensions_1453);
        locals_cryptography$x509$extensions_1453 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_75;
        exception_value = exception_keeper_value_75;
        exception_tb = exception_keeper_tb_75;
        exception_lineno = exception_keeper_lineno_75;

        goto outline_exception_32;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        outline_exception_32:;
        exception_lineno = 1453;
        goto try_except_handler_84;
        outline_result_41:;
        assert(tmp_class_creation_38__class_dict == NULL);
        tmp_class_creation_38__class_dict = tmp_assign_source_229;
    }
    {
        PyObject *tmp_assign_source_230;
        nuitka_bool tmp_condition_result_38;
        PyObject *tmp_key_name_75;
        PyObject *tmp_dict_name_75;
        PyObject *tmp_dict_name_76;
        PyObject *tmp_key_name_76;
        tmp_key_name_75 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_38__class_dict);
        tmp_dict_name_75 = tmp_class_creation_38__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_75, tmp_key_name_75);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1453;

            goto try_except_handler_84;
        }
        tmp_condition_result_38 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_38 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_38;
        } else {
            goto condexpr_false_38;
        }
        condexpr_true_38:;
        CHECK_OBJECT(tmp_class_creation_38__class_dict);
        tmp_dict_name_76 = tmp_class_creation_38__class_dict;
        tmp_key_name_76 = const_str_plain___metaclass__;
        tmp_assign_source_230 = DICT_GET_ITEM(tmp_dict_name_76, tmp_key_name_76);
        if (tmp_assign_source_230 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1453;

            goto try_except_handler_84;
        }
        goto condexpr_end_38;
        condexpr_false_38:;
        tmp_assign_source_230 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_230);
        condexpr_end_38:;
        assert(tmp_class_creation_38__metaclass == NULL);
        tmp_class_creation_38__metaclass = tmp_assign_source_230;
    }
    {
        PyObject *tmp_assign_source_231;
        PyObject *tmp_called_name_90;
        PyObject *tmp_args_element_name_165;
        PyObject *tmp_args_element_name_166;
        PyObject *tmp_args_element_name_167;
        CHECK_OBJECT(tmp_class_creation_38__metaclass);
        tmp_called_name_90 = tmp_class_creation_38__metaclass;
        tmp_args_element_name_165 = const_str_plain_IssuingDistributionPoint;
        tmp_args_element_name_166 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_38__class_dict);
        tmp_args_element_name_167 = tmp_class_creation_38__class_dict;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 1453;
        {
            PyObject *call_args[] = {tmp_args_element_name_165, tmp_args_element_name_166, tmp_args_element_name_167};
            tmp_assign_source_231 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_90, call_args);
        }

        if (tmp_assign_source_231 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1453;

            goto try_except_handler_84;
        }
        assert(tmp_class_creation_38__class == NULL);
        tmp_class_creation_38__class = tmp_assign_source_231;
    }
    {
        PyObject *tmp_assign_source_232;
        PyObject *tmp_called_name_91;
        PyObject *tmp_called_name_92;
        PyObject *tmp_source_name_54;
        PyObject *tmp_mvar_value_125;
        PyObject *tmp_args_element_name_168;
        PyObject *tmp_mvar_value_126;
        PyObject *tmp_args_element_name_169;
        tmp_mvar_value_125 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

        if (unlikely(tmp_mvar_value_125 == NULL)) {
            tmp_mvar_value_125 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
        }

        if (tmp_mvar_value_125 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
            exception_tb = NULL;

            exception_lineno = 1452;

            goto try_except_handler_84;
        }

        tmp_source_name_54 = tmp_mvar_value_125;
        tmp_called_name_92 = LOOKUP_ATTRIBUTE(tmp_source_name_54, const_str_plain_register_interface);
        if (tmp_called_name_92 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1452;

            goto try_except_handler_84;
        }
        tmp_mvar_value_126 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType);

        if (unlikely(tmp_mvar_value_126 == NULL)) {
            tmp_mvar_value_126 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType);
        }

        if (tmp_mvar_value_126 == NULL) {
            Py_DECREF(tmp_called_name_92);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 35484 ], 35, 0);
            exception_tb = NULL;

            exception_lineno = 1452;

            goto try_except_handler_84;
        }

        tmp_args_element_name_168 = tmp_mvar_value_126;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 1452;
        tmp_called_name_91 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_92, tmp_args_element_name_168);
        Py_DECREF(tmp_called_name_92);
        if (tmp_called_name_91 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1452;

            goto try_except_handler_84;
        }
        CHECK_OBJECT(tmp_class_creation_38__class);
        tmp_args_element_name_169 = tmp_class_creation_38__class;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 1452;
        tmp_assign_source_232 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_91, tmp_args_element_name_169);
        Py_DECREF(tmp_called_name_91);
        if (tmp_assign_source_232 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1452;

            goto try_except_handler_84;
        }
        {
            PyObject *old = tmp_class_creation_38__class;
            assert(old != NULL);
            tmp_class_creation_38__class = tmp_assign_source_232;
            Py_DECREF(old);
        }

    }
    goto try_end_42;
    // Exception handler code:
    try_except_handler_84:;
    exception_keeper_type_76 = exception_type;
    exception_keeper_value_76 = exception_value;
    exception_keeper_tb_76 = exception_tb;
    exception_keeper_lineno_76 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_38__class);
    tmp_class_creation_38__class = NULL;

    Py_XDECREF(tmp_class_creation_38__class_dict);
    tmp_class_creation_38__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_38__metaclass);
    tmp_class_creation_38__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_76;
    exception_value = exception_keeper_value_76;
    exception_tb = exception_keeper_tb_76;
    exception_lineno = exception_keeper_lineno_76;

    goto frame_exception_exit_1;
    // End of try:
    try_end_42:;
    {
        PyObject *tmp_assign_source_233;
        CHECK_OBJECT(tmp_class_creation_38__class);
        tmp_assign_source_233 = tmp_class_creation_38__class;
        UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_IssuingDistributionPoint, tmp_assign_source_233);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_38__class);
    Py_DECREF(tmp_class_creation_38__class);
    tmp_class_creation_38__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_38__class_dict);
    Py_DECREF(tmp_class_creation_38__class_dict);
    tmp_class_creation_38__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_38__metaclass);
    Py_DECREF(tmp_class_creation_38__metaclass);
    tmp_class_creation_38__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_234;
        {
            PyObject *tmp_set_locals_35;
            tmp_set_locals_35 = PyDict_New();
            locals_cryptography$x509$extensions_1583 = tmp_set_locals_35;
        }
        tmp_dictset_value = const_str_digest_7822abce90b4f23aa7a437cf95bbfec5;
        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1583, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_204___init__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1583, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_50a05b6f30ae622183421406fd266003_34, codeobj_50a05b6f30ae622183421406fd266003, module_cryptography$x509$extensions, 0);
        frame_50a05b6f30ae622183421406fd266003_34 = cache_frame_50a05b6f30ae622183421406fd266003_34;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_50a05b6f30ae622183421406fd266003_34);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_50a05b6f30ae622183421406fd266003_34) == 2); // Frame stack

        // Framed code:
        {
            PyObject *tmp_called_instance_47;
            PyObject *tmp_mvar_value_127;
            tmp_mvar_value_127 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_127 == NULL)) {
                tmp_mvar_value_127 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_127 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 1590;

                goto frame_exception_exit_34;
            }

            tmp_called_instance_47 = tmp_mvar_value_127;
            frame_50a05b6f30ae622183421406fd266003_34->m_frame.f_lineno = 1590;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_47, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__oid_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1590;

                goto frame_exception_exit_34;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1583, const_str_plain_oid, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1590;

                goto frame_exception_exit_34;
            }
        }
        {
            PyObject *tmp_called_instance_48;
            PyObject *tmp_mvar_value_128;
            tmp_mvar_value_128 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

            if (unlikely(tmp_mvar_value_128 == NULL)) {
                tmp_mvar_value_128 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
            }

            if (tmp_mvar_value_128 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 1591;

                goto frame_exception_exit_34;
            }

            tmp_called_instance_48 = tmp_mvar_value_128;
            frame_50a05b6f30ae622183421406fd266003_34->m_frame.f_lineno = 1591;
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_48, const_str_plain_read_only_property, &PyTuple_GET_ITEM(const_tuple_str_plain__value_tuple, 0));

            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1591;

                goto frame_exception_exit_34;
            }
            tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1583, const_str_plain_value, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1591;

                goto frame_exception_exit_34;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_50a05b6f30ae622183421406fd266003_34);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_33;

        frame_exception_exit_34:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_50a05b6f30ae622183421406fd266003_34);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_50a05b6f30ae622183421406fd266003_34, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_50a05b6f30ae622183421406fd266003_34->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_50a05b6f30ae622183421406fd266003_34, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_50a05b6f30ae622183421406fd266003_34,
            type_description_2
        );


        // Release cached frame.
        if (frame_50a05b6f30ae622183421406fd266003_34 == cache_frame_50a05b6f30ae622183421406fd266003_34) {
            Py_DECREF(frame_50a05b6f30ae622183421406fd266003_34);
        }
        cache_frame_50a05b6f30ae622183421406fd266003_34 = NULL;

        assertFrameObject(frame_50a05b6f30ae622183421406fd266003_34);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_33;

        frame_no_exception_33:;
        goto skip_nested_handling_33;
        nested_frame_exit_33:;

        goto try_except_handler_87;
        skip_nested_handling_33:;
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_205___repr__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1583, const_str_plain___repr__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_206___eq__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1583, const_str_plain___eq__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_207___ne__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1583, const_str_plain___ne__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_cryptography$x509$extensions$$$function_208___hash__();



        tmp_res = PyDict_SetItem(locals_cryptography$x509$extensions_1583, const_str_plain___hash__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_assign_source_234 = locals_cryptography$x509$extensions_1583;
        Py_INCREF(tmp_assign_source_234);
        goto try_return_handler_87;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        // Return handler code:
        try_return_handler_87:;
        Py_DECREF(locals_cryptography$x509$extensions_1583);
        locals_cryptography$x509$extensions_1583 = NULL;
        goto outline_result_42;
        // Exception handler code:
        try_except_handler_87:;
        exception_keeper_type_77 = exception_type;
        exception_keeper_value_77 = exception_value;
        exception_keeper_tb_77 = exception_tb;
        exception_keeper_lineno_77 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_cryptography$x509$extensions_1583);
        locals_cryptography$x509$extensions_1583 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_77;
        exception_value = exception_keeper_value_77;
        exception_tb = exception_keeper_tb_77;
        exception_lineno = exception_keeper_lineno_77;

        goto outline_exception_33;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(cryptography$x509$extensions);
        return NULL;
        outline_exception_33:;
        exception_lineno = 1583;
        goto try_except_handler_86;
        outline_result_42:;
        assert(tmp_class_creation_39__class_dict == NULL);
        tmp_class_creation_39__class_dict = tmp_assign_source_234;
    }
    {
        PyObject *tmp_assign_source_235;
        nuitka_bool tmp_condition_result_39;
        PyObject *tmp_key_name_77;
        PyObject *tmp_dict_name_77;
        PyObject *tmp_dict_name_78;
        PyObject *tmp_key_name_78;
        tmp_key_name_77 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_39__class_dict);
        tmp_dict_name_77 = tmp_class_creation_39__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_77, tmp_key_name_77);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1583;

            goto try_except_handler_86;
        }
        tmp_condition_result_39 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_39 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_39;
        } else {
            goto condexpr_false_39;
        }
        condexpr_true_39:;
        CHECK_OBJECT(tmp_class_creation_39__class_dict);
        tmp_dict_name_78 = tmp_class_creation_39__class_dict;
        tmp_key_name_78 = const_str_plain___metaclass__;
        tmp_assign_source_235 = DICT_GET_ITEM(tmp_dict_name_78, tmp_key_name_78);
        if (tmp_assign_source_235 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1583;

            goto try_except_handler_86;
        }
        goto condexpr_end_39;
        condexpr_false_39:;
        tmp_assign_source_235 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_235);
        condexpr_end_39:;
        assert(tmp_class_creation_39__metaclass == NULL);
        tmp_class_creation_39__metaclass = tmp_assign_source_235;
    }
    {
        PyObject *tmp_assign_source_236;
        PyObject *tmp_called_name_93;
        PyObject *tmp_args_element_name_170;
        PyObject *tmp_args_element_name_171;
        PyObject *tmp_args_element_name_172;
        CHECK_OBJECT(tmp_class_creation_39__metaclass);
        tmp_called_name_93 = tmp_class_creation_39__metaclass;
        tmp_args_element_name_170 = const_str_plain_UnrecognizedExtension;
        tmp_args_element_name_171 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_39__class_dict);
        tmp_args_element_name_172 = tmp_class_creation_39__class_dict;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 1583;
        {
            PyObject *call_args[] = {tmp_args_element_name_170, tmp_args_element_name_171, tmp_args_element_name_172};
            tmp_assign_source_236 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_93, call_args);
        }

        if (tmp_assign_source_236 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1583;

            goto try_except_handler_86;
        }
        assert(tmp_class_creation_39__class == NULL);
        tmp_class_creation_39__class = tmp_assign_source_236;
    }
    {
        PyObject *tmp_assign_source_237;
        PyObject *tmp_called_name_94;
        PyObject *tmp_called_name_95;
        PyObject *tmp_source_name_55;
        PyObject *tmp_mvar_value_129;
        PyObject *tmp_args_element_name_173;
        PyObject *tmp_mvar_value_130;
        PyObject *tmp_args_element_name_174;
        tmp_mvar_value_129 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_utils);

        if (unlikely(tmp_mvar_value_129 == NULL)) {
            tmp_mvar_value_129 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_utils);
        }

        if (tmp_mvar_value_129 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 21457 ], 27, 0);
            exception_tb = NULL;

            exception_lineno = 1582;

            goto try_except_handler_86;
        }

        tmp_source_name_55 = tmp_mvar_value_129;
        tmp_called_name_95 = LOOKUP_ATTRIBUTE(tmp_source_name_55, const_str_plain_register_interface);
        if (tmp_called_name_95 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1582;

            goto try_except_handler_86;
        }
        tmp_mvar_value_130 = GET_STRING_DICT_VALUE(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_ExtensionType);

        if (unlikely(tmp_mvar_value_130 == NULL)) {
            tmp_mvar_value_130 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ExtensionType);
        }

        if (tmp_mvar_value_130 == NULL) {
            Py_DECREF(tmp_called_name_95);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 35484 ], 35, 0);
            exception_tb = NULL;

            exception_lineno = 1582;

            goto try_except_handler_86;
        }

        tmp_args_element_name_173 = tmp_mvar_value_130;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 1582;
        tmp_called_name_94 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_95, tmp_args_element_name_173);
        Py_DECREF(tmp_called_name_95);
        if (tmp_called_name_94 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1582;

            goto try_except_handler_86;
        }
        CHECK_OBJECT(tmp_class_creation_39__class);
        tmp_args_element_name_174 = tmp_class_creation_39__class;
        frame_43c1c6d969ff6899544b1cfb272ea433->m_frame.f_lineno = 1582;
        tmp_assign_source_237 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_94, tmp_args_element_name_174);
        Py_DECREF(tmp_called_name_94);
        if (tmp_assign_source_237 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1582;

            goto try_except_handler_86;
        }
        {
            PyObject *old = tmp_class_creation_39__class;
            assert(old != NULL);
            tmp_class_creation_39__class = tmp_assign_source_237;
            Py_DECREF(old);
        }

    }
    goto try_end_43;
    // Exception handler code:
    try_except_handler_86:;
    exception_keeper_type_78 = exception_type;
    exception_keeper_value_78 = exception_value;
    exception_keeper_tb_78 = exception_tb;
    exception_keeper_lineno_78 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_39__class);
    tmp_class_creation_39__class = NULL;

    Py_XDECREF(tmp_class_creation_39__class_dict);
    tmp_class_creation_39__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_39__metaclass);
    tmp_class_creation_39__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_78;
    exception_value = exception_keeper_value_78;
    exception_tb = exception_keeper_tb_78;
    exception_lineno = exception_keeper_lineno_78;

    goto frame_exception_exit_1;
    // End of try:
    try_end_43:;

    // Restore frame exception if necessary.
#if 0
    RESTORE_FRAME_EXCEPTION(frame_43c1c6d969ff6899544b1cfb272ea433);
#endif
    popFrameStack();

    assertFrameObject(frame_43c1c6d969ff6899544b1cfb272ea433);

    goto frame_no_exception_34;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_43c1c6d969ff6899544b1cfb272ea433);
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK(frame_43c1c6d969ff6899544b1cfb272ea433, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_43c1c6d969ff6899544b1cfb272ea433->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_43c1c6d969ff6899544b1cfb272ea433, exception_lineno);
    }

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto module_exception_exit;

    frame_no_exception_34:;
    {
        PyObject *tmp_assign_source_238;
        CHECK_OBJECT(tmp_class_creation_39__class);
        tmp_assign_source_238 = tmp_class_creation_39__class;
        UPDATE_STRING_DICT0(moduledict_cryptography$x509$extensions, (Nuitka_StringObject *)const_str_plain_UnrecognizedExtension, tmp_assign_source_238);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_39__class);
    Py_DECREF(tmp_class_creation_39__class);
    tmp_class_creation_39__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_39__class_dict);
    Py_DECREF(tmp_class_creation_39__class_dict);
    tmp_class_creation_39__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_39__metaclass);
    Py_DECREF(tmp_class_creation_39__metaclass);
    tmp_class_creation_39__metaclass = NULL;


    return module_cryptography$x509$extensions;
    module_exception_exit:
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);
    return NULL;
}
