/* Generated code for Python module 'OpenSSL.crypto'
 * created by Nuitka version 0.6.6
 *
 * This code is in part copyright 2019 Kay Hayen.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "nuitka/prelude.h"

#include "__helpers.h"

/* The "_module_OpenSSL$crypto" is a Python object pointer of module type.
 *
 * Note: For full compatibility with CPython, every module variable access
 * needs to go through it except for cases where the module cannot possibly
 * have changed in the mean time.
 */

PyObject *module_OpenSSL$crypto;
PyDictObject *moduledict_OpenSSL$crypto;

/* The declarations of module constants used, if any. */
static PyObject *const_str_plain_set_lastUpdate;
extern PyObject *const_str_plain_EVP_PKEY_id;
static PyObject *const_str_plain_OBJ_nid2ln;
static PyObject *const_str_digest_340717166d8c6af86f5d8a6e35ed5a7f;
static PyObject *const_str_digest_014a797afcc3e1ad4f3e6e9aa4631a8a;
static PyObject *const_str_digest_73f7a7ef7b02ca8c5d7fdfe1049be561;
extern PyObject *const_str_plain_data;
static PyObject *const_str_plain__truncate;
static PyObject *const_str_plain_RSA_check_key;
extern PyObject *const_str_plain_X509_CRL_get_nextUpdate;
static PyObject *const_str_plain_X509_NAME_get_index_by_NID;
static PyObject *const_str_plain_issuer_key;
static PyObject *const_str_digest_978cd476d4acffdfb043e6a5e0ebae26;
static PyObject *const_tuple_349fb4cb1ce06b9a51a79a6cd36ef36b_tuple;
extern PyObject *const_str_plain_PEM_write_bio_X509;
extern PyObject *const_str_plain_EVP_MAX_MD_SIZE;
static PyObject *const_tuple_0c127564cb8e0f10a9444ae3c25de3f1_tuple;
static PyObject *const_str_plain_not_after;
static PyObject *const_str_plain_X509_V_FLAG_POLICY_CHECK;
static PyObject *const_str_digest_b52a484c26b348bfec0a17217a58ad7e;
extern PyObject *const_str_plain_startswith;
static PyObject *const_str_digest_8fda740163dc7d07c78736dc2ebb17b1;
extern PyObject *const_str_plain_X509_set_subject_name;
static PyObject *const_str_plain_all_reasons;
static PyObject *const_tuple_str_plain_self_str_plain_which_str_plain_name_tuple;
static PyObject *const_str_digest_90de967a5219b9210479f7eac5c285c8;
static PyObject *const_str_digest_e335a7c8a0dd4d8ab6096b1597d79143;
static PyObject *const_tuple_str_plain_self_str_plain_which_str_plain_when_tuple;
extern PyObject *const_str_plain_UNSPECIFIED;
static PyObject *const_str_digest_a9bcf1af78e6d912e13685d8a606fe30;
static PyObject *const_str_plain_TYPE_RSA;
static PyObject *const_str_plain_X509_VERIFY_PARAM_free;
static PyObject *const_str_digest_52cbe8d655a10e46907a30970ef9889a;
static PyObject *const_str_plain_sk_X509_EXTENSION_free;
extern PyObject *const_str_plain_PKCS12_free;
static PyObject *const_str_digest_435662c26b2c422edb954b82c85c55d9;
static PyObject *const_str_digest_f737de4a45174195dc1e46101235dc35;
static PyObject *const_str_plain_get_rev_date;
extern PyObject *const_str_plain_pkey;
static PyObject *const_str_digest_3d684470d9353bc1a1e8d63a3aab4679;
static PyObject *const_tuple_str_plain_cls_str_plain_lib_tuple;
static PyObject *const_str_plain_X509StoreContext;
extern PyObject *const_str_digest_c075052d723d6707083e869a0e3659bb;
extern PyObject *const_tuple_str_plain_self_str_plain_version_tuple;
extern PyObject *const_str_plain__CertificateRevocationList;
static PyObject *const_str_plain__get_elliptic_curves;
extern PyObject *const_str_plain__problems;
extern PyObject *const_str_plain_stack;
extern PyObject *const_str_digest_bc7a2d385ac0b4ca6f6caa64ccb6a3b9;
extern PyObject *const_str_plain_cipher;
static PyObject *const_str_plain_string_type;
static PyObject *const_tuple_str_digest_e1dc452ac5e3c17f3e15bbf44d17e339_tuple;
extern PyObject *const_str_plain_X509_REVOKED_get0_revocationDate;
static PyObject *const_tuple_str_digest_8e9fba48e24a08144a915d52e31f6d23_tuple;
static PyObject *const_tuple_str_plain_utf8only_tuple;
static PyObject *const_str_digest_aca114104f73a7934675fb06a5336647;
static PyObject *const_str_digest_169aa7f0589e4a3c83203d48f57770af;
static PyObject *const_str_plain_X509_VERIFY_PARAM_new;
extern PyObject *const_str_plain_BIO_new_mem_buf;
static PyObject *const_str_plain__friendlyname;
static PyObject *const_tuple_str_plain_bio_str_plain_ref_tuple;
extern PyObject *const_tuple_str_plain_self_str_plain_other_tuple;
static PyObject *const_str_digest_1565887baecc678658a50e7d1f245653;
extern PyObject *const_str_plain_X509_set_pubkey;
static PyObject *const_str_digest_d546905f9a7fd3b3fc24a90a7432aa72;
static PyObject *const_tuple_str_digest_eee7b0934fe224b34ba6722d84ccd2bf_tuple;
static PyObject *const_str_plain_load_pkcs12;
static PyObject *const_str_plain_X509_REVOKED_add1_ext_i2d;
extern PyObject *const_str_plain_int;
static PyObject *const_str_plain_string_result;
extern PyObject *const_str_plain_X509_NAME_get_entry;
extern PyObject *const_str_plain_X509Name;
static PyObject *const_str_digest_a658b60d9bffa55a9bdfb85ba96aec98;
extern PyObject *const_str_plain_sign;
extern PyObject *const_int_neg_1;
static PyObject *const_str_plain_NOTIFY_POLICY;
extern PyObject *const_str_plain_ASN1_STRING_to_UTF8;
static PyObject *const_str_digest_2f350f536232587387680a9435c758f6;
extern PyObject *const_str_plain_timestamp;
extern PyObject *const_str_plain_EVP_PKEY_free;
static PyObject *const_str_digest_670c62a34c6767f6ecd5db6f969b2f34;
static PyObject *const_str_plain_pkcs12;
static PyObject *const_str_plain_results;
extern PyObject *const_str_plain_X509_CRL_set_issuer_name;
extern PyObject *const_str_plain_X509_new;
static PyObject *const_str_digest_fb60d21f52ae521da77e61851d566364;
extern PyObject *const_str_plain_ERR_clear_error;
extern PyObject *const_str_plain__crl;
static PyObject *const_str_plain_get_short_name;
static PyObject *const_str_plain_digest_obj;
static PyObject *const_str_plain_op;
static PyObject *const_str_plain_type_is_enveloped;
extern PyObject *const_str_plain___file__;
static PyObject *const_str_digest_782fa7272fdd3d3abdc1a0298e5e83fc;
static PyObject *const_str_plain_X509_R_CERT_ALREADY_IN_HASH_TABLE;
static PyObject *const_str_plain_result_buffer;
static PyObject *const_str_plain_utf8only;
extern PyObject *const_str_plain_X509_STORE_CTX_get_current_cert;
static PyObject *const_str_plain_PKeyType;
extern PyObject *const_str_plain_X509_get_ext_count;
extern PyObject *const_str_plain_X509_free;
extern PyObject *const_str_plain_PEM_read_bio_X509_REQ;
static PyObject *const_str_plain_PKCS12_create;
extern PyObject *const_str_plain_dt;
static PyObject *const_str_digest_152d11f8848fac60442a26592ab3da87;
static PyObject *const_str_digest_0632ce6142bf9815370c626f0fb1235a;
extern PyObject *const_str_plain_ia5;
extern PyObject *const_str_plain_Certificate;
extern PyObject *const_str_plain_make_assert;
extern PyObject *const_str_plain_EVP_PKEY_DSA;
static PyObject *const_str_plain_char_result;
static PyObject *const_str_plain_string_timestamp;
static PyObject *const_tuple_7ffc84c231c6d64baeef42ad62a1270d_tuple;
static PyObject *const_tuple_516125a1d64dba4bb10b7a1d5054cba1_tuple;
extern PyObject *const_str_plain__from_raw_x509_ptr;
static PyObject *const_tuple_str_plain_self_str_plain_not_after_str_plain_time_string_tuple;
static PyObject *const_str_digest_3c5d018dd809b9a6147c1b47d39e8d31;
static PyObject *const_str_plain_X509_STORE_CTX_cleanup;
static PyObject *const_str_digest_50f07d7dbc7dc060eb5685744b92c007;
static PyObject *const_str_digest_44f664275c70041c9ae4bef2565506f3;
extern PyObject *const_str_plain_X509_EXTENSION_get_data;
static PyObject *const_str_plain_sk_X509_push;
static PyObject *const_str_digest_6a19008e8f9a834793cf38dcba68883a;
extern PyObject *const_int_pos_2048;
static PyObject *const_str_plain_CRL_CHECK;
static PyObject *const_str_plain_spki;
static PyObject *const_tuple_str_plain_self_str_plain_ret_tuple;
static PyObject *const_str_plain_pypkcs7;
extern PyObject *const_str_plain_X509_get_serialNumber;
extern PyObject *const_str_plain___init__;
extern PyObject *const_str_plain_dsa;
static PyObject *const_str_plain_add_crl;
extern PyObject *const_str_plain_bits;
extern PyObject *const_str_plain_DSAPrivateKey;
static PyObject *const_str_digest_5a3f7f69104a4ed1267a21c950d94463;
static PyObject *const_tuple_str_plain_self_str_plain_flags_tuple;
static PyObject *const_str_plain_X509_V_FLAG_ALLOW_PROXY_CERTS;
extern PyObject *const_str_plain_NID_undef;
extern PyObject *const_str_plain_new;
static PyObject *const_str_digest_7e62ce69c000886ecc0ae0b3e8ae9e79;
static PyObject *const_str_digest_7de17ac920010129977e4280610f275c;
static PyObject *const_str_plain_NID_pbe_WithSHA1And3_Key_TripleDES_CBC;
static PyObject *const_str_plain__get_name;
extern PyObject *const_str_plain__Certificate;
static PyObject *const_str_plain_b64_encode;
extern PyObject *const_str_plain_X509_REVOKED_set_serialNumber;
extern PyObject *const_str_plain_store;
static PyObject *const_str_plain_ref;
extern PyObject *const_str_plain_base64;
extern PyObject *const_str_plain_more_args;
static PyObject *const_tuple_str_plain_type_str_plain_crl_str_plain_bio_str_plain_ret_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_other_str_plain_result_str_plain_op_tuple;
extern PyObject *const_str_angle_genexpr;
extern PyObject *const_str_plain___name__;
static PyObject *const_str_plain_EVP_VerifyUpdate;
static PyObject *const_str_digest_603c60edaf58a8746faa757f20f3f938;
static PyObject *const_str_digest_32726a73c20427f70712d109be7712b4;
static PyObject *const_str_plain__crl_reasons;
extern PyObject *const_str_plain_X509_set_version;
static PyObject *const_str_plain__passphrase;
extern PyObject *const_str_plain_X509_CRL_set_nextUpdate;
extern PyObject *const_str_plain__raise_current_error;
static PyObject *const_str_plain__revoked;
static PyObject *const_tuple_51ff74c45307e7d0bccc36be86c10b54_tuple;
static PyObject *const_str_plain_fname;
extern PyObject *const_str_plain_issuer;
static PyObject *const_str_digest_60cf4d81fa4ac0fb8a6d16cafc145b24;
static PyObject *const_str_digest_bd5b7ac1c36a2ac4b448366689be109e;
static PyObject *const_str_plain__text_type;
extern PyObject *const_str_plain_der;
static PyObject *const_str_plain_ent_nid;
static PyObject *const_str_plain_IGNORE_CRITICAL;
extern PyObject *const_str_plain_add;
static PyObject *const_str_digest_a9fcf3ea8b3ff05d45964d00ac386113;
extern PyObject *const_tuple_str_plain_partial_tuple;
extern PyObject *const_str_plain_DSA_generate_parameters_ex;
static PyObject *const_str_digest_c384f9f99d5890cd2aae342c30dbaa14;
static PyObject *const_str_plain_load_crl;
static PyObject *const_str_plain_i2d_PKCS12_bio;
static PyObject *const_str_digest_5bd123cbe57a454c8d9d37867b598cb2;
extern PyObject *const_str_plain_X509_set_issuer_name;
static PyObject *const_str_digest_3c7878f9f14c822b0ae6ebb3dbe0804c;
extern PyObject *const_str_plain_res;
extern PyObject *const_str_plain_PEM_read_bio_PrivateKey;
extern PyObject *const_str_plain_req;
static PyObject *const_str_plain_crypto_req;
static PyObject *const_str_plain_CHECK_SS_SIGNATURE;
static PyObject *const_str_plain__nid;
static PyObject *const_str_plain_X509_V_FLAG_NOTIFY_POLICY;
static PyObject *const_str_plain_SSL_FILETYPE_PEM;
static PyObject *const_str_plain_d2i_PKCS7_bio;
extern PyObject *const_str_plain_X509_REVOKED_free;
static PyObject *const_str_digest_0807c1b9c5bc0ac3cc25375c4a9ebb2e;
static PyObject *const_str_plain_EVP_PKEY_assign_RSA;
extern PyObject *const_str_plain_sk_X509_EXTENSION_new_null;
extern PyObject *const_str_plain_unspecified;
extern PyObject *const_str_plain_check;
static PyObject *const_str_plain_get_ca_certificates;
extern PyObject *const_str_plain_integer_types;
static PyObject *const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple;
extern PyObject *const_str_plain_asn1_int;
static PyObject *const_str_plain_set_subject;
static PyObject *const_tuple_2abd4adfc3fb4c61eb6347c1066336bb_tuple;
extern PyObject *const_tuple_str_plain_ascii_tuple;
static PyObject *const_str_plain_get_components;
static PyObject *const_tuple_5b465d0345e9fe836325135a03b6a86e_tuple;
static PyObject *const_str_plain_set_privatekey;
static PyObject *const_str_plain_EVP_VerifyFinal;
static PyObject *const_str_digest_26a65c58106d086427e37cb87b0bc3b3;
static PyObject *const_str_digest_8db7448b8246dd51f74c33bda58590bd;
static PyObject *const_tuple_str_plain_self_str_plain__Certificate_str_plain_backend_tuple;
extern PyObject *const_str_plain_get_certificate;
static PyObject *const_str_plain_get_notBefore;
static PyObject *const_str_plain_X509V3_set_ctx_nodb;
extern PyObject *const_str_plain__pkey;
extern PyObject *const_str_plain_x509;
extern PyObject *const_str_plain_clear;
static PyObject *const_str_plain_i2d_PrivateKey_bio;
static PyObject *const_str_digest_05b2bb16e6ee73fd972536e52cc4cabf;
static PyObject *const_str_plain_hexstring_serial;
extern PyObject *const_str_plain_False;
static PyObject *const_tuple_str_plain_integer_types_str_plain_text_type_str_plain_PY3_tuple;
static PyObject *const_str_digest_1ca413f5b66374db6a573ac0926a99ae;
extern PyObject *const_str_plain_exponent;
extern PyObject *const_tuple_str_plain_self_str_plain_subject_tuple;
static PyObject *const_str_plain_X509StoreFlags;
static PyObject *const_str_plain_EVP_SignInit;
static PyObject *const_str_digest_c7bf9684574689f7d764ff6fbd5eab60;
static PyObject *const_str_digest_e1dc452ac5e3c17f3e15bbf44d17e339;
static PyObject *const_tuple_str_plain_op_str_plain_f_tuple;
extern PyObject *const_str_digest_c804b213c384a15865e18bf31cfff70e;
static PyObject *const_tuple_str_plain_b16encode_tuple;
static PyObject *const_str_plain_get_serial_number;
static PyObject *const_str_digest_2f591e55cc116ed5223c119e2f7da344;
static PyObject *const_str_plain_ent_obj;
extern PyObject *const_str_plain_subject;
static PyObject *const_str_plain_vfy_time;
extern PyObject *const_str_plain_userdata;
static PyObject *const_str_plain_sk_X509_EXTENSION_push;
extern PyObject *const_str_plain_critical;
extern PyObject *const_str_plain_days;
static PyObject *const_str_digest_3910fdd1c3b683a0988d08f77454ce47;
static PyObject *const_str_plain_get_extension_count;
static PyObject *const_str_digest_12c1bc175ad6309f9cfc24942b8c76ac;
static PyObject *const_tuple_str_plain_self_str_plain_when_tuple;
static PyObject *const_str_plain_X509V3_EXT_print;
static PyObject *const_str_plain_which;
static PyObject *const_tuple_f55bc3086b9449b7c24969f5e02af09b_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_pkey_str_plain_set_result_tuple;
extern PyObject *const_str_plain_code;
static PyObject *const_tuple_str_plain_self_str_plain_obj_str_plain_nid_tuple;
static PyObject *const_tuple_4cf00dd32a506e6f9e6721c83bedbfad_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_version_str_plain_set_result_tuple;
static PyObject *const_str_plain_i2a_ASN1_INTEGER;
extern PyObject *const_str_plain__evp_pkey_to_public_key;
static PyObject *const_tuple_str_plain_self_str_plain_algor_str_plain_nid_tuple;
static PyObject *const_tuple_6821d02066babb1885e247bdbf40c8ec_tuple;
extern PyObject *const_str_plain_X509_REQ_new;
extern PyObject *const_str_plain__native;
extern PyObject *const_str_plain_X509_REQ_free;
extern PyObject *const_str_plain__ffi;
static PyObject *const_str_plain_X509Type;
extern PyObject *const_str_plain_X509_NAME_entry_count;
static PyObject *const_str_digest_5194c46decfddbd64da780c8c0e4faa3;
static PyObject *const_str_plain_X509_NAME_delete_entry;
static PyObject *const_str_digest_8aae826f04ca2a5df2a0de1a103a1f13;
extern PyObject *const_str_plain_X509_get_subject_name;
extern PyObject *const_str_plain_operator;
static PyObject *const_str_digest_333948d9e51f0e161201a16305959930;
static PyObject *const_str_plain_native_exts_obj;
static PyObject *const_str_digest_9cb57ebafd0926d1746d2e66a6198efe;
static PyObject *const_str_plain_X509_STRICT;
static PyObject *const_tuple_str_digest_e2d15f7f418fdd55a54be9ea476feee3_tuple;
static PyObject *const_tuple_str_plain_cls_str_plain_crypto_cert_str_plain_cert_tuple;
static PyObject *const_str_plain_time_string;
static PyObject *const_str_digest_5339fa8ff3df372e54ef7b09078767aa;
static PyObject *const_tuple_86464d9c162f01af99141e0a5b804d71_tuple;
static PyObject *const_tuple_5ef57f6035eba9ead62528f8493f508e_tuple;
extern PyObject *const_str_plain_EVP_PKEY_EC;
extern PyObject *const_str_plain___getattr__;
static PyObject *const_str_plain_NID_subject_alt_name;
static PyObject *const_str_plain_add_cert;
static PyObject *const_tuple_str_digest_70b987f75825a6c2ffe2c8fe53d85a21_tuple;
static PyObject *const_str_plain_X509V3_EXT_nconf;
extern PyObject *const_str_plain_X509_STORE_CTX_get_error;
extern PyObject *const_str_plain_BIO_get_mem_data;
static PyObject *const_str_digest_5cb0319d0378026eb0ef49838e525520;
extern PyObject *const_str_plain_signature;
static PyObject *const_str_plain_builtin_curves;
static PyObject *const_str_digest_62c9c3f244d467c166be64cd38a755a7;
static PyObject *const_str_digest_f41f911aba33894e1da796354264d96a;
static PyObject *const_str_digest_dc44ec2c02bcac7fac23b8eea57aa5d6;
extern PyObject *const_str_digest_426349c7e201b358f2086eb3f7fb6f47;
extern PyObject *const_str_plain_ctx;
static PyObject *const_str_plain_subject_cert;
extern PyObject *const_str_plain_encode;
static PyObject *const_str_plain_set_pubkey;
extern PyObject *const_str_plain_X509_NAME_free;
static PyObject *const_str_digest_e69f89000e2dc720ec6a70b8f9cb0cac;
static PyObject *const_str_plain_exceptionType;
static PyObject *const_str_digest_61dbd227935e54cb40eecc7de8b8596b;
static PyObject *const_str_digest_1d608c98cc8048d3f7b439059ee29b66;
static PyObject *const_str_digest_79b48b443a4edf88bd64a278e98529d3;
static PyObject *const_str_plain_from_nid;
extern PyObject *const_str_plain_PEM_write_bio_X509_REQ;
static PyObject *const_str_digest_11dbf726734533c622c12e725d15648e;
static PyObject *const_str_plain__spki;
static PyObject *const_str_plain_from_cryptography;
static PyObject *const_str_digest_f56881bccbbc40c6643f9603628e7a5c;
static PyObject *const_str_digest_7a5005a2e44b5258634f5b2837cd8b81;
static PyObject *const_str_plain_set_notBefore;
extern PyObject *const_tuple_empty;
static PyObject *const_str_plain_load_pkcs7_data;
static PyObject *const_str_plain_pycacerts;
static PyObject *const_str_plain_cacerts;
static PyObject *const_str_digest_95aba6f0be0722dff4a715f251a45159;
static PyObject *const_str_digest_4d148c7b7c1bc2fec101962dc1ce2c2f;
static PyObject *const_str_plain_signature_buffer;
static PyObject *const_tuple_str_plain_self_str_plain_lib_str_plain_nid_str_plain_name_tuple;
extern PyObject *const_str_plain_EC_KEY_new_by_curve_name;
extern PyObject *const_int_0;
static PyObject *const_str_digest_70b987f75825a6c2ffe2c8fe53d85a21;
static PyObject *const_str_digest_9781f115d6516693d922717b11376a73;
extern PyObject *const_str_plain_result;
extern PyObject *const_str_plain_X509_CRL_new;
extern PyObject *const_str_plain_EVP_PKEY_new;
static PyObject *const_str_plain__new_mem_buf;
static PyObject *const_str_plain_X509_verify_cert_error_string;
static PyObject *const_str_plain_CRLType;
static PyObject *const_str_digest_79dac080796da8f8fc9c66ebe460ce2f;
static PyObject *const_str_plain_X509_CRL_print;
extern PyObject *const_str_plain_rsa;
extern PyObject *const_str_plain_X509_sign;
static PyObject *const_tuple_fe55f23347ee1ca3dc14a1930b416eaa_tuple;
extern PyObject *const_str_digest_9abb9f40508debfa3aae6d9135753f7e;
extern PyObject *const_str_plain_e;
static PyObject *const_str_digest_0a3eb1716e7caaaf09c8582b572bcb60;
extern PyObject *const_str_plain_OpenSSL_add_all_algorithms;
static PyObject *const_str_digest_d03be6fc9f3e6729b366e69e0856a450;
extern PyObject *const_tuple_str_plain_self_str_plain_issuer_tuple;
static PyObject *const_str_plain_bignum_ptr;
extern PyObject *const_str_plain_gc;
static PyObject *const_str_digest_11c225ccbab9acffc38107dee9691702;
static PyObject *const_str_plain_OBJ_obj2nid;
static PyObject *const_str_digest_4fd5a0c1d1fb7366c52acc7b3ac0b5b1;
extern PyObject *const_str_digest_8b0e1374dcc590bdb16ac8ec2446b5d1;
extern PyObject *const_str_plain__issuer;
static PyObject *const_str_digest_9ae52cddf69d053d9518f458a81ffa1b;
static PyObject *const_str_digest_68e309761e6d5dc5f5c1e53801284f3a;
static PyObject *const_str_plain_X509_EXTENSION_dup;
static PyObject *const_str_digest_7163953ad9ff69e46167d396f5625cf7;
extern PyObject *const_str_plain___lt__;
static PyObject *const_str_plain_SSL_FILETYPE_ASN1;
extern PyObject *const_str_plain_d2i_PrivateKey_bio;
extern PyObject *const_int_pos_100;
static PyObject *const_tuple_76984bb103279dcce095840ed073cae5_tuple;
static PyObject *const_str_plain_sometime;
extern PyObject *const_tuple_str_plain_where_tuple;
extern PyObject *const_str_plain_X509_REQ_get_pubkey;
static PyObject *const_str_digest_f979ae5e9b0a9a41a05276169a44e7e9;
static PyObject *const_str_plain_callback_args;
extern PyObject *const_str_plain_datetime;
extern PyObject *const_str_plain_digest;
static PyObject *const_str_plain_set_store;
extern PyObject *const_str_plain__UNSPECIFIED;
static PyObject *const_str_digest_03f3989a7f0f1ec9623bd001f5a005a7;
static PyObject *const_str_digest_5f245d1740d80da82563e21c9c4f4fbf;
extern PyObject *const_str_plain_append;
static PyObject *const_str_plain_parse_result;
static PyObject *const_str_plain_reason_code;
static PyObject *const_tuple_5903b88f37d1077b2f3871dbc2944417_tuple;
extern PyObject *const_str_plain_verify;
static PyObject *const_str_plain_set_certificate;
static PyObject *const_tuple_f442a9e9eba2c7bd96e443ed0b5afd06_tuple;
static PyObject *const_str_digest_1cf455235163a6978480cc7b12198a27;
static PyObject *const_str_plain_format_result;
extern PyObject *const_str_plain___new__;
extern PyObject *const_str_plain_str;
static PyObject *const_str_digest_11e1356f3459cf012eb88d7288e20e85;
static PyObject *const_str_digest_7338acfc5a3b91c07965b6befadc8c7a;
static PyObject *const_str_plain_get_elliptic_curves;
extern PyObject *const_str_plain_where;
static PyObject *const_str_digest_40e46351c3b918f338d6e675fea0b1ca;
extern PyObject *const_str_plain__make_assert;
static PyObject *const_tuple_str_plain_self_str_plain_exceptionType_tuple;
static PyObject *const_str_plain_RSA_print;
static PyObject *const_tuple_a2a87d1d5695ca90897866b205aec3ce_tuple;
extern PyObject *const_str_plain_RSA_free;
extern PyObject *const_str_plain___metaclass__;
static PyObject *const_str_plain_result_code;
extern PyObject *const_str_plain_d2i_PUBKEY_bio;
extern PyObject *const_int_pos_60;
extern PyObject *const_str_plain_callable;
static PyObject *const_str_plain_X509_subject_name_hash;
extern PyObject *const_str_plain_ERR_GET_REASON;
extern PyObject *const_str_plain_X509_NAME_dup;
static PyObject *const_str_plain_load_certificate_request;
static PyObject *const_str_plain_set_serial;
static PyObject *const_str_plain_X509_NAME_hash;
static PyObject *const_str_digest_1f7559cec53c5da336c35128000e1652;
extern PyObject *const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
extern PyObject *const_tuple_none_none_tuple;
static PyObject *const_str_plain_bignum_serial;
static PyObject *const_str_digest_39641ea33feffed70915f1c391cc979e;
static PyObject *const_str_digest_a12e23c82fcdd4004653da2260294f18;
extern PyObject *const_str_plain__evp_pkey_to_private_key;
extern PyObject *const_str_plain_X509_EXTENSION_free;
extern PyObject *const_str_plain_replace;
extern PyObject *const_str_plain_DNS;
static PyObject *const_str_plain_from_cryptography_key;
extern PyObject *const_str_digest_e33a7f733650e687efe98e5491512b82;
extern PyObject *const_str_plain_PEM_read_bio_X509;
static PyObject *const_str_digest_14af5bef46557b92b5b6c4d670b7a1b8;
static PyObject *const_str_digest_7db2dd03172a07cae912434bb4ced82e;
static PyObject *const_str_plain__cacerts;
static PyObject *const_str_plain_POLICY_CHECK;
static PyObject *const_str_plain_entry_index;
extern PyObject *const_str_plain__evp_pkey;
static PyObject *const_str_digest_80438074180d95b1a2291874613077b5;
static PyObject *const_str_digest_40ce736ad6e52bc3df10a00233b89318;
extern PyObject *const_str_plain_X509_get_notBefore;
extern PyObject *const_str_plain_revoked;
static PyObject *const_str_plain_sign_result;
static PyObject *const_tuple_str_plain_self_str_plain_amount_str_plain_notAfter_tuple;
extern PyObject *const_str_plain_self;
extern PyObject *const_str_plain_cessationOfOperation;
extern PyObject *const_int_pos_512;
static PyObject *const_tuple_str_plain_self_str_plain_spki_tuple;
static PyObject *const_str_digest_141cd36b231fb1bf7caa692f86984b7e;
static PyObject *const_str_plain_NetscapeSPKI;
static PyObject *const_str_digest_866d2e2176ccb47ef7515cbc6c993151;
extern PyObject *const_str_plain__PassphraseHelper;
static PyObject *const_str_plain_export;
static PyObject *const_str_plain_friendlyname_length;
extern PyObject *const_str_plain_name;
static PyObject *const_str_digest_c47cfcedcc7803c0a6ef28b85213e16f;
extern PyObject *const_str_plain_ASN1_TIME_to_generalizedtime;
static PyObject *const_str_plain_NETSCAPE_SPKI_get_pubkey;
static PyObject *const_str_plain_URI;
static PyObject *const_str_plain_ASN1_STRING_set_default_mask_asc;
extern PyObject *const_tuple_str_plain_deprecated_tuple;
extern PyObject *const_str_plain_PEM_read_bio_X509_CRL;
static PyObject *const_str_digest_463cb3c7dbe7753c6683d3195629dca3;
static PyObject *const_str_digest_75a631b53fc267af68d162051a06411c;
extern PyObject *const_str_empty;
static PyObject *const_str_plain_X509_V_FLAG_CRL_CHECK;
extern PyObject *const_str_plain_param;
extern PyObject *const_str_plain___setattr__;
static PyObject *const_str_plain_X509_NAME_add_entry_by_NID;
extern PyObject *const_tuple_str_space_str_empty_tuple;
static PyObject *const_str_plain_NetscapeSPKIType;
static PyObject *const_str_plain_INHIBIT_MAP;
static PyObject *const_str_digest_a078d66f5fc281c4117a5e5c24749809;
static PyObject *const_str_digest_1691c1bfd96a22cfc48aca410da45814;
extern PyObject *const_str_plain_X509_CRL_set_lastUpdate;
extern PyObject *const_str_plain_DSA_new;
static PyObject *const_str_plain_X509_V_FLAG_IGNORE_CRITICAL;
static PyObject *const_dict_5608fce8424ef5aca22387357d834999;
extern PyObject *const_str_plain_X509_EXTENSION_get_object;
extern PyObject *const_str_digest_2c0accc407028fbaba46fefdee9c6c06;
extern PyObject *const_str_plain_PEM_write_bio_X509_CRL;
extern PyObject *const_int_pos_24;
extern PyObject *const_tuple_str_digest_bc7a2d385ac0b4ca6f6caa64ccb6a3b9_int_pos_1_tuple;
static PyObject *const_str_digest_74b73fd54833bfb6b761307c477c0a28;
extern PyObject *const_str_plain_ASN1_TIME_new;
extern PyObject *const_str_plain_RSA_new;
static PyObject *const_list_b8e29824b436479d358fd3771a611e70_list;
static PyObject *const_str_digest_ac089bdfaafc466d410fc6ffe7dfee50;
extern PyObject *const_str_plain_ch;
static PyObject *const_tuple_str_digest_c561652c58984ec0e9541542aa405594_int_pos_512_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_when_str_plain_dt_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_crl_tuple;
static PyObject *const_str_digest_3121be4a855650e38916196ca238bf2b;
static PyObject *const_tuple_false_false_tuple;
extern PyObject *const_str_plain_text_type;
static PyObject *const_tuple_34a51bbef25f1a50174cde73cf717c0e_tuple;
extern PyObject *const_str_plain_Error;
extern PyObject *const_str_plain__set_asn1_time;
static PyObject *const_tuple_7eb0e743d38af9e33bf64e78c0ab103c_tuple;
extern PyObject *const_str_plain_X509_add_ext;
extern PyObject *const_str_plain_X509_REQ_add_extensions;
static PyObject *const_str_plain_get_type_name;
extern PyObject *const_str_plain__init;
extern PyObject *const_str_plain_sk_X509_EXTENSION_num;
extern PyObject *const_str_plain_boundary;
static PyObject *const_str_digest_d7980f3a0e05fb43bc9ed0fa0707a2f9;
static PyObject *const_str_digest_1f681e9f80c6df652cbc3a085be49171;
extern PyObject *const_str_plain__;
static PyObject *const_tuple_8291ba4d3b501c7d6047aff9c84147fc_tuple;
static PyObject *const_str_plain_new_reason_ext;
extern PyObject *const_str_plain_BIO_free;
static PyObject *const_str_plain_X509_V_FLAG_CB_ISSUER_CHECK;
static PyObject *const_str_digest_7d6056c968d1eebfab898757e6f3054e;
static PyObject *const_str_digest_721230a42e287d5632d061ff8f0376d6;
extern PyObject *const_str_plain_None;
static PyObject *const_str_digest_f583009b639aad56f3c96c175e595626;
static PyObject *const_tuple_10f3f1cb3df7aac52b98dbb720bf50d1_tuple;
static PyObject *const_str_plain__more_args;
extern PyObject *const_str_plain_ffi;
static PyObject *const_str_plain_set_notAfter;
static PyObject *const_str_digest_a7eaace656db47cf2975484b27c818e9;
static PyObject *const_str_plain_friendlyname_buffer;
static PyObject *const_str_plain__initialized;
static PyObject *const_str_plain_RSA_F4;
static PyObject *const_str_plain__read_passphrase;
extern PyObject *const_tuple_str_plain_self_str_plain_cert_tuple;
static PyObject *const_tuple_str_plain___tuple;
static PyObject *const_tuple_str_plain_self_str_plain_message_str_plain_certificate_tuple;
static PyObject *const_str_plain_maciter;
extern PyObject *const_str_plain_PKey;
static PyObject *const_str_plain__get_backend;
extern PyObject *const_str_plain_ext;
static PyObject *const_str_plain__set_name;
extern PyObject *const_str_plain_ASN1_INTEGER_to_BN;
extern PyObject *const_str_plain_OBJ_txt2nid;
static PyObject *const_str_digest_c4a5d29f3ecd810d59e3d04a7a935f38;
extern PyObject *const_str_plain_PY3;
extern PyObject *const_str_plain_pop;
static PyObject *const_str_plain_set_ca_certificates;
static PyObject *const_str_digest_0b708bb28192f1a165c843c47343f35a;
static PyObject *const_tuple_str_plain_dsa_str_plain_rsa_tuple;
extern PyObject *const_str_plain_DSA_free;
extern PyObject *const_str_plain_ASN1_TIME_set_string;
static PyObject *const_str_digest_ffd290e8bf49a587d94041b1fd6c3c55;
extern PyObject *const_str_plain_raise_if_problem;
static PyObject *const_str_plain_get_reason;
static PyObject *const_str_plain_answer;
static PyObject *const_tuple_str_plain_self_str_plain_encoded_str_plain_result_tuple;
extern PyObject *const_str_plain__lib;
static PyObject *const_str_plain_X509_VERIFY_PARAM_set_time;
static PyObject *const_str_plain_X509_REQ_get_version;
static PyObject *const_str_digest_989a9acfa289de1c2c451525451533c9;
static PyObject *const_str_digest_f3b04f8993b30e664e4afacb3d64cdc4;
static PyObject *const_str_plain_get_version;
static PyObject *const_str_digest_2e4273bc9cbcc16bcfe5bca70ee1b585;
static PyObject *const_str_plain_X509_REVOKED_delete_ext;
extern PyObject *const_str_plain_generate_key;
extern PyObject *const_tuple_str_plain_self_str_plain_backend_tuple;
extern PyObject *const_str_plain_partial;
extern PyObject *const_tuple_str_plain_self_tuple;
static PyObject *const_str_plain_dump_publickey;
extern PyObject *const_tuple_type_object_tuple;
static PyObject *const_str_plain_FILETYPE_TEXT;
extern PyObject *const_str_plain_EC_KEY_free;
extern PyObject *const_str_plain__exception_from_error_queue;
static PyObject *const_str_plain_PKCS12;
extern PyObject *const_str_plain_dump_certificate;
static PyObject *const_tuple_str_plain_self_str_plain_i_str_plain_obj_str_plain_ext_tuple;
static PyObject *const_str_plain_get_extension;
extern PyObject *const_str_plain_type;
extern PyObject *const_str_plain_ASN1_GENERALIZEDTIME_free;
static PyObject *const_str_digest_d0137950921f709b6c00a3276a078e5f;
static PyObject *const_str_digest_de1d9872d12371b2ead20f3aa79dc834;
extern PyObject *const_str_plain_decode;
static PyObject *const_str_plain_x509req;
extern PyObject *const_str_plain_to_cryptography;
static PyObject *const_str_digest_685b3ded6e482839a3710e6a448d8669;
extern PyObject *const_str_plain_cls;
extern PyObject *const_str_plain_strptime;
static PyObject *const_str_digest_dc9f0c0121231dfd2bb64dc64aae6cc9;
extern PyObject *const_str_plain_sk_X509_num;
static PyObject *const_str_plain_get_serial;
static PyObject *const_str_digest_9a71d9e6319c409dff859e67083fc41c;
static PyObject *const_str_digest_3a45faa244ca861d389c340b29a28988;
extern PyObject *const_tuple_str_plain_self_str_plain_revoked_tuple;
static PyObject *const_str_plain_num_curves;
extern PyObject *const_str_plain_i2d_X509_NAME;
static PyObject *const_str_plain_X509_STORE_free;
static PyObject *const_str_digest_ee89bc744832ab3afc27c4e7a4a73b66;
extern PyObject *const_str_plain_message;
static PyObject *const_str_plain_X509_V_FLAG_CHECK_SS_SIGNATURE;
static PyObject *const_str_digest_f019d8c1ebbf58631ace92b4423b3aad;
extern PyObject *const_str_plain__CertificateSigningRequest;
extern PyObject *const_str_plain_backend;
static PyObject *const_str_plain_set_version;
static PyObject *const_str_plain__X509NameInvalidator;
extern PyObject *const_str_plain_key;
extern PyObject *const_str_plain_object;
static PyObject *const_tuple_3feaf484c2a2250f0d395be4b333fb30_tuple;
extern PyObject *const_str_plain_cast;
extern PyObject *const_str_plain_curve;
extern PyObject *const_str_plain_size;
static PyObject *const_str_digest_d84b19202bfdec9cc8e6f9577d4fac5e;
extern PyObject *const_str_plain___ne__;
extern PyObject *const_str_plain_d2i_PKCS12_bio;
static PyObject *const_str_plain_octet_result;
static PyObject *const_str_plain_TYPE_DH;
extern PyObject *const_tuple_str_plain_x509_tuple;
extern PyObject *const_str_plain__text_to_bytes_and_warn;
static PyObject *const_tuple_5f27e2d018bfbbfa2690b5943a091bcc_tuple;
static PyObject *const_str_plain_PKCS7_type_is_signed;
extern PyObject *const_str_plain_i2d_X509_CRL_bio;
extern PyObject *const_str_plain_obj;
static PyObject *const_str_plain_X509_V_FLAG_CRL_CHECK_ALL;
static PyObject *const_str_plain__subject_invalidator;
static PyObject *const_str_plain_PKCS7_type_is_signedAndEnveloped;
extern PyObject *const_str_plain__cert;
static PyObject *const_str_digest_f68048107421fed17c8f1bc19be3ec03;
static PyObject *const_str_plain_set_time;
static PyObject *const_str_digest_8e9fba48e24a08144a915d52e31f6d23;
static PyObject *const_str_plain_X509_digest;
extern PyObject *const_str_plain_upper;
static PyObject *const_str_digest_5997506aef8ffc5e12c453030416acc6;
static PyObject *const_str_plain_X509_V_FLAG_X509_STRICT;
static PyObject *const_tuple_71acb4312fb0ef6e4480ea2334a6a994_tuple;
static PyObject *const_str_plain_passphrase;
static PyObject *const_str_digest_3918253e50729a002fea544312970ff5;
static PyObject *const_str_plain_type_is_data;
extern PyObject *const_str_plain_EVP_PKEY_DH;
static PyObject *const_str_plain_revoked_copy;
static PyObject *const_tuple_28746fdd1a6563b63939e82f1814a7ff_tuple;
static PyObject *const_str_digest_7b5d428ebb9708d902c18ce8ddfb3cbc;
static PyObject *const_str_plain_X509V3_set_ctx;
static PyObject *const_str_plain_get_elliptic_curve;
extern PyObject *const_str_plain_value;
extern PyObject *const_str_plain_store_ctx;
extern PyObject *const_str_plain_extension;
extern PyObject *const_str_plain_certificateHold;
extern PyObject *const_str_plain_X509_CRL_set_version;
static PyObject *const_str_digest_c71c443223c73b253b21961ef3bd7c9e;
static PyObject *const_str_digest_a643e6a1050d6f3782a0d190235d80a7;
extern PyObject *const_str_plain_email;
static PyObject *const_str_digest_35e2a27cee76091329550405e1cb7dc4;
static PyObject *const_str_plain_NETSCAPE_SPKI_free;
extern PyObject *const_str_plain_PEM_write_bio_PUBKEY;
static PyObject *const_str_plain_get_privatekey;
static PyObject *const_str_plain_X509_print_ex;
static PyObject *const_str_digest_b3f225987bb27e065a500d7fe8bd7c70;
extern PyObject *const_str_plain_DeprecationWarning;
extern PyObject *const_str_plain_i2d_X509_REQ_bio;
static PyObject *const_str_plain__extension;
static PyObject *const_str_digest_c0aedec8dc85440d3dace529a9d9050e;
static PyObject *const_str_plain_fval;
static PyObject *const_str_digest_5699814601a04aa972bd2f18de396c39;
static PyObject *const_str_digest_48639cf22fbd4e6b3714265dae0dbed8;
static PyObject *const_str_plain_string_data;
extern PyObject *const_str_plain_serial;
extern PyObject *const_int_pos_16;
static PyObject *const_str_plain_NETSCAPE_SPKI_verify;
static PyObject *const_str_digest_d6b3262f79e4b59cd83ab54699c92117;
static PyObject *const_str_plain_X509ExtensionType;
static PyObject *const_str_digest_1a7a898c4490dd89b305492a40bf2633;
static PyObject *const_str_plain_X509StoreType;
extern PyObject *const_tuple_str_plain__Certificate_tuple;
static PyObject *const_str_digest_016ce3807ea72a262d921fa7d1804717;
extern PyObject *const_str_plain_NULL;
extern PyObject *const_str_plain_X509_CRL_free;
static PyObject *const_str_plain_X509_STORE_CTX_init;
static PyObject *const_str_plain_dump_crl;
static PyObject *const_tuple_str_plain_self_str_plain_x509_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_key_str_plain_answer_tuple;
extern PyObject *const_str_plain_errors;
static PyObject *const_str_plain_get_issuer;
static PyObject *const_str_plain_X509_STORE_new;
static PyObject *const_list_298f4a46a008df82aecc87d37443e76b_list;
extern PyObject *const_str_plain_CertificateRevocationList;
static PyObject *const_str_plain_EVP_PKEY_bits;
extern PyObject *const_int_pos_1;
extern PyObject *const_str_plain_EVP_get_cipherbyname;
extern PyObject *const_str_plain_flags;
static PyObject *const_str_plain_set_flags;
static PyObject *const_str_plain__store_ctx;
extern PyObject *const_str_plain_X509_NAME_ENTRY_get_data;
extern PyObject *const_str_plain_RSAPrivateKey;
extern PyObject *const_str_plain_add_result;
static PyObject *const_str_plain_set_reason;
static PyObject *const_str_plain_cipher_obj;
extern PyObject *const_str_plain_X509_set_serialNumber;
extern PyObject *const_str_plain_cert;
static PyObject *const_str_plain_encode_result;
extern PyObject *const_str_plain_iter;
extern PyObject *const_str_plain_RSA_generate_key_ex;
extern PyObject *const_str_plain_X509_REQ_sign;
extern PyObject *const_str_plain_err_reason;
extern PyObject *const_str_plain_copy;
static PyObject *const_tuple_80a9571108770bd34772239ad97225a5_tuple;
static PyObject *const_str_digest_213346f5e36f3faf7ff7a566deec4adb;
extern PyObject *const_str_digest_c561652c58984ec0e9541542aa405594;
extern PyObject *const_tuple_str_digest_e33a7f733650e687efe98e5491512b82_tuple;
static PyObject *const_str_plain_amount;
static PyObject *const_str_plain_set_nextUpdate;
static PyObject *const_str_plain_PKCS7Type;
static PyObject *const_str_plain_CRL;
static PyObject *const_str_plain_md_ctx;
static PyObject *const_str_plain__cleanup;
extern PyObject *const_str_plain_X509_NAME_ENTRY_free;
static PyObject *const_str_digest_6b975dcb77568b31c2312e045b6c638c;
extern PyObject *const_str_space;
static PyObject *const_str_plain__bio_to_string;
static PyObject *const_str_digest_cac81eaf46e08badbc89f13fa3bbdf6b;
extern PyObject *const_str_plain_X509_REQ_get_extensions;
static PyObject *const_str_plain_X509_verify_cert;
extern PyObject *const_str_plain_sk_X509_value;
static PyObject *const_str_plain__get_asn1_time;
static PyObject *const_str_digest_3f7d687efa133ae490fe62a28c3c2584;
extern PyObject *const_str_plain_join;
extern PyObject *const_str_plain_EVP_PKEY_size;
extern PyObject *const_str_plain_ASN1_ENUMERATED_free;
static PyObject *const_str_digest_e4c79524acf8a72de25c6c6491f370a8;
static PyObject *const_str_plain_set_rev_date;
extern PyObject *const_str_plain_hash;
extern PyObject *const_str_digest_499043b9b2da602637f07b1aa101ddfb;
extern PyObject *const_tuple_str_plain_self_str_plain_pkey_tuple;
extern PyObject *const_str_plain_X509_CRL_add0_revoked;
extern PyObject *const_str_plain_Cryptography_EVP_MD_CTX_free;
extern PyObject *const_str_plain_version;
extern PyObject *const_str_plain_GEN_EMAIL;
static PyObject *const_str_plain_load_certificate;
extern PyObject *const_str_plain_X509_REQ_set_version;
static PyObject *const_str_plain_X509_STORE_CTX_free;
static PyObject *const_str_digest_719137938e890576c1050ba31a668078;
static PyObject *const_str_digest_500f278b67471fc0f770fccc80d65d95;
static PyObject *const_str_digest_193e0ef9a8bffd6c41bf909f2da817bd;
static PyObject *const_str_digest_ab9563b0fc32f09cfde9a1636d8d2b80;
extern PyObject *const_str_plain___ge__;
static PyObject *const_str_plain_X509Extension;
extern PyObject *const_str_plain_PEM_read_bio_PUBKEY;
extern PyObject *const_str_plain___eq__;
extern PyObject *const_str_plain___le__;
static PyObject *const_str_digest_6ef28169edd3cfe530885f6f9d09c390;
extern PyObject *const_str_plain_EVP_PKEY_RSA;
static PyObject *const_str_digest_b1f5a355e1403668d0044e1a65ec29ce;
static PyObject *const_tuple_13745beac221529fe5d89135e9b648d3_tuple;
extern PyObject *const_str_plain_BN_hex2bn;
static PyObject *const_str_digest_c237653198d1acecae3452511968b22e;
static PyObject *const_str_plain_type_is_signed;
static PyObject *const_str_digest_af63c2663b0a5e83daac69d308dcb1d6;
extern PyObject *const_str_plain_FILETYPE_ASN1;
extern PyObject *const_str_plain_BIO_new;
static PyObject *const_str_plain_get_friendlyname;
extern PyObject *const_str_plain_X509_get_issuer_name;
static PyObject *const_str_plain_set_friendlyname;
static PyObject *const_tuple_7df0279ef5fffac2c0a66ea7c472ab4b_tuple;
static PyObject *const_str_plain__untested_error;
static PyObject *const_str_plain_load_publickey;
extern PyObject *const_str_plain_i;
extern PyObject *const_str_plain__openssl_assert;
extern PyObject *const_str_plain_d;
static PyObject *const_tuple_e0284b4dc341731363d45f065b316e64_tuple;
extern PyObject *const_str_plain_f;
extern PyObject *const_str_plain_crl;
extern PyObject *const_str_plain_hex_str;
static PyObject *const_tuple_f62306bb1360dfa87574f464cff0b6db_tuple;
extern PyObject *const_str_plain_c;
static PyObject *const_str_digest_1dbb147d3e039266688c4d87287eaaad;
static PyObject *const_str_digest_0d3c537bf958e2cc2494cf1be5c283dd;
static PyObject *const_tuple_53b63b794c8b8f328f3f365985abd328_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_pkey_str_plain_result_tuple;
static PyObject *const_str_plain_X509_STORE_set_flags;
extern PyObject *const_str_plain_buffer;
extern PyObject *const_tuple_str_digest_c075052d723d6707083e869a0e3659bb_tuple;
extern PyObject *const_str_plain_X509_NAME_ENTRY_get_object;
static PyObject *const_tuple_be611311fb5723111b9692ddf834f10b_tuple;
static PyObject *const_str_digest_9c28b2ef32679900c21c54152be8ce03;
extern PyObject *const_str_plain_X509_CRL_sign;
static PyObject *const_str_digest_4097a084fab55cf5c5baa1b785e7c82a;
extern PyObject *const_str_plain_r;
static PyObject *const_str_digest_f35548e1d45f67292233a83f1d0adcce;
static PyObject *const_str_plain_get_extensions;
static PyObject *const_str_plain_algor;
static PyObject *const_str_digest_92b8d1a7fa93b4e7d2fab02e37bc15f8;
static PyObject *const_str_plain_EVP_SignFinal;
extern PyObject *const_str_plain__x509_crl;
extern PyObject *const_str_plain_X509Store;
extern PyObject *const_str_plain_names;
extern PyObject *const_str_plain_write_bio;
extern PyObject *const_str_plain_cryptography;
static PyObject *const_str_plain_get_notAfter;
extern PyObject *const_str_plain_EVP_PKEY_get1_RSA;
static PyObject *const_str_plain__set_boundary_time;
static PyObject *const_str_digest_1a3a564060f5ebd53d44f6035495ba48;
extern PyObject *const_str_plain_DSAPublicKey;
extern PyObject *const_str_plain___repr__;
extern PyObject *const_str_plain_FILETYPE_PEM;
extern PyObject *const_str_plain_superseded;
extern PyObject *const_str_plain_native;
static PyObject *const_str_plain_CB_ISSUER_CHECK;
static PyObject *const_str_plain__issuer_invalidator;
static PyObject *const_str_plain_PKCS7_type_is_enveloped;
extern PyObject *const_str_plain__PY3;
static PyObject *const_str_plain_ASN1_STRING_type;
static PyObject *const_tuple_str_plain_self_str_plain_string_type_str_plain_nid_tuple;
static PyObject *const_tuple_str_plain_cls_str_plain_x509_str_plain_cert_tuple;
extern PyObject *const_str_plain___all__;
static PyObject *const_str_digest_117006b03ff8e10f330ac900a6cd41e8;
static PyObject *const_str_digest_221848055f0a545c7ef1969a37bb78a5;
static PyObject *const_str_plain_EC_get_builtin_curves;
static PyObject *const_str_plain_asn1_serial;
extern PyObject *const_str_plain_six;
extern PyObject *const_str_plain_X509_REVOKED_get_ext_count;
extern PyObject *const_str_plain_GENERAL_NAMES_free;
extern PyObject *const_str_plain_Cryptography_EVP_MD_CTX_new;
extern PyObject *const_str_plain__cmp;
extern PyObject *const_str_plain_d2i_X509_bio;
extern PyObject *const_str_plain___debug__;
extern PyObject *const_str_plain_sk_GENERAL_NAME_value;
extern PyObject *const_str_plain_callback;
static PyObject *const_str_digest_0226e12d6e09b849c37787a1a7ec35a4;
static PyObject *const_str_plain_pyrev;
extern PyObject *const_str_plain_sk_X509_REVOKED_value;
static PyObject *const_str_plain_set_serial_number;
static PyObject *const_str_digest_bbde1e297eda38e770b8fce1d06c225b;
static PyObject *const_str_digest_3b5fd85224219fd172d589ec8f98a12a;
static PyObject *const_tuple_8110525d9a52cec647809d72afbc7239_tuple;
static PyObject *const_str_digest_4560cdf69c017b7cd264323295e708cb;
static PyObject *const_tuple_13d990c39f45e826db58a38b07f9cd95_tuple;
static PyObject *const_tuple_1598e2e44a7cbbc56ff6b01a61982114_tuple;
static PyObject *const_str_digest_5e37d069c5e76ee6d50c7e91b7181934;
extern PyObject *const_str_plain___gt__;
static PyObject *const_str_plain_b16encode;
static PyObject *const_tuple_f6b86765c5a5e2cb7660564ebdcec2d7_tuple;
static PyObject *const_str_digest_c85d62bfc2af2f3c2202464fd6374ea7;
static PyObject *const_tuple_4415e41d2d925845f2ba634f8c71f0dc_tuple;
static PyObject *const_str_plain_EVP_SignUpdate;
static PyObject *const_str_plain_digest_name;
extern PyObject *const_str_plain_X509_get_ext;
static PyObject *const_str_digest_0b9d4db9119537682a1f5302a9cbcc57;
extern PyObject *const_str_plain_X509_REQ_verify;
extern PyObject *const_str_plain_GEN_URI;
static PyObject *const_str_plain_X509_V_FLAG_EXPLICIT_POLICY;
static PyObject *const_str_plain_PKCS7_free;
static PyObject *const_str_digest_1d1fec7c0642196df296efbe43db1801;
static PyObject *const_str_plain_exts;
static PyObject *const_str_plain_TYPE_EC;
static PyObject *const_str_plain_rwflag;
static PyObject *const_tuple_str_plain_type_str_plain_buffer_str_plain_bio_str_plain_x509_tuple;
static PyObject *const_tuple_str_digest_4560cdf69c017b7cd264323295e708cb_tuple;
static PyObject *const_str_plain_CRL_CHECK_ALL;
static PyObject *const_str_digest_d85051204198165c5d51e35c1e5d5077;
static PyObject *const_str_digest_a2b9bb33a11d02b696dfc736bf45c56d;
static PyObject *const_str_plain_TYPE_DSA;
extern PyObject *const_str_plain_pycert;
static PyObject *const_str_plain_M_ASN1_OCTET_STRING_print;
static PyObject *const_str_digest_07697dd6fa4854473fa24b52569d5636;
static PyObject *const_str_plain_has_expired;
static PyObject *const_str_plain_gmtime_adj_notAfter;
extern PyObject *const_str_plain_extensions;
static PyObject *const_str_plain__EllipticCurve;
static PyObject *const_str_digest_007f81c06fa49e709fd9306cc6c26627;
static PyObject *const_str_plain_X509Req;
extern PyObject *const_str_plain_BN_free;
extern PyObject *const_str_plain_CertificateSigningRequest;
static PyObject *const_str_plain_small_serial;
static PyObject *const_str_plain_X509_STORE_add_cert;
static PyObject *const_str_plain_revoked_stack;
extern PyObject *const_str_plain_nid;
extern PyObject *const_str_plain_property;
extern PyObject *const_str_plain_X509_get_notAfter;
static PyObject *const_str_plain_X509_STORE_CTX_new;
extern PyObject *const_str_plain_X509_dup;
static PyObject *const_str_plain_digest_result;
extern PyObject *const_str_plain_BN_new;
static PyObject *const_tuple_str_plain__CertificateRevocationList_tuple;
extern PyObject *const_str_plain_helper;
extern PyObject *const_str_plain_BN_to_ASN1_INTEGER;
extern PyObject *const_str_plain_X509_REVOKED_new;
static PyObject *const_str_plain_issuer_cert;
static PyObject *const_tuple_str_plain_self_str_plain__issuer_str_plain_issuer_tuple;
static PyObject *const_str_plain_gmtime_adj_notBefore;
extern PyObject *const_str_digest_9838c39bdf9fdb401c17b0106d8660a3;
extern PyObject *const_str_plain_Cryptography_X509_REVOKED_dup;
extern PyObject *const_str_plain__name;
static PyObject *const_str_plain__exception_from_context;
static PyObject *const_tuple_str_plain_self_str_plain_rsa_str_plain_result_tuple;
static PyObject *const_str_plain_X509_STORE_set1_param;
static PyObject *const_str_plain_get_critical;
static PyObject *const_str_plain_print_result;
extern PyObject *const_str_plain_length;
static PyObject *const_tuple_str_plain_cls_str_plain_lib_str_plain_nid_tuple;
extern PyObject *const_str_plain_encoded;
static PyObject *const_str_plain__req;
static PyObject *const_str_plain_X509_CRL_sort;
extern PyObject *const_str_plain_sk_X509_EXTENSION_value;
static PyObject *const_str_digest_4d14f6e4d6647c6573e3ca9449c2b51f;
static PyObject *const_str_plain__prefixes;
static PyObject *const_tuple_5209455ecbb28249752027c3a839ae1c_tuple;
extern PyObject *const_str_plain_OBJ_nid2sn;
extern PyObject *const_str_plain_d2i_X509_REQ_bio;
extern PyObject *const_str_plain_ASN1_INTEGER_free;
extern PyObject *const_tuple_str_plain_self_str_plain_req_tuple;
extern PyObject *const_str_plain_lib;
static PyObject *const_str_plain_PEM_write_bio_PrivateKey;
static PyObject *const_str_plain_PEM_read_bio_PKCS7;
static PyObject *const_str_plain_friendlyname;
static PyObject *const_tuple_str_plain_self_str_plain_which_tuple;
static PyObject *const_str_digest_0ba82c04a076f46925a74539c2a8ba40;
extern PyObject *const_str_plain_ERR_peek_error;
static PyObject *const_tuple_str_plain_self_str_plain_amount_str_plain_notBefore_tuple;
static PyObject *const_str_plain_to_cryptography_key;
extern PyObject *const_str_plain_algorithm;
static PyObject *const_str_digest_97388c7ddfea4f913fec5c846dd26ef1;
static PyObject *const_tuple_79603f0465bd62773d6ec6c98e743896_tuple;
static PyObject *const_str_digest_e2d15f7f418fdd55a54be9ea476feee3;
static PyObject *const_str_plain_NETSCAPE_SPKI_sign;
static PyObject *const_tuple_str_plain_self_str_plain_bio_str_plain_print_result_tuple;
static PyObject *const_str_digest_61d70cefdce1472400ab8a06d64ef78a;
extern PyObject *const_str_plain_parts;
static PyObject *const_str_plain_load_privatekey;
static PyObject *const_tuple_str_digest_f3b04f8993b30e664e4afacb3d64cdc4_tuple;
static PyObject *const_str_plain_buffer_length;
static PyObject *const_str_plain_bn_result;
static PyObject *const_tuple_str_plain_cls_str_plain_crypto_req_str_plain_req_tuple;
static PyObject *const_str_digest_e19f4eaf61167e65441aca909fe75b36;
static PyObject *const_str_plain_hex_serial;
static PyObject *const_str_plain_MBSTRING_UTF8;
static PyObject *const_tuple_str_plain_self_str_plain_cacerts_str_plain_cert_tuple;
static PyObject *const_str_plain_Revoked;
extern PyObject *const_str_plain___str__;
extern PyObject *const_str_plain_PKCS12_parse;
static PyObject *const_str_plain__only_public;
extern PyObject *const_tuple_str_plain_self_str_plain_dt_tuple;
extern PyObject *const_str_plain_affiliationChanged;
extern PyObject *const_str_plain_evp_md;
extern PyObject *const_str_plain__store;
extern PyObject *const_str_plain_X509_CRL_get_REVOKED;
static PyObject *const_str_plain_GENERAL_NAME_print;
static PyObject *const_str_plain__names;
static PyObject *const_str_digest_c57795fb6a9ac3d47e928f9a8b608571;
static PyObject *const_tuple_str_plain_self_str_plain_store_tuple;
extern PyObject *const_str_plain_ascii;
extern PyObject *const_str_plain_type_name;
static PyObject *const_str_plain_CACompromise;
static PyObject *const_tuple_str_plain_self_str_plain_vfy_time_str_plain_param_tuple;
extern PyObject *const_str_plain_X509_REVOKED_get_ext;
static PyObject *const_str_plain_add_extensions;
static PyObject *const_str_plain_EVP_VerifyInit;
static PyObject *const_str_digest_880f67f2b28115a7ad1d1bfb533fc6bc;
static PyObject *const_str_plain_NID_crl_reason;
static PyObject *const_str_digest_eee7b0934fe224b34ba6722d84ccd2bf;
extern PyObject *const_str_digest_b9c4baf879ebd882d40843df3a4dead7;
static PyObject *const_str_plain_generalized_timestamp;
extern PyObject *const_tuple_int_0_tuple;
static PyObject *const_str_plain_X509StoreContextError;
static PyObject *const_str_digest_b2d5bbfa3f949ddcc231b89e71aa8d92;
extern PyObject *const_str_plain_utcnow;
static PyObject *const_tuple_str_plain_name_str_plain_curve_tuple;
extern PyObject *const_str_plain_X509_get_version;
static PyObject *const_str_plain_notAfter;
static PyObject *const_str_plain_X509_V_FLAG_INHIBIT_MAP;
static PyObject *const_tuple_str_plain_cls_str_plain_crypto_key_str_plain_pkey_tuple;
static PyObject *const_str_digest_fdf1281f34921aa68eda346883bb972d;
static PyObject *const_str_digest_cf86a9123926465ab14a7bd2861326f6;
static PyObject *const_tuple_str_plain_buffer_str_plain_bio_str_plain_data_str_plain_free_tuple;
extern PyObject *const_str_plain_sk_X509_free;
static PyObject *const_str_plain__owner;
static PyObject *const_tuple_21bd89dfe3a1dd3e39e03972a01f5a89_tuple;
extern PyObject *const_str_plain_X509_REQ_get_subject_name;
extern PyObject *const_str_plain_X509_EXTENSION_get_critical;
extern PyObject *const_str_plain___module__;
static PyObject *const_str_plain_ASN1_STRING_data;
static PyObject *const_str_digest_819566a56c114d5ab553db6b3a965184;
static PyObject *const_str_plain_sk_X509_new_null;
extern PyObject *const_str_plain_lower;
static PyObject *const_str_plain_ASN1_STRING_length;
static PyObject *const_tuple_str_digest_016ce3807ea72a262d921fa7d1804717_tuple;
static PyObject *const_str_plain_type_is_signedAndEnveloped;
static PyObject *const_tuple_c1e1b7e48a4d24180e53a91b4e9e45ad_tuple;
static PyObject *const_str_plain_X509_NAME_oneline;
static PyObject *const_str_digest_35f6b1c1261cd55e34a5b00d6cb8d5ea;
extern PyObject *const_str_plain_X509_get_pubkey;
extern PyObject *const_str_plain__x509_req;
static PyObject *const_str_digest_c623dd0c947983ab2cfcbe4c53400720;
static PyObject *const_str_plain_pkcs7;
static PyObject *const_str_digest_9acbe023ce14d1d2ba528bd23b2423a0;
static PyObject *const_str_plain_certificate;
extern PyObject *const_str_plain_exception_from_error_queue;
extern PyObject *const_str_plain_DSA_generate_key;
extern PyObject *const_str_plain_SSL_load_error_strings;
static PyObject *const_str_plain_EVP_PKEY_type;
extern PyObject *const_str_plain__x509;
static PyObject *const_tuple_aa595f479ccfd6af3a4dde57a871f8ed_tuple;
static PyObject *const_str_plain_verify_result;
static PyObject *const_tuple_48783f9f765e1ca05b39b42cba82d1fc_tuple;
static PyObject *const_str_digest_f76c1a90d81cc9627b0b6df42991dbc9;
extern PyObject *const_str_plain_string;
extern PyObject *const_tuple_str_plain_self_str_plain_key_tuple;
static PyObject *const_str_digest_2cf9e4c7f607857df636a128997ff3fc;
extern PyObject *const_str_plain_p12;
static PyObject *const_tuple_d23f6dfb17b5708d3504cb59648ebed0_tuple;
static PyObject *const_str_plain_dump_privatekey;
static PyObject *const_str_digest_686e4f9f1c51b7038afe792590c33346;
static PyObject *const_str_digest_0d8911e895179dcd467b4e9de2f411d4;
extern PyObject *const_int_pos_65535;
static PyObject *const_str_plain__load_elliptic_curves;
static PyObject *const_str_plain_pykey;
static PyObject *const_str_plain__pkcs7;
extern PyObject *const_str_plain_EVP_PKEY_set1_DSA;
static PyObject *const_str_plain__get_boundary_time;
extern PyObject *const_str_plain_sk_GENERAL_NAME_num;
static PyObject *const_tuple_7fda6bda0dce687e350e407f685c57f6_tuple;
static PyObject *const_tuple_str_plain_ASN1_TIME_to_generalizedtime_tuple;
static PyObject *const_str_plain_pem_password_cb;
static PyObject *const_tuple_64996e5d3f2714cc368d8bf48665c67a_tuple;
static PyObject *const_tuple_c5e29833751f21ea567c72bd68a6420e_tuple;
static PyObject *const_str_digest_4a193fbd1ccf06765e0cb44620b7d74a;
static PyObject *const_str_plain_X509_STORE_add_crl;
static PyObject *const_str_plain_PKCS7;
static PyObject *const_tuple_str_plain_cls_str_plain_crypto_crl_str_plain_crl_tuple;
extern PyObject *const_str_plain_ret;
extern PyObject *const_str_plain_functools;
extern PyObject *const_str_plain_RSAPublicKey;
static PyObject *const_str_plain_final_result;
static PyObject *const_tuple_str_digest_80438074180d95b1a2291874613077b5_tuple;
static PyObject *const_str_plain_X509_get0_tbs_sigalg;
static PyObject *const_tuple_d959e8503cbe0fd15122162c0da60661_tuple;
extern PyObject *const_str_plain_byte_string;
extern PyObject *const_str_plain_get_data;
static PyObject *const_str_plain_X509_alias_get0;
static PyObject *const_str_plain_notBefore;
static PyObject *const_str_plain_crypto_crl;
static PyObject *const_str_plain_X509_NAME_cmp;
static PyObject *const_str_plain__integer_types;
static PyObject *const_str_plain_PKCS12Type;
extern PyObject *const_str_plain_other;
static PyObject *const_str_plain_EXPLICIT_POLICY;
extern PyObject *const_str_plain_X509_REQ_set_pubkey;
extern PyObject *const_str_plain_label;
static PyObject *const_str_plain_signature_length;
extern PyObject *const_str_plain_i2d_PUBKEY_bio;
static PyObject *const_str_plain_set_issuer;
static PyObject *const_str_plain_ASN1_INTEGER_set;
static PyObject *const_str_plain_when;
extern PyObject *const_str_plain_BN_bn2hex;
static PyObject *const_str_digest_08a0d510acdd77f37b666a4668538f96;
static PyObject *const_str_digest_713d8c2afef94db133cda1bff1cb496f;
extern PyObject *const_str_plain_OPENSSL_free;
static PyObject *const_str_digest_2dbcbe3e7da77178b4a9da40244d072a;
extern PyObject *const_str_plain_truncate;
extern PyObject *const_str_plain_strftime;
static PyObject *const_str_digest_0d925750cb36e0c0e5f47f40c47790e6;
extern PyObject *const_str_plain_X509_CRL_get_issuer;
extern PyObject *const_str_plain_deprecated;
static PyObject *const_str_digest_66b2a3b8e35254752e96fbbddc255dfd;
static PyObject *const_str_digest_998fe297d663eb0475d60a56d2b84182;
static PyObject *const_str_digest_859c7c43c5cf3124cdd58374d6e7359e;
static PyObject *const_str_plain_BN_set_word;
extern PyObject *const_str_plain_BIO_s_mem;
extern PyObject *const_str_plain_X509_REVOKED_get0_serialNumber;
static PyObject *const_str_digest_3c820c2fc1d76f73132dab0e4e8d3a14;
static PyObject *const_str_digest_bb334a0dc943b8e820be149d2c515af0;
static PyObject *const_tuple_57dca116533b0d6d636b268e7001e41b_tuple;
static PyObject *const_str_plain_crypto_key;
extern PyObject *const_str_plain_bio;
static PyObject *const_str_plain_pycacert;
extern PyObject *const_str_digest_db35ab94a03c3cbeb13cbe2a1d728b77;
static PyObject *const_str_plain_subject_name_hash;
static PyObject *const_tuple_str_plain__CertificateSigningRequest_tuple;
static PyObject *const_str_digest_6b664ec0d0974a050be8b09b84bd0a5d;
extern PyObject *const_tuple_str_plain_self_str_plain_name_tuple;
extern PyObject *const_str_plain_text_to_bytes_and_warn;
extern PyObject *const_str_digest_2b6a6c0099f1f1dd77d2725acd0722df;
static PyObject *const_str_digest_4b3673d04a6e4a628e29457d54d43c0d;
static PyObject *const_str_plain_X509ReqType;
extern PyObject *const_str_plain_set_result;
extern PyObject *const_str_plain_EVP_get_digestbyname;
static PyObject *const_str_plain_V_ASN1_GENERALIZEDTIME;
extern PyObject *const_str_plain__to_EC_KEY;
extern PyObject *const_tuple_str_plain_backend_tuple;
extern PyObject *const_str_plain_sk_X509_REVOKED_num;
extern PyObject *const_str_plain_evp_pkey;
static PyObject *const_str_plain_get_revoked;
static PyObject *const_str_plain_dump_certificate_request;
extern PyObject *const_str_plain_buf;
static PyObject *const_str_plain_data_length;
static PyObject *const_str_plain_X509_gmtime_adj;
extern PyObject *const_str_plain_get_subject;
static PyObject *const_str_plain_NETSCAPE_SPKI_set_pubkey;
static PyObject *const_str_digest_6b6b180b644052fa34c3e81151f6ea0a;
static PyObject *const_str_plain_get_signature_algorithm;
extern PyObject *const_str_chr_58;
extern PyObject *const_str_plain_entry;
static PyObject *const_str_plain_ALLOW_PROXY_CERTS;
static PyObject *const_str_plain_PKCS7_type_is_data;
extern PyObject *const_str_plain_index;
static PyObject *const_str_plain_free;
extern PyObject *const_str_plain_X509V3_EXT_d2i;
extern PyObject *const_str_plain___doc__;
static PyObject *const_str_plain__delete_reason;
static PyObject *const_str_plain_X509NameType;
static PyObject *const_str_digest_6674ab14e1178de501dfb968278a50b9;
extern PyObject *const_str_digest_81f1b0dfcc7a862e6940580ec4cc42d3;
static PyObject *const_tuple_aacd84e9abfa73a83f6f088507b53506_tuple;
static PyObject *const_str_plain_verify_certificate;
static PyObject *const_str_digest_8ad6e418a1b04e7939cf7e738b8257d2;
static PyObject *const_tuple_none_int_pos_2048_int_pos_1_tuple;
extern PyObject *const_tuple_type_Exception_tuple;
static PyObject *const_str_plain_NETSCAPE_SPKI_b64_encode;
static PyObject *const_tuple_788a505d6e43a02df061e74659415d8f_tuple;
extern PyObject *const_str_plain_GEN_DNS;
static PyObject *const_str_plain_get_pubkey;
static PyObject *const_tuple_str_digest_5339fa8ff3df372e54ef7b09078767aa_tuple;
static PyObject *const_str_digest_cd7d7b6c262cf257f5bafa26f39b567e;
static PyObject *const_str_plain_NETSCAPE_SPKI_new;
static PyObject *const_str_digest_1c1759444507dc6d4c0d7b4ce6b62611;
extern PyObject *const_str_plain_X509_CRL_get_lastUpdate;
static PyObject *const_str_plain_result_length;
static PyObject *const_str_digest_2c2564e59b067260d7d96d252fc73cd1;
static PyObject *const_str_plain_crypto_cert;
static PyObject *const_str_plain__subjectAltNameString;
extern PyObject *const_tuple_none_tuple;
static PyObject *const_tuple_270cfc7fce9aafdf0c3eb9f2164206f4_tuple;
extern PyObject *const_str_plain_keyCompromise;
static PyObject *const_str_plain__byte_string;
static PyObject *const_tuple_str_plain_boundary_str_plain_when_str_plain_set_result_tuple;
static PyObject *const_str_plain__curves;
extern PyObject *const_str_plain_reason;
static PyObject *const_str_digest_9226325aac109a91f8326c1a26ede065;
static PyObject *const_tuple_str_digest_0d925750cb36e0c0e5f47f40c47790e6_tuple;
static PyObject *const_str_digest_4357c956c1f3628f437632877b5d8593;
static PyObject *const_str_digest_b16563a844474e8eed4710209909ab32;
static PyObject *const_str_digest_8bcf6e6fbaf96377cbe58ba9960c9d58;
extern PyObject *const_str_plain_X509_STORE_CTX_get_error_depth;
extern PyObject *const_str_plain_ASN1_ENUMERATED_new;
static PyObject *const_str_plain_X509_REQ_print_ex;
static PyObject *const_str_digest_e2d5c2f473553b6759cc455da987e04a;
static PyObject *const_str_plain_ent;
extern PyObject *const_str_plain_X509;
static PyObject *const_str_plain_add_revoked;
extern PyObject *const_str_plain_i2d_X509_bio;
static PyObject *const_str_digest_290681512f72ca11cbf3e4827987aabb;
extern PyObject *const_str_plain_d2i_X509_CRL_bio;
extern PyObject *const_str_plain_ASN1_ENUMERATED_set;
static PyObject *module_filename_obj;

/* Indicator if this modules private constants were created yet. */
static bool constants_created = false;

/* Function to create module private constants. */
static void createModuleConstants(void) {
    const_str_plain_set_lastUpdate = UNSTREAM_STRING(&constant_bin[ 125401 ], 14, 1);
    const_str_plain_OBJ_nid2ln = UNSTREAM_STRING(&constant_bin[ 125415 ], 10, 1);
    const_str_digest_340717166d8c6af86f5d8a6e35ed5a7f = UNSTREAM_STRING(&constant_bin[ 125425 ], 14, 0);
    const_str_digest_014a797afcc3e1ad4f3e6e9aa4631a8a = UNSTREAM_STRING(&constant_bin[ 125439 ], 68, 0);
    const_str_digest_73f7a7ef7b02ca8c5d7fdfe1049be561 = UNSTREAM_STRING(&constant_bin[ 125507 ], 18, 0);
    const_str_plain__truncate = UNSTREAM_STRING(&constant_bin[ 125525 ], 9, 1);
    const_str_plain_RSA_check_key = UNSTREAM_STRING(&constant_bin[ 125534 ], 13, 1);
    const_str_plain_X509_NAME_get_index_by_NID = UNSTREAM_STRING(&constant_bin[ 125547 ], 26, 1);
    const_str_plain_issuer_key = UNSTREAM_STRING(&constant_bin[ 29048 ], 10, 1);
    const_str_digest_978cd476d4acffdfb043e6a5e0ebae26 = UNSTREAM_STRING(&constant_bin[ 125573 ], 258, 0);
    const_tuple_349fb4cb1ce06b9a51a79a6cd36ef36b_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_349fb4cb1ce06b9a51a79a6cd36ef36b_tuple, 0, const_str_plain_cls); Py_INCREF(const_str_plain_cls);
    PyTuple_SET_ITEM(const_tuple_349fb4cb1ce06b9a51a79a6cd36ef36b_tuple, 1, const_str_plain_lib); Py_INCREF(const_str_plain_lib);
    const_str_plain_builtin_curves = UNSTREAM_STRING(&constant_bin[ 125831 ], 14, 1);
    PyTuple_SET_ITEM(const_tuple_349fb4cb1ce06b9a51a79a6cd36ef36b_tuple, 2, const_str_plain_builtin_curves); Py_INCREF(const_str_plain_builtin_curves);
    const_str_plain_num_curves = UNSTREAM_STRING(&constant_bin[ 125845 ], 10, 1);
    PyTuple_SET_ITEM(const_tuple_349fb4cb1ce06b9a51a79a6cd36ef36b_tuple, 3, const_str_plain_num_curves); Py_INCREF(const_str_plain_num_curves);
    const_tuple_0c127564cb8e0f10a9444ae3c25de3f1_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_0c127564cb8e0f10a9444ae3c25de3f1_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_0c127564cb8e0f10a9444ae3c25de3f1_tuple, 1, const_str_plain__CertificateRevocationList); Py_INCREF(const_str_plain__CertificateRevocationList);
    PyTuple_SET_ITEM(const_tuple_0c127564cb8e0f10a9444ae3c25de3f1_tuple, 2, const_str_plain_backend); Py_INCREF(const_str_plain_backend);
    const_str_plain_not_after = UNSTREAM_STRING(&constant_bin[ 125855 ], 9, 1);
    const_str_plain_X509_V_FLAG_POLICY_CHECK = UNSTREAM_STRING(&constant_bin[ 125864 ], 24, 1);
    const_str_digest_b52a484c26b348bfec0a17217a58ad7e = UNSTREAM_STRING(&constant_bin[ 125888 ], 44, 0);
    const_str_digest_8fda740163dc7d07c78736dc2ebb17b1 = UNSTREAM_STRING(&constant_bin[ 125932 ], 250, 0);
    const_str_plain_all_reasons = UNSTREAM_STRING(&constant_bin[ 126182 ], 11, 1);
    const_tuple_str_plain_self_str_plain_which_str_plain_name_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_which_str_plain_name_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    const_str_plain_which = UNSTREAM_STRING(&constant_bin[ 87432 ], 5, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_which_str_plain_name_tuple, 1, const_str_plain_which); Py_INCREF(const_str_plain_which);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_which_str_plain_name_tuple, 2, const_str_plain_name); Py_INCREF(const_str_plain_name);
    const_str_digest_90de967a5219b9210479f7eac5c285c8 = UNSTREAM_STRING(&constant_bin[ 126193 ], 105, 0);
    const_str_digest_e335a7c8a0dd4d8ab6096b1597d79143 = UNSTREAM_STRING(&constant_bin[ 126298 ], 237, 0);
    const_tuple_str_plain_self_str_plain_which_str_plain_when_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_which_str_plain_when_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_which_str_plain_when_tuple, 1, const_str_plain_which); Py_INCREF(const_str_plain_which);
    const_str_plain_when = UNSTREAM_STRING(&constant_bin[ 88495 ], 4, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_which_str_plain_when_tuple, 2, const_str_plain_when); Py_INCREF(const_str_plain_when);
    const_str_digest_a9bcf1af78e6d912e13685d8a606fe30 = UNSTREAM_STRING(&constant_bin[ 126535 ], 170, 0);
    const_str_plain_TYPE_RSA = UNSTREAM_STRING(&constant_bin[ 3359 ], 8, 1);
    const_str_plain_X509_VERIFY_PARAM_free = UNSTREAM_STRING(&constant_bin[ 126705 ], 22, 1);
    const_str_digest_52cbe8d655a10e46907a30970ef9889a = UNSTREAM_STRING(&constant_bin[ 126727 ], 215, 0);
    const_str_plain_sk_X509_EXTENSION_free = UNSTREAM_STRING(&constant_bin[ 126942 ], 22, 1);
    const_str_digest_435662c26b2c422edb954b82c85c55d9 = UNSTREAM_STRING(&constant_bin[ 126964 ], 288, 0);
    const_str_digest_f737de4a45174195dc1e46101235dc35 = UNSTREAM_STRING(&constant_bin[ 127252 ], 144, 0);
    const_str_plain_get_rev_date = UNSTREAM_STRING(&constant_bin[ 127396 ], 12, 1);
    const_str_digest_3d684470d9353bc1a1e8d63a3aab4679 = UNSTREAM_STRING(&constant_bin[ 127408 ], 15, 0);
    const_tuple_str_plain_cls_str_plain_lib_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_cls_str_plain_lib_tuple, 0, const_str_plain_cls); Py_INCREF(const_str_plain_cls);
    PyTuple_SET_ITEM(const_tuple_str_plain_cls_str_plain_lib_tuple, 1, const_str_plain_lib); Py_INCREF(const_str_plain_lib);
    const_str_plain_X509StoreContext = UNSTREAM_STRING(&constant_bin[ 4016 ], 16, 1);
    const_str_plain__get_elliptic_curves = UNSTREAM_STRING(&constant_bin[ 127423 ], 20, 1);
    const_str_plain_string_type = UNSTREAM_STRING(&constant_bin[ 73255 ], 11, 1);
    const_tuple_str_digest_e1dc452ac5e3c17f3e15bbf44d17e339_tuple = PyTuple_New(1);
    const_str_digest_e1dc452ac5e3c17f3e15bbf44d17e339 = UNSTREAM_STRING(&constant_bin[ 127443 ], 6, 0);
    PyTuple_SET_ITEM(const_tuple_str_digest_e1dc452ac5e3c17f3e15bbf44d17e339_tuple, 0, const_str_digest_e1dc452ac5e3c17f3e15bbf44d17e339); Py_INCREF(const_str_digest_e1dc452ac5e3c17f3e15bbf44d17e339);
    const_tuple_str_digest_8e9fba48e24a08144a915d52e31f6d23_tuple = PyTuple_New(1);
    const_str_digest_8e9fba48e24a08144a915d52e31f6d23 = UNSTREAM_STRING(&constant_bin[ 127449 ], 4, 0);
    PyTuple_SET_ITEM(const_tuple_str_digest_8e9fba48e24a08144a915d52e31f6d23_tuple, 0, const_str_digest_8e9fba48e24a08144a915d52e31f6d23); Py_INCREF(const_str_digest_8e9fba48e24a08144a915d52e31f6d23);
    const_tuple_str_plain_utf8only_tuple = PyTuple_New(1);
    const_str_plain_utf8only = UNSTREAM_STRING(&constant_bin[ 127453 ], 8, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain_utf8only_tuple, 0, const_str_plain_utf8only); Py_INCREF(const_str_plain_utf8only);
    const_str_digest_aca114104f73a7934675fb06a5336647 = UNSTREAM_STRING(&constant_bin[ 127461 ], 56, 0);
    const_str_digest_169aa7f0589e4a3c83203d48f57770af = UNSTREAM_STRING(&constant_bin[ 127517 ], 22, 0);
    const_str_plain_X509_VERIFY_PARAM_new = UNSTREAM_STRING(&constant_bin[ 127539 ], 21, 1);
    const_str_plain__friendlyname = UNSTREAM_STRING(&constant_bin[ 127560 ], 13, 1);
    const_tuple_str_plain_bio_str_plain_ref_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_bio_str_plain_ref_tuple, 0, const_str_plain_bio); Py_INCREF(const_str_plain_bio);
    const_str_plain_ref = UNSTREAM_STRING(&constant_bin[ 27590 ], 3, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain_bio_str_plain_ref_tuple, 1, const_str_plain_ref); Py_INCREF(const_str_plain_ref);
    const_str_digest_1565887baecc678658a50e7d1f245653 = UNSTREAM_STRING(&constant_bin[ 127573 ], 236, 0);
    const_str_digest_d546905f9a7fd3b3fc24a90a7432aa72 = UNSTREAM_STRING(&constant_bin[ 127809 ], 48, 0);
    const_tuple_str_digest_eee7b0934fe224b34ba6722d84ccd2bf_tuple = PyTuple_New(1);
    const_str_digest_eee7b0934fe224b34ba6722d84ccd2bf = UNSTREAM_STRING(&constant_bin[ 109032 ], 2, 0);
    PyTuple_SET_ITEM(const_tuple_str_digest_eee7b0934fe224b34ba6722d84ccd2bf_tuple, 0, const_str_digest_eee7b0934fe224b34ba6722d84ccd2bf); Py_INCREF(const_str_digest_eee7b0934fe224b34ba6722d84ccd2bf);
    const_str_plain_load_pkcs12 = UNSTREAM_STRING(&constant_bin[ 127857 ], 11, 1);
    const_str_plain_X509_REVOKED_add1_ext_i2d = UNSTREAM_STRING(&constant_bin[ 127868 ], 25, 1);
    const_str_plain_string_result = UNSTREAM_STRING(&constant_bin[ 127893 ], 13, 1);
    const_str_digest_a658b60d9bffa55a9bdfb85ba96aec98 = UNSTREAM_STRING(&constant_bin[ 127906 ], 104, 0);
    const_str_plain_NOTIFY_POLICY = UNSTREAM_STRING(&constant_bin[ 128010 ], 13, 1);
    const_str_digest_2f350f536232587387680a9435c758f6 = UNSTREAM_STRING(&constant_bin[ 128023 ], 425, 0);
    const_str_digest_670c62a34c6767f6ecd5db6f969b2f34 = UNSTREAM_STRING(&constant_bin[ 128448 ], 500, 0);
    const_str_plain_pkcs12 = UNSTREAM_STRING(&constant_bin[ 127862 ], 6, 1);
    const_str_plain_results = UNSTREAM_STRING(&constant_bin[ 128948 ], 7, 1);
    const_str_digest_fb60d21f52ae521da77e61851d566364 = UNSTREAM_STRING(&constant_bin[ 128955 ], 19, 0);
    const_str_plain_get_short_name = UNSTREAM_STRING(&constant_bin[ 128974 ], 14, 1);
    const_str_plain_digest_obj = UNSTREAM_STRING(&constant_bin[ 128988 ], 10, 1);
    const_str_plain_op = UNSTREAM_STRING(&constant_bin[ 515 ], 2, 1);
    const_str_plain_type_is_enveloped = UNSTREAM_STRING(&constant_bin[ 128998 ], 17, 1);
    const_str_digest_782fa7272fdd3d3abdc1a0298e5e83fc = UNSTREAM_STRING(&constant_bin[ 129015 ], 107, 0);
    const_str_plain_X509_R_CERT_ALREADY_IN_HASH_TABLE = UNSTREAM_STRING(&constant_bin[ 129122 ], 33, 1);
    const_str_plain_result_buffer = UNSTREAM_STRING(&constant_bin[ 129155 ], 13, 1);
    const_str_plain_PKeyType = UNSTREAM_STRING(&constant_bin[ 129168 ], 8, 1);
    const_str_plain_PKCS12_create = UNSTREAM_STRING(&constant_bin[ 129176 ], 13, 1);
    const_str_digest_152d11f8848fac60442a26592ab3da87 = UNSTREAM_STRING(&constant_bin[ 129189 ], 688, 0);
    const_str_digest_0632ce6142bf9815370c626f0fb1235a = UNSTREAM_STRING(&constant_bin[ 129877 ], 26, 0);
    const_str_plain_char_result = UNSTREAM_STRING(&constant_bin[ 129903 ], 11, 1);
    const_str_plain_string_timestamp = UNSTREAM_STRING(&constant_bin[ 129914 ], 16, 1);
    const_tuple_7ffc84c231c6d64baeef42ad62a1270d_tuple = PyTuple_New(5);
    PyTuple_SET_ITEM(const_tuple_7ffc84c231c6d64baeef42ad62a1270d_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_7ffc84c231c6d64baeef42ad62a1270d_tuple, 1, const_str_plain_extensions); Py_INCREF(const_str_plain_extensions);
    PyTuple_SET_ITEM(const_tuple_7ffc84c231c6d64baeef42ad62a1270d_tuple, 2, const_str_plain_ext); Py_INCREF(const_str_plain_ext);
    PyTuple_SET_ITEM(const_tuple_7ffc84c231c6d64baeef42ad62a1270d_tuple, 3, const_str_plain_stack); Py_INCREF(const_str_plain_stack);
    PyTuple_SET_ITEM(const_tuple_7ffc84c231c6d64baeef42ad62a1270d_tuple, 4, const_str_plain_add_result); Py_INCREF(const_str_plain_add_result);
    const_tuple_516125a1d64dba4bb10b7a1d5054cba1_tuple = PyTuple_New(5);
    PyTuple_SET_ITEM(const_tuple_516125a1d64dba4bb10b7a1d5054cba1_tuple, 0, const_str_plain_type); Py_INCREF(const_str_plain_type);
    PyTuple_SET_ITEM(const_tuple_516125a1d64dba4bb10b7a1d5054cba1_tuple, 1, const_str_plain_buffer); Py_INCREF(const_str_plain_buffer);
    PyTuple_SET_ITEM(const_tuple_516125a1d64dba4bb10b7a1d5054cba1_tuple, 2, const_str_plain_bio); Py_INCREF(const_str_plain_bio);
    const_str_plain_pypkcs7 = UNSTREAM_STRING(&constant_bin[ 129930 ], 7, 1);
    PyTuple_SET_ITEM(const_tuple_516125a1d64dba4bb10b7a1d5054cba1_tuple, 3, const_str_plain_pypkcs7); Py_INCREF(const_str_plain_pypkcs7);
    const_str_plain_pkcs7 = UNSTREAM_STRING(&constant_bin[ 126220 ], 5, 1);
    PyTuple_SET_ITEM(const_tuple_516125a1d64dba4bb10b7a1d5054cba1_tuple, 4, const_str_plain_pkcs7); Py_INCREF(const_str_plain_pkcs7);
    const_tuple_str_plain_self_str_plain_not_after_str_plain_time_string_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_not_after_str_plain_time_string_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_not_after_str_plain_time_string_tuple, 1, const_str_plain_not_after); Py_INCREF(const_str_plain_not_after);
    const_str_plain_time_string = UNSTREAM_STRING(&constant_bin[ 129937 ], 11, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_not_after_str_plain_time_string_tuple, 2, const_str_plain_time_string); Py_INCREF(const_str_plain_time_string);
    const_str_digest_3c5d018dd809b9a6147c1b47d39e8d31 = UNSTREAM_STRING(&constant_bin[ 129948 ], 9, 0);
    const_str_plain_X509_STORE_CTX_cleanup = UNSTREAM_STRING(&constant_bin[ 129957 ], 22, 1);
    const_str_digest_50f07d7dbc7dc060eb5685744b92c007 = UNSTREAM_STRING(&constant_bin[ 101339 ], 23, 0);
    const_str_digest_44f664275c70041c9ae4bef2565506f3 = UNSTREAM_STRING(&constant_bin[ 129979 ], 640, 0);
    const_str_plain_sk_X509_push = UNSTREAM_STRING(&constant_bin[ 130619 ], 12, 1);
    const_str_digest_6a19008e8f9a834793cf38dcba68883a = UNSTREAM_STRING(&constant_bin[ 130631 ], 442, 0);
    const_str_plain_CRL_CHECK = UNSTREAM_STRING(&constant_bin[ 131073 ], 9, 1);
    const_str_plain_spki = UNSTREAM_STRING(&constant_bin[ 131082 ], 4, 1);
    const_tuple_str_plain_self_str_plain_ret_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_ret_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_ret_tuple, 1, const_str_plain_ret); Py_INCREF(const_str_plain_ret);
    const_str_plain_add_crl = UNSTREAM_STRING(&constant_bin[ 131086 ], 7, 1);
    const_str_digest_5a3f7f69104a4ed1267a21c950d94463 = UNSTREAM_STRING(&constant_bin[ 131093 ], 773, 0);
    const_tuple_str_plain_self_str_plain_flags_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_flags_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_flags_tuple, 1, const_str_plain_flags); Py_INCREF(const_str_plain_flags);
    const_str_plain_X509_V_FLAG_ALLOW_PROXY_CERTS = UNSTREAM_STRING(&constant_bin[ 131866 ], 29, 1);
    const_str_digest_7e62ce69c000886ecc0ae0b3e8ae9e79 = UNSTREAM_STRING(&constant_bin[ 131895 ], 188, 0);
    const_str_digest_7de17ac920010129977e4280610f275c = UNSTREAM_STRING(&constant_bin[ 132083 ], 271, 0);
    const_str_plain_NID_pbe_WithSHA1And3_Key_TripleDES_CBC = UNSTREAM_STRING(&constant_bin[ 132354 ], 38, 1);
    const_str_plain__get_name = UNSTREAM_STRING(&constant_bin[ 103373 ], 9, 1);
    const_str_plain_b64_encode = UNSTREAM_STRING(&constant_bin[ 132392 ], 10, 1);
    const_tuple_str_plain_type_str_plain_crl_str_plain_bio_str_plain_ret_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_str_plain_type_str_plain_crl_str_plain_bio_str_plain_ret_tuple, 0, const_str_plain_type); Py_INCREF(const_str_plain_type);
    PyTuple_SET_ITEM(const_tuple_str_plain_type_str_plain_crl_str_plain_bio_str_plain_ret_tuple, 1, const_str_plain_crl); Py_INCREF(const_str_plain_crl);
    PyTuple_SET_ITEM(const_tuple_str_plain_type_str_plain_crl_str_plain_bio_str_plain_ret_tuple, 2, const_str_plain_bio); Py_INCREF(const_str_plain_bio);
    PyTuple_SET_ITEM(const_tuple_str_plain_type_str_plain_crl_str_plain_bio_str_plain_ret_tuple, 3, const_str_plain_ret); Py_INCREF(const_str_plain_ret);
    const_tuple_str_plain_self_str_plain_other_str_plain_result_str_plain_op_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_other_str_plain_result_str_plain_op_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_other_str_plain_result_str_plain_op_tuple, 1, const_str_plain_other); Py_INCREF(const_str_plain_other);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_other_str_plain_result_str_plain_op_tuple, 2, const_str_plain_result); Py_INCREF(const_str_plain_result);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_other_str_plain_result_str_plain_op_tuple, 3, const_str_plain_op); Py_INCREF(const_str_plain_op);
    const_str_plain_EVP_VerifyUpdate = UNSTREAM_STRING(&constant_bin[ 132402 ], 16, 1);
    const_str_digest_603c60edaf58a8746faa757f20f3f938 = UNSTREAM_STRING(&constant_bin[ 132418 ], 265, 0);
    const_str_digest_32726a73c20427f70712d109be7712b4 = UNSTREAM_STRING(&constant_bin[ 132683 ], 192, 0);
    const_str_plain__crl_reasons = UNSTREAM_STRING(&constant_bin[ 132875 ], 12, 1);
    const_str_plain__passphrase = UNSTREAM_STRING(&constant_bin[ 113763 ], 11, 1);
    const_str_plain__revoked = UNSTREAM_STRING(&constant_bin[ 132887 ], 8, 1);
    const_tuple_51ff74c45307e7d0bccc36be86c10b54_tuple = PyTuple_New(9);
    PyTuple_SET_ITEM(const_tuple_51ff74c45307e7d0bccc36be86c10b54_tuple, 0, const_str_plain_pkey); Py_INCREF(const_str_plain_pkey);
    PyTuple_SET_ITEM(const_tuple_51ff74c45307e7d0bccc36be86c10b54_tuple, 1, const_str_plain_data); Py_INCREF(const_str_plain_data);
    PyTuple_SET_ITEM(const_tuple_51ff74c45307e7d0bccc36be86c10b54_tuple, 2, const_str_plain_digest); Py_INCREF(const_str_plain_digest);
    const_str_plain_final_result = UNSTREAM_STRING(&constant_bin[ 132895 ], 12, 1);
    PyTuple_SET_ITEM(const_tuple_51ff74c45307e7d0bccc36be86c10b54_tuple, 3, const_str_plain_final_result); Py_INCREF(const_str_plain_final_result);
    const_str_plain_signature_length = UNSTREAM_STRING(&constant_bin[ 132907 ], 16, 1);
    PyTuple_SET_ITEM(const_tuple_51ff74c45307e7d0bccc36be86c10b54_tuple, 4, const_str_plain_signature_length); Py_INCREF(const_str_plain_signature_length);
    PyTuple_SET_ITEM(const_tuple_51ff74c45307e7d0bccc36be86c10b54_tuple, 5, const_str_plain_length); Py_INCREF(const_str_plain_length);
    PyTuple_SET_ITEM(const_tuple_51ff74c45307e7d0bccc36be86c10b54_tuple, 6, const_str_plain_digest_obj); Py_INCREF(const_str_plain_digest_obj);
    const_str_plain_signature_buffer = UNSTREAM_STRING(&constant_bin[ 132923 ], 16, 1);
    PyTuple_SET_ITEM(const_tuple_51ff74c45307e7d0bccc36be86c10b54_tuple, 7, const_str_plain_signature_buffer); Py_INCREF(const_str_plain_signature_buffer);
    const_str_plain_md_ctx = UNSTREAM_STRING(&constant_bin[ 132939 ], 6, 1);
    PyTuple_SET_ITEM(const_tuple_51ff74c45307e7d0bccc36be86c10b54_tuple, 8, const_str_plain_md_ctx); Py_INCREF(const_str_plain_md_ctx);
    const_str_plain_fname = UNSTREAM_STRING(&constant_bin[ 132945 ], 5, 1);
    const_str_digest_60cf4d81fa4ac0fb8a6d16cafc145b24 = UNSTREAM_STRING(&constant_bin[ 132950 ], 266, 0);
    const_str_digest_bd5b7ac1c36a2ac4b448366689be109e = UNSTREAM_STRING(&constant_bin[ 133216 ], 686, 0);
    const_str_plain__text_type = UNSTREAM_STRING(&constant_bin[ 3565 ], 10, 1);
    const_str_plain_ent_nid = UNSTREAM_STRING(&constant_bin[ 133902 ], 7, 1);
    const_str_plain_IGNORE_CRITICAL = UNSTREAM_STRING(&constant_bin[ 133909 ], 15, 1);
    const_str_digest_a9fcf3ea8b3ff05d45964d00ac386113 = UNSTREAM_STRING(&constant_bin[ 133924 ], 249, 0);
    const_str_digest_c384f9f99d5890cd2aae342c30dbaa14 = UNSTREAM_STRING(&constant_bin[ 134173 ], 109, 0);
    const_str_plain_load_crl = UNSTREAM_STRING(&constant_bin[ 134282 ], 8, 1);
    const_str_plain_i2d_PKCS12_bio = UNSTREAM_STRING(&constant_bin[ 134290 ], 14, 1);
    const_str_digest_5bd123cbe57a454c8d9d37867b598cb2 = UNSTREAM_STRING(&constant_bin[ 134304 ], 70, 0);
    const_str_digest_3c7878f9f14c822b0ae6ebb3dbe0804c = UNSTREAM_STRING(&constant_bin[ 134374 ], 50, 0);
    const_str_plain_crypto_req = UNSTREAM_STRING(&constant_bin[ 134424 ], 10, 1);
    const_str_plain_CHECK_SS_SIGNATURE = UNSTREAM_STRING(&constant_bin[ 134434 ], 18, 1);
    const_str_plain__nid = UNSTREAM_STRING(&constant_bin[ 125418 ], 4, 1);
    const_str_plain_X509_V_FLAG_NOTIFY_POLICY = UNSTREAM_STRING(&constant_bin[ 134452 ], 25, 1);
    const_str_plain_SSL_FILETYPE_PEM = UNSTREAM_STRING(&constant_bin[ 134477 ], 16, 1);
    const_str_plain_d2i_PKCS7_bio = UNSTREAM_STRING(&constant_bin[ 134493 ], 13, 1);
    const_str_digest_0807c1b9c5bc0ac3cc25375c4a9ebb2e = UNSTREAM_STRING(&constant_bin[ 134506 ], 189, 0);
    const_str_plain_EVP_PKEY_assign_RSA = UNSTREAM_STRING(&constant_bin[ 134695 ], 19, 1);
    const_str_plain_get_ca_certificates = UNSTREAM_STRING(&constant_bin[ 134714 ], 19, 1);
    const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple = PyTuple_New(18);
    PyTuple_SET_ITEM(const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 0, const_str_plain_buffer); Py_INCREF(const_str_plain_buffer);
    const_str_plain_passphrase = UNSTREAM_STRING(&constant_bin[ 92637 ], 10, 1);
    PyTuple_SET_ITEM(const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 1, const_str_plain_passphrase); Py_INCREF(const_str_plain_passphrase);
    PyTuple_SET_ITEM(const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 2, const_str_plain_bio); Py_INCREF(const_str_plain_bio);
    const_str_plain_pykey = UNSTREAM_STRING(&constant_bin[ 134733 ], 5, 1);
    PyTuple_SET_ITEM(const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 3, const_str_plain_pykey); Py_INCREF(const_str_plain_pykey);
    PyTuple_SET_ITEM(const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 4, const_str_plain_x509); Py_INCREF(const_str_plain_x509);
    const_str_plain_friendlyname_buffer = UNSTREAM_STRING(&constant_bin[ 134738 ], 19, 1);
    PyTuple_SET_ITEM(const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 5, const_str_plain_friendlyname_buffer); Py_INCREF(const_str_plain_friendlyname_buffer);
    PyTuple_SET_ITEM(const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 6, const_str_plain_pkey); Py_INCREF(const_str_plain_pkey);
    PyTuple_SET_ITEM(const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 7, const_str_plain_i); Py_INCREF(const_str_plain_i);
    PyTuple_SET_ITEM(const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 8, const_str_plain_cert); Py_INCREF(const_str_plain_cert);
    const_str_plain_cacerts = UNSTREAM_STRING(&constant_bin[ 134757 ], 7, 1);
    PyTuple_SET_ITEM(const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 9, const_str_plain_cacerts); Py_INCREF(const_str_plain_cacerts);
    PyTuple_SET_ITEM(const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 10, const_str_plain_pycert); Py_INCREF(const_str_plain_pycert);
    const_str_plain_friendlyname_length = UNSTREAM_STRING(&constant_bin[ 134764 ], 19, 1);
    PyTuple_SET_ITEM(const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 11, const_str_plain_friendlyname_length); Py_INCREF(const_str_plain_friendlyname_length);
    PyTuple_SET_ITEM(const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 12, const_str_plain_p12); Py_INCREF(const_str_plain_p12);
    const_str_plain_pycacert = UNSTREAM_STRING(&constant_bin[ 134783 ], 8, 1);
    PyTuple_SET_ITEM(const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 13, const_str_plain_pycacert); Py_INCREF(const_str_plain_pycacert);
    PyTuple_SET_ITEM(const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 14, const_str_plain_pkcs12); Py_INCREF(const_str_plain_pkcs12);
    const_str_plain_friendlyname = UNSTREAM_STRING(&constant_bin[ 127561 ], 12, 1);
    PyTuple_SET_ITEM(const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 15, const_str_plain_friendlyname); Py_INCREF(const_str_plain_friendlyname);
    const_str_plain_pycacerts = UNSTREAM_STRING(&constant_bin[ 134791 ], 9, 1);
    PyTuple_SET_ITEM(const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 16, const_str_plain_pycacerts); Py_INCREF(const_str_plain_pycacerts);
    const_str_plain_parse_result = UNSTREAM_STRING(&constant_bin[ 134800 ], 12, 1);
    PyTuple_SET_ITEM(const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 17, const_str_plain_parse_result); Py_INCREF(const_str_plain_parse_result);
    const_str_plain_set_subject = UNSTREAM_STRING(&constant_bin[ 134812 ], 11, 1);
    const_tuple_2abd4adfc3fb4c61eb6347c1066336bb_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_2abd4adfc3fb4c61eb6347c1066336bb_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_2abd4adfc3fb4c61eb6347c1066336bb_tuple, 1, const_str_plain_bio); Py_INCREF(const_str_plain_bio);
    PyTuple_SET_ITEM(const_tuple_2abd4adfc3fb4c61eb6347c1066336bb_tuple, 2, const_str_plain_result); Py_INCREF(const_str_plain_result);
    PyTuple_SET_ITEM(const_tuple_2abd4adfc3fb4c61eb6347c1066336bb_tuple, 3, const_str_plain_asn1_int); Py_INCREF(const_str_plain_asn1_int);
    const_str_plain_get_components = UNSTREAM_STRING(&constant_bin[ 134823 ], 14, 1);
    const_tuple_5b465d0345e9fe836325135a03b6a86e_tuple = PyTuple_New(8);
    PyTuple_SET_ITEM(const_tuple_5b465d0345e9fe836325135a03b6a86e_tuple, 0, const_str_plain_ffi); Py_INCREF(const_str_plain_ffi);
    PyTuple_SET_ITEM(const_tuple_5b465d0345e9fe836325135a03b6a86e_tuple, 1, const_str_plain_lib); Py_INCREF(const_str_plain_lib);
    PyTuple_SET_ITEM(const_tuple_5b465d0345e9fe836325135a03b6a86e_tuple, 2, const_str_plain_exception_from_error_queue); Py_INCREF(const_str_plain_exception_from_error_queue);
    PyTuple_SET_ITEM(const_tuple_5b465d0345e9fe836325135a03b6a86e_tuple, 3, const_str_plain_byte_string); Py_INCREF(const_str_plain_byte_string);
    PyTuple_SET_ITEM(const_tuple_5b465d0345e9fe836325135a03b6a86e_tuple, 4, const_str_plain_native); Py_INCREF(const_str_plain_native);
    PyTuple_SET_ITEM(const_tuple_5b465d0345e9fe836325135a03b6a86e_tuple, 5, const_str_plain_UNSPECIFIED); Py_INCREF(const_str_plain_UNSPECIFIED);
    PyTuple_SET_ITEM(const_tuple_5b465d0345e9fe836325135a03b6a86e_tuple, 6, const_str_plain_text_to_bytes_and_warn); Py_INCREF(const_str_plain_text_to_bytes_and_warn);
    PyTuple_SET_ITEM(const_tuple_5b465d0345e9fe836325135a03b6a86e_tuple, 7, const_str_plain_make_assert); Py_INCREF(const_str_plain_make_assert);
    const_str_plain_set_privatekey = UNSTREAM_STRING(&constant_bin[ 134837 ], 14, 1);
    const_str_plain_EVP_VerifyFinal = UNSTREAM_STRING(&constant_bin[ 134851 ], 15, 1);
    const_str_digest_26a65c58106d086427e37cb87b0bc3b3 = UNSTREAM_STRING(&constant_bin[ 134866 ], 271, 0);
    const_str_digest_8db7448b8246dd51f74c33bda58590bd = UNSTREAM_STRING(&constant_bin[ 135137 ], 376, 0);
    const_tuple_str_plain_self_str_plain__Certificate_str_plain_backend_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain__Certificate_str_plain_backend_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain__Certificate_str_plain_backend_tuple, 1, const_str_plain__Certificate); Py_INCREF(const_str_plain__Certificate);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain__Certificate_str_plain_backend_tuple, 2, const_str_plain_backend); Py_INCREF(const_str_plain_backend);
    const_str_plain_get_notBefore = UNSTREAM_STRING(&constant_bin[ 135513 ], 13, 1);
    const_str_plain_X509V3_set_ctx_nodb = UNSTREAM_STRING(&constant_bin[ 135526 ], 19, 1);
    const_str_plain_i2d_PrivateKey_bio = UNSTREAM_STRING(&constant_bin[ 135545 ], 18, 1);
    const_str_digest_05b2bb16e6ee73fd972536e52cc4cabf = UNSTREAM_STRING(&constant_bin[ 135563 ], 270, 0);
    const_str_plain_hexstring_serial = UNSTREAM_STRING(&constant_bin[ 135833 ], 16, 1);
    const_tuple_str_plain_integer_types_str_plain_text_type_str_plain_PY3_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_integer_types_str_plain_text_type_str_plain_PY3_tuple, 0, const_str_plain_integer_types); Py_INCREF(const_str_plain_integer_types);
    PyTuple_SET_ITEM(const_tuple_str_plain_integer_types_str_plain_text_type_str_plain_PY3_tuple, 1, const_str_plain_text_type); Py_INCREF(const_str_plain_text_type);
    PyTuple_SET_ITEM(const_tuple_str_plain_integer_types_str_plain_text_type_str_plain_PY3_tuple, 2, const_str_plain_PY3); Py_INCREF(const_str_plain_PY3);
    const_str_digest_1ca413f5b66374db6a573ac0926a99ae = UNSTREAM_STRING(&constant_bin[ 135849 ], 135, 0);
    const_str_plain_X509StoreFlags = UNSTREAM_STRING(&constant_bin[ 135984 ], 14, 1);
    const_str_plain_EVP_SignInit = UNSTREAM_STRING(&constant_bin[ 135998 ], 12, 1);
    const_str_digest_c7bf9684574689f7d764ff6fbd5eab60 = UNSTREAM_STRING(&constant_bin[ 136010 ], 266, 0);
    const_tuple_str_plain_op_str_plain_f_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_op_str_plain_f_tuple, 0, const_str_plain_op); Py_INCREF(const_str_plain_op);
    PyTuple_SET_ITEM(const_tuple_str_plain_op_str_plain_f_tuple, 1, const_str_plain_f); Py_INCREF(const_str_plain_f);
    const_tuple_str_plain_b16encode_tuple = PyTuple_New(1);
    const_str_plain_b16encode = UNSTREAM_STRING(&constant_bin[ 3812 ], 9, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain_b16encode_tuple, 0, const_str_plain_b16encode); Py_INCREF(const_str_plain_b16encode);
    const_str_plain_get_serial_number = UNSTREAM_STRING(&constant_bin[ 136276 ], 17, 1);
    const_str_digest_2f591e55cc116ed5223c119e2f7da344 = UNSTREAM_STRING(&constant_bin[ 136293 ], 150, 0);
    const_str_plain_ent_obj = UNSTREAM_STRING(&constant_bin[ 136443 ], 7, 1);
    const_str_plain_vfy_time = UNSTREAM_STRING(&constant_bin[ 136450 ], 8, 1);
    const_str_plain_sk_X509_EXTENSION_push = UNSTREAM_STRING(&constant_bin[ 136458 ], 22, 1);
    const_str_digest_3910fdd1c3b683a0988d08f77454ce47 = UNSTREAM_STRING(&constant_bin[ 136480 ], 23, 0);
    const_str_plain_get_extension_count = UNSTREAM_STRING(&constant_bin[ 136503 ], 19, 1);
    const_str_digest_12c1bc175ad6309f9cfc24942b8c76ac = UNSTREAM_STRING(&constant_bin[ 136522 ], 158, 0);
    const_tuple_str_plain_self_str_plain_when_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_when_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_when_tuple, 1, const_str_plain_when); Py_INCREF(const_str_plain_when);
    const_str_plain_X509V3_EXT_print = UNSTREAM_STRING(&constant_bin[ 136680 ], 16, 1);
    const_tuple_f55bc3086b9449b7c24969f5e02af09b_tuple = PyTuple_New(8);
    PyTuple_SET_ITEM(const_tuple_f55bc3086b9449b7c24969f5e02af09b_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_f55bc3086b9449b7c24969f5e02af09b_tuple, 1, const_str_plain_type_name); Py_INCREF(const_str_plain_type_name);
    PyTuple_SET_ITEM(const_tuple_f55bc3086b9449b7c24969f5e02af09b_tuple, 2, const_str_plain_critical); Py_INCREF(const_str_plain_critical);
    PyTuple_SET_ITEM(const_tuple_f55bc3086b9449b7c24969f5e02af09b_tuple, 3, const_str_plain_value); Py_INCREF(const_str_plain_value);
    PyTuple_SET_ITEM(const_tuple_f55bc3086b9449b7c24969f5e02af09b_tuple, 4, const_str_plain_subject); Py_INCREF(const_str_plain_subject);
    PyTuple_SET_ITEM(const_tuple_f55bc3086b9449b7c24969f5e02af09b_tuple, 5, const_str_plain_issuer); Py_INCREF(const_str_plain_issuer);
    PyTuple_SET_ITEM(const_tuple_f55bc3086b9449b7c24969f5e02af09b_tuple, 6, const_str_plain_extension); Py_INCREF(const_str_plain_extension);
    PyTuple_SET_ITEM(const_tuple_f55bc3086b9449b7c24969f5e02af09b_tuple, 7, const_str_plain_ctx); Py_INCREF(const_str_plain_ctx);
    const_tuple_str_plain_self_str_plain_pkey_str_plain_set_result_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_pkey_str_plain_set_result_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_pkey_str_plain_set_result_tuple, 1, const_str_plain_pkey); Py_INCREF(const_str_plain_pkey);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_pkey_str_plain_set_result_tuple, 2, const_str_plain_set_result); Py_INCREF(const_str_plain_set_result);
    const_tuple_str_plain_self_str_plain_obj_str_plain_nid_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_obj_str_plain_nid_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_obj_str_plain_nid_tuple, 1, const_str_plain_obj); Py_INCREF(const_str_plain_obj);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_obj_str_plain_nid_tuple, 2, const_str_plain_nid); Py_INCREF(const_str_plain_nid);
    const_tuple_4cf00dd32a506e6f9e6721c83bedbfad_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_4cf00dd32a506e6f9e6721c83bedbfad_tuple, 0, const_str_plain_type); Py_INCREF(const_str_plain_type);
    PyTuple_SET_ITEM(const_tuple_4cf00dd32a506e6f9e6721c83bedbfad_tuple, 1, const_str_plain_cert); Py_INCREF(const_str_plain_cert);
    PyTuple_SET_ITEM(const_tuple_4cf00dd32a506e6f9e6721c83bedbfad_tuple, 2, const_str_plain_bio); Py_INCREF(const_str_plain_bio);
    const_str_plain_result_code = UNSTREAM_STRING(&constant_bin[ 136696 ], 11, 1);
    PyTuple_SET_ITEM(const_tuple_4cf00dd32a506e6f9e6721c83bedbfad_tuple, 3, const_str_plain_result_code); Py_INCREF(const_str_plain_result_code);
    const_tuple_str_plain_self_str_plain_version_str_plain_set_result_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_version_str_plain_set_result_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_version_str_plain_set_result_tuple, 1, const_str_plain_version); Py_INCREF(const_str_plain_version);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_version_str_plain_set_result_tuple, 2, const_str_plain_set_result); Py_INCREF(const_str_plain_set_result);
    const_str_plain_i2a_ASN1_INTEGER = UNSTREAM_STRING(&constant_bin[ 136707 ], 16, 1);
    const_tuple_str_plain_self_str_plain_algor_str_plain_nid_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_algor_str_plain_nid_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    const_str_plain_algor = UNSTREAM_STRING(&constant_bin[ 26178 ], 5, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_algor_str_plain_nid_tuple, 1, const_str_plain_algor); Py_INCREF(const_str_plain_algor);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_algor_str_plain_nid_tuple, 2, const_str_plain_nid); Py_INCREF(const_str_plain_nid);
    const_tuple_6821d02066babb1885e247bdbf40c8ec_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_6821d02066babb1885e247bdbf40c8ec_tuple, 0, const_str_plain_bio); Py_INCREF(const_str_plain_bio);
    const_str_plain_buffer_length = UNSTREAM_STRING(&constant_bin[ 136723 ], 13, 1);
    PyTuple_SET_ITEM(const_tuple_6821d02066babb1885e247bdbf40c8ec_tuple, 1, const_str_plain_buffer_length); Py_INCREF(const_str_plain_buffer_length);
    PyTuple_SET_ITEM(const_tuple_6821d02066babb1885e247bdbf40c8ec_tuple, 2, const_str_plain_result_buffer); Py_INCREF(const_str_plain_result_buffer);
    const_str_plain_X509Type = UNSTREAM_STRING(&constant_bin[ 136736 ], 8, 1);
    const_str_digest_5194c46decfddbd64da780c8c0e4faa3 = UNSTREAM_STRING(&constant_bin[ 136744 ], 46, 0);
    const_str_plain_X509_NAME_delete_entry = UNSTREAM_STRING(&constant_bin[ 136790 ], 22, 1);
    const_str_digest_8aae826f04ca2a5df2a0de1a103a1f13 = UNSTREAM_STRING(&constant_bin[ 136812 ], 24, 0);
    const_str_digest_333948d9e51f0e161201a16305959930 = UNSTREAM_STRING(&constant_bin[ 136836 ], 244, 0);
    const_str_plain_native_exts_obj = UNSTREAM_STRING(&constant_bin[ 137080 ], 15, 1);
    const_str_digest_9cb57ebafd0926d1746d2e66a6198efe = UNSTREAM_STRING(&constant_bin[ 137095 ], 43, 0);
    const_str_plain_X509_STRICT = UNSTREAM_STRING(&constant_bin[ 137138 ], 11, 1);
    const_tuple_str_digest_e2d15f7f418fdd55a54be9ea476feee3_tuple = PyTuple_New(1);
    const_str_digest_e2d15f7f418fdd55a54be9ea476feee3 = UNSTREAM_STRING(&constant_bin[ 137149 ], 16, 0);
    PyTuple_SET_ITEM(const_tuple_str_digest_e2d15f7f418fdd55a54be9ea476feee3_tuple, 0, const_str_digest_e2d15f7f418fdd55a54be9ea476feee3); Py_INCREF(const_str_digest_e2d15f7f418fdd55a54be9ea476feee3);
    const_tuple_str_plain_cls_str_plain_crypto_cert_str_plain_cert_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_cls_str_plain_crypto_cert_str_plain_cert_tuple, 0, const_str_plain_cls); Py_INCREF(const_str_plain_cls);
    const_str_plain_crypto_cert = UNSTREAM_STRING(&constant_bin[ 137165 ], 11, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain_cls_str_plain_crypto_cert_str_plain_cert_tuple, 1, const_str_plain_crypto_cert); Py_INCREF(const_str_plain_crypto_cert);
    PyTuple_SET_ITEM(const_tuple_str_plain_cls_str_plain_crypto_cert_str_plain_cert_tuple, 2, const_str_plain_cert); Py_INCREF(const_str_plain_cert);
    const_str_digest_5339fa8ff3df372e54ef7b09078767aa = UNSTREAM_STRING(&constant_bin[ 137176 ], 15, 0);
    const_tuple_86464d9c162f01af99141e0a5b804d71_tuple = PyTuple_New(5);
    PyTuple_SET_ITEM(const_tuple_86464d9c162f01af99141e0a5b804d71_tuple, 0, const_str_plain_type); Py_INCREF(const_str_plain_type);
    PyTuple_SET_ITEM(const_tuple_86464d9c162f01af99141e0a5b804d71_tuple, 1, const_str_plain_pkey); Py_INCREF(const_str_plain_pkey);
    PyTuple_SET_ITEM(const_tuple_86464d9c162f01af99141e0a5b804d71_tuple, 2, const_str_plain_write_bio); Py_INCREF(const_str_plain_write_bio);
    PyTuple_SET_ITEM(const_tuple_86464d9c162f01af99141e0a5b804d71_tuple, 3, const_str_plain_result_code); Py_INCREF(const_str_plain_result_code);
    PyTuple_SET_ITEM(const_tuple_86464d9c162f01af99141e0a5b804d71_tuple, 4, const_str_plain_bio); Py_INCREF(const_str_plain_bio);
    const_tuple_5ef57f6035eba9ead62528f8493f508e_tuple = PyTuple_New(6);
    PyTuple_SET_ITEM(const_tuple_5ef57f6035eba9ead62528f8493f508e_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_5ef57f6035eba9ead62528f8493f508e_tuple, 1, const_str_plain_bio); Py_INCREF(const_str_plain_bio);
    PyTuple_SET_ITEM(const_tuple_5ef57f6035eba9ead62528f8493f508e_tuple, 2, const_str_plain_obj); Py_INCREF(const_str_plain_obj);
    const_str_plain_print_result = UNSTREAM_STRING(&constant_bin[ 137191 ], 12, 1);
    PyTuple_SET_ITEM(const_tuple_5ef57f6035eba9ead62528f8493f508e_tuple, 3, const_str_plain_print_result); Py_INCREF(const_str_plain_print_result);
    PyTuple_SET_ITEM(const_tuple_5ef57f6035eba9ead62528f8493f508e_tuple, 4, const_str_plain_i); Py_INCREF(const_str_plain_i);
    PyTuple_SET_ITEM(const_tuple_5ef57f6035eba9ead62528f8493f508e_tuple, 5, const_str_plain_ext); Py_INCREF(const_str_plain_ext);
    const_str_plain_NID_subject_alt_name = UNSTREAM_STRING(&constant_bin[ 137203 ], 20, 1);
    const_str_plain_add_cert = UNSTREAM_STRING(&constant_bin[ 137223 ], 8, 1);
    const_tuple_str_digest_70b987f75825a6c2ffe2c8fe53d85a21_tuple = PyTuple_New(1);
    const_str_digest_70b987f75825a6c2ffe2c8fe53d85a21 = UNSTREAM_STRING(&constant_bin[ 137185 ], 6, 0);
    PyTuple_SET_ITEM(const_tuple_str_digest_70b987f75825a6c2ffe2c8fe53d85a21_tuple, 0, const_str_digest_70b987f75825a6c2ffe2c8fe53d85a21); Py_INCREF(const_str_digest_70b987f75825a6c2ffe2c8fe53d85a21);
    const_str_plain_X509V3_EXT_nconf = UNSTREAM_STRING(&constant_bin[ 137231 ], 16, 1);
    const_str_digest_5cb0319d0378026eb0ef49838e525520 = UNSTREAM_STRING(&constant_bin[ 137247 ], 311, 0);
    const_str_digest_62c9c3f244d467c166be64cd38a755a7 = UNSTREAM_STRING(&constant_bin[ 137558 ], 224, 0);
    const_str_digest_f41f911aba33894e1da796354264d96a = UNSTREAM_STRING(&constant_bin[ 137782 ], 435, 0);
    const_str_digest_dc44ec2c02bcac7fac23b8eea57aa5d6 = UNSTREAM_STRING(&constant_bin[ 138217 ], 24, 0);
    const_str_plain_subject_cert = UNSTREAM_STRING(&constant_bin[ 138241 ], 12, 1);
    const_str_plain_set_pubkey = UNSTREAM_STRING(&constant_bin[ 138253 ], 10, 1);
    const_str_digest_e69f89000e2dc720ec6a70b8f9cb0cac = UNSTREAM_STRING(&constant_bin[ 138263 ], 131, 0);
    const_str_plain_exceptionType = UNSTREAM_STRING(&constant_bin[ 138394 ], 13, 1);
    const_str_digest_61dbd227935e54cb40eecc7de8b8596b = UNSTREAM_STRING(&constant_bin[ 138407 ], 137, 0);
    const_str_digest_1d608c98cc8048d3f7b439059ee29b66 = UNSTREAM_STRING(&constant_bin[ 138544 ], 420, 0);
    const_str_digest_79b48b443a4edf88bd64a278e98529d3 = UNSTREAM_STRING(&constant_bin[ 138964 ], 254, 0);
    const_str_plain_from_nid = UNSTREAM_STRING(&constant_bin[ 139218 ], 8, 1);
    const_str_digest_11dbf726734533c622c12e725d15648e = UNSTREAM_STRING(&constant_bin[ 139226 ], 123, 0);
    const_str_plain__spki = UNSTREAM_STRING(&constant_bin[ 139349 ], 5, 1);
    const_str_plain_from_cryptography = UNSTREAM_STRING(&constant_bin[ 139354 ], 17, 1);
    const_str_digest_f56881bccbbc40c6643f9603628e7a5c = UNSTREAM_STRING(&constant_bin[ 139371 ], 273, 0);
    const_str_digest_7a5005a2e44b5258634f5b2837cd8b81 = UNSTREAM_STRING(&constant_bin[ 139644 ], 29, 0);
    const_str_plain_set_notBefore = UNSTREAM_STRING(&constant_bin[ 139673 ], 13, 1);
    const_str_plain_load_pkcs7_data = UNSTREAM_STRING(&constant_bin[ 139686 ], 15, 1);
    const_str_digest_95aba6f0be0722dff4a715f251a45159 = UNSTREAM_STRING(&constant_bin[ 139701 ], 18, 0);
    const_str_digest_4d148c7b7c1bc2fec101962dc1ce2c2f = UNSTREAM_STRING(&constant_bin[ 139719 ], 52, 0);
    const_tuple_str_plain_self_str_plain_lib_str_plain_nid_str_plain_name_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_lib_str_plain_nid_str_plain_name_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_lib_str_plain_nid_str_plain_name_tuple, 1, const_str_plain_lib); Py_INCREF(const_str_plain_lib);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_lib_str_plain_nid_str_plain_name_tuple, 2, const_str_plain_nid); Py_INCREF(const_str_plain_nid);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_lib_str_plain_nid_str_plain_name_tuple, 3, const_str_plain_name); Py_INCREF(const_str_plain_name);
    const_str_digest_9781f115d6516693d922717b11376a73 = UNSTREAM_STRING(&constant_bin[ 139771 ], 277, 0);
    const_str_plain__new_mem_buf = UNSTREAM_STRING(&constant_bin[ 3604 ], 12, 1);
    const_str_plain_X509_verify_cert_error_string = UNSTREAM_STRING(&constant_bin[ 140048 ], 29, 1);
    const_str_plain_CRLType = UNSTREAM_STRING(&constant_bin[ 140077 ], 7, 1);
    const_str_digest_79dac080796da8f8fc9c66ebe460ce2f = UNSTREAM_STRING(&constant_bin[ 140084 ], 29, 0);
    const_str_plain_X509_CRL_print = UNSTREAM_STRING(&constant_bin[ 140113 ], 14, 1);
    const_tuple_fe55f23347ee1ca3dc14a1930b416eaa_tuple = PyTuple_New(5);
    PyTuple_SET_ITEM(const_tuple_fe55f23347ee1ca3dc14a1930b416eaa_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_fe55f23347ee1ca3dc14a1930b416eaa_tuple, 1, const_str_plain_errors); Py_INCREF(const_str_plain_errors);
    PyTuple_SET_ITEM(const_tuple_fe55f23347ee1ca3dc14a1930b416eaa_tuple, 2, const_str_plain__cert); Py_INCREF(const_str_plain__cert);
    PyTuple_SET_ITEM(const_tuple_fe55f23347ee1ca3dc14a1930b416eaa_tuple, 3, const_str_plain_pycert); Py_INCREF(const_str_plain_pycert);
    PyTuple_SET_ITEM(const_tuple_fe55f23347ee1ca3dc14a1930b416eaa_tuple, 4, const_str_plain__x509); Py_INCREF(const_str_plain__x509);
    const_str_digest_0a3eb1716e7caaaf09c8582b572bcb60 = UNSTREAM_STRING(&constant_bin[ 140127 ], 316, 0);
    const_str_digest_d03be6fc9f3e6729b366e69e0856a450 = UNSTREAM_STRING(&constant_bin[ 140443 ], 368, 0);
    const_str_plain_bignum_ptr = UNSTREAM_STRING(&constant_bin[ 140811 ], 10, 1);
    const_str_digest_11c225ccbab9acffc38107dee9691702 = UNSTREAM_STRING(&constant_bin[ 140821 ], 67, 0);
    const_str_plain_OBJ_obj2nid = UNSTREAM_STRING(&constant_bin[ 140888 ], 11, 1);
    const_str_digest_4fd5a0c1d1fb7366c52acc7b3ac0b5b1 = UNSTREAM_STRING(&constant_bin[ 140899 ], 22, 0);
    const_str_digest_9ae52cddf69d053d9518f458a81ffa1b = UNSTREAM_STRING(&constant_bin[ 140921 ], 36, 0);
    const_str_digest_68e309761e6d5dc5f5c1e53801284f3a = UNSTREAM_STRING(&constant_bin[ 140957 ], 55, 0);
    const_str_plain_X509_EXTENSION_dup = UNSTREAM_STRING(&constant_bin[ 141012 ], 18, 1);
    const_str_digest_7163953ad9ff69e46167d396f5625cf7 = UNSTREAM_STRING(&constant_bin[ 141030 ], 31, 0);
    const_str_plain_SSL_FILETYPE_ASN1 = UNSTREAM_STRING(&constant_bin[ 141061 ], 17, 1);
    const_tuple_76984bb103279dcce095840ed073cae5_tuple = PyTuple_New(7);
    PyTuple_SET_ITEM(const_tuple_76984bb103279dcce095840ed073cae5_tuple, 0, const_str_plain_type); Py_INCREF(const_str_plain_type);
    PyTuple_SET_ITEM(const_tuple_76984bb103279dcce095840ed073cae5_tuple, 1, const_str_plain_buffer); Py_INCREF(const_str_plain_buffer);
    PyTuple_SET_ITEM(const_tuple_76984bb103279dcce095840ed073cae5_tuple, 2, const_str_plain_passphrase); Py_INCREF(const_str_plain_passphrase);
    PyTuple_SET_ITEM(const_tuple_76984bb103279dcce095840ed073cae5_tuple, 3, const_str_plain_bio); Py_INCREF(const_str_plain_bio);
    PyTuple_SET_ITEM(const_tuple_76984bb103279dcce095840ed073cae5_tuple, 4, const_str_plain_helper); Py_INCREF(const_str_plain_helper);
    PyTuple_SET_ITEM(const_tuple_76984bb103279dcce095840ed073cae5_tuple, 5, const_str_plain_pkey); Py_INCREF(const_str_plain_pkey);
    PyTuple_SET_ITEM(const_tuple_76984bb103279dcce095840ed073cae5_tuple, 6, const_str_plain_evp_pkey); Py_INCREF(const_str_plain_evp_pkey);
    const_str_plain_sometime = UNSTREAM_STRING(&constant_bin[ 141078 ], 8, 1);
    const_str_digest_f979ae5e9b0a9a41a05276169a44e7e9 = UNSTREAM_STRING(&constant_bin[ 141086 ], 259, 0);
    const_str_plain_callback_args = UNSTREAM_STRING(&constant_bin[ 104314 ], 13, 1);
    const_str_plain_set_store = UNSTREAM_STRING(&constant_bin[ 141345 ], 9, 1);
    const_str_digest_03f3989a7f0f1ec9623bd001f5a005a7 = UNSTREAM_STRING(&constant_bin[ 141354 ], 284, 0);
    const_str_digest_5f245d1740d80da82563e21c9c4f4fbf = UNSTREAM_STRING(&constant_bin[ 141638 ], 107, 0);
    const_str_plain_reason_code = UNSTREAM_STRING(&constant_bin[ 141745 ], 11, 1);
    const_tuple_5903b88f37d1077b2f3871dbc2944417_tuple = PyTuple_New(8);
    PyTuple_SET_ITEM(const_tuple_5903b88f37d1077b2f3871dbc2944417_tuple, 0, const_str_plain_cert); Py_INCREF(const_str_plain_cert);
    PyTuple_SET_ITEM(const_tuple_5903b88f37d1077b2f3871dbc2944417_tuple, 1, const_str_plain_signature); Py_INCREF(const_str_plain_signature);
    PyTuple_SET_ITEM(const_tuple_5903b88f37d1077b2f3871dbc2944417_tuple, 2, const_str_plain_data); Py_INCREF(const_str_plain_data);
    PyTuple_SET_ITEM(const_tuple_5903b88f37d1077b2f3871dbc2944417_tuple, 3, const_str_plain_digest); Py_INCREF(const_str_plain_digest);
    PyTuple_SET_ITEM(const_tuple_5903b88f37d1077b2f3871dbc2944417_tuple, 4, const_str_plain_pkey); Py_INCREF(const_str_plain_pkey);
    PyTuple_SET_ITEM(const_tuple_5903b88f37d1077b2f3871dbc2944417_tuple, 5, const_str_plain_digest_obj); Py_INCREF(const_str_plain_digest_obj);
    const_str_plain_verify_result = UNSTREAM_STRING(&constant_bin[ 141756 ], 13, 1);
    PyTuple_SET_ITEM(const_tuple_5903b88f37d1077b2f3871dbc2944417_tuple, 6, const_str_plain_verify_result); Py_INCREF(const_str_plain_verify_result);
    PyTuple_SET_ITEM(const_tuple_5903b88f37d1077b2f3871dbc2944417_tuple, 7, const_str_plain_md_ctx); Py_INCREF(const_str_plain_md_ctx);
    const_str_plain_set_certificate = UNSTREAM_STRING(&constant_bin[ 141769 ], 15, 1);
    const_tuple_f442a9e9eba2c7bd96e443ed0b5afd06_tuple = PyTuple_New(7);
    PyTuple_SET_ITEM(const_tuple_f442a9e9eba2c7bd96e443ed0b5afd06_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_f442a9e9eba2c7bd96e443ed0b5afd06_tuple, 1, const_str_plain_revoked); Py_INCREF(const_str_plain_revoked);
    PyTuple_SET_ITEM(const_tuple_f442a9e9eba2c7bd96e443ed0b5afd06_tuple, 2, const_str_plain_i); Py_INCREF(const_str_plain_i);
    const_str_plain_pyrev = UNSTREAM_STRING(&constant_bin[ 141784 ], 5, 1);
    PyTuple_SET_ITEM(const_tuple_f442a9e9eba2c7bd96e443ed0b5afd06_tuple, 3, const_str_plain_pyrev); Py_INCREF(const_str_plain_pyrev);
    PyTuple_SET_ITEM(const_tuple_f442a9e9eba2c7bd96e443ed0b5afd06_tuple, 4, const_str_plain_results); Py_INCREF(const_str_plain_results);
    const_str_plain_revoked_stack = UNSTREAM_STRING(&constant_bin[ 141789 ], 13, 1);
    PyTuple_SET_ITEM(const_tuple_f442a9e9eba2c7bd96e443ed0b5afd06_tuple, 5, const_str_plain_revoked_stack); Py_INCREF(const_str_plain_revoked_stack);
    const_str_plain_revoked_copy = UNSTREAM_STRING(&constant_bin[ 141802 ], 12, 1);
    PyTuple_SET_ITEM(const_tuple_f442a9e9eba2c7bd96e443ed0b5afd06_tuple, 6, const_str_plain_revoked_copy); Py_INCREF(const_str_plain_revoked_copy);
    const_str_digest_1cf455235163a6978480cc7b12198a27 = UNSTREAM_STRING(&constant_bin[ 141814 ], 48, 0);
    const_str_plain_format_result = UNSTREAM_STRING(&constant_bin[ 141862 ], 13, 1);
    const_str_digest_11e1356f3459cf012eb88d7288e20e85 = UNSTREAM_STRING(&constant_bin[ 141875 ], 161, 0);
    const_str_digest_7338acfc5a3b91c07965b6befadc8c7a = UNSTREAM_STRING(&constant_bin[ 142036 ], 15, 0);
    const_str_plain_get_elliptic_curves = UNSTREAM_STRING(&constant_bin[ 3476 ], 19, 1);
    const_str_digest_40e46351c3b918f338d6e675fea0b1ca = UNSTREAM_STRING(&constant_bin[ 142051 ], 421, 0);
    const_tuple_str_plain_self_str_plain_exceptionType_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_exceptionType_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_exceptionType_tuple, 1, const_str_plain_exceptionType); Py_INCREF(const_str_plain_exceptionType);
    const_str_plain_RSA_print = UNSTREAM_STRING(&constant_bin[ 142472 ], 9, 1);
    const_tuple_a2a87d1d5695ca90897866b205aec3ce_tuple = PyTuple_New(6);
    PyTuple_SET_ITEM(const_tuple_a2a87d1d5695ca90897866b205aec3ce_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_a2a87d1d5695ca90897866b205aec3ce_tuple, 1, const_str_plain_hex_str); Py_INCREF(const_str_plain_hex_str);
    const_str_plain_bignum_serial = UNSTREAM_STRING(&constant_bin[ 142481 ], 13, 1);
    PyTuple_SET_ITEM(const_tuple_a2a87d1d5695ca90897866b205aec3ce_tuple, 2, const_str_plain_bignum_serial); Py_INCREF(const_str_plain_bignum_serial);
    const_str_plain_asn1_serial = UNSTREAM_STRING(&constant_bin[ 142494 ], 11, 1);
    PyTuple_SET_ITEM(const_tuple_a2a87d1d5695ca90897866b205aec3ce_tuple, 3, const_str_plain_asn1_serial); Py_INCREF(const_str_plain_asn1_serial);
    const_str_plain_bn_result = UNSTREAM_STRING(&constant_bin[ 142505 ], 9, 1);
    PyTuple_SET_ITEM(const_tuple_a2a87d1d5695ca90897866b205aec3ce_tuple, 4, const_str_plain_bn_result); Py_INCREF(const_str_plain_bn_result);
    PyTuple_SET_ITEM(const_tuple_a2a87d1d5695ca90897866b205aec3ce_tuple, 5, const_str_plain_bignum_ptr); Py_INCREF(const_str_plain_bignum_ptr);
    const_str_plain_X509_subject_name_hash = UNSTREAM_STRING(&constant_bin[ 142514 ], 22, 1);
    const_str_plain_load_certificate_request = UNSTREAM_STRING(&constant_bin[ 142536 ], 24, 1);
    const_str_plain_set_serial = UNSTREAM_STRING(&constant_bin[ 142560 ], 10, 1);
    const_str_plain_X509_NAME_hash = UNSTREAM_STRING(&constant_bin[ 142570 ], 14, 1);
    const_str_digest_1f7559cec53c5da336c35128000e1652 = UNSTREAM_STRING(&constant_bin[ 142584 ], 23, 0);
    const_str_digest_39641ea33feffed70915f1c391cc979e = UNSTREAM_STRING(&constant_bin[ 142607 ], 37, 0);
    const_str_digest_a12e23c82fcdd4004653da2260294f18 = UNSTREAM_STRING(&constant_bin[ 142644 ], 400, 0);
    const_str_plain_from_cryptography_key = UNSTREAM_STRING(&constant_bin[ 143044 ], 21, 1);
    const_str_digest_14af5bef46557b92b5b6c4d670b7a1b8 = UNSTREAM_STRING(&constant_bin[ 143065 ], 500, 0);
    const_str_digest_7db2dd03172a07cae912434bb4ced82e = UNSTREAM_STRING(&constant_bin[ 143565 ], 50, 0);
    const_str_plain__cacerts = UNSTREAM_STRING(&constant_bin[ 143615 ], 8, 1);
    const_str_plain_POLICY_CHECK = UNSTREAM_STRING(&constant_bin[ 125876 ], 12, 1);
    const_str_plain_entry_index = UNSTREAM_STRING(&constant_bin[ 143623 ], 11, 1);
    const_str_digest_80438074180d95b1a2291874613077b5 = UNSTREAM_STRING(&constant_bin[ 143634 ], 8, 0);
    const_str_digest_40ce736ad6e52bc3df10a00233b89318 = UNSTREAM_STRING(&constant_bin[ 143642 ], 116, 0);
    const_str_plain_sign_result = UNSTREAM_STRING(&constant_bin[ 143758 ], 11, 1);
    const_tuple_str_plain_self_str_plain_amount_str_plain_notAfter_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_amount_str_plain_notAfter_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    const_str_plain_amount = UNSTREAM_STRING(&constant_bin[ 134597 ], 6, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_amount_str_plain_notAfter_tuple, 1, const_str_plain_amount); Py_INCREF(const_str_plain_amount);
    const_str_plain_notAfter = UNSTREAM_STRING(&constant_bin[ 143769 ], 8, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_amount_str_plain_notAfter_tuple, 2, const_str_plain_notAfter); Py_INCREF(const_str_plain_notAfter);
    const_tuple_str_plain_self_str_plain_spki_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_spki_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_spki_tuple, 1, const_str_plain_spki); Py_INCREF(const_str_plain_spki);
    const_str_digest_141cd36b231fb1bf7caa692f86984b7e = UNSTREAM_STRING(&constant_bin[ 143777 ], 205, 0);
    const_str_plain_NetscapeSPKI = UNSTREAM_STRING(&constant_bin[ 4629 ], 12, 1);
    const_str_digest_866d2e2176ccb47ef7515cbc6c993151 = UNSTREAM_STRING(&constant_bin[ 143982 ], 468, 0);
    const_str_plain_export = UNSTREAM_STRING(&constant_bin[ 88101 ], 6, 1);
    const_str_digest_c47cfcedcc7803c0a6ef28b85213e16f = UNSTREAM_STRING(&constant_bin[ 144450 ], 152, 0);
    const_str_plain_NETSCAPE_SPKI_get_pubkey = UNSTREAM_STRING(&constant_bin[ 144602 ], 24, 1);
    const_str_plain_URI = UNSTREAM_STRING(&constant_bin[ 144626 ], 3, 1);
    const_str_plain_ASN1_STRING_set_default_mask_asc = UNSTREAM_STRING(&constant_bin[ 144629 ], 32, 1);
    const_str_digest_463cb3c7dbe7753c6683d3195629dca3 = UNSTREAM_STRING(&constant_bin[ 144661 ], 54, 0);
    const_str_digest_75a631b53fc267af68d162051a06411c = UNSTREAM_STRING(&constant_bin[ 144715 ], 414, 0);
    const_str_plain_X509_V_FLAG_CRL_CHECK = UNSTREAM_STRING(&constant_bin[ 145129 ], 21, 1);
    const_str_plain_X509_NAME_add_entry_by_NID = UNSTREAM_STRING(&constant_bin[ 145150 ], 26, 1);
    const_str_plain_NetscapeSPKIType = UNSTREAM_STRING(&constant_bin[ 145176 ], 16, 1);
    const_str_plain_INHIBIT_MAP = UNSTREAM_STRING(&constant_bin[ 145192 ], 11, 1);
    const_str_digest_a078d66f5fc281c4117a5e5c24749809 = UNSTREAM_STRING(&constant_bin[ 145203 ], 134, 0);
    const_str_digest_1691c1bfd96a22cfc48aca410da45814 = UNSTREAM_STRING(&constant_bin[ 145337 ], 41, 0);
    const_str_plain_X509_V_FLAG_IGNORE_CRITICAL = UNSTREAM_STRING(&constant_bin[ 145378 ], 27, 1);
    const_dict_5608fce8424ef5aca22387357d834999 = _PyDict_NewPresized( 2 );
    PyDict_SetItem(const_dict_5608fce8424ef5aca22387357d834999, const_str_plain___module__, const_str_digest_6d237a1253b74549ee18fb0e488e3cf9);
    PyDict_SetItem(const_dict_5608fce8424ef5aca22387357d834999, const_str_plain___doc__, const_str_digest_68e309761e6d5dc5f5c1e53801284f3a);
    assert(PyDict_Size(const_dict_5608fce8424ef5aca22387357d834999) == 2);
    const_str_digest_74b73fd54833bfb6b761307c477c0a28 = UNSTREAM_STRING(&constant_bin[ 145405 ], 252, 0);
    const_list_b8e29824b436479d358fd3771a611e70_list = PyMarshal_ReadObjectFromString((char *)&constant_bin[ 145657 ], 600);
    const_str_digest_ac089bdfaafc466d410fc6ffe7dfee50 = UNSTREAM_STRING(&constant_bin[ 146257 ], 191, 0);
    const_tuple_str_digest_c561652c58984ec0e9541542aa405594_int_pos_512_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_digest_c561652c58984ec0e9541542aa405594_int_pos_512_tuple, 0, const_str_digest_c561652c58984ec0e9541542aa405594); Py_INCREF(const_str_digest_c561652c58984ec0e9541542aa405594);
    PyTuple_SET_ITEM(const_tuple_str_digest_c561652c58984ec0e9541542aa405594_int_pos_512_tuple, 1, const_int_pos_512); Py_INCREF(const_int_pos_512);
    const_tuple_str_plain_self_str_plain_when_str_plain_dt_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_when_str_plain_dt_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_when_str_plain_dt_tuple, 1, const_str_plain_when); Py_INCREF(const_str_plain_when);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_when_str_plain_dt_tuple, 2, const_str_plain_dt); Py_INCREF(const_str_plain_dt);
    const_tuple_str_plain_self_str_plain_crl_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_crl_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_crl_tuple, 1, const_str_plain_crl); Py_INCREF(const_str_plain_crl);
    const_str_digest_3121be4a855650e38916196ca238bf2b = UNSTREAM_STRING(&constant_bin[ 146448 ], 403, 0);
    const_tuple_false_false_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_false_false_tuple, 0, Py_False); Py_INCREF(Py_False);
    PyTuple_SET_ITEM(const_tuple_false_false_tuple, 1, Py_False); Py_INCREF(Py_False);
    const_tuple_34a51bbef25f1a50174cde73cf717c0e_tuple = PyTuple_New(5);
    PyTuple_SET_ITEM(const_tuple_34a51bbef25f1a50174cde73cf717c0e_tuple, 0, const_str_plain_type); Py_INCREF(const_str_plain_type);
    PyTuple_SET_ITEM(const_tuple_34a51bbef25f1a50174cde73cf717c0e_tuple, 1, const_str_plain_buffer); Py_INCREF(const_str_plain_buffer);
    PyTuple_SET_ITEM(const_tuple_34a51bbef25f1a50174cde73cf717c0e_tuple, 2, const_str_plain_bio); Py_INCREF(const_str_plain_bio);
    PyTuple_SET_ITEM(const_tuple_34a51bbef25f1a50174cde73cf717c0e_tuple, 3, const_str_plain_pkey); Py_INCREF(const_str_plain_pkey);
    PyTuple_SET_ITEM(const_tuple_34a51bbef25f1a50174cde73cf717c0e_tuple, 4, const_str_plain_evp_pkey); Py_INCREF(const_str_plain_evp_pkey);
    const_tuple_7eb0e743d38af9e33bf64e78c0ab103c_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_7eb0e743d38af9e33bf64e78c0ab103c_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_7eb0e743d38af9e33bf64e78c0ab103c_tuple, 1, const_str_plain__CertificateSigningRequest); Py_INCREF(const_str_plain__CertificateSigningRequest);
    PyTuple_SET_ITEM(const_tuple_7eb0e743d38af9e33bf64e78c0ab103c_tuple, 2, const_str_plain_backend); Py_INCREF(const_str_plain_backend);
    const_str_plain_get_type_name = UNSTREAM_STRING(&constant_bin[ 146851 ], 13, 1);
    const_str_digest_d7980f3a0e05fb43bc9ed0fa0707a2f9 = UNSTREAM_STRING(&constant_bin[ 146864 ], 43, 0);
    const_str_digest_1f681e9f80c6df652cbc3a085be49171 = UNSTREAM_STRING(&constant_bin[ 146907 ], 252, 0);
    const_tuple_8291ba4d3b501c7d6047aff9c84147fc_tuple = PyTuple_New(6);
    PyTuple_SET_ITEM(const_tuple_8291ba4d3b501c7d6047aff9c84147fc_tuple, 0, const_str_plain___eq__); Py_INCREF(const_str_plain___eq__);
    PyTuple_SET_ITEM(const_tuple_8291ba4d3b501c7d6047aff9c84147fc_tuple, 1, const_str_plain___ne__); Py_INCREF(const_str_plain___ne__);
    PyTuple_SET_ITEM(const_tuple_8291ba4d3b501c7d6047aff9c84147fc_tuple, 2, const_str_plain___lt__); Py_INCREF(const_str_plain___lt__);
    PyTuple_SET_ITEM(const_tuple_8291ba4d3b501c7d6047aff9c84147fc_tuple, 3, const_str_plain___le__); Py_INCREF(const_str_plain___le__);
    PyTuple_SET_ITEM(const_tuple_8291ba4d3b501c7d6047aff9c84147fc_tuple, 4, const_str_plain___gt__); Py_INCREF(const_str_plain___gt__);
    PyTuple_SET_ITEM(const_tuple_8291ba4d3b501c7d6047aff9c84147fc_tuple, 5, const_str_plain___ge__); Py_INCREF(const_str_plain___ge__);
    const_str_plain_new_reason_ext = UNSTREAM_STRING(&constant_bin[ 147159 ], 14, 1);
    const_str_plain_X509_V_FLAG_CB_ISSUER_CHECK = UNSTREAM_STRING(&constant_bin[ 147173 ], 27, 1);
    const_str_digest_7d6056c968d1eebfab898757e6f3054e = UNSTREAM_STRING(&constant_bin[ 147200 ], 120, 0);
    const_str_digest_721230a42e287d5632d061ff8f0376d6 = UNSTREAM_STRING(&constant_bin[ 147320 ], 259, 0);
    const_str_digest_f583009b639aad56f3c96c175e595626 = UNSTREAM_STRING(&constant_bin[ 147579 ], 340, 0);
    const_tuple_10f3f1cb3df7aac52b98dbb720bf50d1_tuple = PyTuple_New(5);
    PyTuple_SET_ITEM(const_tuple_10f3f1cb3df7aac52b98dbb720bf50d1_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_10f3f1cb3df7aac52b98dbb720bf50d1_tuple, 1, const_str_plain_pkey); Py_INCREF(const_str_plain_pkey);
    PyTuple_SET_ITEM(const_tuple_10f3f1cb3df7aac52b98dbb720bf50d1_tuple, 2, const_str_plain_digest); Py_INCREF(const_str_plain_digest);
    PyTuple_SET_ITEM(const_tuple_10f3f1cb3df7aac52b98dbb720bf50d1_tuple, 3, const_str_plain_sign_result); Py_INCREF(const_str_plain_sign_result);
    PyTuple_SET_ITEM(const_tuple_10f3f1cb3df7aac52b98dbb720bf50d1_tuple, 4, const_str_plain_evp_md); Py_INCREF(const_str_plain_evp_md);
    const_str_plain__more_args = UNSTREAM_STRING(&constant_bin[ 147919 ], 10, 1);
    const_str_plain_set_notAfter = UNSTREAM_STRING(&constant_bin[ 147929 ], 12, 1);
    const_str_digest_a7eaace656db47cf2975484b27c818e9 = UNSTREAM_STRING(&constant_bin[ 147941 ], 165, 0);
    const_str_plain__initialized = UNSTREAM_STRING(&constant_bin[ 148106 ], 12, 1);
    const_str_plain_RSA_F4 = UNSTREAM_STRING(&constant_bin[ 148118 ], 6, 1);
    const_str_plain__read_passphrase = UNSTREAM_STRING(&constant_bin[ 148124 ], 16, 1);
    const_tuple_str_plain___tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_plain___tuple, 0, const_str_plain__); Py_INCREF(const_str_plain__);
    const_tuple_str_plain_self_str_plain_message_str_plain_certificate_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_message_str_plain_certificate_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_message_str_plain_certificate_tuple, 1, const_str_plain_message); Py_INCREF(const_str_plain_message);
    const_str_plain_certificate = UNSTREAM_STRING(&constant_bin[ 24580 ], 11, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_message_str_plain_certificate_tuple, 2, const_str_plain_certificate); Py_INCREF(const_str_plain_certificate);
    const_str_plain_maciter = UNSTREAM_STRING(&constant_bin[ 130437 ], 7, 1);
    const_str_plain__get_backend = UNSTREAM_STRING(&constant_bin[ 3254 ], 12, 1);
    const_str_plain__set_name = UNSTREAM_STRING(&constant_bin[ 148140 ], 9, 1);
    const_str_digest_c4a5d29f3ecd810d59e3d04a7a935f38 = UNSTREAM_STRING(&constant_bin[ 148149 ], 197, 0);
    const_str_plain_set_ca_certificates = UNSTREAM_STRING(&constant_bin[ 148346 ], 19, 1);
    const_str_digest_0b708bb28192f1a165c843c47343f35a = UNSTREAM_STRING(&constant_bin[ 148365 ], 151, 0);
    const_tuple_str_plain_dsa_str_plain_rsa_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_dsa_str_plain_rsa_tuple, 0, const_str_plain_dsa); Py_INCREF(const_str_plain_dsa);
    PyTuple_SET_ITEM(const_tuple_str_plain_dsa_str_plain_rsa_tuple, 1, const_str_plain_rsa); Py_INCREF(const_str_plain_rsa);
    const_str_digest_ffd290e8bf49a587d94041b1fd6c3c55 = UNSTREAM_STRING(&constant_bin[ 148516 ], 248, 0);
    const_str_plain_get_reason = UNSTREAM_STRING(&constant_bin[ 148764 ], 10, 1);
    const_str_plain_answer = UNSTREAM_STRING(&constant_bin[ 148774 ], 6, 1);
    const_tuple_str_plain_self_str_plain_encoded_str_plain_result_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_encoded_str_plain_result_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_encoded_str_plain_result_tuple, 1, const_str_plain_encoded); Py_INCREF(const_str_plain_encoded);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_encoded_str_plain_result_tuple, 2, const_str_plain_result); Py_INCREF(const_str_plain_result);
    const_str_plain_X509_VERIFY_PARAM_set_time = UNSTREAM_STRING(&constant_bin[ 148780 ], 26, 1);
    const_str_plain_X509_REQ_get_version = UNSTREAM_STRING(&constant_bin[ 148806 ], 20, 1);
    const_str_digest_989a9acfa289de1c2c451525451533c9 = UNSTREAM_STRING(&constant_bin[ 148826 ], 46, 0);
    const_str_digest_f3b04f8993b30e664e4afacb3d64cdc4 = UNSTREAM_STRING(&constant_bin[ 148872 ], 11, 0);
    const_str_plain_get_version = UNSTREAM_STRING(&constant_bin[ 89239 ], 11, 1);
    const_str_digest_2e4273bc9cbcc16bcfe5bca70ee1b585 = UNSTREAM_STRING(&constant_bin[ 148883 ], 233, 0);
    const_str_plain_X509_REVOKED_delete_ext = UNSTREAM_STRING(&constant_bin[ 149116 ], 23, 1);
    const_str_plain_dump_publickey = UNSTREAM_STRING(&constant_bin[ 145986 ], 14, 1);
    const_str_plain_FILETYPE_TEXT = UNSTREAM_STRING(&constant_bin[ 4108 ], 13, 1);
    const_str_plain_PKCS12 = UNSTREAM_STRING(&constant_bin[ 4381 ], 6, 1);
    const_tuple_str_plain_self_str_plain_i_str_plain_obj_str_plain_ext_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_i_str_plain_obj_str_plain_ext_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_i_str_plain_obj_str_plain_ext_tuple, 1, const_str_plain_i); Py_INCREF(const_str_plain_i);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_i_str_plain_obj_str_plain_ext_tuple, 2, const_str_plain_obj); Py_INCREF(const_str_plain_obj);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_i_str_plain_obj_str_plain_ext_tuple, 3, const_str_plain_ext); Py_INCREF(const_str_plain_ext);
    const_str_plain_get_extension = UNSTREAM_STRING(&constant_bin[ 136503 ], 13, 1);
    const_str_digest_d0137950921f709b6c00a3276a078e5f = UNSTREAM_STRING(&constant_bin[ 149139 ], 463, 0);
    const_str_digest_de1d9872d12371b2ead20f3aa79dc834 = UNSTREAM_STRING(&constant_bin[ 149602 ], 208, 0);
    const_str_plain_x509req = UNSTREAM_STRING(&constant_bin[ 149810 ], 7, 1);
    const_str_digest_685b3ded6e482839a3710e6a448d8669 = UNSTREAM_STRING(&constant_bin[ 149817 ], 287, 0);
    const_str_digest_dc9f0c0121231dfd2bb64dc64aae6cc9 = UNSTREAM_STRING(&constant_bin[ 150104 ], 12, 0);
    const_str_plain_get_serial = UNSTREAM_STRING(&constant_bin[ 136276 ], 10, 1);
    const_str_digest_9a71d9e6319c409dff859e67083fc41c = UNSTREAM_STRING(&constant_bin[ 150116 ], 563, 0);
    const_str_digest_3a45faa244ca861d389c340b29a28988 = UNSTREAM_STRING(&constant_bin[ 150679 ], 45, 0);
    const_str_plain_X509_STORE_free = UNSTREAM_STRING(&constant_bin[ 150724 ], 15, 1);
    const_str_digest_ee89bc744832ab3afc27c4e7a4a73b66 = UNSTREAM_STRING(&constant_bin[ 150739 ], 54, 0);
    const_str_plain_X509_V_FLAG_CHECK_SS_SIGNATURE = UNSTREAM_STRING(&constant_bin[ 150793 ], 30, 1);
    const_str_digest_f019d8c1ebbf58631ace92b4423b3aad = UNSTREAM_STRING(&constant_bin[ 150823 ], 51, 0);
    const_str_plain_set_version = UNSTREAM_STRING(&constant_bin[ 150874 ], 11, 1);
    const_str_plain__X509NameInvalidator = UNSTREAM_STRING(&constant_bin[ 3763 ], 20, 1);
    const_tuple_3feaf484c2a2250f0d395be4b333fb30_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_3feaf484c2a2250f0d395be4b333fb30_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_3feaf484c2a2250f0d395be4b333fb30_tuple, 1, const_str_plain_result_buffer); Py_INCREF(const_str_plain_result_buffer);
    PyTuple_SET_ITEM(const_tuple_3feaf484c2a2250f0d395be4b333fb30_tuple, 2, const_str_plain_format_result); Py_INCREF(const_str_plain_format_result);
    const_str_digest_d84b19202bfdec9cc8e6f9577d4fac5e = UNSTREAM_STRING(&constant_bin[ 150885 ], 20, 0);
    const_str_plain_octet_result = UNSTREAM_STRING(&constant_bin[ 150905 ], 12, 1);
    const_str_plain_TYPE_DH = UNSTREAM_STRING(&constant_bin[ 150917 ], 7, 1);
    const_tuple_5f27e2d018bfbbfa2690b5943a091bcc_tuple = PyTuple_New(9);
    PyTuple_SET_ITEM(const_tuple_5f27e2d018bfbbfa2690b5943a091bcc_tuple, 0, const_str_plain_type); Py_INCREF(const_str_plain_type);
    PyTuple_SET_ITEM(const_tuple_5f27e2d018bfbbfa2690b5943a091bcc_tuple, 1, const_str_plain_pkey); Py_INCREF(const_str_plain_pkey);
    PyTuple_SET_ITEM(const_tuple_5f27e2d018bfbbfa2690b5943a091bcc_tuple, 2, const_str_plain_cipher); Py_INCREF(const_str_plain_cipher);
    PyTuple_SET_ITEM(const_tuple_5f27e2d018bfbbfa2690b5943a091bcc_tuple, 3, const_str_plain_passphrase); Py_INCREF(const_str_plain_passphrase);
    PyTuple_SET_ITEM(const_tuple_5f27e2d018bfbbfa2690b5943a091bcc_tuple, 4, const_str_plain_helper); Py_INCREF(const_str_plain_helper);
    PyTuple_SET_ITEM(const_tuple_5f27e2d018bfbbfa2690b5943a091bcc_tuple, 5, const_str_plain_bio); Py_INCREF(const_str_plain_bio);
    const_str_plain_cipher_obj = UNSTREAM_STRING(&constant_bin[ 150924 ], 10, 1);
    PyTuple_SET_ITEM(const_tuple_5f27e2d018bfbbfa2690b5943a091bcc_tuple, 6, const_str_plain_cipher_obj); Py_INCREF(const_str_plain_cipher_obj);
    PyTuple_SET_ITEM(const_tuple_5f27e2d018bfbbfa2690b5943a091bcc_tuple, 7, const_str_plain_rsa); Py_INCREF(const_str_plain_rsa);
    PyTuple_SET_ITEM(const_tuple_5f27e2d018bfbbfa2690b5943a091bcc_tuple, 8, const_str_plain_result_code); Py_INCREF(const_str_plain_result_code);
    const_str_plain_PKCS7_type_is_signed = UNSTREAM_STRING(&constant_bin[ 150934 ], 20, 1);
    const_str_plain_X509_V_FLAG_CRL_CHECK_ALL = UNSTREAM_STRING(&constant_bin[ 150954 ], 25, 1);
    const_str_plain__subject_invalidator = UNSTREAM_STRING(&constant_bin[ 150979 ], 20, 1);
    const_str_plain_PKCS7_type_is_signedAndEnveloped = UNSTREAM_STRING(&constant_bin[ 150999 ], 32, 1);
    const_str_digest_f68048107421fed17c8f1bc19be3ec03 = UNSTREAM_STRING(&constant_bin[ 151031 ], 190, 0);
    const_str_plain_set_time = UNSTREAM_STRING(&constant_bin[ 87780 ], 8, 1);
    const_str_plain_X509_digest = UNSTREAM_STRING(&constant_bin[ 151221 ], 11, 1);
    const_str_digest_5997506aef8ffc5e12c453030416acc6 = UNSTREAM_STRING(&constant_bin[ 151232 ], 68, 0);
    const_str_plain_X509_V_FLAG_X509_STRICT = UNSTREAM_STRING(&constant_bin[ 151300 ], 23, 1);
    const_tuple_71acb4312fb0ef6e4480ea2334a6a994_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_71acb4312fb0ef6e4480ea2334a6a994_tuple, 0, const_str_plain_type); Py_INCREF(const_str_plain_type);
    PyTuple_SET_ITEM(const_tuple_71acb4312fb0ef6e4480ea2334a6a994_tuple, 1, const_str_plain_req); Py_INCREF(const_str_plain_req);
    PyTuple_SET_ITEM(const_tuple_71acb4312fb0ef6e4480ea2334a6a994_tuple, 2, const_str_plain_bio); Py_INCREF(const_str_plain_bio);
    PyTuple_SET_ITEM(const_tuple_71acb4312fb0ef6e4480ea2334a6a994_tuple, 3, const_str_plain_result_code); Py_INCREF(const_str_plain_result_code);
    const_str_digest_3918253e50729a002fea544312970ff5 = UNSTREAM_STRING(&constant_bin[ 151323 ], 64, 0);
    const_str_plain_type_is_data = UNSTREAM_STRING(&constant_bin[ 151387 ], 12, 1);
    const_tuple_28746fdd1a6563b63939e82f1814a7ff_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_28746fdd1a6563b63939e82f1814a7ff_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_28746fdd1a6563b63939e82f1814a7ff_tuple, 1, const_str_plain_index); Py_INCREF(const_str_plain_index);
    PyTuple_SET_ITEM(const_tuple_28746fdd1a6563b63939e82f1814a7ff_tuple, 2, const_str_plain_ext); Py_INCREF(const_str_plain_ext);
    PyTuple_SET_ITEM(const_tuple_28746fdd1a6563b63939e82f1814a7ff_tuple, 3, const_str_plain_extension); Py_INCREF(const_str_plain_extension);
    const_str_digest_7b5d428ebb9708d902c18ce8ddfb3cbc = UNSTREAM_STRING(&constant_bin[ 151399 ], 17, 0);
    const_str_plain_X509V3_set_ctx = UNSTREAM_STRING(&constant_bin[ 135526 ], 14, 1);
    const_str_plain_get_elliptic_curve = UNSTREAM_STRING(&constant_bin[ 3476 ], 18, 1);
    const_str_digest_c71c443223c73b253b21961ef3bd7c9e = UNSTREAM_STRING(&constant_bin[ 151416 ], 645, 0);
    const_str_digest_a643e6a1050d6f3782a0d190235d80a7 = UNSTREAM_STRING(&constant_bin[ 152061 ], 205, 0);
    const_str_digest_35e2a27cee76091329550405e1cb7dc4 = UNSTREAM_STRING(&constant_bin[ 152266 ], 265, 0);
    const_str_plain_NETSCAPE_SPKI_free = UNSTREAM_STRING(&constant_bin[ 152531 ], 18, 1);
    const_str_plain_get_privatekey = UNSTREAM_STRING(&constant_bin[ 152549 ], 14, 1);
    const_str_plain_X509_print_ex = UNSTREAM_STRING(&constant_bin[ 152563 ], 13, 1);
    const_str_digest_b3f225987bb27e065a500d7fe8bd7c70 = UNSTREAM_STRING(&constant_bin[ 152576 ], 24, 0);
    const_str_plain__extension = UNSTREAM_STRING(&constant_bin[ 23738 ], 10, 1);
    const_str_digest_c0aedec8dc85440d3dace529a9d9050e = UNSTREAM_STRING(&constant_bin[ 152600 ], 349, 0);
    const_str_plain_fval = UNSTREAM_STRING(&constant_bin[ 152949 ], 4, 1);
    const_str_digest_5699814601a04aa972bd2f18de396c39 = UNSTREAM_STRING(&constant_bin[ 152953 ], 345, 0);
    const_str_digest_48639cf22fbd4e6b3714265dae0dbed8 = UNSTREAM_STRING(&constant_bin[ 153298 ], 99, 0);
    const_str_plain_string_data = UNSTREAM_STRING(&constant_bin[ 153397 ], 11, 1);
    const_str_plain_NETSCAPE_SPKI_verify = UNSTREAM_STRING(&constant_bin[ 153408 ], 20, 1);
    const_str_digest_d6b3262f79e4b59cd83ab54699c92117 = UNSTREAM_STRING(&constant_bin[ 153428 ], 231, 0);
    const_str_plain_X509ExtensionType = UNSTREAM_STRING(&constant_bin[ 151323 ], 17, 1);
    const_str_digest_1a7a898c4490dd89b305492a40bf2633 = UNSTREAM_STRING(&constant_bin[ 153659 ], 217, 0);
    const_str_plain_X509StoreType = UNSTREAM_STRING(&constant_bin[ 127461 ], 13, 1);
    const_str_digest_016ce3807ea72a262d921fa7d1804717 = UNSTREAM_STRING(&constant_bin[ 153876 ], 10, 0);
    const_str_plain_X509_STORE_CTX_init = UNSTREAM_STRING(&constant_bin[ 153886 ], 19, 1);
    const_str_plain_dump_crl = UNSTREAM_STRING(&constant_bin[ 4186 ], 8, 1);
    const_tuple_str_plain_self_str_plain_x509_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_x509_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_x509_tuple, 1, const_str_plain_x509); Py_INCREF(const_str_plain_x509);
    const_tuple_str_plain_self_str_plain_key_str_plain_answer_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_key_str_plain_answer_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_key_str_plain_answer_tuple, 1, const_str_plain_key); Py_INCREF(const_str_plain_key);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_key_str_plain_answer_tuple, 2, const_str_plain_answer); Py_INCREF(const_str_plain_answer);
    const_str_plain_get_issuer = UNSTREAM_STRING(&constant_bin[ 153905 ], 10, 1);
    const_str_plain_X509_STORE_new = UNSTREAM_STRING(&constant_bin[ 153915 ], 14, 1);
    const_list_298f4a46a008df82aecc87d37443e76b_list = PyList_New(7);
    PyList_SET_ITEM(const_list_298f4a46a008df82aecc87d37443e76b_list, 0, const_str_plain_unspecified); Py_INCREF(const_str_plain_unspecified);
    PyList_SET_ITEM(const_list_298f4a46a008df82aecc87d37443e76b_list, 1, const_str_plain_keyCompromise); Py_INCREF(const_str_plain_keyCompromise);
    const_str_plain_CACompromise = UNSTREAM_STRING(&constant_bin[ 153929 ], 12, 1);
    PyList_SET_ITEM(const_list_298f4a46a008df82aecc87d37443e76b_list, 2, const_str_plain_CACompromise); Py_INCREF(const_str_plain_CACompromise);
    PyList_SET_ITEM(const_list_298f4a46a008df82aecc87d37443e76b_list, 3, const_str_plain_affiliationChanged); Py_INCREF(const_str_plain_affiliationChanged);
    PyList_SET_ITEM(const_list_298f4a46a008df82aecc87d37443e76b_list, 4, const_str_plain_superseded); Py_INCREF(const_str_plain_superseded);
    PyList_SET_ITEM(const_list_298f4a46a008df82aecc87d37443e76b_list, 5, const_str_plain_cessationOfOperation); Py_INCREF(const_str_plain_cessationOfOperation);
    PyList_SET_ITEM(const_list_298f4a46a008df82aecc87d37443e76b_list, 6, const_str_plain_certificateHold); Py_INCREF(const_str_plain_certificateHold);
    const_str_plain_EVP_PKEY_bits = UNSTREAM_STRING(&constant_bin[ 153941 ], 13, 1);
    const_str_plain_set_flags = UNSTREAM_STRING(&constant_bin[ 153954 ], 9, 1);
    const_str_plain__store_ctx = UNSTREAM_STRING(&constant_bin[ 133441 ], 10, 1);
    const_str_plain_set_reason = UNSTREAM_STRING(&constant_bin[ 153963 ], 10, 1);
    const_str_plain_encode_result = UNSTREAM_STRING(&constant_bin[ 52440 ], 13, 1);
    const_tuple_80a9571108770bd34772239ad97225a5_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_80a9571108770bd34772239ad97225a5_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_80a9571108770bd34772239ad97225a5_tuple, 1, const_str_plain_extensions); Py_INCREF(const_str_plain_extensions);
    PyTuple_SET_ITEM(const_tuple_80a9571108770bd34772239ad97225a5_tuple, 2, const_str_plain_ext); Py_INCREF(const_str_plain_ext);
    PyTuple_SET_ITEM(const_tuple_80a9571108770bd34772239ad97225a5_tuple, 3, const_str_plain_add_result); Py_INCREF(const_str_plain_add_result);
    const_str_digest_213346f5e36f3faf7ff7a566deec4adb = UNSTREAM_STRING(&constant_bin[ 153973 ], 252, 0);
    const_str_plain_set_nextUpdate = UNSTREAM_STRING(&constant_bin[ 154225 ], 14, 1);
    const_str_plain_PKCS7Type = UNSTREAM_STRING(&constant_bin[ 141814 ], 9, 1);
    const_str_plain_CRL = UNSTREAM_STRING(&constant_bin[ 4315 ], 3, 1);
    const_str_plain__cleanup = UNSTREAM_STRING(&constant_bin[ 129971 ], 8, 1);
    const_str_digest_6b975dcb77568b31c2312e045b6c638c = UNSTREAM_STRING(&constant_bin[ 154239 ], 35, 0);
    const_str_plain__bio_to_string = UNSTREAM_STRING(&constant_bin[ 3645 ], 14, 1);
    const_str_digest_cac81eaf46e08badbc89f13fa3bbdf6b = UNSTREAM_STRING(&constant_bin[ 154274 ], 477, 0);
    const_str_plain_X509_verify_cert = UNSTREAM_STRING(&constant_bin[ 126061 ], 16, 1);
    const_str_plain__get_asn1_time = UNSTREAM_STRING(&constant_bin[ 3930 ], 14, 1);
    const_str_digest_3f7d687efa133ae490fe62a28c3c2584 = UNSTREAM_STRING(&constant_bin[ 154751 ], 175, 0);
    const_str_digest_e4c79524acf8a72de25c6c6491f370a8 = UNSTREAM_STRING(&constant_bin[ 154926 ], 294, 0);
    const_str_plain_set_rev_date = UNSTREAM_STRING(&constant_bin[ 155220 ], 12, 1);
    const_str_plain_load_certificate = UNSTREAM_STRING(&constant_bin[ 142536 ], 16, 1);
    const_str_plain_X509_STORE_CTX_free = UNSTREAM_STRING(&constant_bin[ 155232 ], 19, 1);
    const_str_digest_719137938e890576c1050ba31a668078 = UNSTREAM_STRING(&constant_bin[ 155251 ], 205, 0);
    const_str_digest_500f278b67471fc0f770fccc80d65d95 = UNSTREAM_STRING(&constant_bin[ 155456 ], 21, 0);
    const_str_digest_193e0ef9a8bffd6c41bf909f2da817bd = UNSTREAM_STRING(&constant_bin[ 155477 ], 283, 0);
    const_str_digest_ab9563b0fc32f09cfde9a1636d8d2b80 = UNSTREAM_STRING(&constant_bin[ 155760 ], 181, 0);
    const_str_plain_X509Extension = UNSTREAM_STRING(&constant_bin[ 3721 ], 13, 1);
    const_str_digest_6ef28169edd3cfe530885f6f9d09c390 = UNSTREAM_STRING(&constant_bin[ 155941 ], 267, 0);
    const_str_digest_b1f5a355e1403668d0044e1a65ec29ce = UNSTREAM_STRING(&constant_bin[ 156208 ], 25, 0);
    const_tuple_13745beac221529fe5d89135e9b648d3_tuple = PyTuple_New(10);
    PyTuple_SET_ITEM(const_tuple_13745beac221529fe5d89135e9b648d3_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_13745beac221529fe5d89135e9b648d3_tuple, 1, const_str_plain_cert); Py_INCREF(const_str_plain_cert);
    PyTuple_SET_ITEM(const_tuple_13745beac221529fe5d89135e9b648d3_tuple, 2, const_str_plain_key); Py_INCREF(const_str_plain_key);
    PyTuple_SET_ITEM(const_tuple_13745beac221529fe5d89135e9b648d3_tuple, 3, const_str_plain_type); Py_INCREF(const_str_plain_type);
    PyTuple_SET_ITEM(const_tuple_13745beac221529fe5d89135e9b648d3_tuple, 4, const_str_plain_days); Py_INCREF(const_str_plain_days);
    PyTuple_SET_ITEM(const_tuple_13745beac221529fe5d89135e9b648d3_tuple, 5, const_str_plain_digest); Py_INCREF(const_str_plain_digest);
    PyTuple_SET_ITEM(const_tuple_13745beac221529fe5d89135e9b648d3_tuple, 6, const_str_plain_bio); Py_INCREF(const_str_plain_bio);
    PyTuple_SET_ITEM(const_tuple_13745beac221529fe5d89135e9b648d3_tuple, 7, const_str_plain_sometime); Py_INCREF(const_str_plain_sometime);
    PyTuple_SET_ITEM(const_tuple_13745beac221529fe5d89135e9b648d3_tuple, 8, const_str_plain_digest_obj); Py_INCREF(const_str_plain_digest_obj);
    PyTuple_SET_ITEM(const_tuple_13745beac221529fe5d89135e9b648d3_tuple, 9, const_str_plain_sign_result); Py_INCREF(const_str_plain_sign_result);
    const_str_digest_c237653198d1acecae3452511968b22e = UNSTREAM_STRING(&constant_bin[ 156233 ], 84, 0);
    const_str_plain_type_is_signed = UNSTREAM_STRING(&constant_bin[ 150940 ], 14, 1);
    const_str_digest_af63c2663b0a5e83daac69d308dcb1d6 = UNSTREAM_STRING(&constant_bin[ 156317 ], 158, 0);
    const_str_plain_get_friendlyname = UNSTREAM_STRING(&constant_bin[ 156475 ], 16, 1);
    const_str_plain_set_friendlyname = UNSTREAM_STRING(&constant_bin[ 156491 ], 16, 1);
    const_tuple_7df0279ef5fffac2c0a66ea7c472ab4b_tuple = PyTuple_New(5);
    PyTuple_SET_ITEM(const_tuple_7df0279ef5fffac2c0a66ea7c472ab4b_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_7df0279ef5fffac2c0a66ea7c472ab4b_tuple, 1, const_str_plain_pkey); Py_INCREF(const_str_plain_pkey);
    PyTuple_SET_ITEM(const_tuple_7df0279ef5fffac2c0a66ea7c472ab4b_tuple, 2, const_str_plain_digest); Py_INCREF(const_str_plain_digest);
    PyTuple_SET_ITEM(const_tuple_7df0279ef5fffac2c0a66ea7c472ab4b_tuple, 3, const_str_plain_digest_obj); Py_INCREF(const_str_plain_digest_obj);
    PyTuple_SET_ITEM(const_tuple_7df0279ef5fffac2c0a66ea7c472ab4b_tuple, 4, const_str_plain_sign_result); Py_INCREF(const_str_plain_sign_result);
    const_str_plain__untested_error = UNSTREAM_STRING(&constant_bin[ 3210 ], 15, 1);
    const_str_plain_load_publickey = UNSTREAM_STRING(&constant_bin[ 146083 ], 14, 1);
    const_tuple_e0284b4dc341731363d45f065b316e64_tuple = PyTuple_New(5);
    PyTuple_SET_ITEM(const_tuple_e0284b4dc341731363d45f065b316e64_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_e0284b4dc341731363d45f065b316e64_tuple, 1, const_str_plain_type); Py_INCREF(const_str_plain_type);
    PyTuple_SET_ITEM(const_tuple_e0284b4dc341731363d45f065b316e64_tuple, 2, const_str_plain_passphrase); Py_INCREF(const_str_plain_passphrase);
    PyTuple_SET_ITEM(const_tuple_e0284b4dc341731363d45f065b316e64_tuple, 3, const_str_plain_more_args); Py_INCREF(const_str_plain_more_args);
    PyTuple_SET_ITEM(const_tuple_e0284b4dc341731363d45f065b316e64_tuple, 4, const_str_plain_truncate); Py_INCREF(const_str_plain_truncate);
    const_tuple_f62306bb1360dfa87574f464cff0b6db_tuple = PyTuple_New(10);
    PyTuple_SET_ITEM(const_tuple_f62306bb1360dfa87574f464cff0b6db_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_f62306bb1360dfa87574f464cff0b6db_tuple, 1, const_str_plain_passphrase); Py_INCREF(const_str_plain_passphrase);
    PyTuple_SET_ITEM(const_tuple_f62306bb1360dfa87574f464cff0b6db_tuple, 2, const_str_plain_iter); Py_INCREF(const_str_plain_iter);
    PyTuple_SET_ITEM(const_tuple_f62306bb1360dfa87574f464cff0b6db_tuple, 3, const_str_plain_maciter); Py_INCREF(const_str_plain_maciter);
    PyTuple_SET_ITEM(const_tuple_f62306bb1360dfa87574f464cff0b6db_tuple, 4, const_str_plain_pkey); Py_INCREF(const_str_plain_pkey);
    PyTuple_SET_ITEM(const_tuple_f62306bb1360dfa87574f464cff0b6db_tuple, 5, const_str_plain_bio); Py_INCREF(const_str_plain_bio);
    PyTuple_SET_ITEM(const_tuple_f62306bb1360dfa87574f464cff0b6db_tuple, 6, const_str_plain_cacerts); Py_INCREF(const_str_plain_cacerts);
    PyTuple_SET_ITEM(const_tuple_f62306bb1360dfa87574f464cff0b6db_tuple, 7, const_str_plain_cert); Py_INCREF(const_str_plain_cert);
    PyTuple_SET_ITEM(const_tuple_f62306bb1360dfa87574f464cff0b6db_tuple, 8, const_str_plain_friendlyname); Py_INCREF(const_str_plain_friendlyname);
    PyTuple_SET_ITEM(const_tuple_f62306bb1360dfa87574f464cff0b6db_tuple, 9, const_str_plain_pkcs12); Py_INCREF(const_str_plain_pkcs12);
    const_str_digest_1dbb147d3e039266688c4d87287eaaad = UNSTREAM_STRING(&constant_bin[ 156507 ], 14, 0);
    const_str_digest_0d3c537bf958e2cc2494cf1be5c283dd = UNSTREAM_STRING(&constant_bin[ 156521 ], 320, 0);
    const_tuple_53b63b794c8b8f328f3f365985abd328_tuple = PyTuple_New(5);
    PyTuple_SET_ITEM(const_tuple_53b63b794c8b8f328f3f365985abd328_tuple, 0, const_str_plain_type); Py_INCREF(const_str_plain_type);
    PyTuple_SET_ITEM(const_tuple_53b63b794c8b8f328f3f365985abd328_tuple, 1, const_str_plain_buffer); Py_INCREF(const_str_plain_buffer);
    PyTuple_SET_ITEM(const_tuple_53b63b794c8b8f328f3f365985abd328_tuple, 2, const_str_plain_bio); Py_INCREF(const_str_plain_bio);
    PyTuple_SET_ITEM(const_tuple_53b63b794c8b8f328f3f365985abd328_tuple, 3, const_str_plain_result); Py_INCREF(const_str_plain_result);
    PyTuple_SET_ITEM(const_tuple_53b63b794c8b8f328f3f365985abd328_tuple, 4, const_str_plain_crl); Py_INCREF(const_str_plain_crl);
    const_tuple_str_plain_self_str_plain_pkey_str_plain_result_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_pkey_str_plain_result_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_pkey_str_plain_result_tuple, 1, const_str_plain_pkey); Py_INCREF(const_str_plain_pkey);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_pkey_str_plain_result_tuple, 2, const_str_plain_result); Py_INCREF(const_str_plain_result);
    const_str_plain_X509_STORE_set_flags = UNSTREAM_STRING(&constant_bin[ 156841 ], 20, 1);
    const_tuple_be611311fb5723111b9692ddf834f10b_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_be611311fb5723111b9692ddf834f10b_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_be611311fb5723111b9692ddf834f10b_tuple, 1, const_str_plain_cert); Py_INCREF(const_str_plain_cert);
    PyTuple_SET_ITEM(const_tuple_be611311fb5723111b9692ddf834f10b_tuple, 2, const_str_plain_code); Py_INCREF(const_str_plain_code);
    PyTuple_SET_ITEM(const_tuple_be611311fb5723111b9692ddf834f10b_tuple, 3, const_str_plain_err_reason); Py_INCREF(const_str_plain_err_reason);
    const_str_digest_9c28b2ef32679900c21c54152be8ce03 = UNSTREAM_STRING(&constant_bin[ 156861 ], 226, 0);
    const_str_digest_4097a084fab55cf5c5baa1b785e7c82a = UNSTREAM_STRING(&constant_bin[ 157087 ], 257, 0);
    const_str_digest_f35548e1d45f67292233a83f1d0adcce = UNSTREAM_STRING(&constant_bin[ 157344 ], 238, 0);
    const_str_plain_get_extensions = UNSTREAM_STRING(&constant_bin[ 157582 ], 14, 1);
    const_str_digest_92b8d1a7fa93b4e7d2fab02e37bc15f8 = UNSTREAM_STRING(&constant_bin[ 157596 ], 159, 0);
    const_str_plain_EVP_SignFinal = UNSTREAM_STRING(&constant_bin[ 157755 ], 13, 1);
    const_str_plain_get_notAfter = UNSTREAM_STRING(&constant_bin[ 157768 ], 12, 1);
    const_str_plain__set_boundary_time = UNSTREAM_STRING(&constant_bin[ 157780 ], 18, 1);
    const_str_digest_1a3a564060f5ebd53d44f6035495ba48 = UNSTREAM_STRING(&constant_bin[ 157798 ], 17, 0);
    const_str_plain_CB_ISSUER_CHECK = UNSTREAM_STRING(&constant_bin[ 147185 ], 15, 1);
    const_str_plain__issuer_invalidator = UNSTREAM_STRING(&constant_bin[ 157815 ], 19, 1);
    const_str_plain_PKCS7_type_is_enveloped = UNSTREAM_STRING(&constant_bin[ 157834 ], 23, 1);
    const_str_plain_ASN1_STRING_type = UNSTREAM_STRING(&constant_bin[ 157857 ], 16, 1);
    const_tuple_str_plain_self_str_plain_string_type_str_plain_nid_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_string_type_str_plain_nid_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_string_type_str_plain_nid_tuple, 1, const_str_plain_string_type); Py_INCREF(const_str_plain_string_type);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_string_type_str_plain_nid_tuple, 2, const_str_plain_nid); Py_INCREF(const_str_plain_nid);
    const_tuple_str_plain_cls_str_plain_x509_str_plain_cert_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_cls_str_plain_x509_str_plain_cert_tuple, 0, const_str_plain_cls); Py_INCREF(const_str_plain_cls);
    PyTuple_SET_ITEM(const_tuple_str_plain_cls_str_plain_x509_str_plain_cert_tuple, 1, const_str_plain_x509); Py_INCREF(const_str_plain_x509);
    PyTuple_SET_ITEM(const_tuple_str_plain_cls_str_plain_x509_str_plain_cert_tuple, 2, const_str_plain_cert); Py_INCREF(const_str_plain_cert);
    const_str_digest_117006b03ff8e10f330ac900a6cd41e8 = UNSTREAM_STRING(&constant_bin[ 157873 ], 25, 0);
    const_str_digest_221848055f0a545c7ef1969a37bb78a5 = UNSTREAM_STRING(&constant_bin[ 157898 ], 10, 0);
    const_str_plain_EC_get_builtin_curves = UNSTREAM_STRING(&constant_bin[ 157908 ], 21, 1);
    const_str_digest_0226e12d6e09b849c37787a1a7ec35a4 = UNSTREAM_STRING(&constant_bin[ 157929 ], 27, 0);
    const_str_plain_set_serial_number = UNSTREAM_STRING(&constant_bin[ 157956 ], 17, 1);
    const_str_digest_bbde1e297eda38e770b8fce1d06c225b = UNSTREAM_STRING(&constant_bin[ 157973 ], 43, 0);
    const_str_digest_3b5fd85224219fd172d589ec8f98a12a = UNSTREAM_STRING(&constant_bin[ 158016 ], 124, 0);
    const_tuple_8110525d9a52cec647809d72afbc7239_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_8110525d9a52cec647809d72afbc7239_tuple, 0, const_str_digest_b9c4baf879ebd882d40843df3a4dead7); Py_INCREF(const_str_digest_b9c4baf879ebd882d40843df3a4dead7);
    PyTuple_SET_ITEM(const_tuple_8110525d9a52cec647809d72afbc7239_tuple, 1, const_str_plain_c); Py_INCREF(const_str_plain_c);
    PyTuple_SET_ITEM(const_tuple_8110525d9a52cec647809d72afbc7239_tuple, 2, const_str_plain_lib); Py_INCREF(const_str_plain_lib);
    PyTuple_SET_ITEM(const_tuple_8110525d9a52cec647809d72afbc7239_tuple, 3, const_str_plain_cls); Py_INCREF(const_str_plain_cls);
    const_str_digest_4560cdf69c017b7cd264323295e708cb = UNSTREAM_STRING(&constant_bin[ 158140 ], 28, 0);
    const_tuple_13d990c39f45e826db58a38b07f9cd95_tuple = PyTuple_New(7);
    PyTuple_SET_ITEM(const_tuple_13d990c39f45e826db58a38b07f9cd95_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_13d990c39f45e826db58a38b07f9cd95_tuple, 1, const_str_plain_serial); Py_INCREF(const_str_plain_serial);
    PyTuple_SET_ITEM(const_tuple_13d990c39f45e826db58a38b07f9cd95_tuple, 2, const_str_plain_asn1_serial); Py_INCREF(const_str_plain_asn1_serial);
    PyTuple_SET_ITEM(const_tuple_13d990c39f45e826db58a38b07f9cd95_tuple, 3, const_str_plain_bignum_serial); Py_INCREF(const_str_plain_bignum_serial);
    PyTuple_SET_ITEM(const_tuple_13d990c39f45e826db58a38b07f9cd95_tuple, 4, const_str_plain_set_result); Py_INCREF(const_str_plain_set_result);
    const_str_plain_small_serial = UNSTREAM_STRING(&constant_bin[ 158168 ], 12, 1);
    PyTuple_SET_ITEM(const_tuple_13d990c39f45e826db58a38b07f9cd95_tuple, 5, const_str_plain_small_serial); Py_INCREF(const_str_plain_small_serial);
    const_str_plain_hex_serial = UNSTREAM_STRING(&constant_bin[ 158180 ], 10, 1);
    PyTuple_SET_ITEM(const_tuple_13d990c39f45e826db58a38b07f9cd95_tuple, 6, const_str_plain_hex_serial); Py_INCREF(const_str_plain_hex_serial);
    const_tuple_1598e2e44a7cbbc56ff6b01a61982114_tuple = PyTuple_New(9);
    PyTuple_SET_ITEM(const_tuple_1598e2e44a7cbbc56ff6b01a61982114_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_1598e2e44a7cbbc56ff6b01a61982114_tuple, 1, const_str_plain_value); Py_INCREF(const_str_plain_value);
    PyTuple_SET_ITEM(const_tuple_1598e2e44a7cbbc56ff6b01a61982114_tuple, 2, const_str_plain_name); Py_INCREF(const_str_plain_name);
    PyTuple_SET_ITEM(const_tuple_1598e2e44a7cbbc56ff6b01a61982114_tuple, 3, const_str_plain_i); Py_INCREF(const_str_plain_i);
    PyTuple_SET_ITEM(const_tuple_1598e2e44a7cbbc56ff6b01a61982114_tuple, 4, const_str_plain_nid); Py_INCREF(const_str_plain_nid);
    PyTuple_SET_ITEM(const_tuple_1598e2e44a7cbbc56ff6b01a61982114_tuple, 5, const_str_plain_fval); Py_INCREF(const_str_plain_fval);
    const_str_plain_ent = UNSTREAM_STRING(&constant_bin[ 24 ], 3, 1);
    PyTuple_SET_ITEM(const_tuple_1598e2e44a7cbbc56ff6b01a61982114_tuple, 6, const_str_plain_ent); Py_INCREF(const_str_plain_ent);
    PyTuple_SET_ITEM(const_tuple_1598e2e44a7cbbc56ff6b01a61982114_tuple, 7, const_str_plain_result); Py_INCREF(const_str_plain_result);
    PyTuple_SET_ITEM(const_tuple_1598e2e44a7cbbc56ff6b01a61982114_tuple, 8, const_str_plain_fname); Py_INCREF(const_str_plain_fname);
    const_str_digest_5e37d069c5e76ee6d50c7e91b7181934 = UNSTREAM_STRING(&constant_bin[ 158190 ], 232, 0);
    const_tuple_f6b86765c5a5e2cb7660564ebdcec2d7_tuple = PyTuple_New(9);
    PyTuple_SET_ITEM(const_tuple_f6b86765c5a5e2cb7660564ebdcec2d7_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_f6b86765c5a5e2cb7660564ebdcec2d7_tuple, 1, const_str_plain_name); Py_INCREF(const_str_plain_name);
    PyTuple_SET_ITEM(const_tuple_f6b86765c5a5e2cb7660564ebdcec2d7_tuple, 2, const_str_plain_result_buffer); Py_INCREF(const_str_plain_result_buffer);
    const_str_plain_data_length = UNSTREAM_STRING(&constant_bin[ 96088 ], 11, 1);
    PyTuple_SET_ITEM(const_tuple_f6b86765c5a5e2cb7660564ebdcec2d7_tuple, 3, const_str_plain_data_length); Py_INCREF(const_str_plain_data_length);
    PyTuple_SET_ITEM(const_tuple_f6b86765c5a5e2cb7660564ebdcec2d7_tuple, 4, const_str_plain_nid); Py_INCREF(const_str_plain_nid);
    PyTuple_SET_ITEM(const_tuple_f6b86765c5a5e2cb7660564ebdcec2d7_tuple, 5, const_str_plain_result); Py_INCREF(const_str_plain_result);
    PyTuple_SET_ITEM(const_tuple_f6b86765c5a5e2cb7660564ebdcec2d7_tuple, 6, const_str_plain_entry_index); Py_INCREF(const_str_plain_entry_index);
    PyTuple_SET_ITEM(const_tuple_f6b86765c5a5e2cb7660564ebdcec2d7_tuple, 7, const_str_plain_entry); Py_INCREF(const_str_plain_entry);
    PyTuple_SET_ITEM(const_tuple_f6b86765c5a5e2cb7660564ebdcec2d7_tuple, 8, const_str_plain_data); Py_INCREF(const_str_plain_data);
    const_str_digest_c85d62bfc2af2f3c2202464fd6374ea7 = UNSTREAM_STRING(&constant_bin[ 158422 ], 20, 0);
    const_tuple_4415e41d2d925845f2ba634f8c71f0dc_tuple = PyTuple_New(6);
    PyTuple_SET_ITEM(const_tuple_4415e41d2d925845f2ba634f8c71f0dc_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    const_str_plain_issuer_cert = UNSTREAM_STRING(&constant_bin[ 158442 ], 11, 1);
    PyTuple_SET_ITEM(const_tuple_4415e41d2d925845f2ba634f8c71f0dc_tuple, 1, const_str_plain_issuer_cert); Py_INCREF(const_str_plain_issuer_cert);
    PyTuple_SET_ITEM(const_tuple_4415e41d2d925845f2ba634f8c71f0dc_tuple, 2, const_str_plain_issuer_key); Py_INCREF(const_str_plain_issuer_key);
    PyTuple_SET_ITEM(const_tuple_4415e41d2d925845f2ba634f8c71f0dc_tuple, 3, const_str_plain_digest); Py_INCREF(const_str_plain_digest);
    PyTuple_SET_ITEM(const_tuple_4415e41d2d925845f2ba634f8c71f0dc_tuple, 4, const_str_plain_digest_obj); Py_INCREF(const_str_plain_digest_obj);
    PyTuple_SET_ITEM(const_tuple_4415e41d2d925845f2ba634f8c71f0dc_tuple, 5, const_str_plain_result); Py_INCREF(const_str_plain_result);
    const_str_plain_EVP_SignUpdate = UNSTREAM_STRING(&constant_bin[ 158453 ], 14, 1);
    const_str_plain_digest_name = UNSTREAM_STRING(&constant_bin[ 137310 ], 11, 1);
    const_str_digest_0b9d4db9119537682a1f5302a9cbcc57 = UNSTREAM_STRING(&constant_bin[ 158467 ], 321, 0);
    const_str_plain_X509_V_FLAG_EXPLICIT_POLICY = UNSTREAM_STRING(&constant_bin[ 158788 ], 27, 1);
    const_str_plain_PKCS7_free = UNSTREAM_STRING(&constant_bin[ 158815 ], 10, 1);
    const_str_digest_1d1fec7c0642196df296efbe43db1801 = UNSTREAM_STRING(&constant_bin[ 158825 ], 722, 0);
    const_str_plain_exts = UNSTREAM_STRING(&constant_bin[ 85354 ], 4, 1);
    const_str_plain_TYPE_EC = UNSTREAM_STRING(&constant_bin[ 159547 ], 7, 1);
    const_str_plain_rwflag = UNSTREAM_STRING(&constant_bin[ 159554 ], 6, 1);
    const_tuple_str_plain_type_str_plain_buffer_str_plain_bio_str_plain_x509_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_str_plain_type_str_plain_buffer_str_plain_bio_str_plain_x509_tuple, 0, const_str_plain_type); Py_INCREF(const_str_plain_type);
    PyTuple_SET_ITEM(const_tuple_str_plain_type_str_plain_buffer_str_plain_bio_str_plain_x509_tuple, 1, const_str_plain_buffer); Py_INCREF(const_str_plain_buffer);
    PyTuple_SET_ITEM(const_tuple_str_plain_type_str_plain_buffer_str_plain_bio_str_plain_x509_tuple, 2, const_str_plain_bio); Py_INCREF(const_str_plain_bio);
    PyTuple_SET_ITEM(const_tuple_str_plain_type_str_plain_buffer_str_plain_bio_str_plain_x509_tuple, 3, const_str_plain_x509); Py_INCREF(const_str_plain_x509);
    const_tuple_str_digest_4560cdf69c017b7cd264323295e708cb_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_digest_4560cdf69c017b7cd264323295e708cb_tuple, 0, const_str_digest_4560cdf69c017b7cd264323295e708cb); Py_INCREF(const_str_digest_4560cdf69c017b7cd264323295e708cb);
    const_str_plain_CRL_CHECK_ALL = UNSTREAM_STRING(&constant_bin[ 150966 ], 13, 1);
    const_str_digest_d85051204198165c5d51e35c1e5d5077 = UNSTREAM_STRING(&constant_bin[ 159560 ], 214, 0);
    const_str_digest_a2b9bb33a11d02b696dfc736bf45c56d = UNSTREAM_STRING(&constant_bin[ 159774 ], 290, 0);
    const_str_plain_TYPE_DSA = UNSTREAM_STRING(&constant_bin[ 3396 ], 8, 1);
    const_str_plain_M_ASN1_OCTET_STRING_print = UNSTREAM_STRING(&constant_bin[ 160064 ], 25, 1);
    const_str_digest_07697dd6fa4854473fa24b52569d5636 = UNSTREAM_STRING(&constant_bin[ 160089 ], 139, 0);
    const_str_plain_has_expired = UNSTREAM_STRING(&constant_bin[ 160228 ], 11, 1);
    const_str_plain_gmtime_adj_notAfter = UNSTREAM_STRING(&constant_bin[ 160239 ], 19, 1);
    const_str_plain__EllipticCurve = UNSTREAM_STRING(&constant_bin[ 3433 ], 14, 1);
    const_str_digest_007f81c06fa49e709fd9306cc6c26627 = UNSTREAM_STRING(&constant_bin[ 160258 ], 189, 0);
    const_str_plain_X509Req = UNSTREAM_STRING(&constant_bin[ 4279 ], 7, 1);
    const_str_plain_X509_STORE_add_cert = UNSTREAM_STRING(&constant_bin[ 160447 ], 19, 1);
    const_str_plain_X509_STORE_CTX_new = UNSTREAM_STRING(&constant_bin[ 160466 ], 18, 1);
    const_str_plain_digest_result = UNSTREAM_STRING(&constant_bin[ 160484 ], 13, 1);
    const_tuple_str_plain__CertificateRevocationList_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_plain__CertificateRevocationList_tuple, 0, const_str_plain__CertificateRevocationList); Py_INCREF(const_str_plain__CertificateRevocationList);
    const_tuple_str_plain_self_str_plain__issuer_str_plain_issuer_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain__issuer_str_plain_issuer_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain__issuer_str_plain_issuer_tuple, 1, const_str_plain__issuer); Py_INCREF(const_str_plain__issuer);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain__issuer_str_plain_issuer_tuple, 2, const_str_plain_issuer); Py_INCREF(const_str_plain_issuer);
    const_str_plain_gmtime_adj_notBefore = UNSTREAM_STRING(&constant_bin[ 160497 ], 20, 1);
    const_str_plain__exception_from_context = UNSTREAM_STRING(&constant_bin[ 160517 ], 23, 1);
    const_tuple_str_plain_self_str_plain_rsa_str_plain_result_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_rsa_str_plain_result_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_rsa_str_plain_result_tuple, 1, const_str_plain_rsa); Py_INCREF(const_str_plain_rsa);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_rsa_str_plain_result_tuple, 2, const_str_plain_result); Py_INCREF(const_str_plain_result);
    const_str_plain_X509_STORE_set1_param = UNSTREAM_STRING(&constant_bin[ 160540 ], 21, 1);
    const_str_plain_get_critical = UNSTREAM_STRING(&constant_bin[ 160561 ], 12, 1);
    const_tuple_str_plain_cls_str_plain_lib_str_plain_nid_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_cls_str_plain_lib_str_plain_nid_tuple, 0, const_str_plain_cls); Py_INCREF(const_str_plain_cls);
    PyTuple_SET_ITEM(const_tuple_str_plain_cls_str_plain_lib_str_plain_nid_tuple, 1, const_str_plain_lib); Py_INCREF(const_str_plain_lib);
    PyTuple_SET_ITEM(const_tuple_str_plain_cls_str_plain_lib_str_plain_nid_tuple, 2, const_str_plain_nid); Py_INCREF(const_str_plain_nid);
    const_str_plain__req = UNSTREAM_STRING(&constant_bin[ 2178 ], 4, 1);
    const_str_plain_X509_CRL_sort = UNSTREAM_STRING(&constant_bin[ 160573 ], 13, 1);
    const_str_digest_4d14f6e4d6647c6573e3ca9449c2b51f = UNSTREAM_STRING(&constant_bin[ 160586 ], 199, 0);
    const_str_plain__prefixes = UNSTREAM_STRING(&constant_bin[ 160785 ], 9, 1);
    const_tuple_5209455ecbb28249752027c3a839ae1c_tuple = PyTuple_New(8);
    PyTuple_SET_ITEM(const_tuple_5209455ecbb28249752027c3a839ae1c_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_5209455ecbb28249752027c3a839ae1c_tuple, 1, const_str_plain_buf); Py_INCREF(const_str_plain_buf);
    PyTuple_SET_ITEM(const_tuple_5209455ecbb28249752027c3a839ae1c_tuple, 2, const_str_plain_size); Py_INCREF(const_str_plain_size);
    PyTuple_SET_ITEM(const_tuple_5209455ecbb28249752027c3a839ae1c_tuple, 3, const_str_plain_rwflag); Py_INCREF(const_str_plain_rwflag);
    PyTuple_SET_ITEM(const_tuple_5209455ecbb28249752027c3a839ae1c_tuple, 4, const_str_plain_userdata); Py_INCREF(const_str_plain_userdata);
    PyTuple_SET_ITEM(const_tuple_5209455ecbb28249752027c3a839ae1c_tuple, 5, const_str_plain_e); Py_INCREF(const_str_plain_e);
    PyTuple_SET_ITEM(const_tuple_5209455ecbb28249752027c3a839ae1c_tuple, 6, const_str_plain_i); Py_INCREF(const_str_plain_i);
    PyTuple_SET_ITEM(const_tuple_5209455ecbb28249752027c3a839ae1c_tuple, 7, const_str_plain_result); Py_INCREF(const_str_plain_result);
    const_str_plain_PEM_write_bio_PrivateKey = UNSTREAM_STRING(&constant_bin[ 160794 ], 24, 1);
    const_str_plain_PEM_read_bio_PKCS7 = UNSTREAM_STRING(&constant_bin[ 160818 ], 18, 1);
    const_tuple_str_plain_self_str_plain_which_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_which_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_which_tuple, 1, const_str_plain_which); Py_INCREF(const_str_plain_which);
    const_str_digest_0ba82c04a076f46925a74539c2a8ba40 = UNSTREAM_STRING(&constant_bin[ 160836 ], 459, 0);
    const_tuple_str_plain_self_str_plain_amount_str_plain_notBefore_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_amount_str_plain_notBefore_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_amount_str_plain_notBefore_tuple, 1, const_str_plain_amount); Py_INCREF(const_str_plain_amount);
    const_str_plain_notBefore = UNSTREAM_STRING(&constant_bin[ 135517 ], 9, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_amount_str_plain_notBefore_tuple, 2, const_str_plain_notBefore); Py_INCREF(const_str_plain_notBefore);
    const_str_plain_to_cryptography_key = UNSTREAM_STRING(&constant_bin[ 161295 ], 19, 1);
    const_str_digest_97388c7ddfea4f913fec5c846dd26ef1 = UNSTREAM_STRING(&constant_bin[ 161314 ], 279, 0);
    const_tuple_79603f0465bd62773d6ec6c98e743896_tuple = PyTuple_New(7);
    PyTuple_SET_ITEM(const_tuple_79603f0465bd62773d6ec6c98e743896_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_79603f0465bd62773d6ec6c98e743896_tuple, 1, const_str_plain_reason); Py_INCREF(const_str_plain_reason);
    PyTuple_SET_ITEM(const_tuple_79603f0465bd62773d6ec6c98e743896_tuple, 2, const_str_plain_reason_code); Py_INCREF(const_str_plain_reason_code);
    PyTuple_SET_ITEM(const_tuple_79603f0465bd62773d6ec6c98e743896_tuple, 3, const_str_plain_set_result); Py_INCREF(const_str_plain_set_result);
    PyTuple_SET_ITEM(const_tuple_79603f0465bd62773d6ec6c98e743896_tuple, 4, const_str_plain_r); Py_INCREF(const_str_plain_r);
    PyTuple_SET_ITEM(const_tuple_79603f0465bd62773d6ec6c98e743896_tuple, 5, const_str_plain_add_result); Py_INCREF(const_str_plain_add_result);
    PyTuple_SET_ITEM(const_tuple_79603f0465bd62773d6ec6c98e743896_tuple, 6, const_str_plain_new_reason_ext); Py_INCREF(const_str_plain_new_reason_ext);
    const_str_plain_NETSCAPE_SPKI_sign = UNSTREAM_STRING(&constant_bin[ 161593 ], 18, 1);
    const_tuple_str_plain_self_str_plain_bio_str_plain_print_result_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_bio_str_plain_print_result_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_bio_str_plain_print_result_tuple, 1, const_str_plain_bio); Py_INCREF(const_str_plain_bio);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_bio_str_plain_print_result_tuple, 2, const_str_plain_print_result); Py_INCREF(const_str_plain_print_result);
    const_str_digest_61d70cefdce1472400ab8a06d64ef78a = UNSTREAM_STRING(&constant_bin[ 161611 ], 142, 0);
    const_str_plain_load_privatekey = UNSTREAM_STRING(&constant_bin[ 146102 ], 15, 1);
    const_tuple_str_digest_f3b04f8993b30e664e4afacb3d64cdc4_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_digest_f3b04f8993b30e664e4afacb3d64cdc4_tuple, 0, const_str_digest_f3b04f8993b30e664e4afacb3d64cdc4); Py_INCREF(const_str_digest_f3b04f8993b30e664e4afacb3d64cdc4);
    const_tuple_str_plain_cls_str_plain_crypto_req_str_plain_req_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_cls_str_plain_crypto_req_str_plain_req_tuple, 0, const_str_plain_cls); Py_INCREF(const_str_plain_cls);
    PyTuple_SET_ITEM(const_tuple_str_plain_cls_str_plain_crypto_req_str_plain_req_tuple, 1, const_str_plain_crypto_req); Py_INCREF(const_str_plain_crypto_req);
    PyTuple_SET_ITEM(const_tuple_str_plain_cls_str_plain_crypto_req_str_plain_req_tuple, 2, const_str_plain_req); Py_INCREF(const_str_plain_req);
    const_str_digest_e19f4eaf61167e65441aca909fe75b36 = UNSTREAM_STRING(&constant_bin[ 161753 ], 23, 0);
    const_str_plain_MBSTRING_UTF8 = UNSTREAM_STRING(&constant_bin[ 161776 ], 13, 1);
    const_tuple_str_plain_self_str_plain_cacerts_str_plain_cert_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_cacerts_str_plain_cert_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_cacerts_str_plain_cert_tuple, 1, const_str_plain_cacerts); Py_INCREF(const_str_plain_cacerts);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_cacerts_str_plain_cert_tuple, 2, const_str_plain_cert); Py_INCREF(const_str_plain_cert);
    const_str_plain_Revoked = UNSTREAM_STRING(&constant_bin[ 4150 ], 7, 1);
    const_str_plain__only_public = UNSTREAM_STRING(&constant_bin[ 161789 ], 12, 1);
    const_str_plain_GENERAL_NAME_print = UNSTREAM_STRING(&constant_bin[ 161801 ], 18, 1);
    const_str_plain__names = UNSTREAM_STRING(&constant_bin[ 23682 ], 6, 1);
    const_str_digest_c57795fb6a9ac3d47e928f9a8b608571 = UNSTREAM_STRING(&constant_bin[ 161819 ], 43, 0);
    const_tuple_str_plain_self_str_plain_store_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_store_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_store_tuple, 1, const_str_plain_store); Py_INCREF(const_str_plain_store);
    const_tuple_str_plain_self_str_plain_vfy_time_str_plain_param_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_vfy_time_str_plain_param_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_vfy_time_str_plain_param_tuple, 1, const_str_plain_vfy_time); Py_INCREF(const_str_plain_vfy_time);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_vfy_time_str_plain_param_tuple, 2, const_str_plain_param); Py_INCREF(const_str_plain_param);
    const_str_plain_add_extensions = UNSTREAM_STRING(&constant_bin[ 161862 ], 14, 1);
    const_str_plain_EVP_VerifyInit = UNSTREAM_STRING(&constant_bin[ 161876 ], 14, 1);
    const_str_digest_880f67f2b28115a7ad1d1bfb533fc6bc = UNSTREAM_STRING(&constant_bin[ 161890 ], 313, 0);
    const_str_plain_NID_crl_reason = UNSTREAM_STRING(&constant_bin[ 162203 ], 14, 1);
    const_str_plain_generalized_timestamp = UNSTREAM_STRING(&constant_bin[ 162217 ], 21, 1);
    const_str_plain_X509StoreContextError = UNSTREAM_STRING(&constant_bin[ 4016 ], 21, 1);
    const_str_digest_b2d5bbfa3f949ddcc231b89e71aa8d92 = UNSTREAM_STRING(&constant_bin[ 162238 ], 181, 0);
    const_tuple_str_plain_name_str_plain_curve_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_name_str_plain_curve_tuple, 0, const_str_plain_name); Py_INCREF(const_str_plain_name);
    PyTuple_SET_ITEM(const_tuple_str_plain_name_str_plain_curve_tuple, 1, const_str_plain_curve); Py_INCREF(const_str_plain_curve);
    const_str_plain_X509_V_FLAG_INHIBIT_MAP = UNSTREAM_STRING(&constant_bin[ 162419 ], 23, 1);
    const_tuple_str_plain_cls_str_plain_crypto_key_str_plain_pkey_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_cls_str_plain_crypto_key_str_plain_pkey_tuple, 0, const_str_plain_cls); Py_INCREF(const_str_plain_cls);
    const_str_plain_crypto_key = UNSTREAM_STRING(&constant_bin[ 146985 ], 10, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain_cls_str_plain_crypto_key_str_plain_pkey_tuple, 1, const_str_plain_crypto_key); Py_INCREF(const_str_plain_crypto_key);
    PyTuple_SET_ITEM(const_tuple_str_plain_cls_str_plain_crypto_key_str_plain_pkey_tuple, 2, const_str_plain_pkey); Py_INCREF(const_str_plain_pkey);
    const_str_digest_fdf1281f34921aa68eda346883bb972d = UNSTREAM_STRING(&constant_bin[ 162442 ], 62, 0);
    const_str_digest_cf86a9123926465ab14a7bd2861326f6 = UNSTREAM_STRING(&constant_bin[ 162504 ], 571, 0);
    const_tuple_str_plain_buffer_str_plain_bio_str_plain_data_str_plain_free_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_str_plain_buffer_str_plain_bio_str_plain_data_str_plain_free_tuple, 0, const_str_plain_buffer); Py_INCREF(const_str_plain_buffer);
    PyTuple_SET_ITEM(const_tuple_str_plain_buffer_str_plain_bio_str_plain_data_str_plain_free_tuple, 1, const_str_plain_bio); Py_INCREF(const_str_plain_bio);
    PyTuple_SET_ITEM(const_tuple_str_plain_buffer_str_plain_bio_str_plain_data_str_plain_free_tuple, 2, const_str_plain_data); Py_INCREF(const_str_plain_data);
    const_str_plain_free = UNSTREAM_STRING(&constant_bin[ 105452 ], 4, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain_buffer_str_plain_bio_str_plain_data_str_plain_free_tuple, 3, const_str_plain_free); Py_INCREF(const_str_plain_free);
    const_str_plain__owner = UNSTREAM_STRING(&constant_bin[ 163075 ], 6, 1);
    const_tuple_21bd89dfe3a1dd3e39e03972a01f5a89_tuple = PyTuple_New(5);
    PyTuple_SET_ITEM(const_tuple_21bd89dfe3a1dd3e39e03972a01f5a89_tuple, 0, const_str_plain_type); Py_INCREF(const_str_plain_type);
    PyTuple_SET_ITEM(const_tuple_21bd89dfe3a1dd3e39e03972a01f5a89_tuple, 1, const_str_plain_buffer); Py_INCREF(const_str_plain_buffer);
    PyTuple_SET_ITEM(const_tuple_21bd89dfe3a1dd3e39e03972a01f5a89_tuple, 2, const_str_plain_bio); Py_INCREF(const_str_plain_bio);
    PyTuple_SET_ITEM(const_tuple_21bd89dfe3a1dd3e39e03972a01f5a89_tuple, 3, const_str_plain_req); Py_INCREF(const_str_plain_req);
    PyTuple_SET_ITEM(const_tuple_21bd89dfe3a1dd3e39e03972a01f5a89_tuple, 4, const_str_plain_x509req); Py_INCREF(const_str_plain_x509req);
    const_str_plain_ASN1_STRING_data = UNSTREAM_STRING(&constant_bin[ 163081 ], 16, 1);
    const_str_digest_819566a56c114d5ab553db6b3a965184 = UNSTREAM_STRING(&constant_bin[ 163097 ], 18, 0);
    const_str_plain_sk_X509_new_null = UNSTREAM_STRING(&constant_bin[ 163115 ], 16, 1);
    const_str_plain_ASN1_STRING_length = UNSTREAM_STRING(&constant_bin[ 163131 ], 18, 1);
    const_tuple_str_digest_016ce3807ea72a262d921fa7d1804717_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_digest_016ce3807ea72a262d921fa7d1804717_tuple, 0, const_str_digest_016ce3807ea72a262d921fa7d1804717); Py_INCREF(const_str_digest_016ce3807ea72a262d921fa7d1804717);
    const_str_plain_type_is_signedAndEnveloped = UNSTREAM_STRING(&constant_bin[ 151005 ], 26, 1);
    const_tuple_c1e1b7e48a4d24180e53a91b4e9e45ad_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_c1e1b7e48a4d24180e53a91b4e9e45ad_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_c1e1b7e48a4d24180e53a91b4e9e45ad_tuple, 1, const_str_plain_store); Py_INCREF(const_str_plain_store);
    PyTuple_SET_ITEM(const_tuple_c1e1b7e48a4d24180e53a91b4e9e45ad_tuple, 2, const_str_plain_certificate); Py_INCREF(const_str_plain_certificate);
    PyTuple_SET_ITEM(const_tuple_c1e1b7e48a4d24180e53a91b4e9e45ad_tuple, 3, const_str_plain_store_ctx); Py_INCREF(const_str_plain_store_ctx);
    const_str_plain_X509_NAME_oneline = UNSTREAM_STRING(&constant_bin[ 163149 ], 17, 1);
    const_str_digest_35f6b1c1261cd55e34a5b00d6cb8d5ea = UNSTREAM_STRING(&constant_bin[ 163166 ], 37, 0);
    const_str_digest_c623dd0c947983ab2cfcbe4c53400720 = UNSTREAM_STRING(&constant_bin[ 163203 ], 14, 0);
    const_str_digest_9acbe023ce14d1d2ba528bd23b2423a0 = UNSTREAM_STRING(&constant_bin[ 163217 ], 415, 0);
    const_str_plain_EVP_PKEY_type = UNSTREAM_STRING(&constant_bin[ 163632 ], 13, 1);
    const_tuple_aa595f479ccfd6af3a4dde57a871f8ed_tuple = PyTuple_New(5);
    PyTuple_SET_ITEM(const_tuple_aa595f479ccfd6af3a4dde57a871f8ed_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_aa595f479ccfd6af3a4dde57a871f8ed_tuple, 1, const_str_plain_char_result); Py_INCREF(const_str_plain_char_result);
    PyTuple_SET_ITEM(const_tuple_aa595f479ccfd6af3a4dde57a871f8ed_tuple, 2, const_str_plain_octet_result); Py_INCREF(const_str_plain_octet_result);
    PyTuple_SET_ITEM(const_tuple_aa595f479ccfd6af3a4dde57a871f8ed_tuple, 3, const_str_plain_string_result); Py_INCREF(const_str_plain_string_result);
    const_str_plain_result_length = UNSTREAM_STRING(&constant_bin[ 163645 ], 13, 1);
    PyTuple_SET_ITEM(const_tuple_aa595f479ccfd6af3a4dde57a871f8ed_tuple, 4, const_str_plain_result_length); Py_INCREF(const_str_plain_result_length);
    const_tuple_48783f9f765e1ca05b39b42cba82d1fc_tuple = PyTuple_New(8);
    PyTuple_SET_ITEM(const_tuple_48783f9f765e1ca05b39b42cba82d1fc_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_48783f9f765e1ca05b39b42cba82d1fc_tuple, 1, const_str_plain_bio); Py_INCREF(const_str_plain_bio);
    PyTuple_SET_ITEM(const_tuple_48783f9f765e1ca05b39b42cba82d1fc_tuple, 2, const_str_plain_name); Py_INCREF(const_str_plain_name);
    PyTuple_SET_ITEM(const_tuple_48783f9f765e1ca05b39b42cba82d1fc_tuple, 3, const_str_plain_i); Py_INCREF(const_str_plain_i);
    PyTuple_SET_ITEM(const_tuple_48783f9f765e1ca05b39b42cba82d1fc_tuple, 4, const_str_plain_value); Py_INCREF(const_str_plain_value);
    PyTuple_SET_ITEM(const_tuple_48783f9f765e1ca05b39b42cba82d1fc_tuple, 5, const_str_plain_label); Py_INCREF(const_str_plain_label);
    PyTuple_SET_ITEM(const_tuple_48783f9f765e1ca05b39b42cba82d1fc_tuple, 6, const_str_plain_parts); Py_INCREF(const_str_plain_parts);
    PyTuple_SET_ITEM(const_tuple_48783f9f765e1ca05b39b42cba82d1fc_tuple, 7, const_str_plain_names); Py_INCREF(const_str_plain_names);
    const_str_digest_f76c1a90d81cc9627b0b6df42991dbc9 = UNSTREAM_STRING(&constant_bin[ 163658 ], 393, 0);
    const_str_digest_2cf9e4c7f607857df636a128997ff3fc = UNSTREAM_STRING(&constant_bin[ 164051 ], 31, 0);
    const_tuple_d23f6dfb17b5708d3504cb59648ebed0_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_d23f6dfb17b5708d3504cb59648ebed0_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_d23f6dfb17b5708d3504cb59648ebed0_tuple, 1, const_str_plain_which); Py_INCREF(const_str_plain_which);
    PyTuple_SET_ITEM(const_tuple_d23f6dfb17b5708d3504cb59648ebed0_tuple, 2, const_str_plain_name); Py_INCREF(const_str_plain_name);
    PyTuple_SET_ITEM(const_tuple_d23f6dfb17b5708d3504cb59648ebed0_tuple, 3, const_str_plain_set_result); Py_INCREF(const_str_plain_set_result);
    const_str_plain_dump_privatekey = UNSTREAM_STRING(&constant_bin[ 146005 ], 15, 1);
    const_str_digest_686e4f9f1c51b7038afe792590c33346 = UNSTREAM_STRING(&constant_bin[ 164082 ], 118, 0);
    const_str_digest_0d8911e895179dcd467b4e9de2f411d4 = UNSTREAM_STRING(&constant_bin[ 164200 ], 250, 0);
    const_str_plain__load_elliptic_curves = UNSTREAM_STRING(&constant_bin[ 164450 ], 21, 1);
    const_str_plain__pkcs7 = UNSTREAM_STRING(&constant_bin[ 126219 ], 6, 1);
    const_str_plain__get_boundary_time = UNSTREAM_STRING(&constant_bin[ 164471 ], 18, 1);
    const_tuple_7fda6bda0dce687e350e407f685c57f6_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_7fda6bda0dce687e350e407f685c57f6_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_7fda6bda0dce687e350e407f685c57f6_tuple, 1, const_str_plain_result_buffer); Py_INCREF(const_str_plain_result_buffer);
    PyTuple_SET_ITEM(const_tuple_7fda6bda0dce687e350e407f685c57f6_tuple, 2, const_str_plain_string_result); Py_INCREF(const_str_plain_string_result);
    PyTuple_SET_ITEM(const_tuple_7fda6bda0dce687e350e407f685c57f6_tuple, 3, const_str_plain_encode_result); Py_INCREF(const_str_plain_encode_result);
    const_tuple_str_plain_ASN1_TIME_to_generalizedtime_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_plain_ASN1_TIME_to_generalizedtime_tuple, 0, const_str_plain_ASN1_TIME_to_generalizedtime); Py_INCREF(const_str_plain_ASN1_TIME_to_generalizedtime);
    const_str_plain_pem_password_cb = UNSTREAM_STRING(&constant_bin[ 164489 ], 15, 1);
    const_tuple_64996e5d3f2714cc368d8bf48665c67a_tuple = PyTuple_New(6);
    PyTuple_SET_ITEM(const_tuple_64996e5d3f2714cc368d8bf48665c67a_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_64996e5d3f2714cc368d8bf48665c67a_tuple, 1, const_str_plain_bignum_serial); Py_INCREF(const_str_plain_bignum_serial);
    PyTuple_SET_ITEM(const_tuple_64996e5d3f2714cc368d8bf48665c67a_tuple, 2, const_str_plain_hexstring_serial); Py_INCREF(const_str_plain_hexstring_serial);
    PyTuple_SET_ITEM(const_tuple_64996e5d3f2714cc368d8bf48665c67a_tuple, 3, const_str_plain_asn1_serial); Py_INCREF(const_str_plain_asn1_serial);
    PyTuple_SET_ITEM(const_tuple_64996e5d3f2714cc368d8bf48665c67a_tuple, 4, const_str_plain_hex_serial); Py_INCREF(const_str_plain_hex_serial);
    PyTuple_SET_ITEM(const_tuple_64996e5d3f2714cc368d8bf48665c67a_tuple, 5, const_str_plain_serial); Py_INCREF(const_str_plain_serial);
    const_tuple_c5e29833751f21ea567c72bd68a6420e_tuple = PyTuple_New(5);
    PyTuple_SET_ITEM(const_tuple_c5e29833751f21ea567c72bd68a6420e_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_c5e29833751f21ea567c72bd68a6420e_tuple, 1, const_str_plain_i); Py_INCREF(const_str_plain_i);
    PyTuple_SET_ITEM(const_tuple_c5e29833751f21ea567c72bd68a6420e_tuple, 2, const_str_plain_ext); Py_INCREF(const_str_plain_ext);
    PyTuple_SET_ITEM(const_tuple_c5e29833751f21ea567c72bd68a6420e_tuple, 3, const_str_plain_exts); Py_INCREF(const_str_plain_exts);
    PyTuple_SET_ITEM(const_tuple_c5e29833751f21ea567c72bd68a6420e_tuple, 4, const_str_plain_native_exts_obj); Py_INCREF(const_str_plain_native_exts_obj);
    const_str_digest_4a193fbd1ccf06765e0cb44620b7d74a = UNSTREAM_STRING(&constant_bin[ 164504 ], 346, 0);
    const_str_plain_X509_STORE_add_crl = UNSTREAM_STRING(&constant_bin[ 164850 ], 18, 1);
    const_str_plain_PKCS7 = UNSTREAM_STRING(&constant_bin[ 4347 ], 5, 1);
    const_tuple_str_plain_cls_str_plain_crypto_crl_str_plain_crl_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_cls_str_plain_crypto_crl_str_plain_crl_tuple, 0, const_str_plain_cls); Py_INCREF(const_str_plain_cls);
    const_str_plain_crypto_crl = UNSTREAM_STRING(&constant_bin[ 139419 ], 10, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain_cls_str_plain_crypto_crl_str_plain_crl_tuple, 1, const_str_plain_crypto_crl); Py_INCREF(const_str_plain_crypto_crl);
    PyTuple_SET_ITEM(const_tuple_str_plain_cls_str_plain_crypto_crl_str_plain_crl_tuple, 2, const_str_plain_crl); Py_INCREF(const_str_plain_crl);
    const_tuple_str_digest_80438074180d95b1a2291874613077b5_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_digest_80438074180d95b1a2291874613077b5_tuple, 0, const_str_digest_80438074180d95b1a2291874613077b5); Py_INCREF(const_str_digest_80438074180d95b1a2291874613077b5);
    const_str_plain_X509_get0_tbs_sigalg = UNSTREAM_STRING(&constant_bin[ 164868 ], 20, 1);
    const_tuple_d959e8503cbe0fd15122162c0da60661_tuple = PyTuple_New(5);
    PyTuple_SET_ITEM(const_tuple_d959e8503cbe0fd15122162c0da60661_tuple, 0, const_str_plain_timestamp); Py_INCREF(const_str_plain_timestamp);
    PyTuple_SET_ITEM(const_tuple_d959e8503cbe0fd15122162c0da60661_tuple, 1, const_str_plain_generalized_timestamp); Py_INCREF(const_str_plain_generalized_timestamp);
    PyTuple_SET_ITEM(const_tuple_d959e8503cbe0fd15122162c0da60661_tuple, 2, const_str_plain_string_result); Py_INCREF(const_str_plain_string_result);
    PyTuple_SET_ITEM(const_tuple_d959e8503cbe0fd15122162c0da60661_tuple, 3, const_str_plain_string_data); Py_INCREF(const_str_plain_string_data);
    PyTuple_SET_ITEM(const_tuple_d959e8503cbe0fd15122162c0da60661_tuple, 4, const_str_plain_string_timestamp); Py_INCREF(const_str_plain_string_timestamp);
    const_str_plain_X509_alias_get0 = UNSTREAM_STRING(&constant_bin[ 164888 ], 15, 1);
    const_str_plain_X509_NAME_cmp = UNSTREAM_STRING(&constant_bin[ 164903 ], 13, 1);
    const_str_plain__integer_types = UNSTREAM_STRING(&constant_bin[ 3850 ], 14, 1);
    const_str_plain_PKCS12Type = UNSTREAM_STRING(&constant_bin[ 134374 ], 10, 1);
    const_str_plain_EXPLICIT_POLICY = UNSTREAM_STRING(&constant_bin[ 158800 ], 15, 1);
    const_str_plain_set_issuer = UNSTREAM_STRING(&constant_bin[ 164916 ], 10, 1);
    const_str_plain_ASN1_INTEGER_set = UNSTREAM_STRING(&constant_bin[ 164926 ], 16, 1);
    const_str_digest_08a0d510acdd77f37b666a4668538f96 = UNSTREAM_STRING(&constant_bin[ 164942 ], 44, 0);
    const_str_digest_713d8c2afef94db133cda1bff1cb496f = UNSTREAM_STRING(&constant_bin[ 164986 ], 33, 0);
    const_str_digest_2dbcbe3e7da77178b4a9da40244d072a = UNSTREAM_STRING(&constant_bin[ 165019 ], 26, 0);
    const_str_digest_0d925750cb36e0c0e5f47f40c47790e6 = UNSTREAM_STRING(&constant_bin[ 165045 ], 22, 0);
    const_str_digest_66b2a3b8e35254752e96fbbddc255dfd = UNSTREAM_STRING(&constant_bin[ 165067 ], 174, 0);
    const_str_digest_998fe297d663eb0475d60a56d2b84182 = UNSTREAM_STRING(&constant_bin[ 165241 ], 447, 0);
    const_str_digest_859c7c43c5cf3124cdd58374d6e7359e = UNSTREAM_STRING(&constant_bin[ 165688 ], 79, 0);
    const_str_plain_BN_set_word = UNSTREAM_STRING(&constant_bin[ 165767 ], 11, 1);
    const_str_digest_3c820c2fc1d76f73132dab0e4e8d3a14 = UNSTREAM_STRING(&constant_bin[ 165778 ], 32, 0);
    const_str_digest_bb334a0dc943b8e820be149d2c515af0 = UNSTREAM_STRING(&constant_bin[ 165810 ], 19, 0);
    const_tuple_57dca116533b0d6d636b268e7001e41b_tuple = PyTuple_New(7);
    PyTuple_SET_ITEM(const_tuple_57dca116533b0d6d636b268e7001e41b_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_57dca116533b0d6d636b268e7001e41b_tuple, 1, const_str_plain_digest_name); Py_INCREF(const_str_plain_digest_name);
    PyTuple_SET_ITEM(const_tuple_57dca116533b0d6d636b268e7001e41b_tuple, 2, const_str_plain_digest_result); Py_INCREF(const_str_plain_digest_result);
    PyTuple_SET_ITEM(const_tuple_57dca116533b0d6d636b268e7001e41b_tuple, 3, const_str_plain_ch); Py_INCREF(const_str_plain_ch);
    PyTuple_SET_ITEM(const_tuple_57dca116533b0d6d636b268e7001e41b_tuple, 4, const_str_plain_result_length); Py_INCREF(const_str_plain_result_length);
    PyTuple_SET_ITEM(const_tuple_57dca116533b0d6d636b268e7001e41b_tuple, 5, const_str_plain_result_buffer); Py_INCREF(const_str_plain_result_buffer);
    PyTuple_SET_ITEM(const_tuple_57dca116533b0d6d636b268e7001e41b_tuple, 6, const_str_plain_digest); Py_INCREF(const_str_plain_digest);
    const_str_plain_subject_name_hash = UNSTREAM_STRING(&constant_bin[ 142519 ], 17, 1);
    const_tuple_str_plain__CertificateSigningRequest_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_plain__CertificateSigningRequest_tuple, 0, const_str_plain__CertificateSigningRequest); Py_INCREF(const_str_plain__CertificateSigningRequest);
    const_str_digest_6b664ec0d0974a050be8b09b84bd0a5d = UNSTREAM_STRING(&constant_bin[ 165829 ], 177, 0);
    const_str_digest_4b3673d04a6e4a628e29457d54d43c0d = UNSTREAM_STRING(&constant_bin[ 166006 ], 29, 0);
    const_str_plain_X509ReqType = UNSTREAM_STRING(&constant_bin[ 139719 ], 11, 1);
    const_str_plain_V_ASN1_GENERALIZEDTIME = UNSTREAM_STRING(&constant_bin[ 166035 ], 22, 1);
    const_str_plain_get_revoked = UNSTREAM_STRING(&constant_bin[ 166057 ], 11, 1);
    const_str_plain_dump_certificate_request = UNSTREAM_STRING(&constant_bin[ 146122 ], 24, 1);
    const_str_plain_X509_gmtime_adj = UNSTREAM_STRING(&constant_bin[ 166068 ], 15, 1);
    const_str_plain_NETSCAPE_SPKI_set_pubkey = UNSTREAM_STRING(&constant_bin[ 166083 ], 24, 1);
    const_str_digest_6b6b180b644052fa34c3e81151f6ea0a = UNSTREAM_STRING(&constant_bin[ 166107 ], 40, 0);
    const_str_plain_get_signature_algorithm = UNSTREAM_STRING(&constant_bin[ 166147 ], 23, 1);
    const_str_plain_ALLOW_PROXY_CERTS = UNSTREAM_STRING(&constant_bin[ 131878 ], 17, 1);
    const_str_plain_PKCS7_type_is_data = UNSTREAM_STRING(&constant_bin[ 166170 ], 18, 1);
    const_str_plain__delete_reason = UNSTREAM_STRING(&constant_bin[ 166188 ], 14, 1);
    const_str_plain_X509NameType = UNSTREAM_STRING(&constant_bin[ 150739 ], 12, 1);
    const_str_digest_6674ab14e1178de501dfb968278a50b9 = UNSTREAM_STRING(&constant_bin[ 142607 ], 21, 0);
    const_tuple_aacd84e9abfa73a83f6f088507b53506_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_aacd84e9abfa73a83f6f088507b53506_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_aacd84e9abfa73a83f6f088507b53506_tuple, 1, const_str_plain_revoked); Py_INCREF(const_str_plain_revoked);
    PyTuple_SET_ITEM(const_tuple_aacd84e9abfa73a83f6f088507b53506_tuple, 2, const_str_plain_copy); Py_INCREF(const_str_plain_copy);
    PyTuple_SET_ITEM(const_tuple_aacd84e9abfa73a83f6f088507b53506_tuple, 3, const_str_plain_add_result); Py_INCREF(const_str_plain_add_result);
    const_str_plain_verify_certificate = UNSTREAM_STRING(&constant_bin[ 134038 ], 18, 1);
    const_str_digest_8ad6e418a1b04e7939cf7e738b8257d2 = UNSTREAM_STRING(&constant_bin[ 166202 ], 161, 0);
    const_tuple_none_int_pos_2048_int_pos_1_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_none_int_pos_2048_int_pos_1_tuple, 0, Py_None); Py_INCREF(Py_None);
    PyTuple_SET_ITEM(const_tuple_none_int_pos_2048_int_pos_1_tuple, 1, const_int_pos_2048); Py_INCREF(const_int_pos_2048);
    PyTuple_SET_ITEM(const_tuple_none_int_pos_2048_int_pos_1_tuple, 2, const_int_pos_1); Py_INCREF(const_int_pos_1);
    const_str_plain_NETSCAPE_SPKI_b64_encode = UNSTREAM_STRING(&constant_bin[ 166363 ], 24, 1);
    const_tuple_788a505d6e43a02df061e74659415d8f_tuple = PyTuple_New(9);
    PyTuple_SET_ITEM(const_tuple_788a505d6e43a02df061e74659415d8f_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_788a505d6e43a02df061e74659415d8f_tuple, 1, const_str_plain_name); Py_INCREF(const_str_plain_name);
    PyTuple_SET_ITEM(const_tuple_788a505d6e43a02df061e74659415d8f_tuple, 2, const_str_plain_value); Py_INCREF(const_str_plain_value);
    PyTuple_SET_ITEM(const_tuple_788a505d6e43a02df061e74659415d8f_tuple, 3, const_str_plain_i); Py_INCREF(const_str_plain_i);
    PyTuple_SET_ITEM(const_tuple_788a505d6e43a02df061e74659415d8f_tuple, 4, const_str_plain_nid); Py_INCREF(const_str_plain_nid);
    PyTuple_SET_ITEM(const_tuple_788a505d6e43a02df061e74659415d8f_tuple, 5, const_str_plain_ent_obj); Py_INCREF(const_str_plain_ent_obj);
    PyTuple_SET_ITEM(const_tuple_788a505d6e43a02df061e74659415d8f_tuple, 6, const_str_plain_ent); Py_INCREF(const_str_plain_ent);
    PyTuple_SET_ITEM(const_tuple_788a505d6e43a02df061e74659415d8f_tuple, 7, const_str_plain_ent_nid); Py_INCREF(const_str_plain_ent_nid);
    PyTuple_SET_ITEM(const_tuple_788a505d6e43a02df061e74659415d8f_tuple, 8, const_str_plain_add_result); Py_INCREF(const_str_plain_add_result);
    const_str_plain_get_pubkey = UNSTREAM_STRING(&constant_bin[ 144616 ], 10, 1);
    const_tuple_str_digest_5339fa8ff3df372e54ef7b09078767aa_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_digest_5339fa8ff3df372e54ef7b09078767aa_tuple, 0, const_str_digest_5339fa8ff3df372e54ef7b09078767aa); Py_INCREF(const_str_digest_5339fa8ff3df372e54ef7b09078767aa);
    const_str_digest_cd7d7b6c262cf257f5bafa26f39b567e = UNSTREAM_STRING(&constant_bin[ 166387 ], 356, 0);
    const_str_plain_NETSCAPE_SPKI_new = UNSTREAM_STRING(&constant_bin[ 166743 ], 17, 1);
    const_str_digest_1c1759444507dc6d4c0d7b4ce6b62611 = UNSTREAM_STRING(&constant_bin[ 166760 ], 273, 0);
    const_str_digest_2c2564e59b067260d7d96d252fc73cd1 = UNSTREAM_STRING(&constant_bin[ 167033 ], 248, 0);
    const_str_plain__subjectAltNameString = UNSTREAM_STRING(&constant_bin[ 167281 ], 21, 1);
    const_tuple_270cfc7fce9aafdf0c3eb9f2164206f4_tuple = PyTuple_New(8);
    PyTuple_SET_ITEM(const_tuple_270cfc7fce9aafdf0c3eb9f2164206f4_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_270cfc7fce9aafdf0c3eb9f2164206f4_tuple, 1, const_str_plain_type); Py_INCREF(const_str_plain_type);
    PyTuple_SET_ITEM(const_tuple_270cfc7fce9aafdf0c3eb9f2164206f4_tuple, 2, const_str_plain_bits); Py_INCREF(const_str_plain_bits);
    PyTuple_SET_ITEM(const_tuple_270cfc7fce9aafdf0c3eb9f2164206f4_tuple, 3, const_str_plain_exponent); Py_INCREF(const_str_plain_exponent);
    PyTuple_SET_ITEM(const_tuple_270cfc7fce9aafdf0c3eb9f2164206f4_tuple, 4, const_str_plain_rsa); Py_INCREF(const_str_plain_rsa);
    PyTuple_SET_ITEM(const_tuple_270cfc7fce9aafdf0c3eb9f2164206f4_tuple, 5, const_str_plain_result); Py_INCREF(const_str_plain_result);
    PyTuple_SET_ITEM(const_tuple_270cfc7fce9aafdf0c3eb9f2164206f4_tuple, 6, const_str_plain_res); Py_INCREF(const_str_plain_res);
    PyTuple_SET_ITEM(const_tuple_270cfc7fce9aafdf0c3eb9f2164206f4_tuple, 7, const_str_plain_dsa); Py_INCREF(const_str_plain_dsa);
    const_str_plain__byte_string = UNSTREAM_STRING(&constant_bin[ 3524 ], 12, 1);
    const_tuple_str_plain_boundary_str_plain_when_str_plain_set_result_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_boundary_str_plain_when_str_plain_set_result_tuple, 0, const_str_plain_boundary); Py_INCREF(const_str_plain_boundary);
    PyTuple_SET_ITEM(const_tuple_str_plain_boundary_str_plain_when_str_plain_set_result_tuple, 1, const_str_plain_when); Py_INCREF(const_str_plain_when);
    PyTuple_SET_ITEM(const_tuple_str_plain_boundary_str_plain_when_str_plain_set_result_tuple, 2, const_str_plain_set_result); Py_INCREF(const_str_plain_set_result);
    const_str_plain__curves = UNSTREAM_STRING(&constant_bin[ 3488 ], 7, 1);
    const_str_digest_9226325aac109a91f8326c1a26ede065 = UNSTREAM_STRING(&constant_bin[ 167302 ], 48, 0);
    const_tuple_str_digest_0d925750cb36e0c0e5f47f40c47790e6_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_digest_0d925750cb36e0c0e5f47f40c47790e6_tuple, 0, const_str_digest_0d925750cb36e0c0e5f47f40c47790e6); Py_INCREF(const_str_digest_0d925750cb36e0c0e5f47f40c47790e6);
    const_str_digest_4357c956c1f3628f437632877b5d8593 = UNSTREAM_STRING(&constant_bin[ 167350 ], 197, 0);
    const_str_digest_b16563a844474e8eed4710209909ab32 = UNSTREAM_STRING(&constant_bin[ 167547 ], 283, 0);
    const_str_digest_8bcf6e6fbaf96377cbe58ba9960c9d58 = UNSTREAM_STRING(&constant_bin[ 167830 ], 211, 0);
    const_str_plain_X509_REQ_print_ex = UNSTREAM_STRING(&constant_bin[ 168041 ], 17, 1);
    const_str_digest_e2d5c2f473553b6759cc455da987e04a = UNSTREAM_STRING(&constant_bin[ 168058 ], 163, 0);
    const_str_plain_add_revoked = UNSTREAM_STRING(&constant_bin[ 168221 ], 11, 1);
    const_str_digest_290681512f72ca11cbf3e4827987aabb = UNSTREAM_STRING(&constant_bin[ 168232 ], 20, 0);

    constants_created = true;
}

/* Function to verify module private constants for non-corruption. */
#ifndef __NUITKA_NO_ASSERT__
void checkModuleConstants_OpenSSL$crypto(void) {
    // The module may not have been used at all, then ignore this.
    if (constants_created == false) return;


}
#endif

// The module code objects.
static PyCodeObject *codeobj_90b1b594fc4594b0a0c51455faad8850;
static PyCodeObject *codeobj_d796a9417638ea0fc15dcdcd73475757;
static PyCodeObject *codeobj_de021b22d6a553ff379ffc2219845a9b;
static PyCodeObject *codeobj_0f24a32b5663577b8612198b9ee32e1e;
static PyCodeObject *codeobj_e48c7ada7caf70ebce53c5531940cfed;
static PyCodeObject *codeobj_584960adc98f2327e7352a334ee7240a;
static PyCodeObject *codeobj_26554ef6367a9e88a5185ae01f6efee0;
static PyCodeObject *codeobj_b729aae3be3cb5ee6312ba7b28f48a0d;
static PyCodeObject *codeobj_bdc51ef1a1907bf0b04d0d14fa40b94d;
static PyCodeObject *codeobj_6159802766a8a7093088b919012df71c;
static PyCodeObject *codeobj_53b82250513b686ddc71f0e4ae92fdc3;
static PyCodeObject *codeobj_3731d5a3d74f70f79665c7581fc4f176;
static PyCodeObject *codeobj_62546cfe1d011d24bbde27bbb93b6ea0;
static PyCodeObject *codeobj_c90140b7a0c346bc70320cca292002db;
static PyCodeObject *codeobj_4f7957c52b7d5aeb30baabbb3d3cb7ab;
static PyCodeObject *codeobj_67b084766e0c2154c70a16d23028087b;
static PyCodeObject *codeobj_8f2729c6c39bb67f3ed78460f5e5408b;
static PyCodeObject *codeobj_06e2adf77b5f629c14d7d22dc40bc355;
static PyCodeObject *codeobj_e6be03b19f17c55a33c123c191305d01;
static PyCodeObject *codeobj_80f015fcfa447ca62d4c55502f1ecad1;
static PyCodeObject *codeobj_b23a0f51f84827c54de24c1656bcf51f;
static PyCodeObject *codeobj_3823949e19d48b686be78204ad33eba9;
static PyCodeObject *codeobj_d7eda580e48a4e0112100f560fb2f9fd;
static PyCodeObject *codeobj_3f33b64820845ae325979d13781edcfd;
static PyCodeObject *codeobj_91db092762599116cb72df14f7165542;
static PyCodeObject *codeobj_454ecf415d37cf2ce7deb60c0cb6fa3d;
static PyCodeObject *codeobj_464dcdbbc2ccc429632456551d5ba288;
static PyCodeObject *codeobj_a3749c6c6ff08577b8d8b833eefc14bb;
static PyCodeObject *codeobj_9fcd3c1df2ae19417cd7c1bcb969e1f5;
static PyCodeObject *codeobj_d193f68fff8cd4832932098a276bfaeb;
static PyCodeObject *codeobj_53fed2bee792bc330db8eb5d73e6e5ef;
static PyCodeObject *codeobj_bc037b68e8bf53563613e38c02309b68;
static PyCodeObject *codeobj_9b1e39652aee4650ee015af31b51eda4;
static PyCodeObject *codeobj_66c965dc3bd160a9871b648a43656817;
static PyCodeObject *codeobj_ab2b9954406330adf0a2ccc8c799cd72;
static PyCodeObject *codeobj_5cabe66b4bd10e5fcd686ac603345ff9;
static PyCodeObject *codeobj_3891a493a4dd850f62e56c17ddb5ee47;
static PyCodeObject *codeobj_f994384600d98651e10407a7de0bb709;
static PyCodeObject *codeobj_246be403ac420ea7d6be029dab25a09c;
static PyCodeObject *codeobj_305731e8abbf83d9573a0ae65d31c97c;
static PyCodeObject *codeobj_901f14040af7aac06f554767a4550324;
static PyCodeObject *codeobj_273dd0eea5c54fb2d8406e6bc14d5e15;
static PyCodeObject *codeobj_80105bd3cbfef104f47288369fe3a34c;
static PyCodeObject *codeobj_00371fda50c01bb4d85c5c5a04406452;
static PyCodeObject *codeobj_96e5ab6839a5b468daf580820eac0fba;
static PyCodeObject *codeobj_10246d31c9c113ffc000a4408916df7b;
static PyCodeObject *codeobj_e5f1885b429cf8c4e78efa560593ce5d;
static PyCodeObject *codeobj_4beb331670662238f060a150b02707c9;
static PyCodeObject *codeobj_8569be16f63185d6aef0adf92c520ee5;
static PyCodeObject *codeobj_cb358a0ddff832515567a748ef6af7f5;
static PyCodeObject *codeobj_c7126baf39e9c42b3efde559aa07f143;
static PyCodeObject *codeobj_a985957de3abbe239f1f1229dc888507;
static PyCodeObject *codeobj_9d20210919ad40c1e8d81a9f37aef9bb;
static PyCodeObject *codeobj_c83a206dfc0a5b352706e7cad0f33b53;
static PyCodeObject *codeobj_41b835cb0b40d60758bdeb7772fa66f4;
static PyCodeObject *codeobj_913c87f9ab8d54a08d5eac957c322eee;
static PyCodeObject *codeobj_457f951bde44f2371cea4fa29a1876af;
static PyCodeObject *codeobj_98c960373d8e9f9023212df2b317530b;
static PyCodeObject *codeobj_1e39bc936ea94807eaf0b02a24efd7e5;
static PyCodeObject *codeobj_23a2727bfec75a11d2ac8664eefa517a;
static PyCodeObject *codeobj_68a1e3325fbb1f364eb9342008f9697e;
static PyCodeObject *codeobj_fa5b81e573b15ecdf6f1dca4e70b2a76;
static PyCodeObject *codeobj_46e833f2a78ffcfd023683533321764a;
static PyCodeObject *codeobj_52082d9f842a277aa94ee6a0252a7f07;
static PyCodeObject *codeobj_3afae2cb1616023deaf9f3e5ada83ddc;
static PyCodeObject *codeobj_dae642fc1d00d46dc97a94e0671a6f94;
static PyCodeObject *codeobj_72e2fe225c7664a56842ff4e880953c2;
static PyCodeObject *codeobj_826e459e0dc58f5a99e0a127a3e82d23;
static PyCodeObject *codeobj_fc7001d155a0450e09ea5b4d5d2bc9f9;
static PyCodeObject *codeobj_4f7104a5c773de3617ea99428a718a9f;
static PyCodeObject *codeobj_549d02a6f8fe9c9053e01fafd28ef642;
static PyCodeObject *codeobj_37ee45b6be0afd221cf7a538d742d0bf;
static PyCodeObject *codeobj_937719077c95baa6246e33cb27a31dc5;
static PyCodeObject *codeobj_87202647bd1de477b2de0eb2aa352e4f;
static PyCodeObject *codeobj_ac78feb39cb3a4f1fcd5ca3fb25b3cc6;
static PyCodeObject *codeobj_63d5d54775413644d68413130bf8b01c;
static PyCodeObject *codeobj_e7cef9cdd61becb04e1edcd19e659b06;
static PyCodeObject *codeobj_22beaaaea5c6ee0a49315be496a852c0;
static PyCodeObject *codeobj_f4d7239bd6f37a2305732ecc4423ba01;
static PyCodeObject *codeobj_1427e696c3581db99d7e88aa6e2d20e2;
static PyCodeObject *codeobj_6ac5e01a4091f7c0a9e36a34af31a1a9;
static PyCodeObject *codeobj_d5561b45ad99d14efabf12463381b5d5;
static PyCodeObject *codeobj_40b3430de5e3101d094061fa2d5cec01;
static PyCodeObject *codeobj_fe948b55a81e35b717d1b9b97c2db26b;
static PyCodeObject *codeobj_b718d7c7e21f2f8cf1e62e44bd27b1df;
static PyCodeObject *codeobj_cdc04db7a74dd11ea6b2177a19c32798;
static PyCodeObject *codeobj_b9f83c00bb65fd2c7bce3d5bc80d9004;
static PyCodeObject *codeobj_8f12fd3ce35b73023a06827bde816a58;
static PyCodeObject *codeobj_b100013f16a2576dec9318822455e6e9;
static PyCodeObject *codeobj_c00a9d5fb891facbacf0fc1ab1c7e398;
static PyCodeObject *codeobj_e3d47dcc2e5c78370ad068837f5c1643;
static PyCodeObject *codeobj_abddb661c4d0d4ad0339365c339f0316;
static PyCodeObject *codeobj_2f6eda6ffd4b44390873f4f24070482e;
static PyCodeObject *codeobj_a3d6ff1e9626c3f8ac77d23bb924b11c;
static PyCodeObject *codeobj_45711045417d5734fe1ffb353cc7753b;
static PyCodeObject *codeobj_295f1119c769c014813a47d7534945e3;
static PyCodeObject *codeobj_83dbeb702a8014baa25622a5026507ba;
static PyCodeObject *codeobj_c92bad46c4a7152b022309b9441ca8ed;
static PyCodeObject *codeobj_a7d4834ead0a1a60fe3119338536d0f3;
static PyCodeObject *codeobj_38e0d057067d90e2fbb10ff012ac6d82;
static PyCodeObject *codeobj_426fef8004659e269aa693019fc0f0fd;
static PyCodeObject *codeobj_7ebcd9852a4c17ff014df7666a66c809;
static PyCodeObject *codeobj_b2d34b562f393e96bd01c8d2200fd8b0;
static PyCodeObject *codeobj_12a92438471858197cd72f0dfaa82ede;
static PyCodeObject *codeobj_ab078d627a4f8a1ea8d9fa8ec2ab7620;
static PyCodeObject *codeobj_2f75f854001e71ff4003dca12987865c;
static PyCodeObject *codeobj_e4f22ea9413d3c0f22c2aa13efebb1d8;
static PyCodeObject *codeobj_368e52860340c0239edd479ec201e937;
static PyCodeObject *codeobj_62f5aa8a8fda43f2d7f41809819c949c;
static PyCodeObject *codeobj_ba8c4dae468348f7ff9c62739bc12bc4;
static PyCodeObject *codeobj_cdc94e00f8d570018ee7361d163914a9;
static PyCodeObject *codeobj_ab9238934dc2a850ec08f1603c825e21;
static PyCodeObject *codeobj_0167861cea57ebc738ecf400cc04ebfa;
static PyCodeObject *codeobj_c084b3860bf0d3247773b3ddb209b309;
static PyCodeObject *codeobj_638f670f35af3781de5f2f4c9835741e;
static PyCodeObject *codeobj_fcdc69651d69daf00844268634ce9361;
static PyCodeObject *codeobj_4de131a75c684fec0469c48115745d08;
static PyCodeObject *codeobj_50ee192f9d0e8e84633297c994f58a6a;
static PyCodeObject *codeobj_fbdfdccccf232276b858abd51cb882bb;
static PyCodeObject *codeobj_9108a7396152423879c9fb4fd180f6ef;
static PyCodeObject *codeobj_3ba03b4a83863db0211776596d7369dc;
static PyCodeObject *codeobj_dd9bf8ebdf933d2516db3e82c61898d8;
static PyCodeObject *codeobj_6e98a073ab05ca431e08e0cd283b2282;
static PyCodeObject *codeobj_cb2229b3594b0ea74e790a288340fb5b;
static PyCodeObject *codeobj_bd97d2185c62e99374c1533c90a95f19;
static PyCodeObject *codeobj_b7fff7ac811f5c1447b68a592d106780;
static PyCodeObject *codeobj_84543461673eee61a7305bb77fc49b09;
static PyCodeObject *codeobj_0d63d1af7f4ff3d26e5354dc78437737;
static PyCodeObject *codeobj_75232e283be8a43fe94949460ca59119;
static PyCodeObject *codeobj_999486723fe5c8277b4a8914c9586c78;
static PyCodeObject *codeobj_60b024772fde8ae0bc098cb534c29ad5;
static PyCodeObject *codeobj_60a54c7eb9de93d0fd2fe53bbdafcf10;
static PyCodeObject *codeobj_7b28dcc872c0fc1e599bc7f4fd0593c7;
static PyCodeObject *codeobj_6adba4da8c74bf815c0210e671b10c64;
static PyCodeObject *codeobj_09ba91e9bcc11b447039b645c382509f;
static PyCodeObject *codeobj_7d3a859e1d891c970bd1bda57166fb91;
static PyCodeObject *codeobj_f85802ded5ad9e24c28efb6d7f3ae0de;
static PyCodeObject *codeobj_f40f51dde7e8f7585957d7400a166b67;
static PyCodeObject *codeobj_e7a5b9023d1f01cca25bb4c11d94736c;
static PyCodeObject *codeobj_144ee34ca155af9932b2f45dad52e660;
static PyCodeObject *codeobj_cfb453c9877c1441541c8778d573d561;
static PyCodeObject *codeobj_69ba33aac22465dc3e11fe94f2672358;
static PyCodeObject *codeobj_151b1f6515b68f745ad19e8b1fbe6905;
static PyCodeObject *codeobj_5654d7a7e7e1d262193996dc0e844779;
static PyCodeObject *codeobj_f86a27bee71853ffe2494335d054f9c2;
static PyCodeObject *codeobj_5ed9e5e6e97c4656f6c19f9fb33742ec;
static PyCodeObject *codeobj_555e64665b36c5489cfa1aab914f4b68;
static PyCodeObject *codeobj_5206be546a6fa8e25a02dc839db5f52a;
static PyCodeObject *codeobj_3e08719da027c8ef5763e0014ecff43a;
static PyCodeObject *codeobj_1ea23726b81bbec2d72c3f055e13f1f3;
static PyCodeObject *codeobj_80d62758301ca388b22f45ed7f965aa4;
static PyCodeObject *codeobj_8c86ab161458de9d92d55080e4948b8b;
static PyCodeObject *codeobj_a5dfabf8fb4be3653adb4ee5e3a9d1ee;
static PyCodeObject *codeobj_c91f46b1da28091dae5fe2a35b791807;
static PyCodeObject *codeobj_603b25455c6bfd7b211c177899c083b0;
static PyCodeObject *codeobj_4f6e8e494b7d709f425892031ee6c86e;
static PyCodeObject *codeobj_bff0f237096588ea8e24a7bf1bb681f0;
static PyCodeObject *codeobj_97f156a5c2f4577fd55162ed1d43b342;
static PyCodeObject *codeobj_c813942487f91c1997585eb0b387e327;
static PyCodeObject *codeobj_183dcbba32fef389a142755b74a73efe;
static PyCodeObject *codeobj_17fae881cac6fcbcb689c6d8ff5eee21;
static PyCodeObject *codeobj_592334dbe6f644d58958dafe39779ba7;
static PyCodeObject *codeobj_9bf9cf1b8da4c938f3ae767506473565;
static PyCodeObject *codeobj_404049e2a875869f38e29055c42cb643;
static PyCodeObject *codeobj_3675b56e8a472299e465a6cac7a20233;
static PyCodeObject *codeobj_03c4cee92a073dc3714d696db7ba0ad3;
static PyCodeObject *codeobj_7d7f67b2a9e1de973b6a168bc3652501;
static PyCodeObject *codeobj_6580b2147d66eb9876d3eb667c120ce7;
static PyCodeObject *codeobj_a6f140d90bf737cea4d50cfd537ab5e2;
static PyCodeObject *codeobj_cf70a0fe535b0c265515473726b4c514;

static void createModuleCodeObjects(void) {
    module_filename_obj = MAKE_RELATIVE_PATH(const_str_digest_1a3a564060f5ebd53d44f6035495ba48);
    codeobj_90b1b594fc4594b0a0c51455faad8850 = MAKE_CODEOBJECT(module_filename_obj, 418, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_angle_genexpr, const_tuple_8110525d9a52cec647809d72afbc7239_tuple, 1, 0, 0);
    codeobj_d796a9417638ea0fc15dcdcd73475757 = MAKE_CODEOBJECT(module_filename_obj, 1, CO_NOFREE, const_str_digest_1f7559cec53c5da336c35128000e1652, const_tuple_empty, 0, 0, 0);
    codeobj_de021b22d6a553ff379ffc2219845a9b = MAKE_CODEOBJECT(module_filename_obj, 2123, CO_NEWLOCALS | CO_NOFREE, const_str_plain_CRL, const_tuple_empty, 0, 0, 0);
    codeobj_0f24a32b5663577b8612198b9ee32e1e = MAKE_CODEOBJECT(module_filename_obj, 219, CO_NEWLOCALS | CO_NOFREE, const_str_plain_PKey, const_tuple_empty, 0, 0, 0);
    codeobj_e48c7ada7caf70ebce53c5531940cfed = MAKE_CODEOBJECT(module_filename_obj, 1080, CO_NEWLOCALS | CO_NOFREE, const_str_plain_X509, const_tuple_empty, 0, 0, 0);
    codeobj_584960adc98f2327e7352a334ee7240a = MAKE_CODEOBJECT(module_filename_obj, 716, CO_NEWLOCALS | CO_NOFREE, const_str_plain_X509Extension, const_tuple_empty, 0, 0, 0);
    codeobj_26554ef6367a9e88a5185ae01f6efee0 = MAKE_CODEOBJECT(module_filename_obj, 516, CO_NEWLOCALS | CO_NOFREE, const_str_plain_X509Name, const_tuple_empty, 0, 0, 0);
    codeobj_b729aae3be3cb5ee6312ba7b28f48a0d = MAKE_CODEOBJECT(module_filename_obj, 874, CO_NEWLOCALS | CO_NOFREE, const_str_plain_X509Req, const_tuple_empty, 0, 0, 0);
    codeobj_bdc51ef1a1907bf0b04d0d14fa40b94d = MAKE_CODEOBJECT(module_filename_obj, 1553, CO_NEWLOCALS | CO_NOFREE, const_str_plain_X509StoreFlags, const_tuple_empty, 0, 0, 0);
    codeobj_6159802766a8a7093088b919012df71c = MAKE_CODEOBJECT(module_filename_obj, 377, CO_NEWLOCALS | CO_NOFREE, const_str_plain__EllipticCurve, const_tuple_empty, 0, 0, 0);
    codeobj_53b82250513b686ddc71f0e4ae92fdc3 = MAKE_CODEOBJECT(module_filename_obj, 2677, CO_NEWLOCALS | CO_NOFREE, const_str_plain__PassphraseHelper, const_tuple_empty, 0, 0, 0);
    codeobj_3731d5a3d74f70f79665c7581fc4f176 = MAKE_CODEOBJECT(module_filename_obj, 587, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain___getattr__, const_tuple_f6b86765c5a5e2cb7660564ebdcec2d7_tuple, 2, 0, 0);
    codeobj_62546cfe1d011d24bbde27bbb93b6ea0 = MAKE_CODEOBJECT(module_filename_obj, 207, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain___init__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_c90140b7a0c346bc70320cca292002db = MAKE_CODEOBJECT(module_filename_obj, 2404, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain___init__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_4f7957c52b7d5aeb30baabbb3d3cb7ab = MAKE_CODEOBJECT(module_filename_obj, 2128, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain___init__, const_tuple_str_plain_self_str_plain_crl_tuple, 1, 0, 0);
    codeobj_67b084766e0c2154c70a16d23028087b = MAKE_CODEOBJECT(module_filename_obj, 452, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain___init__, const_tuple_str_plain_self_str_plain_lib_str_plain_nid_str_plain_name_tuple, 4, 0, 0);
    codeobj_8f2729c6c39bb67f3ed78460f5e5408b = MAKE_CODEOBJECT(module_filename_obj, 1703, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain___init__, const_tuple_str_plain_self_str_plain_message_str_plain_certificate_tuple, 3, 0, 0);
    codeobj_06e2adf77b5f629c14d7d22dc40bc355 = MAKE_CODEOBJECT(module_filename_obj, 541, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain___init__, const_tuple_str_plain_self_str_plain_name_tuple, 2, 0, 0);
    codeobj_e6be03b19f17c55a33c123c191305d01 = MAKE_CODEOBJECT(module_filename_obj, 226, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain___init__, const_tuple_str_plain_self_str_plain_pkey_tuple, 1, 0, 0);
    codeobj_80f015fcfa447ca62d4c55502f1ecad1 = MAKE_CODEOBJECT(module_filename_obj, 879, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain___init__, const_tuple_str_plain_self_str_plain_req_tuple, 1, 0, 0);
    codeobj_b23a0f51f84827c54de24c1656bcf51f = MAKE_CODEOBJECT(module_filename_obj, 1972, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain___init__, const_tuple_str_plain_self_str_plain_revoked_tuple, 1, 0, 0);
    codeobj_3823949e19d48b686be78204ad33eba9 = MAKE_CODEOBJECT(module_filename_obj, 2585, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain___init__, const_tuple_str_plain_self_str_plain_spki_tuple, 1, 0, 0);
    codeobj_d7eda580e48a4e0112100f560fb2f9fd = MAKE_CODEOBJECT(module_filename_obj, 1590, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain___init__, const_tuple_str_plain_self_str_plain_store_tuple, 1, 0, 0);
    codeobj_3f33b64820845ae325979d13781edcfd = MAKE_CODEOBJECT(module_filename_obj, 1726, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain___init__, const_tuple_c1e1b7e48a4d24180e53a91b4e9e45ad_tuple, 3, 0, 0);
    codeobj_91db092762599116cb72df14f7165542 = MAKE_CODEOBJECT(module_filename_obj, 2678, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain___init__, const_tuple_e0284b4dc341731363d45f065b316e64_tuple, 5, 0, 0);
    codeobj_454ecf415d37cf2ce7deb60c0cb6fa3d = MAKE_CODEOBJECT(module_filename_obj, 721, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain___init__, const_tuple_f55bc3086b9449b7c24969f5e02af09b_tuple, 6, 0, 0);
    codeobj_464dcdbbc2ccc429632456551d5ba288 = MAKE_CODEOBJECT(module_filename_obj, 1084, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain___init__, const_tuple_str_plain_self_str_plain_x509_tuple, 1, 0, 0);
    codeobj_a3749c6c6ff08577b8d8b833eefc14bb = MAKE_CODEOBJECT(module_filename_obj, 390, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain___ne__, const_tuple_str_plain_self_str_plain_other_tuple, 2, 0, 0);
    codeobj_9fcd3c1df2ae19417cd7c1bcb969e1f5 = MAKE_CODEOBJECT(module_filename_obj, 469, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain___repr__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_d193f68fff8cd4832932098a276bfaeb = MAKE_CODEOBJECT(module_filename_obj, 644, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain___repr__, const_tuple_3feaf484c2a2250f0d395be4b333fb30_tuple, 1, 0, 0);
    codeobj_53fed2bee792bc330db8eb5d73e6e5ef = MAKE_CODEOBJECT(module_filename_obj, 551, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain___setattr__, const_tuple_788a505d6e43a02df061e74659415d8f_tuple, 3, 0, 0);
    codeobj_bc037b68e8bf53563613e38c02309b68 = MAKE_CODEOBJECT(module_filename_obj, 815, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain___str__, const_tuple_str_plain_self_str_plain_bio_str_plain_print_result_tuple, 1, 0, 0);
    codeobj_9b1e39652aee4650ee015af31b51eda4 = MAKE_CODEOBJECT(module_filename_obj, 135, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain__bio_to_string, const_tuple_6821d02066babb1885e247bdbf40c8ec_tuple, 1, 0, 0);
    codeobj_66c965dc3bd160a9871b648a43656817 = MAKE_CODEOBJECT(module_filename_obj, 1749, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain__cleanup, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_ab2b9954406330adf0a2ccc8c799cd72 = MAKE_CODEOBJECT(module_filename_obj, 627, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain__cmp, const_tuple_str_plain_op_str_plain_f_tuple, 1, 0, 0);
    codeobj_5cabe66b4bd10e5fcd686ac603345ff9 = MAKE_CODEOBJECT(module_filename_obj, 2017, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain__delete_reason, const_tuple_str_plain_self_str_plain_i_str_plain_obj_str_plain_ext_tuple, 1, 0, 0);
    codeobj_3891a493a4dd850f62e56c17ddb5ee47 = MAKE_CODEOBJECT(module_filename_obj, 1757, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain__exception_from_context, const_tuple_fe55f23347ee1ca3dc14a1930b416eaa_tuple, 1, 0, 0);
    codeobj_f994384600d98651e10407a7de0bb709 = MAKE_CODEOBJECT(module_filename_obj, 1092, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain__from_raw_x509_ptr, const_tuple_str_plain_cls_str_plain_x509_str_plain_cert_tuple, 2, 0, 0);
    codeobj_246be403ac420ea7d6be029dab25a09c = MAKE_CODEOBJECT(module_filename_obj, 166, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain__get_asn1_time, const_tuple_d959e8503cbe0fd15122162c0da60661_tuple, 1, 0, 0);
    codeobj_305731e8abbf83d9573a0ae65d31c97c = MAKE_CODEOBJECT(module_filename_obj, 88, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain__get_backend, const_tuple_str_plain_backend_tuple, 0, 0, 0);
    codeobj_901f14040af7aac06f554767a4550324 = MAKE_CODEOBJECT(module_filename_obj, 1364, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain__get_boundary_time, const_tuple_str_plain_self_str_plain_which_tuple, 2, 0, 0);
    codeobj_273dd0eea5c54fb2d8406e6bc14d5e15 = MAKE_CODEOBJECT(module_filename_obj, 421, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain__get_elliptic_curves, const_tuple_str_plain_cls_str_plain_lib_tuple, 2, 0, 0);
    codeobj_80105bd3cbfef104f47288369fe3a34c = MAKE_CODEOBJECT(module_filename_obj, 1422, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain__get_name, const_tuple_str_plain_self_str_plain_which_str_plain_name_tuple, 2, 0, 0);
    codeobj_00371fda50c01bb4d85c5c5a04406452 = MAKE_CODEOBJECT(module_filename_obj, 1736, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain__init, const_tuple_str_plain_self_str_plain_ret_tuple, 1, 0, 0);
    codeobj_96e5ab6839a5b468daf580820eac0fba = MAKE_CODEOBJECT(module_filename_obj, 401, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain__load_elliptic_curves, const_tuple_349fb4cb1ce06b9a51a79a6cd36ef36b_tuple, 2, 0, 0);
    codeobj_10246d31c9c113ffc000a4408916df7b = MAKE_CODEOBJECT(module_filename_obj, 109, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain__new_mem_buf, const_tuple_str_plain_buffer_str_plain_bio_str_plain_data_str_plain_free_tuple, 1, 0, 0);
    codeobj_e5f1885b429cf8c4e78efa560593ce5d = MAKE_CODEOBJECT(module_filename_obj, 782, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain__nid, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_4beb331670662238f060a150b02707c9 = MAKE_CODEOBJECT(module_filename_obj, 2725, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain__read_passphrase, const_tuple_5209455ecbb28249752027c3a839ae1c_tuple, 5, 0, 0);
    codeobj_8569be16f63185d6aef0adf92c520ee5 = MAKE_CODEOBJECT(module_filename_obj, 144, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain__set_asn1_time, const_tuple_str_plain_boundary_str_plain_when_str_plain_set_result_tuple, 2, 0, 0);
    codeobj_cb358a0ddff832515567a748ef6af7f5 = MAKE_CODEOBJECT(module_filename_obj, 1380, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain__set_boundary_time, const_tuple_str_plain_self_str_plain_which_str_plain_when_tuple, 3, 0, 0);
    codeobj_c7126baf39e9c42b3efde559aa07f143 = MAKE_CODEOBJECT(module_filename_obj, 2229, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain__set_boundary_time, const_tuple_str_plain_self_str_plain_which_str_plain_when_tuple, 3, 0, 0);
    codeobj_a985957de3abbe239f1f1229dc888507 = MAKE_CODEOBJECT(module_filename_obj, 1433, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain__set_name, const_tuple_d23f6dfb17b5708d3504cb59648ebed0_tuple, 3, 0, 0);
    codeobj_9d20210919ad40c1e8d81a9f37aef9bb = MAKE_CODEOBJECT(module_filename_obj, 794, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain__subjectAltNameString, const_tuple_48783f9f765e1ca05b39b42cba82d1fc_tuple, 1, 0, 0);
    codeobj_c83a206dfc0a5b352706e7cad0f33b53 = MAKE_CODEOBJECT(module_filename_obj, 472, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain__to_EC_KEY, const_tuple_str_plain_self_str_plain_key_tuple, 1, 0, 0);
    codeobj_41b835cb0b40d60758bdeb7772fa66f4 = MAKE_CODEOBJECT(module_filename_obj, 100, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain__untested_error, const_tuple_str_plain_where_tuple, 1, 0, 0);
    codeobj_913c87f9ab8d54a08d5eac957c322eee = MAKE_CODEOBJECT(module_filename_obj, 210, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_add, const_tuple_str_plain_self_str_plain_name_tuple, 2, 0, 0);
    codeobj_457f951bde44f2371cea4fa29a1876af = MAKE_CODEOBJECT(module_filename_obj, 1594, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_add_cert, const_tuple_be611311fb5723111b9692ddf834f10b_tuple, 2, 0, 0);
    codeobj_98c960373d8e9f9023212df2b317530b = MAKE_CODEOBJECT(module_filename_obj, 1624, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_add_crl, const_tuple_str_plain_self_str_plain_crl_tuple, 2, 0, 0);
    codeobj_1e39bc936ea94807eaf0b02a24efd7e5 = MAKE_CODEOBJECT(module_filename_obj, 1506, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_add_extensions, const_tuple_80a9571108770bd34772239ad97225a5_tuple, 2, 0, 0);
    codeobj_23a2727bfec75a11d2ac8664eefa517a = MAKE_CODEOBJECT(module_filename_obj, 987, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_add_extensions, const_tuple_7ffc84c231c6d64baeef42ad62a1270d_tuple, 2, 0, 0);
    codeobj_68a1e3325fbb1f364eb9342008f9697e = MAKE_CODEOBJECT(module_filename_obj, 2186, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_add_revoked, const_tuple_aacd84e9abfa73a83f6f088507b53506_tuple, 2, 0, 0);
    codeobj_fa5b81e573b15ecdf6f1dca4e70b2a76 = MAKE_CODEOBJECT(module_filename_obj, 2089, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_all_reasons, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_46e833f2a78ffcfd023683533321764a = MAKE_CODEOBJECT(module_filename_obj, 2633, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_b64_encode, const_tuple_str_plain_self_str_plain_encoded_str_plain_result_tuple, 1, 0, 0);
    codeobj_52082d9f842a277aa94ee6a0252a7f07 = MAKE_CODEOBJECT(module_filename_obj, 361, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_bits, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_3afae2cb1616023deaf9f3e5ada83ddc = MAKE_CODEOBJECT(module_filename_obj, 2688, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_callback, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_dae642fc1d00d46dc97a94e0671a6f94 = MAKE_CODEOBJECT(module_filename_obj, 2701, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_callback_args, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_72e2fe225c7664a56842ff4e880953c2 = MAKE_CODEOBJECT(module_filename_obj, 327, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_check, const_tuple_str_plain_self_str_plain_rsa_str_plain_result_tuple, 1, 0, 0);
    codeobj_826e459e0dc58f5a99e0a127a3e82d23 = MAKE_CODEOBJECT(module_filename_obj, 213, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_clear, const_tuple_str_plain_self_str_plain_name_tuple, 1, 0, 0);
    codeobj_fc7001d155a0450e09ea5b4d5d2bc9f9 = MAKE_CODEOBJECT(module_filename_obj, 668, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_der, const_tuple_7fda6bda0dce687e350e407f685c57f6_tuple, 1, 0, 0);
    codeobj_4f7104a5c773de3617ea99428a718a9f = MAKE_CODEOBJECT(module_filename_obj, 1230, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_digest, const_tuple_57dca116533b0d6d636b268e7001e41b_tuple, 2, 0, 0);
    codeobj_549d02a6f8fe9c9053e01fafd28ef642 = MAKE_CODEOBJECT(module_filename_obj, 1842, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_dump_certificate, const_tuple_4cf00dd32a506e6f9e6721c83bedbfad_tuple, 2, 0, 0);
    codeobj_37ee45b6be0afd221cf7a538d742d0bf = MAKE_CODEOBJECT(module_filename_obj, 2817, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_dump_certificate_request, const_tuple_71acb4312fb0ef6e4480ea2334a6a994_tuple, 2, 0, 0);
    codeobj_937719077c95baa6246e33cb27a31dc5 = MAKE_CODEOBJECT(module_filename_obj, 2943, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_dump_crl, const_tuple_str_plain_type_str_plain_crl_str_plain_bio_str_plain_ret_tuple, 2, 0, 0);
    codeobj_87202647bd1de477b2de0eb2aa352e4f = MAKE_CODEOBJECT(module_filename_obj, 1894, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_dump_privatekey, const_tuple_5f27e2d018bfbbfa2690b5943a091bcc_tuple, 4, 0, 0);
    codeobj_ac78feb39cb3a4f1fcd5ca3fb25b3cc6 = MAKE_CODEOBJECT(module_filename_obj, 1869, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_dump_publickey, const_tuple_86464d9c162f01af99141e0a5b804d71_tuple, 2, 0, 0);
    codeobj_63d5d54775413644d68413130bf8b01c = MAKE_CODEOBJECT(module_filename_obj, 2287, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_export, const_tuple_13745beac221529fe5d89135e9b648d3_tuple, 6, 0, 0);
    codeobj_e7cef9cdd61becb04e1edcd19e659b06 = MAKE_CODEOBJECT(module_filename_obj, 2512, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_export, const_tuple_f62306bb1360dfa87574f464cff0b6db_tuple, 4, 0, 0);
    codeobj_22beaaaea5c6ee0a49315be496a852c0 = MAKE_CODEOBJECT(module_filename_obj, 628, CO_OPTIMIZED | CO_NEWLOCALS, const_str_plain_f, const_tuple_str_plain_self_str_plain_other_str_plain_result_str_plain_op_tuple, 2, 0, 0);
    codeobj_f4d7239bd6f37a2305732ecc4423ba01 = MAKE_CODEOBJECT(module_filename_obj, 126, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_free, const_tuple_str_plain_bio_str_plain_ref_tuple, 2, 0, 0);
    codeobj_1427e696c3581db99d7e88aa6e2d20e2 = MAKE_CODEOBJECT(module_filename_obj, 1112, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_from_cryptography, const_tuple_str_plain_cls_str_plain_crypto_cert_str_plain_cert_tuple, 2, 0, 0);
    codeobj_6ac5e01a4091f7c0a9e36a34af31a1a9 = MAKE_CODEOBJECT(module_filename_obj, 2146, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_from_cryptography, const_tuple_str_plain_cls_str_plain_crypto_crl_str_plain_crl_tuple, 2, 0, 0);
    codeobj_d5561b45ad99d14efabf12463381b5d5 = MAKE_CODEOBJECT(module_filename_obj, 899, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_from_cryptography, const_tuple_str_plain_cls_str_plain_crypto_req_str_plain_req_tuple, 2, 0, 0);
    codeobj_40b3430de5e3101d094061fa2d5cec01 = MAKE_CODEOBJECT(module_filename_obj, 248, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_from_cryptography_key, const_tuple_str_plain_cls_str_plain_crypto_key_str_plain_pkey_tuple, 2, 0, 0);
    codeobj_fe948b55a81e35b717d1b9b97c2db26b = MAKE_CODEOBJECT(module_filename_obj, 435, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_from_nid, const_tuple_str_plain_cls_str_plain_lib_str_plain_nid_tuple, 3, 0, 0);
    codeobj_b718d7c7e21f2f8cf1e62e44bd27b1df = MAKE_CODEOBJECT(module_filename_obj, 271, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_generate_key, const_tuple_270cfc7fce9aafdf0c3eb9f2164206f4_tuple, 3, 0, 0);
    codeobj_cdc04db7a74dd11ea6b2177a19c32798 = MAKE_CODEOBJECT(module_filename_obj, 2454, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_ca_certificates, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_b9f83c00bb65fd2c7bce3d5bc80d9004 = MAKE_CODEOBJECT(module_filename_obj, 2410, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_certificate, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_8f12fd3ce35b73023a06827bde816a58 = MAKE_CODEOBJECT(module_filename_obj, 683, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_components, const_tuple_1598e2e44a7cbbc56ff6b01a61982114_tuple, 1, 0, 0);
    codeobj_b100013f16a2576dec9318822455e6e9 = MAKE_CODEOBJECT(module_filename_obj, 828, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_critical, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_c00a9d5fb891facbacf0fc1ab1c7e398 = MAKE_CODEOBJECT(module_filename_obj, 851, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_data, const_tuple_aa595f479ccfd6af3a4dde57a871f8ed_tuple, 1, 0, 0);
    codeobj_e3d47dcc2e5c78370ad068837f5c1643 = MAKE_CODEOBJECT(module_filename_obj, 498, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_elliptic_curve, const_tuple_str_plain_name_str_plain_curve_tuple, 1, 0, 0);
    codeobj_abddb661c4d0d4ad0339365c339f0316 = MAKE_CODEOBJECT(module_filename_obj, 483, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_elliptic_curves, const_tuple_empty, 0, 0, 0);
    codeobj_2f6eda6ffd4b44390873f4f24070482e = MAKE_CODEOBJECT(module_filename_obj, 1522, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_extension, const_tuple_28746fdd1a6563b63939e82f1814a7ff_tuple, 2, 0, 0);
    codeobj_a3d6ff1e9626c3f8ac77d23bb924b11c = MAKE_CODEOBJECT(module_filename_obj, 1495, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_extension_count, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_45711045417d5734fe1ffb353cc7753b = MAKE_CODEOBJECT(module_filename_obj, 1010, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_extensions, const_tuple_c5e29833751f21ea567c72bd68a6420e_tuple, 1, 0, 0);
    codeobj_295f1119c769c014813a47d7534945e3 = MAKE_CODEOBJECT(module_filename_obj, 2503, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_friendlyname, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_83dbeb702a8014baa25622a5026507ba = MAKE_CODEOBJECT(module_filename_obj, 2203, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_issuer, const_tuple_str_plain_self_str_plain__issuer_str_plain_issuer_tuple, 1, 0, 0);
    codeobj_c92bad46c4a7152b022309b9441ca8ed = MAKE_CODEOBJECT(module_filename_obj, 1439, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_issuer, const_tuple_str_plain_self_str_plain_name_tuple, 1, 0, 0);
    codeobj_a7d4834ead0a1a60fe3119338536d0f3 = MAKE_CODEOBJECT(module_filename_obj, 1396, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_notAfter, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_38e0d057067d90e2fbb10ff012ac6d82 = MAKE_CODEOBJECT(module_filename_obj, 1367, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_notBefore, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_426fef8004659e269aa693019fc0f0fd = MAKE_CODEOBJECT(module_filename_obj, 2432, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_privatekey, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_7ebcd9852a4c17ff014df7666a66c809 = MAKE_CODEOBJECT(module_filename_obj, 930, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_pubkey, const_tuple_str_plain_self_str_plain_pkey_tuple, 1, 0, 0);
    codeobj_b2d34b562f393e96bd01c8d2200fd8b0 = MAKE_CODEOBJECT(module_filename_obj, 1155, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_pubkey, const_tuple_str_plain_self_str_plain_pkey_tuple, 1, 0, 0);
    codeobj_12a92438471858197cd72f0dfaa82ede = MAKE_CODEOBJECT(module_filename_obj, 2645, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_pubkey, const_tuple_str_plain_self_str_plain_pkey_tuple, 1, 0, 0);
    codeobj_ab078d627a4f8a1ea8d9fa8ec2ab7620 = MAKE_CODEOBJECT(module_filename_obj, 2062, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_reason, const_tuple_5ef57f6035eba9ead62528f8493f508e_tuple, 1, 0, 0);
    codeobj_2f75f854001e71ff4003dca12987865c = MAKE_CODEOBJECT(module_filename_obj, 2112, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_rev_date, const_tuple_str_plain_self_str_plain_dt_tuple, 1, 0, 0);
    codeobj_e4f22ea9413d3c0f22c2aa13efebb1d8 = MAKE_CODEOBJECT(module_filename_obj, 2165, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_revoked, const_tuple_f442a9e9eba2c7bd96e443ed0b5afd06_tuple, 1, 0, 0);
    codeobj_368e52860340c0239edd479ec201e937 = MAKE_CODEOBJECT(module_filename_obj, 1999, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_serial, const_tuple_2abd4adfc3fb4c61eb6347c1066336bb_tuple, 1, 0, 0);
    codeobj_62f5aa8a8fda43f2d7f41809819c949c = MAKE_CODEOBJECT(module_filename_obj, 1305, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_serial_number, const_tuple_64996e5d3f2714cc368d8bf48665c67a_tuple, 1, 0, 0);
    codeobj_ba8c4dae468348f7ff9c62739bc12bc4 = MAKE_CODEOBJECT(module_filename_obj, 836, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_short_name, const_tuple_str_plain_self_str_plain_obj_str_plain_nid_tuple, 1, 0, 0);
    codeobj_cdc94e00f8d570018ee7361d163914a9 = MAKE_CODEOBJECT(module_filename_obj, 1213, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_signature_algorithm, const_tuple_str_plain_self_str_plain_algor_str_plain_nid_tuple, 1, 0, 0);
    codeobj_ab9238934dc2a850ec08f1603c825e21 = MAKE_CODEOBJECT(module_filename_obj, 965, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_subject, const_tuple_str_plain_self_str_plain_name_tuple, 1, 0, 0);
    codeobj_0167861cea57ebc738ecf400cc04ebfa = MAKE_CODEOBJECT(module_filename_obj, 1467, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_subject, const_tuple_str_plain_self_str_plain_name_tuple, 1, 0, 0);
    codeobj_c084b3860bf0d3247773b3ddb209b309 = MAKE_CODEOBJECT(module_filename_obj, 2381, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_type_name, const_tuple_str_plain_self_str_plain_string_type_str_plain_nid_tuple, 1, 0, 0);
    codeobj_638f670f35af3781de5f2f4c9835741e = MAKE_CODEOBJECT(module_filename_obj, 955, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_version, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_fcdc69651d69daf00844268634ce9361 = MAKE_CODEOBJECT(module_filename_obj, 1146, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_version, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_4de131a75c684fec0469c48115745d08 = MAKE_CODEOBJECT(module_filename_obj, 1325, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_gmtime_adj_notAfter, const_tuple_str_plain_self_str_plain_amount_str_plain_notAfter_tuple, 2, 0, 0);
    codeobj_50ee192f9d0e8e84633297c994f58a6a = MAKE_CODEOBJECT(module_filename_obj, 1339, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_gmtime_adj_notBefore, const_tuple_str_plain_self_str_plain_amount_str_plain_notBefore_tuple, 2, 0, 0);
    codeobj_fbdfdccccf232276b858abd51cb882bb = MAKE_CODEOBJECT(module_filename_obj, 1352, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_has_expired, const_tuple_str_plain_self_str_plain_not_after_str_plain_time_string_tuple, 1, 0, 0);
    codeobj_9108a7396152423879c9fb4fd180f6ef = MAKE_CODEOBJECT(module_filename_obj, 656, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_hash, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_3ba03b4a83863db0211776596d7369dc = MAKE_CODEOBJECT(module_filename_obj, 1812, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_load_certificate, const_tuple_str_plain_type_str_plain_buffer_str_plain_bio_str_plain_x509_tuple, 2, 0, 0);
    codeobj_dd9bf8ebdf933d2516db3e82c61898d8 = MAKE_CODEOBJECT(module_filename_obj, 2845, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_load_certificate_request, const_tuple_21bd89dfe3a1dd3e39e03972a01f5a89_tuple, 2, 0, 0);
    codeobj_6e98a073ab05ca431e08e0cd283b2282 = MAKE_CODEOBJECT(module_filename_obj, 2971, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_load_crl, const_tuple_53b63b794c8b8f328f3f365985abd328_tuple, 2, 0, 0);
    codeobj_cb2229b3594b0ea74e790a288340fb5b = MAKE_CODEOBJECT(module_filename_obj, 3030, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_load_pkcs12, const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 2, 0, 0);
    codeobj_bd97d2185c62e99374c1533c90a95f19 = MAKE_CODEOBJECT(module_filename_obj, 3001, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_load_pkcs7_data, const_tuple_516125a1d64dba4bb10b7a1d5054cba1_tuple, 2, 0, 0);
    codeobj_b7fff7ac811f5c1447b68a592d106780 = MAKE_CODEOBJECT(module_filename_obj, 2781, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_load_privatekey, const_tuple_76984bb103279dcce095840ed073cae5_tuple, 3, 0, 0);
    codeobj_84543461673eee61a7305bb77fc49b09 = MAKE_CODEOBJECT(module_filename_obj, 2748, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_load_publickey, const_tuple_34a51bbef25f1a50174cde73cf717c0e_tuple, 2, 0, 0);
    codeobj_0d63d1af7f4ff3d26e5354dc78437737 = MAKE_CODEOBJECT(module_filename_obj, 2714, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_raise_if_problem, const_tuple_str_plain_self_str_plain_exceptionType_tuple, 2, 0, 0);
    codeobj_75232e283be8a43fe94949460ca59119 = MAKE_CODEOBJECT(module_filename_obj, 2465, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_ca_certificates, const_tuple_str_plain_self_str_plain_cacerts_str_plain_cert_tuple, 2, 0, 0);
    codeobj_999486723fe5c8277b4a8914c9586c78 = MAKE_CODEOBJECT(module_filename_obj, 2419, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_certificate, const_tuple_str_plain_self_str_plain_cert_tuple, 2, 0, 0);
    codeobj_60b024772fde8ae0bc098cb534c29ad5 = MAKE_CODEOBJECT(module_filename_obj, 1640, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_flags, const_tuple_str_plain_self_str_plain_flags_tuple, 2, 0, 0);
    codeobj_60a54c7eb9de93d0fd2fe53bbdafcf10 = MAKE_CODEOBJECT(module_filename_obj, 2486, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_friendlyname, const_tuple_str_plain_self_str_plain_name_tuple, 2, 0, 0);
    codeobj_7b28dcc872c0fc1e599bc7f4fd0593c7 = MAKE_CODEOBJECT(module_filename_obj, 1455, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_issuer, const_tuple_str_plain_self_str_plain_issuer_tuple, 2, 0, 0);
    codeobj_6adba4da8c74bf815c0210e671b10c64 = MAKE_CODEOBJECT(module_filename_obj, 2232, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_lastUpdate, const_tuple_str_plain_self_str_plain_when_tuple, 2, 0, 0);
    codeobj_09ba91e9bcc11b447039b645c382509f = MAKE_CODEOBJECT(module_filename_obj, 2247, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_nextUpdate, const_tuple_str_plain_self_str_plain_when_tuple, 2, 0, 0);
    codeobj_7d3a859e1d891c970bd1bda57166fb91 = MAKE_CODEOBJECT(module_filename_obj, 1409, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_notAfter, const_tuple_str_plain_self_str_plain_when_tuple, 2, 0, 0);
    codeobj_f85802ded5ad9e24c28efb6d7f3ae0de = MAKE_CODEOBJECT(module_filename_obj, 1383, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_notBefore, const_tuple_str_plain_self_str_plain_when_tuple, 2, 0, 0);
    codeobj_f40f51dde7e8f7585957d7400a166b67 = MAKE_CODEOBJECT(module_filename_obj, 2441, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_privatekey, const_tuple_str_plain_self_str_plain_pkey_tuple, 2, 0, 0);
    codeobj_e7a5b9023d1f01cca25bb4c11d94736c = MAKE_CODEOBJECT(module_filename_obj, 918, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_pubkey, const_tuple_str_plain_self_str_plain_pkey_str_plain_set_result_tuple, 2, 0, 0);
    codeobj_144ee34ca155af9932b2f45dad52e660 = MAKE_CODEOBJECT(module_filename_obj, 1170, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_pubkey, const_tuple_str_plain_self_str_plain_pkey_str_plain_set_result_tuple, 2, 0, 0);
    codeobj_cfb453c9877c1441541c8778d573d561 = MAKE_CODEOBJECT(module_filename_obj, 2659, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_pubkey, const_tuple_str_plain_self_str_plain_pkey_str_plain_set_result_tuple, 2, 0, 0);
    codeobj_69ba33aac22465dc3e11fe94f2672358 = MAKE_CODEOBJECT(module_filename_obj, 2026, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_reason, const_tuple_79603f0465bd62773d6ec6c98e743896_tuple, 2, 0, 0);
    codeobj_151b1f6515b68f745ad19e8b1fbe6905 = MAKE_CODEOBJECT(module_filename_obj, 2101, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_rev_date, const_tuple_str_plain_self_str_plain_when_str_plain_dt_tuple, 2, 0, 0);
    codeobj_5654d7a7e7e1d262193996dc0e844779 = MAKE_CODEOBJECT(module_filename_obj, 1976, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_serial, const_tuple_a2a87d1d5695ca90897866b205aec3ce_tuple, 2, 0, 0);
    codeobj_f86a27bee71853ffe2494335d054f9c2 = MAKE_CODEOBJECT(module_filename_obj, 1266, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_serial_number, const_tuple_13d990c39f45e826db58a38b07f9cd95_tuple, 2, 0, 0);
    codeobj_5ed9e5e6e97c4656f6c19f9fb33742ec = MAKE_CODEOBJECT(module_filename_obj, 1778, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_store, const_tuple_str_plain_self_str_plain_store_tuple, 2, 0, 0);
    codeobj_555e64665b36c5489cfa1aab914f4b68 = MAKE_CODEOBJECT(module_filename_obj, 1483, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_subject, const_tuple_str_plain_self_str_plain_subject_tuple, 2, 0, 0);
    codeobj_5206be546a6fa8e25a02dc839db5f52a = MAKE_CODEOBJECT(module_filename_obj, 1664, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_time, const_tuple_str_plain_self_str_plain_vfy_time_str_plain_param_tuple, 2, 0, 0);
    codeobj_3e08719da027c8ef5763e0014ecff43a = MAKE_CODEOBJECT(module_filename_obj, 1131, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_version, const_tuple_str_plain_self_str_plain_version_tuple, 2, 0, 0);
    codeobj_1ea23726b81bbec2d72c3f055e13f1f3 = MAKE_CODEOBJECT(module_filename_obj, 2218, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_version, const_tuple_str_plain_self_str_plain_version_tuple, 2, 0, 0);
    codeobj_80d62758301ca388b22f45ed7f965aa4 = MAKE_CODEOBJECT(module_filename_obj, 944, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_version, const_tuple_str_plain_self_str_plain_version_str_plain_set_result_tuple, 2, 0, 0);
    codeobj_8c86ab161458de9d92d55080e4948b8b = MAKE_CODEOBJECT(module_filename_obj, 2873, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_sign, const_tuple_51ff74c45307e7d0bccc36be86c10b54_tuple, 3, 0, 0);
    codeobj_a5dfabf8fb4be3653adb4ee5e3a9d1ee = MAKE_CODEOBJECT(module_filename_obj, 2262, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_sign, const_tuple_4415e41d2d925845f2ba634f8c71f0dc_tuple, 4, 0, 0);
    codeobj_c91f46b1da28091dae5fe2a35b791807 = MAKE_CODEOBJECT(module_filename_obj, 1027, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_sign, const_tuple_7df0279ef5fffac2c0a66ea7c472ab4b_tuple, 3, 0, 0);
    codeobj_603b25455c6bfd7b211c177899c083b0 = MAKE_CODEOBJECT(module_filename_obj, 2589, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_sign, const_tuple_7df0279ef5fffac2c0a66ea7c472ab4b_tuple, 3, 0, 0);
    codeobj_4f6e8e494b7d709f425892031ee6c86e = MAKE_CODEOBJECT(module_filename_obj, 1185, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_sign, const_tuple_10f3f1cb3df7aac52b98dbb720bf50d1_tuple, 3, 0, 0);
    codeobj_bff0f237096588ea8e24a7bf1bb681f0 = MAKE_CODEOBJECT(module_filename_obj, 1257, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_subject_name_hash, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_97f156a5c2f4577fd55162ed1d43b342 = MAKE_CODEOBJECT(module_filename_obj, 1100, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_to_cryptography, const_tuple_str_plain_self_str_plain__Certificate_str_plain_backend_tuple, 1, 0, 0);
    codeobj_c813942487f91c1997585eb0b387e327 = MAKE_CODEOBJECT(module_filename_obj, 2132, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_to_cryptography, const_tuple_0c127564cb8e0f10a9444ae3c25de3f1_tuple, 1, 0, 0);
    codeobj_183dcbba32fef389a142755b74a73efe = MAKE_CODEOBJECT(module_filename_obj, 885, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_to_cryptography, const_tuple_7eb0e743d38af9e33bf64e78c0ab103c_tuple, 1, 0, 0);
    codeobj_17fae881cac6fcbcb689c6d8ff5eee21 = MAKE_CODEOBJECT(module_filename_obj, 231, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_to_cryptography_key, const_tuple_str_plain_self_str_plain_backend_tuple, 1, 0, 0);
    codeobj_592334dbe6f644d58958dafe39779ba7 = MAKE_CODEOBJECT(module_filename_obj, 353, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_type, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_9bf9cf1b8da4c938f3ae767506473565 = MAKE_CODEOBJECT(module_filename_obj, 2373, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_type_is_data, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_404049e2a875869f38e29055c42cb643 = MAKE_CODEOBJECT(module_filename_obj, 2357, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_type_is_enveloped, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_3675b56e8a472299e465a6cac7a20233 = MAKE_CODEOBJECT(module_filename_obj, 2349, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_type_is_signed, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_03c4cee92a073dc3714d696db7ba0ad3 = MAKE_CODEOBJECT(module_filename_obj, 2365, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_type_is_signedAndEnveloped, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_7d7f67b2a9e1de973b6a168bc3652501 = MAKE_CODEOBJECT(module_filename_obj, 2907, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_verify, const_tuple_5903b88f37d1077b2f3871dbc2944417_tuple, 4, 0, 0);
    codeobj_6580b2147d66eb9876d3eb667c120ce7 = MAKE_CODEOBJECT(module_filename_obj, 2616, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_verify, const_tuple_str_plain_self_str_plain_key_str_plain_answer_tuple, 2, 0, 0);
    codeobj_a6f140d90bf737cea4d50cfd537ab5e2 = MAKE_CODEOBJECT(module_filename_obj, 1051, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_verify, const_tuple_str_plain_self_str_plain_pkey_str_plain_result_tuple, 2, 0, 0);
    codeobj_cf70a0fe535b0c265515473726b4c514 = MAKE_CODEOBJECT(module_filename_obj, 1789, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_verify_certificate, const_tuple_str_plain_self_str_plain_ret_tuple, 1, 0, 0);
}

// The module function declarations.
static PyObject *OpenSSL$crypto$$$function_18__load_elliptic_curves$$$genexpr_1_genexpr_maker(void);


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_100_dump_privatekey(PyObject *defaults);


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_101___init__();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_102_set_serial();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_103_get_serial();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_104__delete_reason();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_105_set_reason();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_106_get_reason();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_107_all_reasons();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_108_set_rev_date();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_109_get_rev_date();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_10___init__();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_110___init__();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_111_to_cryptography();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_112_from_cryptography();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_113_get_revoked();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_114_add_revoked();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_115_get_issuer();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_116_set_version();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_117__set_boundary_time();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_118_set_lastUpdate();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_119_set_nextUpdate();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_11_to_cryptography_key();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_120_sign();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_121_export(PyObject *defaults);


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_122_type_is_signed();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_123_type_is_enveloped();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_124_type_is_signedAndEnveloped();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_125_type_is_data();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_126_get_type_name();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_127___init__();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_128_get_certificate();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_129_set_certificate();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_12_from_cryptography_key();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_130_get_privatekey();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_131_set_privatekey();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_132_get_ca_certificates();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_133_set_ca_certificates();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_134_set_friendlyname();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_135_get_friendlyname();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_136_export(PyObject *defaults);


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_137___init__();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_138_sign();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_139_verify();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_13_generate_key();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_140_b64_encode();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_141_get_pubkey();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_142_set_pubkey();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_143___init__(PyObject *defaults);


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_144_callback();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_145_callback_args();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_146_raise_if_problem(PyObject *defaults);


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_147__read_passphrase();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_148_load_publickey();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_149_load_privatekey(PyObject *defaults);


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_14_check();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_150_dump_certificate_request();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_151_load_certificate_request();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_152_sign();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_153_verify();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_154_dump_crl();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_155_load_crl();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_156_load_pkcs7_data();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_157_load_pkcs12(PyObject *defaults);


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_15_type();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_16_bits();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_17___ne__();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_18__load_elliptic_curves();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_19__get_elliptic_curves();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_1__get_backend();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_20_from_nid();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_21___init__();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_22___repr__();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_23__to_EC_KEY();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_24_get_elliptic_curves();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_25_get_elliptic_curve();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_26___init__();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_27___setattr__();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_28___getattr__();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_29__cmp();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_29__cmp$$$function_1_f();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_2__untested_error();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_30___repr__();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_31_hash();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_32_der();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_33_get_components();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_34___init__(PyObject *defaults);


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_35__nid();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_36__subjectAltNameString();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_37___str__();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_38_get_critical();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_39_get_short_name();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_3__new_mem_buf(PyObject *defaults);


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_3__new_mem_buf$$$function_1_free(PyObject *defaults);


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_40_get_data();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_41___init__();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_42_to_cryptography();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_43_from_cryptography();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_44_set_pubkey();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_45_get_pubkey();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_46_set_version();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_47_get_version();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_48_get_subject();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_49_add_extensions();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_4__bio_to_string();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_50_get_extensions();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_51_sign();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_52_verify();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_53___init__();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_54__from_raw_x509_ptr();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_55_to_cryptography();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_56_from_cryptography();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_57_set_version();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_58_get_version();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_59_get_pubkey();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_5__set_asn1_time();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_60_set_pubkey();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_61_sign();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_62_get_signature_algorithm();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_63_digest();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_64_subject_name_hash();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_65_set_serial_number();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_66_get_serial_number();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_67_gmtime_adj_notAfter();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_68_gmtime_adj_notBefore();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_69_has_expired();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_6__get_asn1_time();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_70__get_boundary_time();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_71_get_notBefore();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_72__set_boundary_time();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_73_set_notBefore();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_74_get_notAfter();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_75_set_notAfter();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_76__get_name();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_77__set_name();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_78_get_issuer();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_79_set_issuer();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_7___init__();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_80_get_subject();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_81_set_subject();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_82_get_extension_count();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_83_add_extensions();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_84_get_extension();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_85___init__();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_86_add_cert();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_87_add_crl();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_88_set_flags();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_89_set_time();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_8_add();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_90___init__();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_91___init__();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_92__init();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_93__cleanup();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_94__exception_from_context();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_95_set_store();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_96_verify_certificate();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_97_load_certificate();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_98_dump_certificate();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_99_dump_publickey();


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_9_clear();


// The module function definitions.
static PyObject *impl_OpenSSL$crypto$$$function_1__get_backend(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *var_backend = NULL;
    struct Nuitka_FrameObject *frame_305731e8abbf83d9573a0ae65d31c97c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_305731e8abbf83d9573a0ae65d31c97c = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_305731e8abbf83d9573a0ae65d31c97c, codeobj_305731e8abbf83d9573a0ae65d31c97c, module_OpenSSL$crypto, sizeof(void *));
    frame_305731e8abbf83d9573a0ae65d31c97c = cache_frame_305731e8abbf83d9573a0ae65d31c97c;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_305731e8abbf83d9573a0ae65d31c97c);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_305731e8abbf83d9573a0ae65d31c97c) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_import_name_from_1;
        PyObject *tmp_name_name_1;
        PyObject *tmp_globals_name_1;
        PyObject *tmp_locals_name_1;
        PyObject *tmp_fromlist_name_1;
        tmp_name_name_1 = const_str_digest_9abb9f40508debfa3aae6d9135753f7e;
        tmp_globals_name_1 = (PyObject *)moduledict_OpenSSL$crypto;
        tmp_locals_name_1 = Py_None;
        tmp_fromlist_name_1 = const_tuple_str_plain_backend_tuple;
        frame_305731e8abbf83d9573a0ae65d31c97c->m_frame.f_lineno = 96;
        tmp_import_name_from_1 = IMPORT_MODULE4(tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1);
        if (tmp_import_name_from_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 96;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_1 = IMPORT_NAME(tmp_import_name_from_1, const_str_plain_backend);
        Py_DECREF(tmp_import_name_from_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 96;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        assert(var_backend == NULL);
        var_backend = tmp_assign_source_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_305731e8abbf83d9573a0ae65d31c97c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_305731e8abbf83d9573a0ae65d31c97c);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_305731e8abbf83d9573a0ae65d31c97c, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_305731e8abbf83d9573a0ae65d31c97c->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_305731e8abbf83d9573a0ae65d31c97c, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_305731e8abbf83d9573a0ae65d31c97c,
        type_description_1,
        var_backend
    );


    // Release cached frame.
    if (frame_305731e8abbf83d9573a0ae65d31c97c == cache_frame_305731e8abbf83d9573a0ae65d31c97c) {
        Py_DECREF(frame_305731e8abbf83d9573a0ae65d31c97c);
    }
    cache_frame_305731e8abbf83d9573a0ae65d31c97c = NULL;

    assertFrameObject(frame_305731e8abbf83d9573a0ae65d31c97c);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT(var_backend);
    tmp_return_value = var_backend;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_1__get_backend);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_backend);
    Py_DECREF(var_backend);
    var_backend = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_1__get_backend);
    return NULL;

function_exception_exit:
    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_2__untested_error(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_where = python_pars[0];
    struct Nuitka_FrameObject *frame_41b835cb0b40d60758bdeb7772fa66f4;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_41b835cb0b40d60758bdeb7772fa66f4 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_41b835cb0b40d60758bdeb7772fa66f4, codeobj_41b835cb0b40d60758bdeb7772fa66f4, module_OpenSSL$crypto, sizeof(void *));
    frame_41b835cb0b40d60758bdeb7772fa66f4 = cache_frame_41b835cb0b40d60758bdeb7772fa66f4;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_41b835cb0b40d60758bdeb7772fa66f4);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_41b835cb0b40d60758bdeb7772fa66f4) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_raise_type_1;
        PyObject *tmp_make_exception_arg_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_tuple_element_1;
        tmp_left_name_1 = const_str_digest_819566a56c114d5ab553db6b3a965184;
        CHECK_OBJECT(par_where);
        tmp_tuple_element_1 = par_where;
        tmp_right_name_1 = PyTuple_New(1);
        Py_INCREF(tmp_tuple_element_1);
        PyTuple_SET_ITEM(tmp_right_name_1, 0, tmp_tuple_element_1);
        tmp_make_exception_arg_1 = BINARY_OPERATION_MOD_STR_TUPLE(tmp_left_name_1, tmp_right_name_1);
        Py_DECREF(tmp_right_name_1);
        if (tmp_make_exception_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 106;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_41b835cb0b40d60758bdeb7772fa66f4->m_frame.f_lineno = 106;
        tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_RuntimeError, tmp_make_exception_arg_1);
        Py_DECREF(tmp_make_exception_arg_1);
        assert(!(tmp_raise_type_1 == NULL));
        exception_type = tmp_raise_type_1;
        exception_lineno = 106;
        RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_41b835cb0b40d60758bdeb7772fa66f4);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_41b835cb0b40d60758bdeb7772fa66f4);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_41b835cb0b40d60758bdeb7772fa66f4, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_41b835cb0b40d60758bdeb7772fa66f4->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_41b835cb0b40d60758bdeb7772fa66f4, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_41b835cb0b40d60758bdeb7772fa66f4,
        type_description_1,
        par_where
    );


    // Release cached frame.
    if (frame_41b835cb0b40d60758bdeb7772fa66f4 == cache_frame_41b835cb0b40d60758bdeb7772fa66f4) {
        Py_DECREF(frame_41b835cb0b40d60758bdeb7772fa66f4);
    }
    cache_frame_41b835cb0b40d60758bdeb7772fa66f4 = NULL;

    assertFrameObject(frame_41b835cb0b40d60758bdeb7772fa66f4);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_2__untested_error);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_where);
    Py_DECREF(par_where);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

}


static PyObject *impl_OpenSSL$crypto$$$function_3__new_mem_buf(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_buffer = python_pars[0];
    PyObject *var_bio = NULL;
    PyObject *var_data = NULL;
    PyObject *var_free = NULL;
    struct Nuitka_FrameObject *frame_10246d31c9c113ffc000a4408916df7b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_10246d31c9c113ffc000a4408916df7b = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_10246d31c9c113ffc000a4408916df7b, codeobj_10246d31c9c113ffc000a4408916df7b, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_10246d31c9c113ffc000a4408916df7b = cache_frame_10246d31c9c113ffc000a4408916df7b;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_10246d31c9c113ffc000a4408916df7b);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_10246d31c9c113ffc000a4408916df7b) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_buffer);
        tmp_compexpr_left_1 = par_buffer;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_called_name_1;
            PyObject *tmp_source_name_1;
            PyObject *tmp_mvar_value_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_mvar_value_2;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_1 == NULL)) {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_1 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 119;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_1 = tmp_mvar_value_1;
            tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_BIO_new);
            if (tmp_called_name_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 119;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_2 == NULL) {
                Py_DECREF(tmp_called_name_1);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 119;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_1 = tmp_mvar_value_2;
            frame_10246d31c9c113ffc000a4408916df7b->m_frame.f_lineno = 119;
            tmp_args_element_name_1 = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_BIO_s_mem);
            if (tmp_args_element_name_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_1);

                exception_lineno = 119;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            frame_10246d31c9c113ffc000a4408916df7b->m_frame.f_lineno = 119;
            tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_element_name_1);
            if (tmp_assign_source_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 119;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            assert(var_bio == NULL);
            var_bio = tmp_assign_source_1;
        }
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_source_name_2;
            PyObject *tmp_mvar_value_3;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_3 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 120;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_2 = tmp_mvar_value_3;
            tmp_assign_source_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_BIO_free);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 120;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            assert(var_free == NULL);
            var_free = tmp_assign_source_2;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_called_instance_2;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_args_element_name_3;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_4 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 122;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_2 = tmp_mvar_value_4;
            tmp_args_element_name_2 = const_str_digest_c561652c58984ec0e9541542aa405594;
            CHECK_OBJECT(par_buffer);
            tmp_args_element_name_3 = par_buffer;
            frame_10246d31c9c113ffc000a4408916df7b->m_frame.f_lineno = 122;
            {
                PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
                tmp_assign_source_3 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_2, const_str_plain_new, call_args);
            }

            if (tmp_assign_source_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 122;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            assert(var_data == NULL);
            var_data = tmp_assign_source_3;
        }
        {
            PyObject *tmp_assign_source_4;
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_3;
            PyObject *tmp_mvar_value_5;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_args_element_name_5;
            PyObject *tmp_len_arg_1;
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_5 == NULL)) {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_5 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 123;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_3 = tmp_mvar_value_5;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_BIO_new_mem_buf);
            if (tmp_called_name_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 123;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_data);
            tmp_args_element_name_4 = var_data;
            CHECK_OBJECT(par_buffer);
            tmp_len_arg_1 = par_buffer;
            tmp_args_element_name_5 = BUILTIN_LEN(tmp_len_arg_1);
            if (tmp_args_element_name_5 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_2);

                exception_lineno = 123;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            frame_10246d31c9c113ffc000a4408916df7b->m_frame.f_lineno = 123;
            {
                PyObject *call_args[] = {tmp_args_element_name_4, tmp_args_element_name_5};
                tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
            }

            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_5);
            if (tmp_assign_source_4 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 123;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            assert(var_bio == NULL);
            var_bio = tmp_assign_source_4;
        }
        {
            PyObject *tmp_assign_source_5;
            PyObject *tmp_defaults_1;
            PyObject *tmp_tuple_element_1;
            CHECK_OBJECT(var_data);
            tmp_tuple_element_1 = var_data;
            tmp_defaults_1 = PyTuple_New(1);
            Py_INCREF(tmp_tuple_element_1);
            PyTuple_SET_ITEM(tmp_defaults_1, 0, tmp_tuple_element_1);
            tmp_assign_source_5 = MAKE_FUNCTION_OpenSSL$crypto$$$function_3__new_mem_buf$$$function_1_free(tmp_defaults_1);



            assert(var_free == NULL);
            var_free = tmp_assign_source_5;
        }
        branch_end_1:;
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_7;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_6 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 129;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_6;
        CHECK_OBJECT(var_bio);
        tmp_compexpr_left_2 = var_bio;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_7 == NULL)) {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_7 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 129;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_7;
        tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_NULL);
        if (tmp_compexpr_right_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 129;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_6 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
        Py_DECREF(tmp_compexpr_right_2);
        if (tmp_args_element_name_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 129;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_10246d31c9c113ffc000a4408916df7b->m_frame.f_lineno = 129;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_3, tmp_args_element_name_6);
        Py_DECREF(tmp_args_element_name_6);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 129;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_args_element_name_8;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_8 == NULL)) {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_8 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 131;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_3 = tmp_mvar_value_8;
        CHECK_OBJECT(var_bio);
        tmp_args_element_name_7 = var_bio;
        CHECK_OBJECT(var_free);
        tmp_args_element_name_8 = var_free;
        frame_10246d31c9c113ffc000a4408916df7b->m_frame.f_lineno = 131;
        {
            PyObject *call_args[] = {tmp_args_element_name_7, tmp_args_element_name_8};
            tmp_assign_source_6 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_3, const_str_plain_gc, call_args);
        }

        if (tmp_assign_source_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 131;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var_bio;
            assert(old != NULL);
            var_bio = tmp_assign_source_6;
            Py_DECREF(old);
        }

    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_10246d31c9c113ffc000a4408916df7b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_10246d31c9c113ffc000a4408916df7b);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_10246d31c9c113ffc000a4408916df7b, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_10246d31c9c113ffc000a4408916df7b->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_10246d31c9c113ffc000a4408916df7b, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_10246d31c9c113ffc000a4408916df7b,
        type_description_1,
        par_buffer,
        var_bio,
        var_data,
        var_free
    );


    // Release cached frame.
    if (frame_10246d31c9c113ffc000a4408916df7b == cache_frame_10246d31c9c113ffc000a4408916df7b) {
        Py_DECREF(frame_10246d31c9c113ffc000a4408916df7b);
    }
    cache_frame_10246d31c9c113ffc000a4408916df7b = NULL;

    assertFrameObject(frame_10246d31c9c113ffc000a4408916df7b);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT(var_bio);
    tmp_return_value = var_bio;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_3__new_mem_buf);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_bio);
    Py_DECREF(var_bio);
    var_bio = NULL;

    Py_XDECREF(var_data);
    var_data = NULL;

    CHECK_OBJECT((PyObject *)var_free);
    Py_DECREF(var_free);
    var_free = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_bio);
    var_bio = NULL;

    Py_XDECREF(var_data);
    var_data = NULL;

    Py_XDECREF(var_free);
    var_free = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_3__new_mem_buf);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_buffer);
    Py_DECREF(par_buffer);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_buffer);
    Py_DECREF(par_buffer);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_3__new_mem_buf$$$function_1_free(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_bio = python_pars[0];
    PyObject *par_ref = python_pars[1];
    struct Nuitka_FrameObject *frame_f4d7239bd6f37a2305732ecc4423ba01;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_f4d7239bd6f37a2305732ecc4423ba01 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_f4d7239bd6f37a2305732ecc4423ba01, codeobj_f4d7239bd6f37a2305732ecc4423ba01, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *));
    frame_f4d7239bd6f37a2305732ecc4423ba01 = cache_frame_f4d7239bd6f37a2305732ecc4423ba01;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_f4d7239bd6f37a2305732ecc4423ba01);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_f4d7239bd6f37a2305732ecc4423ba01) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 127;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT(par_bio);
        tmp_args_element_name_1 = par_bio;
        frame_f4d7239bd6f37a2305732ecc4423ba01->m_frame.f_lineno = 127;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_BIO_free, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 127;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_f4d7239bd6f37a2305732ecc4423ba01);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_f4d7239bd6f37a2305732ecc4423ba01);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_f4d7239bd6f37a2305732ecc4423ba01);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_f4d7239bd6f37a2305732ecc4423ba01, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_f4d7239bd6f37a2305732ecc4423ba01->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_f4d7239bd6f37a2305732ecc4423ba01, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f4d7239bd6f37a2305732ecc4423ba01,
        type_description_1,
        par_bio,
        par_ref
    );


    // Release cached frame.
    if (frame_f4d7239bd6f37a2305732ecc4423ba01 == cache_frame_f4d7239bd6f37a2305732ecc4423ba01) {
        Py_DECREF(frame_f4d7239bd6f37a2305732ecc4423ba01);
    }
    cache_frame_f4d7239bd6f37a2305732ecc4423ba01 = NULL;

    assertFrameObject(frame_f4d7239bd6f37a2305732ecc4423ba01);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_3__new_mem_buf$$$function_1_free);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_bio);
    Py_DECREF(par_bio);
    CHECK_OBJECT(par_ref);
    Py_DECREF(par_ref);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_bio);
    Py_DECREF(par_bio);
    CHECK_OBJECT(par_ref);
    Py_DECREF(par_ref);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_4__bio_to_string(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_bio = python_pars[0];
    PyObject *var_buffer_length = NULL;
    PyObject *var_result_buffer = NULL;
    struct Nuitka_FrameObject *frame_9b1e39652aee4650ee015af31b51eda4;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_9b1e39652aee4650ee015af31b51eda4 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_9b1e39652aee4650ee015af31b51eda4, codeobj_9b1e39652aee4650ee015af31b51eda4, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_9b1e39652aee4650ee015af31b51eda4 = cache_frame_9b1e39652aee4650ee015af31b51eda4;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_9b1e39652aee4650ee015af31b51eda4);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_9b1e39652aee4650ee015af31b51eda4) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 139;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_9b1e39652aee4650ee015af31b51eda4->m_frame.f_lineno = 139;
        tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_new, &PyTuple_GET_ITEM(const_tuple_str_digest_70b987f75825a6c2ffe2c8fe53d85a21_tuple, 0));

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 139;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_result_buffer == NULL);
        var_result_buffer = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 140;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_2;
        CHECK_OBJECT(par_bio);
        tmp_args_element_name_1 = par_bio;
        CHECK_OBJECT(var_result_buffer);
        tmp_args_element_name_2 = var_result_buffer;
        frame_9b1e39652aee4650ee015af31b51eda4->m_frame.f_lineno = 140;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_2 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_2, const_str_plain_BIO_get_mem_data, call_args);
        }

        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 140;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_buffer_length == NULL);
        var_buffer_length = tmp_assign_source_2;
    }
    {
        Py_ssize_t tmp_sliceslicedel_index_lower_1;
        Py_ssize_t tmp_slice_index_upper_1;
        PyObject *tmp_slice_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_subscript_name_1;
        PyObject *tmp_args_element_name_4;
        tmp_sliceslicedel_index_lower_1 = 0;
        tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 141;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_3;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_buffer);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 141;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_result_buffer);
        tmp_subscribed_name_1 = var_result_buffer;
        tmp_subscript_name_1 = const_int_0;
        tmp_args_element_name_3 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_1, tmp_subscript_name_1, 0);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 141;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_buffer_length);
        tmp_args_element_name_4 = var_buffer_length;
        frame_9b1e39652aee4650ee015af31b51eda4->m_frame.f_lineno = 141;
        {
            PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4};
            tmp_slice_source_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_slice_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 141;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = LOOKUP_INDEX_SLICE(tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1);
        Py_DECREF(tmp_slice_source_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 141;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9b1e39652aee4650ee015af31b51eda4);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_9b1e39652aee4650ee015af31b51eda4);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9b1e39652aee4650ee015af31b51eda4);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_9b1e39652aee4650ee015af31b51eda4, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_9b1e39652aee4650ee015af31b51eda4->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_9b1e39652aee4650ee015af31b51eda4, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9b1e39652aee4650ee015af31b51eda4,
        type_description_1,
        par_bio,
        var_buffer_length,
        var_result_buffer
    );


    // Release cached frame.
    if (frame_9b1e39652aee4650ee015af31b51eda4 == cache_frame_9b1e39652aee4650ee015af31b51eda4) {
        Py_DECREF(frame_9b1e39652aee4650ee015af31b51eda4);
    }
    cache_frame_9b1e39652aee4650ee015af31b51eda4 = NULL;

    assertFrameObject(frame_9b1e39652aee4650ee015af31b51eda4);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_4__bio_to_string);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_buffer_length);
    Py_DECREF(var_buffer_length);
    var_buffer_length = NULL;

    CHECK_OBJECT((PyObject *)var_result_buffer);
    Py_DECREF(var_result_buffer);
    var_result_buffer = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_buffer_length);
    var_buffer_length = NULL;

    Py_XDECREF(var_result_buffer);
    var_result_buffer = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_4__bio_to_string);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_bio);
    Py_DECREF(par_bio);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_bio);
    Py_DECREF(par_bio);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_5__set_asn1_time(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_boundary = python_pars[0];
    PyObject *par_when = python_pars[1];
    PyObject *var_set_result = NULL;
    struct Nuitka_FrameObject *frame_8569be16f63185d6aef0adf92c520ee5;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_8569be16f63185d6aef0adf92c520ee5 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_8569be16f63185d6aef0adf92c520ee5, codeobj_8569be16f63185d6aef0adf92c520ee5, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_8569be16f63185d6aef0adf92c520ee5 = cache_frame_8569be16f63185d6aef0adf92c520ee5;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_8569be16f63185d6aef0adf92c520ee5);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_8569be16f63185d6aef0adf92c520ee5) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        CHECK_OBJECT(par_when);
        tmp_isinstance_inst_1 = par_when;
        tmp_isinstance_cls_1 = (PyObject *)&PyString_Type;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 158;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 158;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_0632ce6142bf9815370c626f0fb1235a;
            frame_8569be16f63185d6aef0adf92c520ee5->m_frame.f_lineno = 159;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 159;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 161;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT(par_boundary);
        tmp_args_element_name_1 = par_boundary;
        CHECK_OBJECT(par_when);
        tmp_args_element_name_2 = par_when;
        frame_8569be16f63185d6aef0adf92c520ee5->m_frame.f_lineno = 161;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain_ASN1_TIME_set_string, call_args);
        }

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 161;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_set_result == NULL);
        var_set_result = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(var_set_result);
        tmp_compexpr_left_1 = var_set_result;
        tmp_compexpr_right_1 = const_int_0;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_INT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 162;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            tmp_make_exception_arg_2 = const_str_digest_c623dd0c947983ab2cfcbe4c53400720;
            frame_8569be16f63185d6aef0adf92c520ee5->m_frame.f_lineno = 163;
            tmp_raise_type_2 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_2);
            assert(!(tmp_raise_type_2 == NULL));
            exception_type = tmp_raise_type_2;
            exception_lineno = 163;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8569be16f63185d6aef0adf92c520ee5);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8569be16f63185d6aef0adf92c520ee5);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_8569be16f63185d6aef0adf92c520ee5, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_8569be16f63185d6aef0adf92c520ee5->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_8569be16f63185d6aef0adf92c520ee5, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8569be16f63185d6aef0adf92c520ee5,
        type_description_1,
        par_boundary,
        par_when,
        var_set_result
    );


    // Release cached frame.
    if (frame_8569be16f63185d6aef0adf92c520ee5 == cache_frame_8569be16f63185d6aef0adf92c520ee5) {
        Py_DECREF(frame_8569be16f63185d6aef0adf92c520ee5);
    }
    cache_frame_8569be16f63185d6aef0adf92c520ee5 = NULL;

    assertFrameObject(frame_8569be16f63185d6aef0adf92c520ee5);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_5__set_asn1_time);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_set_result);
    Py_DECREF(var_set_result);
    var_set_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_set_result);
    var_set_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_5__set_asn1_time);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_boundary);
    Py_DECREF(par_boundary);
    CHECK_OBJECT(par_when);
    Py_DECREF(par_when);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_boundary);
    Py_DECREF(par_boundary);
    CHECK_OBJECT(par_when);
    Py_DECREF(par_when);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_6__get_asn1_time(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_timestamp = python_pars[0];
    PyObject *var_generalized_timestamp = NULL;
    PyObject *var_string_result = NULL;
    PyObject *var_string_data = NULL;
    PyObject *var_string_timestamp = NULL;
    struct Nuitka_FrameObject *frame_246be403ac420ea7d6be029dab25a09c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_246be403ac420ea7d6be029dab25a09c = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_246be403ac420ea7d6be029dab25a09c, codeobj_246be403ac420ea7d6be029dab25a09c, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_246be403ac420ea7d6be029dab25a09c = cache_frame_246be403ac420ea7d6be029dab25a09c;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_246be403ac420ea7d6be029dab25a09c);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_246be403ac420ea7d6be029dab25a09c) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 176;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        tmp_args_element_name_1 = const_str_digest_dc9f0c0121231dfd2bb64dc64aae6cc9;
        CHECK_OBJECT(par_timestamp);
        tmp_args_element_name_2 = par_timestamp;
        frame_246be403ac420ea7d6be029dab25a09c->m_frame.f_lineno = 176;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain_cast, call_args);
        }

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 176;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(var_string_timestamp == NULL);
        var_string_timestamp = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 177;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_2;
        CHECK_OBJECT(var_string_timestamp);
        tmp_args_element_name_3 = var_string_timestamp;
        frame_246be403ac420ea7d6be029dab25a09c->m_frame.f_lineno = 177;
        {
            PyObject *call_args[] = {tmp_args_element_name_3};
            tmp_compexpr_left_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_ASN1_STRING_length, call_args);
        }

        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 177;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = const_int_0;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_INT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 177;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_None;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        goto branch_end_1;
        branch_no_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_called_instance_3;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_source_name_1;
            PyObject *tmp_mvar_value_4;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_3 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 180;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_3 = tmp_mvar_value_3;
            CHECK_OBJECT(var_string_timestamp);
            tmp_args_element_name_4 = var_string_timestamp;
            frame_246be403ac420ea7d6be029dab25a09c->m_frame.f_lineno = 180;
            {
                PyObject *call_args[] = {tmp_args_element_name_4};
                tmp_compexpr_left_2 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_3, const_str_plain_ASN1_STRING_type, call_args);
            }

            if (tmp_compexpr_left_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 180;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_4 == NULL) {
                Py_DECREF(tmp_compexpr_left_2);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 180;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_1 = tmp_mvar_value_4;
            tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_V_ASN1_GENERALIZEDTIME);
            if (tmp_compexpr_right_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_compexpr_left_2);

                exception_lineno = 180;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
            Py_DECREF(tmp_compexpr_left_2);
            Py_DECREF(tmp_compexpr_right_2);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 180;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
                goto branch_yes_2;
            } else {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_called_name_1;
                PyObject *tmp_source_name_2;
                PyObject *tmp_mvar_value_5;
                PyObject *tmp_args_element_name_5;
                PyObject *tmp_called_instance_4;
                PyObject *tmp_mvar_value_6;
                PyObject *tmp_args_element_name_6;
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

                if (unlikely(tmp_mvar_value_5 == NULL)) {
                    tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
                }

                if (tmp_mvar_value_5 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 182;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_2 = tmp_mvar_value_5;
                tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_string);
                if (tmp_called_name_1 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 182;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

                if (unlikely(tmp_mvar_value_6 == NULL)) {
                    tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
                }

                if (tmp_mvar_value_6 == NULL) {
                    Py_DECREF(tmp_called_name_1);
                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 182;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_instance_4 = tmp_mvar_value_6;
                CHECK_OBJECT(var_string_timestamp);
                tmp_args_element_name_6 = var_string_timestamp;
                frame_246be403ac420ea7d6be029dab25a09c->m_frame.f_lineno = 182;
                {
                    PyObject *call_args[] = {tmp_args_element_name_6};
                    tmp_args_element_name_5 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_4, const_str_plain_ASN1_STRING_data, call_args);
                }

                if (tmp_args_element_name_5 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    Py_DECREF(tmp_called_name_1);

                    exception_lineno = 182;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                frame_246be403ac420ea7d6be029dab25a09c->m_frame.f_lineno = 182;
                tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_5);
                Py_DECREF(tmp_called_name_1);
                Py_DECREF(tmp_args_element_name_5);
                if (tmp_return_value == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 182;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                goto frame_return_exit_1;
            }
            goto branch_end_2;
            branch_no_2:;
            {
                PyObject *tmp_assign_source_2;
                PyObject *tmp_called_instance_5;
                PyObject *tmp_mvar_value_7;
                tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

                if (unlikely(tmp_mvar_value_7 == NULL)) {
                    tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
                }

                if (tmp_mvar_value_7 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 184;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_instance_5 = tmp_mvar_value_7;
                frame_246be403ac420ea7d6be029dab25a09c->m_frame.f_lineno = 184;
                tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_5, const_str_plain_new, &PyTuple_GET_ITEM(const_tuple_str_digest_0d925750cb36e0c0e5f47f40c47790e6_tuple, 0));

                if (tmp_assign_source_2 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 184;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                assert(var_generalized_timestamp == NULL);
                var_generalized_timestamp = tmp_assign_source_2;
            }
            {
                PyObject *tmp_called_instance_6;
                PyObject *tmp_mvar_value_8;
                PyObject *tmp_call_result_1;
                PyObject *tmp_args_element_name_7;
                PyObject *tmp_args_element_name_8;
                tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

                if (unlikely(tmp_mvar_value_8 == NULL)) {
                    tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
                }

                if (tmp_mvar_value_8 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 185;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_instance_6 = tmp_mvar_value_8;
                CHECK_OBJECT(par_timestamp);
                tmp_args_element_name_7 = par_timestamp;
                CHECK_OBJECT(var_generalized_timestamp);
                tmp_args_element_name_8 = var_generalized_timestamp;
                frame_246be403ac420ea7d6be029dab25a09c->m_frame.f_lineno = 185;
                {
                    PyObject *call_args[] = {tmp_args_element_name_7, tmp_args_element_name_8};
                    tmp_call_result_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_6, const_str_plain_ASN1_TIME_to_generalizedtime, call_args);
                }

                if (tmp_call_result_1 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 185;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                Py_DECREF(tmp_call_result_1);
            }
            {
                nuitka_bool tmp_condition_result_3;
                PyObject *tmp_compexpr_left_3;
                PyObject *tmp_compexpr_right_3;
                PyObject *tmp_subscribed_name_1;
                PyObject *tmp_subscript_name_1;
                PyObject *tmp_source_name_3;
                PyObject *tmp_mvar_value_9;
                CHECK_OBJECT(var_generalized_timestamp);
                tmp_subscribed_name_1 = var_generalized_timestamp;
                tmp_subscript_name_1 = const_int_0;
                tmp_compexpr_left_3 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_1, tmp_subscript_name_1, 0);
                if (tmp_compexpr_left_3 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 186;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                tmp_mvar_value_9 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

                if (unlikely(tmp_mvar_value_9 == NULL)) {
                    tmp_mvar_value_9 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
                }

                if (tmp_mvar_value_9 == NULL) {
                    Py_DECREF(tmp_compexpr_left_3);
                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 186;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_3 = tmp_mvar_value_9;
                tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_NULL);
                if (tmp_compexpr_right_3 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    Py_DECREF(tmp_compexpr_left_3);

                    exception_lineno = 186;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_3, tmp_compexpr_right_3);
                Py_DECREF(tmp_compexpr_left_3);
                Py_DECREF(tmp_compexpr_right_3);
                if (tmp_res == -1) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 186;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                tmp_condition_result_3 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
                    goto branch_yes_3;
                } else {
                    goto branch_no_3;
                }
                branch_yes_3:;
                {
                    PyObject *tmp_called_name_2;
                    PyObject *tmp_mvar_value_10;
                    PyObject *tmp_call_result_2;
                    tmp_mvar_value_10 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__untested_error);

                    if (unlikely(tmp_mvar_value_10 == NULL)) {
                        tmp_mvar_value_10 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__untested_error);
                    }

                    if (tmp_mvar_value_10 == NULL) {

                        exception_type = PyExc_NameError;
                        Py_INCREF(exception_type);
                        exception_value = UNSTREAM_STRING(&constant_bin[ 3197 ], 44, 0);
                        exception_tb = NULL;

                        exception_lineno = 196;
                        type_description_1 = "ooooo";
                        goto frame_exception_exit_1;
                    }

                    tmp_called_name_2 = tmp_mvar_value_10;
                    frame_246be403ac420ea7d6be029dab25a09c->m_frame.f_lineno = 196;
                    tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS1(tmp_called_name_2, &PyTuple_GET_ITEM(const_tuple_str_plain_ASN1_TIME_to_generalizedtime_tuple, 0));

                    if (tmp_call_result_2 == NULL) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                        exception_lineno = 196;
                        type_description_1 = "ooooo";
                        goto frame_exception_exit_1;
                    }
                    Py_DECREF(tmp_call_result_2);
                }
                goto branch_end_3;
                branch_no_3:;
                {
                    PyObject *tmp_assign_source_3;
                    PyObject *tmp_called_name_3;
                    PyObject *tmp_source_name_4;
                    PyObject *tmp_mvar_value_11;
                    PyObject *tmp_args_element_name_9;
                    PyObject *tmp_args_element_name_10;
                    PyObject *tmp_subscribed_name_2;
                    PyObject *tmp_subscript_name_2;
                    tmp_mvar_value_11 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

                    if (unlikely(tmp_mvar_value_11 == NULL)) {
                        tmp_mvar_value_11 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
                    }

                    if (tmp_mvar_value_11 == NULL) {

                        exception_type = PyExc_NameError;
                        Py_INCREF(exception_type);
                        exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                        exception_tb = NULL;

                        exception_lineno = 198;
                        type_description_1 = "ooooo";
                        goto frame_exception_exit_1;
                    }

                    tmp_source_name_4 = tmp_mvar_value_11;
                    tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_cast);
                    if (tmp_called_name_3 == NULL) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                        exception_lineno = 198;
                        type_description_1 = "ooooo";
                        goto frame_exception_exit_1;
                    }
                    tmp_args_element_name_9 = const_str_digest_dc9f0c0121231dfd2bb64dc64aae6cc9;
                    CHECK_OBJECT(var_generalized_timestamp);
                    tmp_subscribed_name_2 = var_generalized_timestamp;
                    tmp_subscript_name_2 = const_int_0;
                    tmp_args_element_name_10 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_2, tmp_subscript_name_2, 0);
                    if (tmp_args_element_name_10 == NULL) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                        Py_DECREF(tmp_called_name_3);

                        exception_lineno = 199;
                        type_description_1 = "ooooo";
                        goto frame_exception_exit_1;
                    }
                    frame_246be403ac420ea7d6be029dab25a09c->m_frame.f_lineno = 198;
                    {
                        PyObject *call_args[] = {tmp_args_element_name_9, tmp_args_element_name_10};
                        tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_3, call_args);
                    }

                    Py_DECREF(tmp_called_name_3);
                    Py_DECREF(tmp_args_element_name_10);
                    if (tmp_assign_source_3 == NULL) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                        exception_lineno = 198;
                        type_description_1 = "ooooo";
                        goto frame_exception_exit_1;
                    }
                    {
                        PyObject *old = var_string_timestamp;
                        assert(old != NULL);
                        var_string_timestamp = tmp_assign_source_3;
                        Py_DECREF(old);
                    }

                }
                {
                    PyObject *tmp_assign_source_4;
                    PyObject *tmp_called_instance_7;
                    PyObject *tmp_mvar_value_12;
                    PyObject *tmp_args_element_name_11;
                    tmp_mvar_value_12 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

                    if (unlikely(tmp_mvar_value_12 == NULL)) {
                        tmp_mvar_value_12 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
                    }

                    if (tmp_mvar_value_12 == NULL) {

                        exception_type = PyExc_NameError;
                        Py_INCREF(exception_type);
                        exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                        exception_tb = NULL;

                        exception_lineno = 200;
                        type_description_1 = "ooooo";
                        goto frame_exception_exit_1;
                    }

                    tmp_called_instance_7 = tmp_mvar_value_12;
                    CHECK_OBJECT(var_string_timestamp);
                    tmp_args_element_name_11 = var_string_timestamp;
                    frame_246be403ac420ea7d6be029dab25a09c->m_frame.f_lineno = 200;
                    {
                        PyObject *call_args[] = {tmp_args_element_name_11};
                        tmp_assign_source_4 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_7, const_str_plain_ASN1_STRING_data, call_args);
                    }

                    if (tmp_assign_source_4 == NULL) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                        exception_lineno = 200;
                        type_description_1 = "ooooo";
                        goto frame_exception_exit_1;
                    }
                    assert(var_string_data == NULL);
                    var_string_data = tmp_assign_source_4;
                }
                {
                    PyObject *tmp_assign_source_5;
                    PyObject *tmp_called_instance_8;
                    PyObject *tmp_mvar_value_13;
                    PyObject *tmp_args_element_name_12;
                    tmp_mvar_value_13 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

                    if (unlikely(tmp_mvar_value_13 == NULL)) {
                        tmp_mvar_value_13 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
                    }

                    if (tmp_mvar_value_13 == NULL) {

                        exception_type = PyExc_NameError;
                        Py_INCREF(exception_type);
                        exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                        exception_tb = NULL;

                        exception_lineno = 201;
                        type_description_1 = "ooooo";
                        goto frame_exception_exit_1;
                    }

                    tmp_called_instance_8 = tmp_mvar_value_13;
                    CHECK_OBJECT(var_string_data);
                    tmp_args_element_name_12 = var_string_data;
                    frame_246be403ac420ea7d6be029dab25a09c->m_frame.f_lineno = 201;
                    {
                        PyObject *call_args[] = {tmp_args_element_name_12};
                        tmp_assign_source_5 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_8, const_str_plain_string, call_args);
                    }

                    if (tmp_assign_source_5 == NULL) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                        exception_lineno = 201;
                        type_description_1 = "ooooo";
                        goto frame_exception_exit_1;
                    }
                    assert(var_string_result == NULL);
                    var_string_result = tmp_assign_source_5;
                }
                {
                    PyObject *tmp_called_name_4;
                    PyObject *tmp_source_name_5;
                    PyObject *tmp_mvar_value_14;
                    PyObject *tmp_call_result_3;
                    PyObject *tmp_args_element_name_13;
                    PyObject *tmp_subscribed_name_3;
                    PyObject *tmp_subscript_name_3;
                    tmp_mvar_value_14 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

                    if (unlikely(tmp_mvar_value_14 == NULL)) {
                        tmp_mvar_value_14 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
                    }

                    if (tmp_mvar_value_14 == NULL) {

                        exception_type = PyExc_NameError;
                        Py_INCREF(exception_type);
                        exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                        exception_tb = NULL;

                        exception_lineno = 202;
                        type_description_1 = "ooooo";
                        goto frame_exception_exit_1;
                    }

                    tmp_source_name_5 = tmp_mvar_value_14;
                    tmp_called_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_ASN1_GENERALIZEDTIME_free);
                    if (tmp_called_name_4 == NULL) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                        exception_lineno = 202;
                        type_description_1 = "ooooo";
                        goto frame_exception_exit_1;
                    }
                    CHECK_OBJECT(var_generalized_timestamp);
                    tmp_subscribed_name_3 = var_generalized_timestamp;
                    tmp_subscript_name_3 = const_int_0;
                    tmp_args_element_name_13 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_3, tmp_subscript_name_3, 0);
                    if (tmp_args_element_name_13 == NULL) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                        Py_DECREF(tmp_called_name_4);

                        exception_lineno = 202;
                        type_description_1 = "ooooo";
                        goto frame_exception_exit_1;
                    }
                    frame_246be403ac420ea7d6be029dab25a09c->m_frame.f_lineno = 202;
                    tmp_call_result_3 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_4, tmp_args_element_name_13);
                    Py_DECREF(tmp_called_name_4);
                    Py_DECREF(tmp_args_element_name_13);
                    if (tmp_call_result_3 == NULL) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                        exception_lineno = 202;
                        type_description_1 = "ooooo";
                        goto frame_exception_exit_1;
                    }
                    Py_DECREF(tmp_call_result_3);
                }
                CHECK_OBJECT(var_string_result);
                tmp_return_value = var_string_result;
                Py_INCREF(tmp_return_value);
                goto frame_return_exit_1;
                branch_end_3:;
            }
            branch_end_2:;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_246be403ac420ea7d6be029dab25a09c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_246be403ac420ea7d6be029dab25a09c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_246be403ac420ea7d6be029dab25a09c);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_246be403ac420ea7d6be029dab25a09c, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_246be403ac420ea7d6be029dab25a09c->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_246be403ac420ea7d6be029dab25a09c, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_246be403ac420ea7d6be029dab25a09c,
        type_description_1,
        par_timestamp,
        var_generalized_timestamp,
        var_string_result,
        var_string_data,
        var_string_timestamp
    );


    // Release cached frame.
    if (frame_246be403ac420ea7d6be029dab25a09c == cache_frame_246be403ac420ea7d6be029dab25a09c) {
        Py_DECREF(frame_246be403ac420ea7d6be029dab25a09c);
    }
    cache_frame_246be403ac420ea7d6be029dab25a09c = NULL;

    assertFrameObject(frame_246be403ac420ea7d6be029dab25a09c);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_6__get_asn1_time);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_generalized_timestamp);
    var_generalized_timestamp = NULL;

    Py_XDECREF(var_string_result);
    var_string_result = NULL;

    Py_XDECREF(var_string_data);
    var_string_data = NULL;

    CHECK_OBJECT((PyObject *)var_string_timestamp);
    Py_DECREF(var_string_timestamp);
    var_string_timestamp = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_generalized_timestamp);
    var_generalized_timestamp = NULL;

    Py_XDECREF(var_string_result);
    var_string_result = NULL;

    Py_XDECREF(var_string_data);
    var_string_data = NULL;

    Py_XDECREF(var_string_timestamp);
    var_string_timestamp = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_6__get_asn1_time);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_timestamp);
    Py_DECREF(par_timestamp);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_timestamp);
    Py_DECREF(par_timestamp);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_7___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_62546cfe1d011d24bbde27bbb93b6ea0;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_62546cfe1d011d24bbde27bbb93b6ea0 = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_62546cfe1d011d24bbde27bbb93b6ea0, codeobj_62546cfe1d011d24bbde27bbb93b6ea0, module_OpenSSL$crypto, sizeof(void *));
    frame_62546cfe1d011d24bbde27bbb93b6ea0 = cache_frame_62546cfe1d011d24bbde27bbb93b6ea0;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_62546cfe1d011d24bbde27bbb93b6ea0);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_62546cfe1d011d24bbde27bbb93b6ea0) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        tmp_assattr_name_1 = PyList_New(0);
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__names, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 208;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_62546cfe1d011d24bbde27bbb93b6ea0);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_62546cfe1d011d24bbde27bbb93b6ea0);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_62546cfe1d011d24bbde27bbb93b6ea0, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_62546cfe1d011d24bbde27bbb93b6ea0->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_62546cfe1d011d24bbde27bbb93b6ea0, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_62546cfe1d011d24bbde27bbb93b6ea0,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_62546cfe1d011d24bbde27bbb93b6ea0 == cache_frame_62546cfe1d011d24bbde27bbb93b6ea0) {
        Py_DECREF(frame_62546cfe1d011d24bbde27bbb93b6ea0);
    }
    cache_frame_62546cfe1d011d24bbde27bbb93b6ea0 = NULL;

    assertFrameObject(frame_62546cfe1d011d24bbde27bbb93b6ea0);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_7___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_8_add(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_name = python_pars[1];
    struct Nuitka_FrameObject *frame_913c87f9ab8d54a08d5eac957c322eee;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_913c87f9ab8d54a08d5eac957c322eee = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_913c87f9ab8d54a08d5eac957c322eee, codeobj_913c87f9ab8d54a08d5eac957c322eee, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *));
    frame_913c87f9ab8d54a08d5eac957c322eee = cache_frame_913c87f9ab8d54a08d5eac957c322eee;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_913c87f9ab8d54a08d5eac957c322eee);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_913c87f9ab8d54a08d5eac957c322eee) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__names);
        if (tmp_called_instance_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 211;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_name);
        tmp_args_element_name_1 = par_name;
        frame_913c87f9ab8d54a08d5eac957c322eee->m_frame.f_lineno = 211;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_append, call_args);
        }

        Py_DECREF(tmp_called_instance_1);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 211;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_913c87f9ab8d54a08d5eac957c322eee);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_913c87f9ab8d54a08d5eac957c322eee);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_913c87f9ab8d54a08d5eac957c322eee, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_913c87f9ab8d54a08d5eac957c322eee->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_913c87f9ab8d54a08d5eac957c322eee, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_913c87f9ab8d54a08d5eac957c322eee,
        type_description_1,
        par_self,
        par_name
    );


    // Release cached frame.
    if (frame_913c87f9ab8d54a08d5eac957c322eee == cache_frame_913c87f9ab8d54a08d5eac957c322eee) {
        Py_DECREF(frame_913c87f9ab8d54a08d5eac957c322eee);
    }
    cache_frame_913c87f9ab8d54a08d5eac957c322eee = NULL;

    assertFrameObject(frame_913c87f9ab8d54a08d5eac957c322eee);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_8_add);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_name);
    Py_DECREF(par_name);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_name);
    Py_DECREF(par_name);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_9_clear(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_name = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_826e459e0dc58f5a99e0a127a3e82d23;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_826e459e0dc58f5a99e0a127a3e82d23 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_826e459e0dc58f5a99e0a127a3e82d23, codeobj_826e459e0dc58f5a99e0a127a3e82d23, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *));
    frame_826e459e0dc58f5a99e0a127a3e82d23 = cache_frame_826e459e0dc58f5a99e0a127a3e82d23;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_826e459e0dc58f5a99e0a127a3e82d23);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_826e459e0dc58f5a99e0a127a3e82d23) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_iter_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__names);
        if (tmp_iter_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 214;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_1 = MAKE_ITERATOR(tmp_iter_arg_1);
        Py_DECREF(tmp_iter_arg_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 214;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert(tmp_for_loop_1__for_iterator == NULL);
        tmp_for_loop_1__for_iterator = tmp_assign_source_1;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT(tmp_for_loop_1__for_iterator);
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_2 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_2 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "oo";
                exception_lineno = 214;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_2;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_3;
        CHECK_OBJECT(tmp_for_loop_1__iter_value);
        tmp_assign_source_3 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_name;
            var_name = tmp_assign_source_3;
            Py_INCREF(var_name);
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_attrdel_target_1;
        CHECK_OBJECT(var_name);
        tmp_attrdel_target_1 = var_name;
        tmp_res = PyObject_DelAttr(tmp_attrdel_target_1, const_str_plain__name);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 216;
            type_description_1 = "oo";
            goto try_except_handler_2;
        }
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


        exception_lineno = 214;
        type_description_1 = "oo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_826e459e0dc58f5a99e0a127a3e82d23);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_826e459e0dc58f5a99e0a127a3e82d23);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_826e459e0dc58f5a99e0a127a3e82d23, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_826e459e0dc58f5a99e0a127a3e82d23->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_826e459e0dc58f5a99e0a127a3e82d23, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_826e459e0dc58f5a99e0a127a3e82d23,
        type_description_1,
        par_self,
        var_name
    );


    // Release cached frame.
    if (frame_826e459e0dc58f5a99e0a127a3e82d23 == cache_frame_826e459e0dc58f5a99e0a127a3e82d23) {
        Py_DECREF(frame_826e459e0dc58f5a99e0a127a3e82d23);
    }
    cache_frame_826e459e0dc58f5a99e0a127a3e82d23 = NULL;

    assertFrameObject(frame_826e459e0dc58f5a99e0a127a3e82d23);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_9_clear);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_name);
    var_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_name);
    var_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_9_clear);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_10___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_pkey = NULL;
    struct Nuitka_FrameObject *frame_e6be03b19f17c55a33c123c191305d01;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_e6be03b19f17c55a33c123c191305d01 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_e6be03b19f17c55a33c123c191305d01, codeobj_e6be03b19f17c55a33c123c191305d01, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *));
    frame_e6be03b19f17c55a33c123c191305d01 = cache_frame_e6be03b19f17c55a33c123c191305d01;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_e6be03b19f17c55a33c123c191305d01);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_e6be03b19f17c55a33c123c191305d01) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 227;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_e6be03b19f17c55a33c123c191305d01->m_frame.f_lineno = 227;
        tmp_assign_source_1 = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_EVP_PKEY_new);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 227;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert(var_pkey == NULL);
        var_pkey = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 228;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_gc);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 228;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_pkey);
        tmp_args_element_name_1 = var_pkey;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 228;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_EVP_PKEY_free);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 228;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_e6be03b19f17c55a33c123c191305d01->m_frame.f_lineno = 228;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 228;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__pkey, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 228;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        tmp_assattr_name_2 = Py_False;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain__initialized, tmp_assattr_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 229;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e6be03b19f17c55a33c123c191305d01);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e6be03b19f17c55a33c123c191305d01);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_e6be03b19f17c55a33c123c191305d01, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_e6be03b19f17c55a33c123c191305d01->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_e6be03b19f17c55a33c123c191305d01, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e6be03b19f17c55a33c123c191305d01,
        type_description_1,
        par_self,
        var_pkey
    );


    // Release cached frame.
    if (frame_e6be03b19f17c55a33c123c191305d01 == cache_frame_e6be03b19f17c55a33c123c191305d01) {
        Py_DECREF(frame_e6be03b19f17c55a33c123c191305d01);
    }
    cache_frame_e6be03b19f17c55a33c123c191305d01 = NULL;

    assertFrameObject(frame_e6be03b19f17c55a33c123c191305d01);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_10___init__);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_pkey);
    Py_DECREF(var_pkey);
    var_pkey = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_pkey);
    var_pkey = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_10___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_11_to_cryptography_key(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_backend = NULL;
    struct Nuitka_FrameObject *frame_17fae881cac6fcbcb689c6d8ff5eee21;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_17fae881cac6fcbcb689c6d8ff5eee21 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_17fae881cac6fcbcb689c6d8ff5eee21, codeobj_17fae881cac6fcbcb689c6d8ff5eee21, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *));
    frame_17fae881cac6fcbcb689c6d8ff5eee21 = cache_frame_17fae881cac6fcbcb689c6d8ff5eee21;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_17fae881cac6fcbcb689c6d8ff5eee21);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_17fae881cac6fcbcb689c6d8ff5eee21) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__get_backend);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__get_backend);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3241 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 242;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        frame_17fae881cac6fcbcb689c6d8ff5eee21->m_frame.f_lineno = 242;
        tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS(tmp_called_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 242;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert(var_backend == NULL);
        var_backend = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_attribute_value_1;
        int tmp_truth_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_attribute_value_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__only_public);
        if (tmp_attribute_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 243;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE(tmp_attribute_value_1);
        if (tmp_truth_name_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_attribute_value_1);

            exception_lineno = 243;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_attribute_value_1);
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_2;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_source_name_3;
            CHECK_OBJECT(var_backend);
            tmp_source_name_2 = var_backend;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__evp_pkey_to_public_key);
            if (tmp_called_name_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 244;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(par_self);
            tmp_source_name_3 = par_self;
            tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__pkey);
            if (tmp_args_element_name_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_2);

                exception_lineno = 244;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            frame_17fae881cac6fcbcb689c6d8ff5eee21->m_frame.f_lineno = 244;
            tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_1);
            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_1);
            if (tmp_return_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 244;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_called_name_3;
            PyObject *tmp_source_name_4;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_source_name_5;
            CHECK_OBJECT(var_backend);
            tmp_source_name_4 = var_backend;
            tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain__evp_pkey_to_private_key);
            if (tmp_called_name_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 246;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(par_self);
            tmp_source_name_5 = par_self;
            tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain__pkey);
            if (tmp_args_element_name_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_3);

                exception_lineno = 246;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            frame_17fae881cac6fcbcb689c6d8ff5eee21->m_frame.f_lineno = 246;
            tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_3, tmp_args_element_name_2);
            Py_DECREF(tmp_called_name_3);
            Py_DECREF(tmp_args_element_name_2);
            if (tmp_return_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 246;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_17fae881cac6fcbcb689c6d8ff5eee21);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_17fae881cac6fcbcb689c6d8ff5eee21);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_17fae881cac6fcbcb689c6d8ff5eee21);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_17fae881cac6fcbcb689c6d8ff5eee21, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_17fae881cac6fcbcb689c6d8ff5eee21->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_17fae881cac6fcbcb689c6d8ff5eee21, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_17fae881cac6fcbcb689c6d8ff5eee21,
        type_description_1,
        par_self,
        var_backend
    );


    // Release cached frame.
    if (frame_17fae881cac6fcbcb689c6d8ff5eee21 == cache_frame_17fae881cac6fcbcb689c6d8ff5eee21) {
        Py_DECREF(frame_17fae881cac6fcbcb689c6d8ff5eee21);
    }
    cache_frame_17fae881cac6fcbcb689c6d8ff5eee21 = NULL;

    assertFrameObject(frame_17fae881cac6fcbcb689c6d8ff5eee21);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_11_to_cryptography_key);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_backend);
    Py_DECREF(var_backend);
    var_backend = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_backend);
    var_backend = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_11_to_cryptography_key);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_12_from_cryptography_key(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_crypto_key = python_pars[1];
    PyObject *var_pkey = NULL;
    struct Nuitka_FrameObject *frame_40b3430de5e3101d094061fa2d5cec01;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_40b3430de5e3101d094061fa2d5cec01 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_40b3430de5e3101d094061fa2d5cec01, codeobj_40b3430de5e3101d094061fa2d5cec01, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_40b3430de5e3101d094061fa2d5cec01 = cache_frame_40b3430de5e3101d094061fa2d5cec01;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_40b3430de5e3101d094061fa2d5cec01);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_40b3430de5e3101d094061fa2d5cec01) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        CHECK_OBJECT(par_cls);
        tmp_called_name_1 = par_cls;
        frame_40b3430de5e3101d094061fa2d5cec01->m_frame.f_lineno = 260;
        tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS(tmp_called_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 260;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_pkey == NULL);
        var_pkey = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_4;
        CHECK_OBJECT(par_crypto_key);
        tmp_isinstance_inst_1 = par_crypto_key;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_rsa);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_rsa);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3282 ], 32, 0);
            exception_tb = NULL;

            exception_lineno = 261;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_RSAPublicKey);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 261;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_isinstance_cls_1 = PyTuple_New(4);
        PyTuple_SET_ITEM(tmp_isinstance_cls_1, 0, tmp_tuple_element_1);
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_rsa);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_rsa);
        }

        if (tmp_mvar_value_2 == NULL) {
            Py_DECREF(tmp_isinstance_cls_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3282 ], 32, 0);
            exception_tb = NULL;

            exception_lineno = 261;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_RSAPrivateKey);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_isinstance_cls_1);

            exception_lineno = 261;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM(tmp_isinstance_cls_1, 1, tmp_tuple_element_1);
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_dsa);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_dsa);
        }

        if (tmp_mvar_value_3 == NULL) {
            Py_DECREF(tmp_isinstance_cls_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3314 ], 32, 0);
            exception_tb = NULL;

            exception_lineno = 262;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_3;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_DSAPublicKey);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_isinstance_cls_1);

            exception_lineno = 262;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM(tmp_isinstance_cls_1, 2, tmp_tuple_element_1);
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_dsa);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_dsa);
        }

        if (tmp_mvar_value_4 == NULL) {
            Py_DECREF(tmp_isinstance_cls_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3314 ], 32, 0);
            exception_tb = NULL;

            exception_lineno = 262;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_4;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_DSAPrivateKey);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_isinstance_cls_1);

            exception_lineno = 262;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM(tmp_isinstance_cls_1, 3, tmp_tuple_element_1);
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        Py_DECREF(tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 261;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 261;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_290681512f72ca11cbf3e4827987aabb;
            frame_40b3430de5e3101d094061fa2d5cec01->m_frame.f_lineno = 263;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 263;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_source_name_5;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_crypto_key);
        tmp_source_name_5 = par_crypto_key;
        tmp_assattr_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain__evp_pkey);
        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 265;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_pkey);
        tmp_assattr_target_1 = var_pkey;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__pkey, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 265;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_isinstance_inst_2;
        PyObject *tmp_isinstance_cls_2;
        PyObject *tmp_tuple_element_2;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_6;
        CHECK_OBJECT(par_crypto_key);
        tmp_isinstance_inst_2 = par_crypto_key;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_rsa);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_rsa);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3282 ], 32, 0);
            exception_tb = NULL;

            exception_lineno = 266;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_5;
        tmp_tuple_element_2 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_RSAPublicKey);
        if (tmp_tuple_element_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 266;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_isinstance_cls_2 = PyTuple_New(2);
        PyTuple_SET_ITEM(tmp_isinstance_cls_2, 0, tmp_tuple_element_2);
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_dsa);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_dsa);
        }

        if (tmp_mvar_value_6 == NULL) {
            Py_DECREF(tmp_isinstance_cls_2);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3314 ], 32, 0);
            exception_tb = NULL;

            exception_lineno = 266;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = tmp_mvar_value_6;
        tmp_tuple_element_2 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain_DSAPublicKey);
        if (tmp_tuple_element_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_isinstance_cls_2);

            exception_lineno = 266;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM(tmp_isinstance_cls_2, 1, tmp_tuple_element_2);
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_2, tmp_isinstance_cls_2);
        Py_DECREF(tmp_isinstance_cls_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 266;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assattr_name_2;
            PyObject *tmp_assattr_target_2;
            tmp_assattr_name_2 = Py_True;
            CHECK_OBJECT(var_pkey);
            tmp_assattr_target_2 = var_pkey;
            tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain__only_public, tmp_assattr_name_2);
            if (tmp_result == false) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 267;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
        }
        branch_no_2:;
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_assattr_target_3;
        tmp_assattr_name_3 = Py_True;
        CHECK_OBJECT(var_pkey);
        tmp_assattr_target_3 = var_pkey;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_3, const_str_plain__initialized, tmp_assattr_name_3);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 268;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_40b3430de5e3101d094061fa2d5cec01);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_40b3430de5e3101d094061fa2d5cec01);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_40b3430de5e3101d094061fa2d5cec01, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_40b3430de5e3101d094061fa2d5cec01->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_40b3430de5e3101d094061fa2d5cec01, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_40b3430de5e3101d094061fa2d5cec01,
        type_description_1,
        par_cls,
        par_crypto_key,
        var_pkey
    );


    // Release cached frame.
    if (frame_40b3430de5e3101d094061fa2d5cec01 == cache_frame_40b3430de5e3101d094061fa2d5cec01) {
        Py_DECREF(frame_40b3430de5e3101d094061fa2d5cec01);
    }
    cache_frame_40b3430de5e3101d094061fa2d5cec01 = NULL;

    assertFrameObject(frame_40b3430de5e3101d094061fa2d5cec01);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT(var_pkey);
    tmp_return_value = var_pkey;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_12_from_cryptography_key);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_pkey);
    Py_DECREF(var_pkey);
    var_pkey = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_pkey);
    var_pkey = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_12_from_cryptography_key);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_crypto_key);
    Py_DECREF(par_crypto_key);
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_crypto_key);
    Py_DECREF(par_crypto_key);
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_13_generate_key(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_type = python_pars[1];
    PyObject *par_bits = python_pars[2];
    PyObject *var_exponent = NULL;
    PyObject *var_rsa = NULL;
    PyObject *var_result = NULL;
    PyObject *var_res = NULL;
    PyObject *var_dsa = NULL;
    struct Nuitka_FrameObject *frame_b718d7c7e21f2f8cf1e62e44bd27b1df;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_b718d7c7e21f2f8cf1e62e44bd27b1df = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_b718d7c7e21f2f8cf1e62e44bd27b1df, codeobj_b718d7c7e21f2f8cf1e62e44bd27b1df, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_b718d7c7e21f2f8cf1e62e44bd27b1df = cache_frame_b718d7c7e21f2f8cf1e62e44bd27b1df;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_b718d7c7e21f2f8cf1e62e44bd27b1df);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_b718d7c7e21f2f8cf1e62e44bd27b1df) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        CHECK_OBJECT(par_type);
        tmp_isinstance_inst_1 = par_type;
        tmp_isinstance_cls_1 = (PyObject *)&PyInt_Type;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 287;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 287;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_50f07d7dbc7dc060eb5685744b92c007;
            frame_b718d7c7e21f2f8cf1e62e44bd27b1df->m_frame.f_lineno = 288;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 288;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_2;
        PyObject *tmp_isinstance_inst_2;
        PyObject *tmp_isinstance_cls_2;
        CHECK_OBJECT(par_bits);
        tmp_isinstance_inst_2 = par_bits;
        tmp_isinstance_cls_2 = (PyObject *)&PyInt_Type;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_2, tmp_isinstance_cls_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 290;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_2 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 290;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            tmp_make_exception_arg_2 = const_str_digest_3910fdd1c3b683a0988d08f77454ce47;
            frame_b718d7c7e21f2f8cf1e62e44bd27b1df->m_frame.f_lineno = 291;
            tmp_raise_type_2 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_2);
            assert(!(tmp_raise_type_2 == NULL));
            exception_type = tmp_raise_type_2;
            exception_lineno = 291;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_type);
        tmp_compexpr_left_1 = par_type;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_TYPE_RSA);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_TYPE_RSA);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3346 ], 37, 0);
            exception_tb = NULL;

            exception_lineno = 293;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 293;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
            goto branch_yes_3;
        } else {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            nuitka_bool tmp_condition_result_4;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            CHECK_OBJECT(par_bits);
            tmp_compexpr_left_2 = par_bits;
            tmp_compexpr_right_2 = const_int_0;
            tmp_res = RICH_COMPARE_BOOL_LTE_OBJECT_INT(tmp_compexpr_left_2, tmp_compexpr_right_2);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 294;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_4 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_4 == NUITKA_BOOL_TRUE) {
                goto branch_yes_4;
            } else {
                goto branch_no_4;
            }
            branch_yes_4:;
            {
                PyObject *tmp_raise_type_3;
                PyObject *tmp_make_exception_arg_3;
                tmp_make_exception_arg_3 = const_str_digest_4fd5a0c1d1fb7366c52acc7b3ac0b5b1;
                frame_b718d7c7e21f2f8cf1e62e44bd27b1df->m_frame.f_lineno = 295;
                tmp_raise_type_3 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_3);
                assert(!(tmp_raise_type_3 == NULL));
                exception_type = tmp_raise_type_3;
                exception_lineno = 295;
                RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            branch_no_4:;
        }
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_mvar_value_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 298;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_1 = tmp_mvar_value_2;
            frame_b718d7c7e21f2f8cf1e62e44bd27b1df->m_frame.f_lineno = 298;
            tmp_assign_source_1 = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_BN_new);
            if (tmp_assign_source_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 298;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            assert(var_exponent == NULL);
            var_exponent = tmp_assign_source_1;
        }
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_called_name_1;
            PyObject *tmp_source_name_1;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_source_name_2;
            PyObject *tmp_mvar_value_4;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_3 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 299;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_1 = tmp_mvar_value_3;
            tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_gc);
            if (tmp_called_name_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 299;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_exponent);
            tmp_args_element_name_1 = var_exponent;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_4 == NULL) {
                Py_DECREF(tmp_called_name_1);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 299;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_2 = tmp_mvar_value_4;
            tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_BN_free);
            if (tmp_args_element_name_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_1);

                exception_lineno = 299;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            frame_b718d7c7e21f2f8cf1e62e44bd27b1df->m_frame.f_lineno = 299;
            {
                PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
                tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
            }

            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_element_name_2);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 299;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = var_exponent;
                assert(old != NULL);
                var_exponent = tmp_assign_source_2;
                Py_DECREF(old);
            }

        }
        {
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_3;
            PyObject *tmp_mvar_value_5;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_source_name_4;
            PyObject *tmp_mvar_value_6;
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_5 == NULL)) {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_5 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 300;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_3 = tmp_mvar_value_5;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_BN_set_word);
            if (tmp_called_name_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 300;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_exponent);
            tmp_args_element_name_3 = var_exponent;
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_6 == NULL)) {
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_6 == NULL) {
                Py_DECREF(tmp_called_name_2);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 300;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_4 = tmp_mvar_value_6;
            tmp_args_element_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_RSA_F4);
            if (tmp_args_element_name_4 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_2);

                exception_lineno = 300;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            frame_b718d7c7e21f2f8cf1e62e44bd27b1df->m_frame.f_lineno = 300;
            {
                PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4};
                tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
            }

            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_4);
            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 300;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_1);
        }
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_called_instance_2;
            PyObject *tmp_mvar_value_7;
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_7 == NULL)) {
                tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_7 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 302;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_2 = tmp_mvar_value_7;
            frame_b718d7c7e21f2f8cf1e62e44bd27b1df->m_frame.f_lineno = 302;
            tmp_assign_source_3 = CALL_METHOD_NO_ARGS(tmp_called_instance_2, const_str_plain_RSA_new);
            if (tmp_assign_source_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 302;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            assert(var_rsa == NULL);
            var_rsa = tmp_assign_source_3;
        }
        {
            PyObject *tmp_assign_source_4;
            PyObject *tmp_called_name_3;
            PyObject *tmp_source_name_5;
            PyObject *tmp_mvar_value_8;
            PyObject *tmp_args_element_name_5;
            PyObject *tmp_args_element_name_6;
            PyObject *tmp_args_element_name_7;
            PyObject *tmp_args_element_name_8;
            PyObject *tmp_source_name_6;
            PyObject *tmp_mvar_value_9;
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_8 == NULL)) {
                tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_8 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 304;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_5 = tmp_mvar_value_8;
            tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_RSA_generate_key_ex);
            if (tmp_called_name_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 304;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_rsa);
            tmp_args_element_name_5 = var_rsa;
            CHECK_OBJECT(par_bits);
            tmp_args_element_name_6 = par_bits;
            CHECK_OBJECT(var_exponent);
            tmp_args_element_name_7 = var_exponent;
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_9 == NULL)) {
                tmp_mvar_value_9 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_9 == NULL) {
                Py_DECREF(tmp_called_name_3);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 304;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_6 = tmp_mvar_value_9;
            tmp_args_element_name_8 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_NULL);
            if (tmp_args_element_name_8 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_3);

                exception_lineno = 304;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            frame_b718d7c7e21f2f8cf1e62e44bd27b1df->m_frame.f_lineno = 304;
            {
                PyObject *call_args[] = {tmp_args_element_name_5, tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8};
                tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS4(tmp_called_name_3, call_args);
            }

            Py_DECREF(tmp_called_name_3);
            Py_DECREF(tmp_args_element_name_8);
            if (tmp_assign_source_4 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 304;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            assert(var_result == NULL);
            var_result = tmp_assign_source_4;
        }
        {
            PyObject *tmp_called_name_4;
            PyObject *tmp_mvar_value_10;
            PyObject *tmp_call_result_2;
            PyObject *tmp_args_element_name_9;
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

            if (unlikely(tmp_mvar_value_10 == NULL)) {
                tmp_mvar_value_10 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
            }

            if (tmp_mvar_value_10 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
                exception_tb = NULL;

                exception_lineno = 305;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_4 = tmp_mvar_value_10;
            CHECK_OBJECT(var_result);
            tmp_compexpr_left_3 = var_result;
            tmp_compexpr_right_3 = const_int_pos_1;
            tmp_args_element_name_9 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_3, tmp_compexpr_right_3);
            if (tmp_args_element_name_9 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 305;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            frame_b718d7c7e21f2f8cf1e62e44bd27b1df->m_frame.f_lineno = 305;
            tmp_call_result_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_4, tmp_args_element_name_9);
            Py_DECREF(tmp_args_element_name_9);
            if (tmp_call_result_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 305;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_2);
        }
        {
            PyObject *tmp_assign_source_5;
            PyObject *tmp_called_name_5;
            PyObject *tmp_source_name_7;
            PyObject *tmp_mvar_value_11;
            PyObject *tmp_args_element_name_10;
            PyObject *tmp_source_name_8;
            PyObject *tmp_args_element_name_11;
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_11 == NULL)) {
                tmp_mvar_value_11 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_11 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 307;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_7 = tmp_mvar_value_11;
            tmp_called_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain_EVP_PKEY_assign_RSA);
            if (tmp_called_name_5 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 307;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(par_self);
            tmp_source_name_8 = par_self;
            tmp_args_element_name_10 = LOOKUP_ATTRIBUTE(tmp_source_name_8, const_str_plain__pkey);
            if (tmp_args_element_name_10 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_5);

                exception_lineno = 307;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_rsa);
            tmp_args_element_name_11 = var_rsa;
            frame_b718d7c7e21f2f8cf1e62e44bd27b1df->m_frame.f_lineno = 307;
            {
                PyObject *call_args[] = {tmp_args_element_name_10, tmp_args_element_name_11};
                tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_5, call_args);
            }

            Py_DECREF(tmp_called_name_5);
            Py_DECREF(tmp_args_element_name_10);
            if (tmp_assign_source_5 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 307;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = var_result;
                assert(old != NULL);
                var_result = tmp_assign_source_5;
                Py_DECREF(old);
            }

        }
        {
            PyObject *tmp_called_name_6;
            PyObject *tmp_mvar_value_12;
            PyObject *tmp_call_result_3;
            PyObject *tmp_args_element_name_12;
            PyObject *tmp_compexpr_left_4;
            PyObject *tmp_compexpr_right_4;
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

            if (unlikely(tmp_mvar_value_12 == NULL)) {
                tmp_mvar_value_12 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
            }

            if (tmp_mvar_value_12 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
                exception_tb = NULL;

                exception_lineno = 308;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_6 = tmp_mvar_value_12;
            CHECK_OBJECT(var_result);
            tmp_compexpr_left_4 = var_result;
            tmp_compexpr_right_4 = const_int_pos_1;
            tmp_args_element_name_12 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_4, tmp_compexpr_right_4);
            if (tmp_args_element_name_12 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 308;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            frame_b718d7c7e21f2f8cf1e62e44bd27b1df->m_frame.f_lineno = 308;
            tmp_call_result_3 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_6, tmp_args_element_name_12);
            Py_DECREF(tmp_args_element_name_12);
            if (tmp_call_result_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 308;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_3);
        }
        goto branch_end_3;
        branch_no_3:;
        {
            nuitka_bool tmp_condition_result_5;
            PyObject *tmp_compexpr_left_5;
            PyObject *tmp_compexpr_right_5;
            PyObject *tmp_mvar_value_13;
            CHECK_OBJECT(par_type);
            tmp_compexpr_left_5 = par_type;
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_TYPE_DSA);

            if (unlikely(tmp_mvar_value_13 == NULL)) {
                tmp_mvar_value_13 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_TYPE_DSA);
            }

            if (tmp_mvar_value_13 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 3383 ], 37, 0);
                exception_tb = NULL;

                exception_lineno = 310;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_5 = tmp_mvar_value_13;
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_5, tmp_compexpr_right_5);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 310;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_5 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_5 == NUITKA_BOOL_TRUE) {
                goto branch_yes_5;
            } else {
                goto branch_no_5;
            }
            branch_yes_5:;
            {
                PyObject *tmp_assign_source_6;
                PyObject *tmp_called_instance_3;
                PyObject *tmp_mvar_value_14;
                tmp_mvar_value_14 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

                if (unlikely(tmp_mvar_value_14 == NULL)) {
                    tmp_mvar_value_14 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
                }

                if (tmp_mvar_value_14 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 311;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_instance_3 = tmp_mvar_value_14;
                frame_b718d7c7e21f2f8cf1e62e44bd27b1df->m_frame.f_lineno = 311;
                tmp_assign_source_6 = CALL_METHOD_NO_ARGS(tmp_called_instance_3, const_str_plain_DSA_new);
                if (tmp_assign_source_6 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 311;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                assert(var_dsa == NULL);
                var_dsa = tmp_assign_source_6;
            }
            {
                PyObject *tmp_called_name_7;
                PyObject *tmp_mvar_value_15;
                PyObject *tmp_call_result_4;
                PyObject *tmp_args_element_name_13;
                PyObject *tmp_compexpr_left_6;
                PyObject *tmp_compexpr_right_6;
                PyObject *tmp_source_name_9;
                PyObject *tmp_mvar_value_16;
                tmp_mvar_value_15 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

                if (unlikely(tmp_mvar_value_15 == NULL)) {
                    tmp_mvar_value_15 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
                }

                if (tmp_mvar_value_15 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
                    exception_tb = NULL;

                    exception_lineno = 312;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_name_7 = tmp_mvar_value_15;
                CHECK_OBJECT(var_dsa);
                tmp_compexpr_left_6 = var_dsa;
                tmp_mvar_value_16 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

                if (unlikely(tmp_mvar_value_16 == NULL)) {
                    tmp_mvar_value_16 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
                }

                if (tmp_mvar_value_16 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 312;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_9 = tmp_mvar_value_16;
                tmp_compexpr_right_6 = LOOKUP_ATTRIBUTE(tmp_source_name_9, const_str_plain_NULL);
                if (tmp_compexpr_right_6 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 312;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                tmp_args_element_name_13 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_6, tmp_compexpr_right_6);
                Py_DECREF(tmp_compexpr_right_6);
                if (tmp_args_element_name_13 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 312;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                frame_b718d7c7e21f2f8cf1e62e44bd27b1df->m_frame.f_lineno = 312;
                tmp_call_result_4 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_7, tmp_args_element_name_13);
                Py_DECREF(tmp_args_element_name_13);
                if (tmp_call_result_4 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 312;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                Py_DECREF(tmp_call_result_4);
            }
            {
                PyObject *tmp_assign_source_7;
                PyObject *tmp_called_name_8;
                PyObject *tmp_source_name_10;
                PyObject *tmp_mvar_value_17;
                PyObject *tmp_args_element_name_14;
                PyObject *tmp_args_element_name_15;
                PyObject *tmp_source_name_11;
                PyObject *tmp_mvar_value_18;
                tmp_mvar_value_17 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

                if (unlikely(tmp_mvar_value_17 == NULL)) {
                    tmp_mvar_value_17 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
                }

                if (tmp_mvar_value_17 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 314;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_10 = tmp_mvar_value_17;
                tmp_called_name_8 = LOOKUP_ATTRIBUTE(tmp_source_name_10, const_str_plain_gc);
                if (tmp_called_name_8 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 314;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT(var_dsa);
                tmp_args_element_name_14 = var_dsa;
                tmp_mvar_value_18 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

                if (unlikely(tmp_mvar_value_18 == NULL)) {
                    tmp_mvar_value_18 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
                }

                if (tmp_mvar_value_18 == NULL) {
                    Py_DECREF(tmp_called_name_8);
                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 314;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_11 = tmp_mvar_value_18;
                tmp_args_element_name_15 = LOOKUP_ATTRIBUTE(tmp_source_name_11, const_str_plain_DSA_free);
                if (tmp_args_element_name_15 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    Py_DECREF(tmp_called_name_8);

                    exception_lineno = 314;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                frame_b718d7c7e21f2f8cf1e62e44bd27b1df->m_frame.f_lineno = 314;
                {
                    PyObject *call_args[] = {tmp_args_element_name_14, tmp_args_element_name_15};
                    tmp_assign_source_7 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_8, call_args);
                }

                Py_DECREF(tmp_called_name_8);
                Py_DECREF(tmp_args_element_name_15);
                if (tmp_assign_source_7 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 314;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                {
                    PyObject *old = var_dsa;
                    assert(old != NULL);
                    var_dsa = tmp_assign_source_7;
                    Py_DECREF(old);
                }

            }
            {
                PyObject *tmp_assign_source_8;
                PyObject *tmp_called_name_9;
                PyObject *tmp_source_name_12;
                PyObject *tmp_mvar_value_19;
                PyObject *tmp_args_element_name_16;
                PyObject *tmp_args_element_name_17;
                PyObject *tmp_args_element_name_18;
                PyObject *tmp_source_name_13;
                PyObject *tmp_mvar_value_20;
                PyObject *tmp_args_element_name_19;
                PyObject *tmp_args_element_name_20;
                PyObject *tmp_source_name_14;
                PyObject *tmp_mvar_value_21;
                PyObject *tmp_args_element_name_21;
                PyObject *tmp_source_name_15;
                PyObject *tmp_mvar_value_22;
                PyObject *tmp_args_element_name_22;
                PyObject *tmp_source_name_16;
                PyObject *tmp_mvar_value_23;
                tmp_mvar_value_19 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

                if (unlikely(tmp_mvar_value_19 == NULL)) {
                    tmp_mvar_value_19 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
                }

                if (tmp_mvar_value_19 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 315;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_12 = tmp_mvar_value_19;
                tmp_called_name_9 = LOOKUP_ATTRIBUTE(tmp_source_name_12, const_str_plain_DSA_generate_parameters_ex);
                if (tmp_called_name_9 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 315;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT(var_dsa);
                tmp_args_element_name_16 = var_dsa;
                CHECK_OBJECT(par_bits);
                tmp_args_element_name_17 = par_bits;
                tmp_mvar_value_20 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

                if (unlikely(tmp_mvar_value_20 == NULL)) {
                    tmp_mvar_value_20 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
                }

                if (tmp_mvar_value_20 == NULL) {
                    Py_DECREF(tmp_called_name_9);
                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 316;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_13 = tmp_mvar_value_20;
                tmp_args_element_name_18 = LOOKUP_ATTRIBUTE(tmp_source_name_13, const_str_plain_NULL);
                if (tmp_args_element_name_18 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    Py_DECREF(tmp_called_name_9);

                    exception_lineno = 316;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                tmp_args_element_name_19 = const_int_0;
                tmp_mvar_value_21 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

                if (unlikely(tmp_mvar_value_21 == NULL)) {
                    tmp_mvar_value_21 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
                }

                if (tmp_mvar_value_21 == NULL) {
                    Py_DECREF(tmp_called_name_9);
                    Py_DECREF(tmp_args_element_name_18);
                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 316;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_14 = tmp_mvar_value_21;
                tmp_args_element_name_20 = LOOKUP_ATTRIBUTE(tmp_source_name_14, const_str_plain_NULL);
                if (tmp_args_element_name_20 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    Py_DECREF(tmp_called_name_9);
                    Py_DECREF(tmp_args_element_name_18);

                    exception_lineno = 316;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                tmp_mvar_value_22 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

                if (unlikely(tmp_mvar_value_22 == NULL)) {
                    tmp_mvar_value_22 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
                }

                if (tmp_mvar_value_22 == NULL) {
                    Py_DECREF(tmp_called_name_9);
                    Py_DECREF(tmp_args_element_name_18);
                    Py_DECREF(tmp_args_element_name_20);
                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 316;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_15 = tmp_mvar_value_22;
                tmp_args_element_name_21 = LOOKUP_ATTRIBUTE(tmp_source_name_15, const_str_plain_NULL);
                if (tmp_args_element_name_21 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    Py_DECREF(tmp_called_name_9);
                    Py_DECREF(tmp_args_element_name_18);
                    Py_DECREF(tmp_args_element_name_20);

                    exception_lineno = 316;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                tmp_mvar_value_23 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

                if (unlikely(tmp_mvar_value_23 == NULL)) {
                    tmp_mvar_value_23 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
                }

                if (tmp_mvar_value_23 == NULL) {
                    Py_DECREF(tmp_called_name_9);
                    Py_DECREF(tmp_args_element_name_18);
                    Py_DECREF(tmp_args_element_name_20);
                    Py_DECREF(tmp_args_element_name_21);
                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 316;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_16 = tmp_mvar_value_23;
                tmp_args_element_name_22 = LOOKUP_ATTRIBUTE(tmp_source_name_16, const_str_plain_NULL);
                if (tmp_args_element_name_22 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    Py_DECREF(tmp_called_name_9);
                    Py_DECREF(tmp_args_element_name_18);
                    Py_DECREF(tmp_args_element_name_20);
                    Py_DECREF(tmp_args_element_name_21);

                    exception_lineno = 316;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                frame_b718d7c7e21f2f8cf1e62e44bd27b1df->m_frame.f_lineno = 315;
                {
                    PyObject *call_args[] = {tmp_args_element_name_16, tmp_args_element_name_17, tmp_args_element_name_18, tmp_args_element_name_19, tmp_args_element_name_20, tmp_args_element_name_21, tmp_args_element_name_22};
                    tmp_assign_source_8 = CALL_FUNCTION_WITH_ARGS7(tmp_called_name_9, call_args);
                }

                Py_DECREF(tmp_called_name_9);
                Py_DECREF(tmp_args_element_name_18);
                Py_DECREF(tmp_args_element_name_20);
                Py_DECREF(tmp_args_element_name_21);
                Py_DECREF(tmp_args_element_name_22);
                if (tmp_assign_source_8 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 315;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                assert(var_res == NULL);
                var_res = tmp_assign_source_8;
            }
            {
                PyObject *tmp_called_name_10;
                PyObject *tmp_mvar_value_24;
                PyObject *tmp_call_result_5;
                PyObject *tmp_args_element_name_23;
                PyObject *tmp_compexpr_left_7;
                PyObject *tmp_compexpr_right_7;
                tmp_mvar_value_24 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

                if (unlikely(tmp_mvar_value_24 == NULL)) {
                    tmp_mvar_value_24 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
                }

                if (tmp_mvar_value_24 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
                    exception_tb = NULL;

                    exception_lineno = 318;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_name_10 = tmp_mvar_value_24;
                CHECK_OBJECT(var_res);
                tmp_compexpr_left_7 = var_res;
                tmp_compexpr_right_7 = const_int_pos_1;
                tmp_args_element_name_23 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_7, tmp_compexpr_right_7);
                if (tmp_args_element_name_23 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 318;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                frame_b718d7c7e21f2f8cf1e62e44bd27b1df->m_frame.f_lineno = 318;
                tmp_call_result_5 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_10, tmp_args_element_name_23);
                Py_DECREF(tmp_args_element_name_23);
                if (tmp_call_result_5 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 318;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                Py_DECREF(tmp_call_result_5);
            }
            {
                PyObject *tmp_called_name_11;
                PyObject *tmp_mvar_value_25;
                PyObject *tmp_call_result_6;
                PyObject *tmp_args_element_name_24;
                PyObject *tmp_compexpr_left_8;
                PyObject *tmp_compexpr_right_8;
                PyObject *tmp_called_instance_4;
                PyObject *tmp_mvar_value_26;
                PyObject *tmp_args_element_name_25;
                tmp_mvar_value_25 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

                if (unlikely(tmp_mvar_value_25 == NULL)) {
                    tmp_mvar_value_25 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
                }

                if (tmp_mvar_value_25 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
                    exception_tb = NULL;

                    exception_lineno = 320;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_name_11 = tmp_mvar_value_25;
                tmp_mvar_value_26 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

                if (unlikely(tmp_mvar_value_26 == NULL)) {
                    tmp_mvar_value_26 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
                }

                if (tmp_mvar_value_26 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 320;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_instance_4 = tmp_mvar_value_26;
                CHECK_OBJECT(var_dsa);
                tmp_args_element_name_25 = var_dsa;
                frame_b718d7c7e21f2f8cf1e62e44bd27b1df->m_frame.f_lineno = 320;
                {
                    PyObject *call_args[] = {tmp_args_element_name_25};
                    tmp_compexpr_left_8 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_4, const_str_plain_DSA_generate_key, call_args);
                }

                if (tmp_compexpr_left_8 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 320;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                tmp_compexpr_right_8 = const_int_pos_1;
                tmp_args_element_name_24 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_8, tmp_compexpr_right_8);
                Py_DECREF(tmp_compexpr_left_8);
                if (tmp_args_element_name_24 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 320;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                frame_b718d7c7e21f2f8cf1e62e44bd27b1df->m_frame.f_lineno = 320;
                tmp_call_result_6 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_11, tmp_args_element_name_24);
                Py_DECREF(tmp_args_element_name_24);
                if (tmp_call_result_6 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 320;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                Py_DECREF(tmp_call_result_6);
            }
            {
                PyObject *tmp_called_name_12;
                PyObject *tmp_mvar_value_27;
                PyObject *tmp_call_result_7;
                PyObject *tmp_args_element_name_26;
                PyObject *tmp_compexpr_left_9;
                PyObject *tmp_compexpr_right_9;
                PyObject *tmp_called_name_13;
                PyObject *tmp_source_name_17;
                PyObject *tmp_mvar_value_28;
                PyObject *tmp_args_element_name_27;
                PyObject *tmp_source_name_18;
                PyObject *tmp_args_element_name_28;
                tmp_mvar_value_27 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

                if (unlikely(tmp_mvar_value_27 == NULL)) {
                    tmp_mvar_value_27 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
                }

                if (tmp_mvar_value_27 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
                    exception_tb = NULL;

                    exception_lineno = 321;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_name_12 = tmp_mvar_value_27;
                tmp_mvar_value_28 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

                if (unlikely(tmp_mvar_value_28 == NULL)) {
                    tmp_mvar_value_28 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
                }

                if (tmp_mvar_value_28 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 321;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_17 = tmp_mvar_value_28;
                tmp_called_name_13 = LOOKUP_ATTRIBUTE(tmp_source_name_17, const_str_plain_EVP_PKEY_set1_DSA);
                if (tmp_called_name_13 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 321;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT(par_self);
                tmp_source_name_18 = par_self;
                tmp_args_element_name_27 = LOOKUP_ATTRIBUTE(tmp_source_name_18, const_str_plain__pkey);
                if (tmp_args_element_name_27 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    Py_DECREF(tmp_called_name_13);

                    exception_lineno = 321;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT(var_dsa);
                tmp_args_element_name_28 = var_dsa;
                frame_b718d7c7e21f2f8cf1e62e44bd27b1df->m_frame.f_lineno = 321;
                {
                    PyObject *call_args[] = {tmp_args_element_name_27, tmp_args_element_name_28};
                    tmp_compexpr_left_9 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_13, call_args);
                }

                Py_DECREF(tmp_called_name_13);
                Py_DECREF(tmp_args_element_name_27);
                if (tmp_compexpr_left_9 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 321;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                tmp_compexpr_right_9 = const_int_pos_1;
                tmp_args_element_name_26 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_9, tmp_compexpr_right_9);
                Py_DECREF(tmp_compexpr_left_9);
                if (tmp_args_element_name_26 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 321;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                frame_b718d7c7e21f2f8cf1e62e44bd27b1df->m_frame.f_lineno = 321;
                tmp_call_result_7 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_12, tmp_args_element_name_26);
                Py_DECREF(tmp_args_element_name_26);
                if (tmp_call_result_7 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 321;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                Py_DECREF(tmp_call_result_7);
            }
            goto branch_end_5;
            branch_no_5:;
            {
                PyObject *tmp_raise_type_4;
                PyObject *tmp_called_name_14;
                PyObject *tmp_mvar_value_29;
                tmp_mvar_value_29 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_Error);

                if (unlikely(tmp_mvar_value_29 == NULL)) {
                    tmp_mvar_value_29 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_Error);
                }

                if (tmp_mvar_value_29 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 49 ], 34, 0);
                    exception_tb = NULL;

                    exception_lineno = 323;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_name_14 = tmp_mvar_value_29;
                frame_b718d7c7e21f2f8cf1e62e44bd27b1df->m_frame.f_lineno = 323;
                tmp_raise_type_4 = CALL_FUNCTION_WITH_ARGS1(tmp_called_name_14, &PyTuple_GET_ITEM(const_tuple_str_digest_e2d15f7f418fdd55a54be9ea476feee3_tuple, 0));

                if (tmp_raise_type_4 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 323;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                exception_type = tmp_raise_type_4;
                exception_lineno = 323;
                RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            branch_end_5:;
        }
        branch_end_3:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        tmp_assattr_name_1 = Py_True;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__initialized, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 325;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b718d7c7e21f2f8cf1e62e44bd27b1df);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b718d7c7e21f2f8cf1e62e44bd27b1df);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_b718d7c7e21f2f8cf1e62e44bd27b1df, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_b718d7c7e21f2f8cf1e62e44bd27b1df->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_b718d7c7e21f2f8cf1e62e44bd27b1df, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b718d7c7e21f2f8cf1e62e44bd27b1df,
        type_description_1,
        par_self,
        par_type,
        par_bits,
        var_exponent,
        var_rsa,
        var_result,
        var_res,
        var_dsa
    );


    // Release cached frame.
    if (frame_b718d7c7e21f2f8cf1e62e44bd27b1df == cache_frame_b718d7c7e21f2f8cf1e62e44bd27b1df) {
        Py_DECREF(frame_b718d7c7e21f2f8cf1e62e44bd27b1df);
    }
    cache_frame_b718d7c7e21f2f8cf1e62e44bd27b1df = NULL;

    assertFrameObject(frame_b718d7c7e21f2f8cf1e62e44bd27b1df);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_13_generate_key);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_exponent);
    var_exponent = NULL;

    Py_XDECREF(var_rsa);
    var_rsa = NULL;

    Py_XDECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_res);
    var_res = NULL;

    Py_XDECREF(var_dsa);
    var_dsa = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_exponent);
    var_exponent = NULL;

    Py_XDECREF(var_rsa);
    var_rsa = NULL;

    Py_XDECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_res);
    var_res = NULL;

    Py_XDECREF(var_dsa);
    var_dsa = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_13_generate_key);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_bits);
    Py_DECREF(par_bits);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_bits);
    Py_DECREF(par_bits);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_14_check(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_rsa = NULL;
    PyObject *var_result = NULL;
    struct Nuitka_FrameObject *frame_72e2fe225c7664a56842ff4e880953c2;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_72e2fe225c7664a56842ff4e880953c2 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_72e2fe225c7664a56842ff4e880953c2, codeobj_72e2fe225c7664a56842ff4e880953c2, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_72e2fe225c7664a56842ff4e880953c2 = cache_frame_72e2fe225c7664a56842ff4e880953c2;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_72e2fe225c7664a56842ff4e880953c2);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_72e2fe225c7664a56842ff4e880953c2) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_attribute_value_1;
        int tmp_truth_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_attribute_value_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__only_public);
        if (tmp_attribute_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 340;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE(tmp_attribute_value_1);
        if (tmp_truth_name_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_attribute_value_1);

            exception_lineno = 340;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_attribute_value_1);
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_3d684470d9353bc1a1e8d63a3aab4679;
            frame_72e2fe225c7664a56842ff4e880953c2->m_frame.f_lineno = 341;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 341;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 343;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_EVP_PKEY_type);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 343;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        frame_72e2fe225c7664a56842ff4e880953c2->m_frame.f_lineno = 343;
        tmp_args_element_name_1 = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_type);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 343;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_72e2fe225c7664a56842ff4e880953c2->m_frame.f_lineno = 343;
        tmp_compexpr_left_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 343;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {
            Py_DECREF(tmp_compexpr_left_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 343;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_EVP_PKEY_RSA);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_1);

            exception_lineno = 343;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 343;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            tmp_make_exception_arg_2 = const_str_digest_c85d62bfc2af2f3c2202464fd6374ea7;
            frame_72e2fe225c7664a56842ff4e880953c2->m_frame.f_lineno = 344;
            tmp_raise_type_2 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_2);
            assert(!(tmp_raise_type_2 == NULL));
            exception_type = tmp_raise_type_2;
            exception_lineno = 344;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_5;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 346;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_3;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_EVP_PKEY_get1_RSA);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 346;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_5 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain__pkey);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 346;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_72e2fe225c7664a56842ff4e880953c2->m_frame.f_lineno = 346;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_2);
        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 346;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_rsa == NULL);
        var_rsa = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_5;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 347;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_4;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_gc);
        if (tmp_called_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 347;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_rsa);
        tmp_args_element_name_3 = var_rsa;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_5 == NULL) {
            Py_DECREF(tmp_called_name_3);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 347;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = tmp_mvar_value_5;
        tmp_args_element_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain_RSA_free);
        if (tmp_args_element_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);

            exception_lineno = 347;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_72e2fe225c7664a56842ff4e880953c2->m_frame.f_lineno = 347;
        {
            PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4};
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_3, call_args);
        }

        Py_DECREF(tmp_called_name_3);
        Py_DECREF(tmp_args_element_name_4);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 347;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var_rsa;
            assert(old != NULL);
            var_rsa = tmp_assign_source_2;
            Py_DECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_args_element_name_5;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_6 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 348;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_6;
        CHECK_OBJECT(var_rsa);
        tmp_args_element_name_5 = var_rsa;
        frame_72e2fe225c7664a56842ff4e880953c2->m_frame.f_lineno = 348;
        {
            PyObject *call_args[] = {tmp_args_element_name_5};
            tmp_assign_source_3 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_RSA_check_key, call_args);
        }

        if (tmp_assign_source_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 348;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_result == NULL);
        var_result = tmp_assign_source_3;
    }
    {
        nuitka_bool tmp_condition_result_3;
        int tmp_truth_name_2;
        CHECK_OBJECT(var_result);
        tmp_truth_name_2 = CHECK_IF_TRUE(var_result);
        if (tmp_truth_name_2 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 349;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = tmp_truth_name_2 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
            goto branch_yes_3;
        } else {
            goto branch_no_3;
        }
        branch_yes_3:;
        tmp_return_value = Py_True;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_3:;
    }
    {
        PyObject *tmp_called_name_4;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_call_result_1;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error);

        if (unlikely(tmp_mvar_value_7 == NULL)) {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error);
        }

        if (tmp_mvar_value_7 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 0 ], 49, 0);
            exception_tb = NULL;

            exception_lineno = 351;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_4 = tmp_mvar_value_7;
        frame_72e2fe225c7664a56842ff4e880953c2->m_frame.f_lineno = 351;
        tmp_call_result_1 = CALL_FUNCTION_NO_ARGS(tmp_called_name_4);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 351;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_72e2fe225c7664a56842ff4e880953c2);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_72e2fe225c7664a56842ff4e880953c2);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_72e2fe225c7664a56842ff4e880953c2);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_72e2fe225c7664a56842ff4e880953c2, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_72e2fe225c7664a56842ff4e880953c2->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_72e2fe225c7664a56842ff4e880953c2, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_72e2fe225c7664a56842ff4e880953c2,
        type_description_1,
        par_self,
        var_rsa,
        var_result
    );


    // Release cached frame.
    if (frame_72e2fe225c7664a56842ff4e880953c2 == cache_frame_72e2fe225c7664a56842ff4e880953c2) {
        Py_DECREF(frame_72e2fe225c7664a56842ff4e880953c2);
    }
    cache_frame_72e2fe225c7664a56842ff4e880953c2 = NULL;

    assertFrameObject(frame_72e2fe225c7664a56842ff4e880953c2);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_14_check);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_rsa);
    Py_DECREF(var_rsa);
    var_rsa = NULL;

    CHECK_OBJECT((PyObject *)var_result);
    Py_DECREF(var_result);
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_rsa);
    var_rsa = NULL;

    Py_XDECREF(var_result);
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_14_check);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_15_type(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_592334dbe6f644d58958dafe39779ba7;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_592334dbe6f644d58958dafe39779ba7 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_592334dbe6f644d58958dafe39779ba7, codeobj_592334dbe6f644d58958dafe39779ba7, module_OpenSSL$crypto, sizeof(void *));
    frame_592334dbe6f644d58958dafe39779ba7 = cache_frame_592334dbe6f644d58958dafe39779ba7;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_592334dbe6f644d58958dafe39779ba7);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_592334dbe6f644d58958dafe39779ba7) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 359;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_EVP_PKEY_id);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 359;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__pkey);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 359;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_592334dbe6f644d58958dafe39779ba7->m_frame.f_lineno = 359;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 359;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_592334dbe6f644d58958dafe39779ba7);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_592334dbe6f644d58958dafe39779ba7);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_592334dbe6f644d58958dafe39779ba7);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_592334dbe6f644d58958dafe39779ba7, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_592334dbe6f644d58958dafe39779ba7->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_592334dbe6f644d58958dafe39779ba7, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_592334dbe6f644d58958dafe39779ba7,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_592334dbe6f644d58958dafe39779ba7 == cache_frame_592334dbe6f644d58958dafe39779ba7) {
        Py_DECREF(frame_592334dbe6f644d58958dafe39779ba7);
    }
    cache_frame_592334dbe6f644d58958dafe39779ba7 = NULL;

    assertFrameObject(frame_592334dbe6f644d58958dafe39779ba7);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_15_type);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_16_bits(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_52082d9f842a277aa94ee6a0252a7f07;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_52082d9f842a277aa94ee6a0252a7f07 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_52082d9f842a277aa94ee6a0252a7f07, codeobj_52082d9f842a277aa94ee6a0252a7f07, module_OpenSSL$crypto, sizeof(void *));
    frame_52082d9f842a277aa94ee6a0252a7f07 = cache_frame_52082d9f842a277aa94ee6a0252a7f07;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_52082d9f842a277aa94ee6a0252a7f07);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_52082d9f842a277aa94ee6a0252a7f07) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 367;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_EVP_PKEY_bits);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 367;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__pkey);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 367;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_52082d9f842a277aa94ee6a0252a7f07->m_frame.f_lineno = 367;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 367;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_52082d9f842a277aa94ee6a0252a7f07);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_52082d9f842a277aa94ee6a0252a7f07);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_52082d9f842a277aa94ee6a0252a7f07);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_52082d9f842a277aa94ee6a0252a7f07, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_52082d9f842a277aa94ee6a0252a7f07->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_52082d9f842a277aa94ee6a0252a7f07, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_52082d9f842a277aa94ee6a0252a7f07,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_52082d9f842a277aa94ee6a0252a7f07 == cache_frame_52082d9f842a277aa94ee6a0252a7f07) {
        Py_DECREF(frame_52082d9f842a277aa94ee6a0252a7f07);
    }
    cache_frame_52082d9f842a277aa94ee6a0252a7f07 = NULL;

    assertFrameObject(frame_52082d9f842a277aa94ee6a0252a7f07);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_16_bits);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_17___ne__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    struct Nuitka_FrameObject *frame_a3749c6c6ff08577b8d8b833eefc14bb;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_a3749c6c6ff08577b8d8b833eefc14bb = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_a3749c6c6ff08577b8d8b833eefc14bb, codeobj_a3749c6c6ff08577b8d8b833eefc14bb, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *));
    frame_a3749c6c6ff08577b8d8b833eefc14bb = cache_frame_a3749c6c6ff08577b8d8b833eefc14bb;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_a3749c6c6ff08577b8d8b833eefc14bb);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_a3749c6c6ff08577b8d8b833eefc14bb) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_other);
        tmp_isinstance_inst_1 = par_other;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__EllipticCurve);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__EllipticCurve);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3420 ], 43, 0);
            exception_tb = NULL;

            exception_lineno = 397;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 397;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_type_name_1;
            PyObject *tmp_mvar_value_2;
            PyObject *tmp_object_name_1;
            PyObject *tmp_args_element_name_1;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__EllipticCurve);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__EllipticCurve);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 3420 ], 43, 0);
                exception_tb = NULL;

                exception_lineno = 398;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }

            tmp_type_name_1 = tmp_mvar_value_2;
            CHECK_OBJECT(par_self);
            tmp_object_name_1 = par_self;
            tmp_called_instance_1 = BUILTIN_SUPER(tmp_type_name_1, tmp_object_name_1);
            if (tmp_called_instance_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 398;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(par_other);
            tmp_args_element_name_1 = par_other;
            frame_a3749c6c6ff08577b8d8b833eefc14bb->m_frame.f_lineno = 398;
            {
                PyObject *call_args[] = {tmp_args_element_name_1};
                tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain___ne__, call_args);
            }

            Py_DECREF(tmp_called_instance_1);
            if (tmp_return_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 398;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a3749c6c6ff08577b8d8b833eefc14bb);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_a3749c6c6ff08577b8d8b833eefc14bb);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a3749c6c6ff08577b8d8b833eefc14bb);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_a3749c6c6ff08577b8d8b833eefc14bb, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_a3749c6c6ff08577b8d8b833eefc14bb->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_a3749c6c6ff08577b8d8b833eefc14bb, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a3749c6c6ff08577b8d8b833eefc14bb,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if (frame_a3749c6c6ff08577b8d8b833eefc14bb == cache_frame_a3749c6c6ff08577b8d8b833eefc14bb) {
        Py_DECREF(frame_a3749c6c6ff08577b8d8b833eefc14bb);
    }
    cache_frame_a3749c6c6ff08577b8d8b833eefc14bb = NULL;

    assertFrameObject(frame_a3749c6c6ff08577b8d8b833eefc14bb);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_NotImplemented;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_17___ne__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_18__load_elliptic_curves(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_cls = PyCell_NEW1(python_pars[0]);
    struct Nuitka_CellObject *par_lib = PyCell_NEW1(python_pars[1]);
    PyObject *var_builtin_curves = NULL;
    PyObject *var_num_curves = NULL;
    PyObject *tmp_genexpr_1__$0 = NULL;
    struct Nuitka_FrameObject *frame_96e5ab6839a5b468daf580820eac0fba;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_96e5ab6839a5b468daf580820eac0fba = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_96e5ab6839a5b468daf580820eac0fba, codeobj_96e5ab6839a5b468daf580820eac0fba, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_96e5ab6839a5b468daf580820eac0fba = cache_frame_96e5ab6839a5b468daf580820eac0fba;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_96e5ab6839a5b468daf580820eac0fba);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_96e5ab6839a5b468daf580820eac0fba) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT(PyCell_GET(par_lib));
        tmp_source_name_1 = PyCell_GET(par_lib);
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_EC_get_builtin_curves);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 411;
            type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_1 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 411;
            type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_1;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_NULL);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 411;
            type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_2 = const_int_0;
        frame_96e5ab6839a5b468daf580820eac0fba->m_frame.f_lineno = 411;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 411;
            type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }
        assert(var_num_curves == NULL);
        var_num_curves = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 412;
            type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_2;
        tmp_args_element_name_3 = const_str_digest_73f7a7ef7b02ca8c5d7fdfe1049be561;
        CHECK_OBJECT(var_num_curves);
        tmp_args_element_name_4 = var_num_curves;
        frame_96e5ab6839a5b468daf580820eac0fba->m_frame.f_lineno = 412;
        {
            PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4};
            tmp_assign_source_2 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain_new, call_args);
        }

        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 412;
            type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }
        assert(var_builtin_curves == NULL);
        var_builtin_curves = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_args_element_name_6;
        CHECK_OBJECT(PyCell_GET(par_lib));
        tmp_called_instance_2 = PyCell_GET(par_lib);
        CHECK_OBJECT(var_builtin_curves);
        tmp_args_element_name_5 = var_builtin_curves;
        CHECK_OBJECT(var_num_curves);
        tmp_args_element_name_6 = var_num_curves;
        frame_96e5ab6839a5b468daf580820eac0fba->m_frame.f_lineno = 416;
        {
            PyObject *call_args[] = {tmp_args_element_name_5, tmp_args_element_name_6};
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_2, const_str_plain_EC_get_builtin_curves, call_args);
        }

        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 416;
            type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_set_arg_1;
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT(var_builtin_curves);
            tmp_iter_arg_1 = var_builtin_curves;
            tmp_assign_source_3 = MAKE_ITERATOR(tmp_iter_arg_1);
            if (tmp_assign_source_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 418;
                type_description_1 = "ccoo";
                goto frame_exception_exit_1;
            }
            assert(tmp_genexpr_1__$0 == NULL);
            tmp_genexpr_1__$0 = tmp_assign_source_3;
        }
        // Tried code:
        tmp_set_arg_1 = OpenSSL$crypto$$$function_18__load_elliptic_curves$$$genexpr_1_genexpr_maker();

        ((struct Nuitka_GeneratorObject *)tmp_set_arg_1)->m_closure[0] = par_cls;
        Py_INCREF(((struct Nuitka_GeneratorObject *)tmp_set_arg_1)->m_closure[0]);
        ((struct Nuitka_GeneratorObject *)tmp_set_arg_1)->m_closure[1] = PyCell_NEW0(tmp_genexpr_1__$0);
        ((struct Nuitka_GeneratorObject *)tmp_set_arg_1)->m_closure[2] = par_lib;
        Py_INCREF(((struct Nuitka_GeneratorObject *)tmp_set_arg_1)->m_closure[2]);


        goto try_return_handler_2;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_18__load_elliptic_curves);
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        CHECK_OBJECT((PyObject *)tmp_genexpr_1__$0);
        Py_DECREF(tmp_genexpr_1__$0);
        tmp_genexpr_1__$0 = NULL;

        goto outline_result_1;
        // End of try:
        CHECK_OBJECT((PyObject *)tmp_genexpr_1__$0);
        Py_DECREF(tmp_genexpr_1__$0);
        tmp_genexpr_1__$0 = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_18__load_elliptic_curves);
        return NULL;
        outline_result_1:;
        tmp_return_value = PySet_New(tmp_set_arg_1);
        Py_DECREF(tmp_set_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 417;
            type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_96e5ab6839a5b468daf580820eac0fba);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_96e5ab6839a5b468daf580820eac0fba);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_96e5ab6839a5b468daf580820eac0fba);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_96e5ab6839a5b468daf580820eac0fba, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_96e5ab6839a5b468daf580820eac0fba->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_96e5ab6839a5b468daf580820eac0fba, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_96e5ab6839a5b468daf580820eac0fba,
        type_description_1,
        par_cls,
        par_lib,
        var_builtin_curves,
        var_num_curves
    );


    // Release cached frame.
    if (frame_96e5ab6839a5b468daf580820eac0fba == cache_frame_96e5ab6839a5b468daf580820eac0fba) {
        Py_DECREF(frame_96e5ab6839a5b468daf580820eac0fba);
    }
    cache_frame_96e5ab6839a5b468daf580820eac0fba = NULL;

    assertFrameObject(frame_96e5ab6839a5b468daf580820eac0fba);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_18__load_elliptic_curves);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_builtin_curves);
    Py_DECREF(var_builtin_curves);
    var_builtin_curves = NULL;

    CHECK_OBJECT((PyObject *)var_num_curves);
    Py_DECREF(var_num_curves);
    var_num_curves = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_builtin_curves);
    var_builtin_curves = NULL;

    Py_XDECREF(var_num_curves);
    var_num_curves = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_18__load_elliptic_curves);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_lib);
    Py_DECREF(par_lib);
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_lib);
    Py_DECREF(par_lib);
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}



struct OpenSSL$crypto$$$function_18__load_elliptic_curves$$$genexpr_1_genexpr_locals {
    PyObject *var_c;
    PyObject *tmp_iter_value_0;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *OpenSSL$crypto$$$function_18__load_elliptic_curves$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value ) {
    CHECK_OBJECT((PyObject *)generator);
    assert(Nuitka_Generator_Check( (PyObject *)generator ));

    // Heap access if used.
    struct OpenSSL$crypto$$$function_18__load_elliptic_curves$$$genexpr_1_genexpr_locals *generator_heap = (struct OpenSSL$crypto$$$function_18__load_elliptic_curves$$$genexpr_1_genexpr_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_c = NULL;
    generator_heap->tmp_iter_value_0 = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_m_frame, codeobj_90b1b594fc4594b0a0c51455faad8850, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF(generator->m_frame);
    assert(Py_REFCNT(generator->m_frame) == 2); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR(generator->m_frame->m_frame.f_back);

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF(generator->m_frame->m_frame.f_back);

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF(generator->m_frame);

    Nuitka_Frame_MarkAsExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

        EXC_TYPE_F(generator) = EXC_TYPE(thread_state);
        if (EXC_TYPE_F(generator) == Py_None) EXC_TYPE_F(generator) = NULL;
        Py_XINCREF(EXC_TYPE_F(generator));
        EXC_VALUE_F(generator) = EXC_VALUE(thread_state);
        Py_XINCREF(EXC_VALUE_F(generator));
        EXC_TRACEBACK_F(generator) = EXC_TRACEBACK(thread_state);
        Py_XINCREF(EXC_TRACEBACK_F(generator));
    }

#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_1;
        CHECK_OBJECT(PyCell_GET(generator->m_closure[1]));
        tmp_next_source_1 = PyCell_GET(generator->m_closure[1]);
        tmp_assign_source_1 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_1 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);
                generator_heap->type_description_1 = "Nocc";
                generator_heap->exception_lineno = 418;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_iter_value_0;
            generator_heap->tmp_iter_value_0 = tmp_assign_source_1;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT(generator_heap->tmp_iter_value_0);
        tmp_assign_source_2 = generator_heap->tmp_iter_value_0;
        {
            PyObject *old = generator_heap->var_c;
            generator_heap->var_c = tmp_assign_source_2;
            Py_INCREF(generator_heap->var_c);
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_expression_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        if (PyCell_GET(generator->m_closure[0]) == NULL) {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF(generator_heap->exception_type);
            generator_heap->exception_value = PyString_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "cls");
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 418;
            generator_heap->type_description_1 = "Nocc";
            goto try_except_handler_2;
        }

        tmp_source_name_1 = PyCell_GET(generator->m_closure[0]);
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_from_nid);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 418;
            generator_heap->type_description_1 = "Nocc";
            goto try_except_handler_2;
        }
        if (PyCell_GET(generator->m_closure[2]) == NULL) {
            Py_DECREF(tmp_called_name_1);
            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF(generator_heap->exception_type);
            generator_heap->exception_value = PyString_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "lib");
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 418;
            generator_heap->type_description_1 = "Nocc";
            goto try_except_handler_2;
        }

        tmp_args_element_name_1 = PyCell_GET(generator->m_closure[2]);
        CHECK_OBJECT(generator_heap->var_c);
        tmp_source_name_2 = generator_heap->var_c;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_nid);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);
            Py_DECREF(tmp_called_name_1);

            generator_heap->exception_lineno = 418;
            generator_heap->type_description_1 = "Nocc";
            goto try_except_handler_2;
        }
        generator->m_frame->m_frame.f_lineno = 418;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_expression_name_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_expression_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 418;
            generator_heap->type_description_1 = "Nocc";
            goto try_except_handler_2;
        }
        Nuitka_PreserveHeap(generator_heap->yield_tmps, &tmp_called_name_1, sizeof(PyObject *), &tmp_source_name_1, sizeof(PyObject *), &tmp_args_element_name_1, sizeof(PyObject *), &tmp_args_element_name_2, sizeof(PyObject *), &tmp_source_name_2, sizeof(PyObject *), NULL);
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        Nuitka_RestoreHeap(generator_heap->yield_tmps, &tmp_called_name_1, sizeof(PyObject *), &tmp_source_name_1, sizeof(PyObject *), &tmp_args_element_name_1, sizeof(PyObject *), &tmp_args_element_name_2, sizeof(PyObject *), &tmp_source_name_2, sizeof(PyObject *), NULL);
        if (yield_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 418;
            generator_heap->type_description_1 = "Nocc";
            goto try_except_handler_2;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


        generator_heap->exception_lineno = 418;
        generator_heap->type_description_1 = "Nocc";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    // Allow re-use of the frame again.
    Py_DECREF(generator->m_frame);
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if (!EXCEPTION_MATCH_GENERATOR(generator_heap->exception_type)) {
        if (generator_heap->exception_tb == NULL) {
            generator_heap->exception_tb = MAKE_TRACEBACK(generator->m_frame, generator_heap->exception_lineno);
        } else if (generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame) {
            generator_heap->exception_tb = ADD_TRACEBACK(generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno);
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            NULL,
            generator_heap->var_c,
            generator->m_closure[2],
            generator->m_closure[0]
        );


        // Release cached frame.
        if (generator->m_frame == cache_m_frame) {
            Py_DECREF(generator->m_frame);
        }
        cache_m_frame = NULL;

        assertFrameObject(generator->m_frame);
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    Py_DECREF(generator->m_frame);

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->var_c);
    generator_heap->var_c = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    Py_XDECREF(generator_heap->var_c);
    generator_heap->var_c = NULL;



    return NULL;

    function_exception_exit:
    assert(generator_heap->exception_type);
    RESTORE_ERROR_OCCURRED(generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb);

    return NULL;

}

static PyObject *OpenSSL$crypto$$$function_18__load_elliptic_curves$$$genexpr_1_genexpr_maker(void) {
    return Nuitka_Generator_New(
        OpenSSL$crypto$$$function_18__load_elliptic_curves$$$genexpr_1_genexpr_context,
        module_OpenSSL$crypto,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_90b1b594fc4594b0a0c51455faad8850,
        3,
        sizeof(struct OpenSSL$crypto$$$function_18__load_elliptic_curves$$$genexpr_1_genexpr_locals)
    );
}


static PyObject *impl_OpenSSL$crypto$$$function_19__get_elliptic_curves(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_lib = python_pars[1];
    struct Nuitka_FrameObject *frame_273dd0eea5c54fb2d8406e6bc14d5e15;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_273dd0eea5c54fb2d8406e6bc14d5e15 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_273dd0eea5c54fb2d8406e6bc14d5e15, codeobj_273dd0eea5c54fb2d8406e6bc14d5e15, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *));
    frame_273dd0eea5c54fb2d8406e6bc14d5e15 = cache_frame_273dd0eea5c54fb2d8406e6bc14d5e15;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_273dd0eea5c54fb2d8406e6bc14d5e15);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_273dd0eea5c54fb2d8406e6bc14d5e15) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_cls);
        tmp_source_name_1 = par_cls;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__curves);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 431;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_compexpr_left_1);
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assattr_name_1;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_assattr_target_1;
            CHECK_OBJECT(par_cls);
            tmp_called_instance_1 = par_cls;
            CHECK_OBJECT(par_lib);
            tmp_args_element_name_1 = par_lib;
            frame_273dd0eea5c54fb2d8406e6bc14d5e15->m_frame.f_lineno = 432;
            {
                PyObject *call_args[] = {tmp_args_element_name_1};
                tmp_assattr_name_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain__load_elliptic_curves, call_args);
            }

            if (tmp_assattr_name_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 432;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(par_cls);
            tmp_assattr_target_1 = par_cls;
            tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__curves, tmp_assattr_name_1);
            Py_DECREF(tmp_assattr_name_1);
            if (tmp_result == false) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 432;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_cls);
        tmp_source_name_2 = par_cls;
        tmp_return_value = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__curves);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 433;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_273dd0eea5c54fb2d8406e6bc14d5e15);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_273dd0eea5c54fb2d8406e6bc14d5e15);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_273dd0eea5c54fb2d8406e6bc14d5e15);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_273dd0eea5c54fb2d8406e6bc14d5e15, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_273dd0eea5c54fb2d8406e6bc14d5e15->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_273dd0eea5c54fb2d8406e6bc14d5e15, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_273dd0eea5c54fb2d8406e6bc14d5e15,
        type_description_1,
        par_cls,
        par_lib
    );


    // Release cached frame.
    if (frame_273dd0eea5c54fb2d8406e6bc14d5e15 == cache_frame_273dd0eea5c54fb2d8406e6bc14d5e15) {
        Py_DECREF(frame_273dd0eea5c54fb2d8406e6bc14d5e15);
    }
    cache_frame_273dd0eea5c54fb2d8406e6bc14d5e15 = NULL;

    assertFrameObject(frame_273dd0eea5c54fb2d8406e6bc14d5e15);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_19__get_elliptic_curves);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_lib);
    Py_DECREF(par_lib);
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_lib);
    Py_DECREF(par_lib);
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_20_from_nid(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_lib = python_pars[1];
    PyObject *par_nid = python_pars[2];
    struct Nuitka_FrameObject *frame_fe948b55a81e35b717d1b9b97c2db26b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_fe948b55a81e35b717d1b9b97c2db26b = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_fe948b55a81e35b717d1b9b97c2db26b, codeobj_fe948b55a81e35b717d1b9b97c2db26b, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_fe948b55a81e35b717d1b9b97c2db26b = cache_frame_fe948b55a81e35b717d1b9b97c2db26b;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_fe948b55a81e35b717d1b9b97c2db26b);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_fe948b55a81e35b717d1b9b97c2db26b) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_args_element_name_5;
        CHECK_OBJECT(par_cls);
        tmp_called_name_1 = par_cls;
        CHECK_OBJECT(par_lib);
        tmp_args_element_name_1 = par_lib;
        CHECK_OBJECT(par_nid);
        tmp_args_element_name_2 = par_nid;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 450;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_string);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 450;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_lib);
        tmp_called_instance_2 = par_lib;
        CHECK_OBJECT(par_nid);
        tmp_args_element_name_5 = par_nid;
        frame_fe948b55a81e35b717d1b9b97c2db26b->m_frame.f_lineno = 450;
        {
            PyObject *call_args[] = {tmp_args_element_name_5};
            tmp_args_element_name_4 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_OBJ_nid2sn, call_args);
        }

        if (tmp_args_element_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 450;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_fe948b55a81e35b717d1b9b97c2db26b->m_frame.f_lineno = 450;
        tmp_called_instance_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_4);
        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_4);
        if (tmp_called_instance_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 450;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_fe948b55a81e35b717d1b9b97c2db26b->m_frame.f_lineno = 450;
        tmp_args_element_name_3 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_decode, &PyTuple_GET_ITEM(const_tuple_str_plain_ascii_tuple, 0));

        Py_DECREF(tmp_called_instance_1);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 450;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_fe948b55a81e35b717d1b9b97c2db26b->m_frame.f_lineno = 450;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_return_value = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_args_element_name_3);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 450;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_fe948b55a81e35b717d1b9b97c2db26b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_fe948b55a81e35b717d1b9b97c2db26b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_fe948b55a81e35b717d1b9b97c2db26b);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_fe948b55a81e35b717d1b9b97c2db26b, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_fe948b55a81e35b717d1b9b97c2db26b->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_fe948b55a81e35b717d1b9b97c2db26b, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_fe948b55a81e35b717d1b9b97c2db26b,
        type_description_1,
        par_cls,
        par_lib,
        par_nid
    );


    // Release cached frame.
    if (frame_fe948b55a81e35b717d1b9b97c2db26b == cache_frame_fe948b55a81e35b717d1b9b97c2db26b) {
        Py_DECREF(frame_fe948b55a81e35b717d1b9b97c2db26b);
    }
    cache_frame_fe948b55a81e35b717d1b9b97c2db26b = NULL;

    assertFrameObject(frame_fe948b55a81e35b717d1b9b97c2db26b);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_20_from_nid);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_nid);
    Py_DECREF(par_nid);
    CHECK_OBJECT(par_lib);
    Py_DECREF(par_lib);
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_nid);
    Py_DECREF(par_nid);
    CHECK_OBJECT(par_lib);
    Py_DECREF(par_lib);
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_21___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_lib = python_pars[1];
    PyObject *par_nid = python_pars[2];
    PyObject *par_name = python_pars[3];
    struct Nuitka_FrameObject *frame_67b084766e0c2154c70a16d23028087b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_67b084766e0c2154c70a16d23028087b = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_67b084766e0c2154c70a16d23028087b, codeobj_67b084766e0c2154c70a16d23028087b, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_67b084766e0c2154c70a16d23028087b = cache_frame_67b084766e0c2154c70a16d23028087b;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_67b084766e0c2154c70a16d23028087b);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_67b084766e0c2154c70a16d23028087b) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_lib);
        tmp_assattr_name_1 = par_lib;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__lib, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 465;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT(par_nid);
        tmp_assattr_name_2 = par_nid;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain__nid, tmp_assattr_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 466;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_assattr_target_3;
        CHECK_OBJECT(par_name);
        tmp_assattr_name_3 = par_name;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_3 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_3, const_str_plain_name, tmp_assattr_name_3);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 467;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_67b084766e0c2154c70a16d23028087b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_67b084766e0c2154c70a16d23028087b);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_67b084766e0c2154c70a16d23028087b, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_67b084766e0c2154c70a16d23028087b->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_67b084766e0c2154c70a16d23028087b, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_67b084766e0c2154c70a16d23028087b,
        type_description_1,
        par_self,
        par_lib,
        par_nid,
        par_name
    );


    // Release cached frame.
    if (frame_67b084766e0c2154c70a16d23028087b == cache_frame_67b084766e0c2154c70a16d23028087b) {
        Py_DECREF(frame_67b084766e0c2154c70a16d23028087b);
    }
    cache_frame_67b084766e0c2154c70a16d23028087b = NULL;

    assertFrameObject(frame_67b084766e0c2154c70a16d23028087b);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_21___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_nid);
    Py_DECREF(par_nid);
    CHECK_OBJECT(par_lib);
    Py_DECREF(par_lib);
    CHECK_OBJECT(par_name);
    Py_DECREF(par_name);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_nid);
    Py_DECREF(par_nid);
    CHECK_OBJECT(par_lib);
    Py_DECREF(par_lib);
    CHECK_OBJECT(par_name);
    Py_DECREF(par_name);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_22___repr__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_9fcd3c1df2ae19417cd7c1bcb969e1f5;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_9fcd3c1df2ae19417cd7c1bcb969e1f5 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_9fcd3c1df2ae19417cd7c1bcb969e1f5, codeobj_9fcd3c1df2ae19417cd7c1bcb969e1f5, module_OpenSSL$crypto, sizeof(void *));
    frame_9fcd3c1df2ae19417cd7c1bcb969e1f5 = cache_frame_9fcd3c1df2ae19417cd7c1bcb969e1f5;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_9fcd3c1df2ae19417cd7c1bcb969e1f5);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_9fcd3c1df2ae19417cd7c1bcb969e1f5) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_1;
        tmp_left_name_1 = const_str_digest_221848055f0a545c7ef1969a37bb78a5;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_name);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 470;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_1 = PyTuple_New(1);
        PyTuple_SET_ITEM(tmp_right_name_1, 0, tmp_tuple_element_1);
        tmp_return_value = BINARY_OPERATION_MOD_STR_TUPLE(tmp_left_name_1, tmp_right_name_1);
        Py_DECREF(tmp_right_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 470;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9fcd3c1df2ae19417cd7c1bcb969e1f5);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_9fcd3c1df2ae19417cd7c1bcb969e1f5);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9fcd3c1df2ae19417cd7c1bcb969e1f5);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_9fcd3c1df2ae19417cd7c1bcb969e1f5, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_9fcd3c1df2ae19417cd7c1bcb969e1f5->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_9fcd3c1df2ae19417cd7c1bcb969e1f5, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9fcd3c1df2ae19417cd7c1bcb969e1f5,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_9fcd3c1df2ae19417cd7c1bcb969e1f5 == cache_frame_9fcd3c1df2ae19417cd7c1bcb969e1f5) {
        Py_DECREF(frame_9fcd3c1df2ae19417cd7c1bcb969e1f5);
    }
    cache_frame_9fcd3c1df2ae19417cd7c1bcb969e1f5 = NULL;

    assertFrameObject(frame_9fcd3c1df2ae19417cd7c1bcb969e1f5);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_22___repr__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_23__to_EC_KEY(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_key = NULL;
    struct Nuitka_FrameObject *frame_c83a206dfc0a5b352706e7cad0f33b53;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_c83a206dfc0a5b352706e7cad0f33b53 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_c83a206dfc0a5b352706e7cad0f33b53, codeobj_c83a206dfc0a5b352706e7cad0f33b53, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *));
    frame_c83a206dfc0a5b352706e7cad0f33b53 = cache_frame_c83a206dfc0a5b352706e7cad0f33b53;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_c83a206dfc0a5b352706e7cad0f33b53);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_c83a206dfc0a5b352706e7cad0f33b53) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_3;
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__lib);
        if (tmp_source_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 479;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_EC_KEY_new_by_curve_name);
        Py_DECREF(tmp_source_name_1);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 479;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__nid);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 479;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_c83a206dfc0a5b352706e7cad0f33b53->m_frame.f_lineno = 479;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 479;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert(var_key == NULL);
        var_key = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 480;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_1;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_gc);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 480;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_key);
        tmp_args_element_name_2 = var_key;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {
            Py_DECREF(tmp_called_name_2);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 480;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_2;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_EC_KEY_free);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 480;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_c83a206dfc0a5b352706e7cad0f33b53->m_frame.f_lineno = 480;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 480;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c83a206dfc0a5b352706e7cad0f33b53);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_c83a206dfc0a5b352706e7cad0f33b53);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c83a206dfc0a5b352706e7cad0f33b53);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_c83a206dfc0a5b352706e7cad0f33b53, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_c83a206dfc0a5b352706e7cad0f33b53->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_c83a206dfc0a5b352706e7cad0f33b53, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c83a206dfc0a5b352706e7cad0f33b53,
        type_description_1,
        par_self,
        var_key
    );


    // Release cached frame.
    if (frame_c83a206dfc0a5b352706e7cad0f33b53 == cache_frame_c83a206dfc0a5b352706e7cad0f33b53) {
        Py_DECREF(frame_c83a206dfc0a5b352706e7cad0f33b53);
    }
    cache_frame_c83a206dfc0a5b352706e7cad0f33b53 = NULL;

    assertFrameObject(frame_c83a206dfc0a5b352706e7cad0f33b53);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_23__to_EC_KEY);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_key);
    Py_DECREF(var_key);
    var_key = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_key);
    var_key = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_23__to_EC_KEY);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_24_get_elliptic_curves(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_FrameObject *frame_abddb661c4d0d4ad0339365c339f0316;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_abddb661c4d0d4ad0339365c339f0316 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_abddb661c4d0d4ad0339365c339f0316, codeobj_abddb661c4d0d4ad0339365c339f0316, module_OpenSSL$crypto, 0);
    frame_abddb661c4d0d4ad0339365c339f0316 = cache_frame_abddb661c4d0d4ad0339365c339f0316;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_abddb661c4d0d4ad0339365c339f0316);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_abddb661c4d0d4ad0339365c339f0316) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__EllipticCurve);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__EllipticCurve);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3420 ], 43, 0);
            exception_tb = NULL;

            exception_lineno = 495;

            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__get_elliptic_curves);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 495;

            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 495;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = tmp_mvar_value_2;
        frame_abddb661c4d0d4ad0339365c339f0316->m_frame.f_lineno = 495;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 495;

            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_abddb661c4d0d4ad0339365c339f0316);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_abddb661c4d0d4ad0339365c339f0316);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_abddb661c4d0d4ad0339365c339f0316);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_abddb661c4d0d4ad0339365c339f0316, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_abddb661c4d0d4ad0339365c339f0316->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_abddb661c4d0d4ad0339365c339f0316, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_abddb661c4d0d4ad0339365c339f0316,
        type_description_1
    );


    // Release cached frame.
    if (frame_abddb661c4d0d4ad0339365c339f0316 == cache_frame_abddb661c4d0d4ad0339365c339f0316) {
        Py_DECREF(frame_abddb661c4d0d4ad0339365c339f0316);
    }
    cache_frame_abddb661c4d0d4ad0339365c339f0316 = NULL;

    assertFrameObject(frame_abddb661c4d0d4ad0339365c339f0316);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_24_get_elliptic_curves);
    return NULL;

function_exception_exit:
    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_25_get_elliptic_curve(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_name = python_pars[0];
    PyObject *var_curve = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_e3d47dcc2e5c78370ad068837f5c1643;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_e3d47dcc2e5c78370ad068837f5c1643 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_e3d47dcc2e5c78370ad068837f5c1643, codeobj_e3d47dcc2e5c78370ad068837f5c1643, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *));
    frame_e3d47dcc2e5c78370ad068837f5c1643 = cache_frame_e3d47dcc2e5c78370ad068837f5c1643;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_e3d47dcc2e5c78370ad068837f5c1643);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_e3d47dcc2e5c78370ad068837f5c1643) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_get_elliptic_curves);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_get_elliptic_curves);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3463 ], 48, 0);
            exception_tb = NULL;

            exception_lineno = 510;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        frame_e3d47dcc2e5c78370ad068837f5c1643->m_frame.f_lineno = 510;
        tmp_iter_arg_1 = CALL_FUNCTION_NO_ARGS(tmp_called_name_1);
        if (tmp_iter_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 510;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_1 = MAKE_ITERATOR(tmp_iter_arg_1);
        Py_DECREF(tmp_iter_arg_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 510;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert(tmp_for_loop_1__for_iterator == NULL);
        tmp_for_loop_1__for_iterator = tmp_assign_source_1;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT(tmp_for_loop_1__for_iterator);
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_2 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_2 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "oo";
                exception_lineno = 510;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_2;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_3;
        CHECK_OBJECT(tmp_for_loop_1__iter_value);
        tmp_assign_source_3 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_curve;
            var_curve = tmp_assign_source_3;
            Py_INCREF(var_curve);
            Py_XDECREF(old);
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(var_curve);
        tmp_source_name_1 = var_curve;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_name);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 511;
            type_description_1 = "oo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT(par_name);
        tmp_compexpr_right_1 = par_name;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 511;
            type_description_1 = "oo";
            goto try_except_handler_2;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        CHECK_OBJECT(var_curve);
        tmp_return_value = var_curve;
        Py_INCREF(tmp_return_value);
        goto try_return_handler_2;
        branch_no_1:;
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


        exception_lineno = 510;
        type_description_1 = "oo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT((PyObject *)tmp_for_loop_1__iter_value);
    Py_DECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    goto frame_return_exit_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    {
        PyObject *tmp_raise_type_1;
        PyObject *tmp_make_exception_arg_1;
        PyObject *tmp_make_exception_arg_2;
        tmp_make_exception_arg_1 = const_str_digest_95aba6f0be0722dff4a715f251a45159;
        CHECK_OBJECT(par_name);
        tmp_make_exception_arg_2 = par_name;
        frame_e3d47dcc2e5c78370ad068837f5c1643->m_frame.f_lineno = 513;
        {
            PyObject *call_args[] = {tmp_make_exception_arg_1, tmp_make_exception_arg_2};
            tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS2(PyExc_ValueError, call_args);
        }

        assert(!(tmp_raise_type_1 == NULL));
        exception_type = tmp_raise_type_1;
        exception_lineno = 513;
        RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e3d47dcc2e5c78370ad068837f5c1643);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_e3d47dcc2e5c78370ad068837f5c1643);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e3d47dcc2e5c78370ad068837f5c1643);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_e3d47dcc2e5c78370ad068837f5c1643, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_e3d47dcc2e5c78370ad068837f5c1643->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_e3d47dcc2e5c78370ad068837f5c1643, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e3d47dcc2e5c78370ad068837f5c1643,
        type_description_1,
        par_name,
        var_curve
    );


    // Release cached frame.
    if (frame_e3d47dcc2e5c78370ad068837f5c1643 == cache_frame_e3d47dcc2e5c78370ad068837f5c1643) {
        Py_DECREF(frame_e3d47dcc2e5c78370ad068837f5c1643);
    }
    cache_frame_e3d47dcc2e5c78370ad068837f5c1643 = NULL;

    assertFrameObject(frame_e3d47dcc2e5c78370ad068837f5c1643);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_25_get_elliptic_curve);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_curve);
    Py_DECREF(var_curve);
    var_curve = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_curve);
    var_curve = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_25_get_elliptic_curve);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_name);
    Py_DECREF(par_name);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_name);
    Py_DECREF(par_name);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_26___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_name = python_pars[1];
    struct Nuitka_FrameObject *frame_06e2adf77b5f629c14d7d22dc40bc355;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_06e2adf77b5f629c14d7d22dc40bc355 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_06e2adf77b5f629c14d7d22dc40bc355, codeobj_06e2adf77b5f629c14d7d22dc40bc355, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *));
    frame_06e2adf77b5f629c14d7d22dc40bc355 = cache_frame_06e2adf77b5f629c14d7d22dc40bc355;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_06e2adf77b5f629c14d7d22dc40bc355);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_06e2adf77b5f629c14d7d22dc40bc355) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 548;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_X509_NAME_dup);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 548;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_name);
        tmp_source_name_2 = par_name;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__name);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 548;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_06e2adf77b5f629c14d7d22dc40bc355->m_frame.f_lineno = 548;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 548;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = par_name;
            assert(old != NULL);
            par_name = tmp_assign_source_1;
            Py_DECREF(old);
        }

    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 549;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_gc);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 549;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_name);
        tmp_args_element_name_2 = par_name;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {
            Py_DECREF(tmp_called_name_2);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 549;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_3;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_X509_NAME_free);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 549;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_06e2adf77b5f629c14d7d22dc40bc355->m_frame.f_lineno = 549;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 549;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__name, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 549;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_06e2adf77b5f629c14d7d22dc40bc355);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_06e2adf77b5f629c14d7d22dc40bc355);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_06e2adf77b5f629c14d7d22dc40bc355, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_06e2adf77b5f629c14d7d22dc40bc355->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_06e2adf77b5f629c14d7d22dc40bc355, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_06e2adf77b5f629c14d7d22dc40bc355,
        type_description_1,
        par_self,
        par_name
    );


    // Release cached frame.
    if (frame_06e2adf77b5f629c14d7d22dc40bc355 == cache_frame_06e2adf77b5f629c14d7d22dc40bc355) {
        Py_DECREF(frame_06e2adf77b5f629c14d7d22dc40bc355);
    }
    cache_frame_06e2adf77b5f629c14d7d22dc40bc355 = NULL;

    assertFrameObject(frame_06e2adf77b5f629c14d7d22dc40bc355);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_26___init__);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)par_name);
    Py_DECREF(par_name);
    par_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)par_name);
    Py_DECREF(par_name);
    par_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_26___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_27___setattr__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_name = python_pars[1];
    PyObject *par_value = python_pars[2];
    PyObject *var_i = NULL;
    PyObject *var_nid = NULL;
    PyObject *var_ent_obj = NULL;
    PyObject *var_ent = NULL;
    PyObject *var_ent_nid = NULL;
    PyObject *var_add_result = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_53fed2bee792bc330db8eb5d73e6e5ef;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    bool tmp_result;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    static struct Nuitka_FrameObject *cache_frame_53fed2bee792bc330db8eb5d73e6e5ef = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_53fed2bee792bc330db8eb5d73e6e5ef, codeobj_53fed2bee792bc330db8eb5d73e6e5ef, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_53fed2bee792bc330db8eb5d73e6e5ef = cache_frame_53fed2bee792bc330db8eb5d73e6e5ef;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_53fed2bee792bc330db8eb5d73e6e5ef);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_53fed2bee792bc330db8eb5d73e6e5ef) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        int tmp_truth_name_1;
        CHECK_OBJECT(par_name);
        tmp_called_instance_1 = par_name;
        frame_53fed2bee792bc330db8eb5d73e6e5ef->m_frame.f_lineno = 552;
        tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_startswith, &PyTuple_GET_ITEM(const_tuple_str_plain___tuple, 0));

        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 552;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE(tmp_call_result_1);
        if (tmp_truth_name_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_call_result_1);

            exception_lineno = 552;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_call_result_1);
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_type_name_1;
            PyObject *tmp_mvar_value_1;
            PyObject *tmp_object_name_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Name);

            if (unlikely(tmp_mvar_value_1 == NULL)) {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Name);
            }

            if (tmp_mvar_value_1 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 1105 ], 37, 0);
                exception_tb = NULL;

                exception_lineno = 553;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_type_name_1 = tmp_mvar_value_1;
            CHECK_OBJECT(par_self);
            tmp_object_name_1 = par_self;
            tmp_called_instance_2 = BUILTIN_SUPER(tmp_type_name_1, tmp_object_name_1);
            if (tmp_called_instance_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 553;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(par_name);
            tmp_args_element_name_1 = par_name;
            CHECK_OBJECT(par_value);
            tmp_args_element_name_2 = par_value;
            frame_53fed2bee792bc330db8eb5d73e6e5ef->m_frame.f_lineno = 553;
            {
                PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
                tmp_return_value = CALL_METHOD_WITH_ARGS2(tmp_called_instance_2, const_str_plain___setattr__, call_args);
            }

            Py_DECREF(tmp_called_instance_2);
            if (tmp_return_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 553;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_type_arg_1;
        CHECK_OBJECT(par_name);
        tmp_type_arg_1 = par_name;
        tmp_compexpr_left_1 = BUILTIN_TYPE1(tmp_type_arg_1);
        assert(!(tmp_compexpr_left_1 == NULL));
        tmp_compexpr_right_1 = (PyObject *)&PyString_Type;
        tmp_condition_result_2 = (tmp_compexpr_left_1 != tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_compexpr_left_1);
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            PyObject *tmp_tuple_element_1;
            PyObject *tmp_source_name_1;
            PyObject *tmp_type_arg_2;
            tmp_left_name_1 = const_str_digest_bbde1e297eda38e770b8fce1d06c225b;
            CHECK_OBJECT(par_value);
            tmp_type_arg_2 = par_value;
            tmp_source_name_1 = BUILTIN_TYPE1(tmp_type_arg_2);
            assert(!(tmp_source_name_1 == NULL));
            tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain___name__);
            Py_DECREF(tmp_source_name_1);
            if (tmp_tuple_element_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 559;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_right_name_1 = PyTuple_New(1);
            PyTuple_SET_ITEM(tmp_right_name_1, 0, tmp_tuple_element_1);
            tmp_make_exception_arg_1 = BINARY_OPERATION_MOD_STR_TUPLE(tmp_left_name_1, tmp_right_name_1);
            Py_DECREF(tmp_right_name_1);
            if (tmp_make_exception_arg_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 558;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            frame_53fed2bee792bc330db8eb5d73e6e5ef->m_frame.f_lineno = 558;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            Py_DECREF(tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 558;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 561;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_OBJ_txt2nid);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 561;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__byte_string);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__byte_string);
        }

        if (tmp_mvar_value_3 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3511 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 561;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_3;
        CHECK_OBJECT(par_name);
        tmp_args_element_name_4 = par_name;
        frame_53fed2bee792bc330db8eb5d73e6e5ef->m_frame.f_lineno = 561;
        tmp_args_element_name_3 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_4);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 561;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        frame_53fed2bee792bc330db8eb5d73e6e5ef->m_frame.f_lineno = 561;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_3);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 561;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_nid == NULL);
        var_nid = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_4;
        CHECK_OBJECT(var_nid);
        tmp_compexpr_left_2 = var_nid;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 562;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_4;
        tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_NID_undef);
        if (tmp_compexpr_right_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 562;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
        Py_DECREF(tmp_compexpr_right_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 562;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
            goto branch_yes_3;
        } else {
            goto branch_no_3;
        }
        branch_yes_3:;
        // Tried code:
        {
            PyObject *tmp_called_name_3;
            PyObject *tmp_mvar_value_5;
            PyObject *tmp_call_result_2;
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error);

            if (unlikely(tmp_mvar_value_5 == NULL)) {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error);
            }

            if (tmp_mvar_value_5 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 0 ], 49, 0);
                exception_tb = NULL;

                exception_lineno = 564;
                type_description_1 = "ooooooooo";
                goto try_except_handler_2;
            }

            tmp_called_name_3 = tmp_mvar_value_5;
            frame_53fed2bee792bc330db8eb5d73e6e5ef->m_frame.f_lineno = 564;
            tmp_call_result_2 = CALL_FUNCTION_NO_ARGS(tmp_called_name_3);
            if (tmp_call_result_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 564;
                type_description_1 = "ooooooooo";
                goto try_except_handler_2;
            }
            Py_DECREF(tmp_call_result_2);
        }
        goto try_end_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Preserve existing published exception.
        PRESERVE_FRAME_EXCEPTION(frame_53fed2bee792bc330db8eb5d73e6e5ef);
        if (exception_keeper_tb_1 == NULL) {
            exception_keeper_tb_1 = MAKE_TRACEBACK(frame_53fed2bee792bc330db8eb5d73e6e5ef, exception_keeper_lineno_1);
        } else if (exception_keeper_lineno_1 != 0) {
            exception_keeper_tb_1 = ADD_TRACEBACK(exception_keeper_tb_1, frame_53fed2bee792bc330db8eb5d73e6e5ef, exception_keeper_lineno_1);
        }

        NORMALIZE_EXCEPTION(&exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1);
        PUBLISH_EXCEPTION(&exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1);
        {
            nuitka_bool tmp_condition_result_4;
            PyObject *tmp_operand_name_1;
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            PyObject *tmp_mvar_value_6;
            tmp_compexpr_left_3 = EXC_TYPE(PyThreadState_GET());
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_Error);

            if (unlikely(tmp_mvar_value_6 == NULL)) {
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_Error);
            }

            if (tmp_mvar_value_6 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 49 ], 34, 0);
                exception_tb = NULL;

                exception_lineno = 565;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_3 = tmp_mvar_value_6;
            tmp_res = EXCEPTION_MATCH_BOOL(tmp_compexpr_left_3, tmp_compexpr_right_3);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 565;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 565;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_4 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_4 == NUITKA_BOOL_TRUE) {
                goto branch_yes_4;
            } else {
                goto branch_no_4;
            }
            branch_yes_4:;
            tmp_result = RERAISE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            if (unlikely(tmp_result == false)) {
                exception_lineno = 563;
            }

            if (exception_tb && exception_tb->tb_frame == &frame_53fed2bee792bc330db8eb5d73e6e5ef->m_frame) frame_53fed2bee792bc330db8eb5d73e6e5ef->m_frame.f_lineno = exception_tb->tb_lineno;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
            branch_no_4:;
        }
        goto try_end_1;
        // exception handler codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_27___setattr__);
        return NULL;
        // End of try:
        try_end_1:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            tmp_make_exception_arg_2 = const_str_digest_7b5d428ebb9708d902c18ce8ddfb3cbc;
            frame_53fed2bee792bc330db8eb5d73e6e5ef->m_frame.f_lineno = 567;
            tmp_raise_type_2 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_AttributeError, tmp_make_exception_arg_2);
            assert(!(tmp_raise_type_2 == NULL));
            exception_type = tmp_raise_type_2;
            exception_lineno = 567;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_3:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_range_arg_1;
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_5;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_7 == NULL)) {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_7 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 570;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_7;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_X509_NAME_entry_count);
        if (tmp_called_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 570;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_5 = par_self;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain__name);
        if (tmp_args_element_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_4);

            exception_lineno = 570;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        frame_53fed2bee792bc330db8eb5d73e6e5ef->m_frame.f_lineno = 570;
        tmp_range_arg_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_4, tmp_args_element_name_5);
        Py_DECREF(tmp_called_name_4);
        Py_DECREF(tmp_args_element_name_5);
        if (tmp_range_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 570;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_iter_arg_1 = BUILTIN_RANGE(tmp_range_arg_1);
        Py_DECREF(tmp_range_arg_1);
        if (tmp_iter_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 570;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_2 = MAKE_ITERATOR(tmp_iter_arg_1);
        Py_DECREF(tmp_iter_arg_1);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 570;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert(tmp_for_loop_1__for_iterator == NULL);
        tmp_for_loop_1__for_iterator = tmp_assign_source_2;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_3;
        CHECK_OBJECT(tmp_for_loop_1__for_iterator);
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_3 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_3 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "ooooooooo";
                exception_lineno = 570;
                goto try_except_handler_3;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_3;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_4;
        CHECK_OBJECT(tmp_for_loop_1__iter_value);
        tmp_assign_source_4 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_i;
            var_i = tmp_assign_source_4;
            Py_INCREF(var_i);
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_called_name_5;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_source_name_7;
        PyObject *tmp_args_element_name_7;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_8 == NULL)) {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_8 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 571;
            type_description_1 = "ooooooooo";
            goto try_except_handler_3;
        }

        tmp_source_name_6 = tmp_mvar_value_8;
        tmp_called_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_X509_NAME_get_entry);
        if (tmp_called_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 571;
            type_description_1 = "ooooooooo";
            goto try_except_handler_3;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_7 = par_self;
        tmp_args_element_name_6 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain__name);
        if (tmp_args_element_name_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_5);

            exception_lineno = 571;
            type_description_1 = "ooooooooo";
            goto try_except_handler_3;
        }
        CHECK_OBJECT(var_i);
        tmp_args_element_name_7 = var_i;
        frame_53fed2bee792bc330db8eb5d73e6e5ef->m_frame.f_lineno = 571;
        {
            PyObject *call_args[] = {tmp_args_element_name_6, tmp_args_element_name_7};
            tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_5, call_args);
        }

        Py_DECREF(tmp_called_name_5);
        Py_DECREF(tmp_args_element_name_6);
        if (tmp_assign_source_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 571;
            type_description_1 = "ooooooooo";
            goto try_except_handler_3;
        }
        {
            PyObject *old = var_ent;
            var_ent = tmp_assign_source_5;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_9;
        PyObject *tmp_args_element_name_8;
        tmp_mvar_value_9 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_9 == NULL)) {
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_9 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 572;
            type_description_1 = "ooooooooo";
            goto try_except_handler_3;
        }

        tmp_called_instance_3 = tmp_mvar_value_9;
        CHECK_OBJECT(var_ent);
        tmp_args_element_name_8 = var_ent;
        frame_53fed2bee792bc330db8eb5d73e6e5ef->m_frame.f_lineno = 572;
        {
            PyObject *call_args[] = {tmp_args_element_name_8};
            tmp_assign_source_6 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_3, const_str_plain_X509_NAME_ENTRY_get_object, call_args);
        }

        if (tmp_assign_source_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 572;
            type_description_1 = "ooooooooo";
            goto try_except_handler_3;
        }
        {
            PyObject *old = var_ent_obj;
            var_ent_obj = tmp_assign_source_6;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_called_instance_4;
        PyObject *tmp_mvar_value_10;
        PyObject *tmp_args_element_name_9;
        tmp_mvar_value_10 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_10 == NULL)) {
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_10 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 573;
            type_description_1 = "ooooooooo";
            goto try_except_handler_3;
        }

        tmp_called_instance_4 = tmp_mvar_value_10;
        CHECK_OBJECT(var_ent_obj);
        tmp_args_element_name_9 = var_ent_obj;
        frame_53fed2bee792bc330db8eb5d73e6e5ef->m_frame.f_lineno = 573;
        {
            PyObject *call_args[] = {tmp_args_element_name_9};
            tmp_assign_source_7 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_4, const_str_plain_OBJ_obj2nid, call_args);
        }

        if (tmp_assign_source_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 573;
            type_description_1 = "ooooooooo";
            goto try_except_handler_3;
        }
        {
            PyObject *old = var_ent_nid;
            var_ent_nid = tmp_assign_source_7;
            Py_XDECREF(old);
        }

    }
    {
        nuitka_bool tmp_condition_result_5;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        CHECK_OBJECT(var_nid);
        tmp_compexpr_left_4 = var_nid;
        CHECK_OBJECT(var_ent_nid);
        tmp_compexpr_right_4 = var_ent_nid;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_4, tmp_compexpr_right_4);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 574;
            type_description_1 = "ooooooooo";
            goto try_except_handler_3;
        }
        tmp_condition_result_5 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_5 == NUITKA_BOOL_TRUE) {
            goto branch_yes_5;
        } else {
            goto branch_no_5;
        }
        branch_yes_5:;
        {
            PyObject *tmp_assign_source_8;
            PyObject *tmp_called_name_6;
            PyObject *tmp_source_name_8;
            PyObject *tmp_mvar_value_11;
            PyObject *tmp_args_element_name_10;
            PyObject *tmp_source_name_9;
            PyObject *tmp_args_element_name_11;
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_11 == NULL)) {
                tmp_mvar_value_11 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_11 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 575;
                type_description_1 = "ooooooooo";
                goto try_except_handler_3;
            }

            tmp_source_name_8 = tmp_mvar_value_11;
            tmp_called_name_6 = LOOKUP_ATTRIBUTE(tmp_source_name_8, const_str_plain_X509_NAME_delete_entry);
            if (tmp_called_name_6 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 575;
                type_description_1 = "ooooooooo";
                goto try_except_handler_3;
            }
            CHECK_OBJECT(par_self);
            tmp_source_name_9 = par_self;
            tmp_args_element_name_10 = LOOKUP_ATTRIBUTE(tmp_source_name_9, const_str_plain__name);
            if (tmp_args_element_name_10 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_6);

                exception_lineno = 575;
                type_description_1 = "ooooooooo";
                goto try_except_handler_3;
            }
            CHECK_OBJECT(var_i);
            tmp_args_element_name_11 = var_i;
            frame_53fed2bee792bc330db8eb5d73e6e5ef->m_frame.f_lineno = 575;
            {
                PyObject *call_args[] = {tmp_args_element_name_10, tmp_args_element_name_11};
                tmp_assign_source_8 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_6, call_args);
            }

            Py_DECREF(tmp_called_name_6);
            Py_DECREF(tmp_args_element_name_10);
            if (tmp_assign_source_8 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 575;
                type_description_1 = "ooooooooo";
                goto try_except_handler_3;
            }
            {
                PyObject *old = var_ent;
                assert(old != NULL);
                var_ent = tmp_assign_source_8;
                Py_DECREF(old);
            }

        }
        {
            PyObject *tmp_called_instance_5;
            PyObject *tmp_mvar_value_12;
            PyObject *tmp_call_result_3;
            PyObject *tmp_args_element_name_12;
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_12 == NULL)) {
                tmp_mvar_value_12 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_12 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 576;
                type_description_1 = "ooooooooo";
                goto try_except_handler_3;
            }

            tmp_called_instance_5 = tmp_mvar_value_12;
            CHECK_OBJECT(var_ent);
            tmp_args_element_name_12 = var_ent;
            frame_53fed2bee792bc330db8eb5d73e6e5ef->m_frame.f_lineno = 576;
            {
                PyObject *call_args[] = {tmp_args_element_name_12};
                tmp_call_result_3 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_5, const_str_plain_X509_NAME_ENTRY_free, call_args);
            }

            if (tmp_call_result_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 576;
                type_description_1 = "ooooooooo";
                goto try_except_handler_3;
            }
            Py_DECREF(tmp_call_result_3);
        }
        goto loop_end_1;
        branch_no_5:;
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


        exception_lineno = 570;
        type_description_1 = "ooooooooo";
        goto try_except_handler_3;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    {
        nuitka_bool tmp_condition_result_6;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_13;
        CHECK_OBJECT(par_value);
        tmp_isinstance_inst_1 = par_value;
        tmp_mvar_value_13 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__text_type);

        if (unlikely(tmp_mvar_value_13 == NULL)) {
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__text_type);
        }

        if (tmp_mvar_value_13 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3552 ], 39, 0);
            exception_tb = NULL;

            exception_lineno = 579;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_13;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 579;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_6 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_6 == NUITKA_BOOL_TRUE) {
            goto branch_yes_6;
        } else {
            goto branch_no_6;
        }
        branch_yes_6:;
        {
            PyObject *tmp_assign_source_9;
            PyObject *tmp_called_instance_6;
            CHECK_OBJECT(par_value);
            tmp_called_instance_6 = par_value;
            frame_53fed2bee792bc330db8eb5d73e6e5ef->m_frame.f_lineno = 580;
            tmp_assign_source_9 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_6, const_str_plain_encode, &PyTuple_GET_ITEM(const_tuple_str_digest_c075052d723d6707083e869a0e3659bb_tuple, 0));

            if (tmp_assign_source_9 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 580;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_value;
                assert(old != NULL);
                par_value = tmp_assign_source_9;
                Py_DECREF(old);
            }

        }
        branch_no_6:;
    }
    {
        PyObject *tmp_assign_source_10;
        PyObject *tmp_called_name_7;
        PyObject *tmp_source_name_10;
        PyObject *tmp_mvar_value_14;
        PyObject *tmp_args_element_name_13;
        PyObject *tmp_source_name_11;
        PyObject *tmp_args_element_name_14;
        PyObject *tmp_args_element_name_15;
        PyObject *tmp_source_name_12;
        PyObject *tmp_mvar_value_15;
        PyObject *tmp_args_element_name_16;
        PyObject *tmp_args_element_name_17;
        PyObject *tmp_args_element_name_18;
        PyObject *tmp_args_element_name_19;
        tmp_mvar_value_14 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_14 == NULL)) {
            tmp_mvar_value_14 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_14 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 582;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_10 = tmp_mvar_value_14;
        tmp_called_name_7 = LOOKUP_ATTRIBUTE(tmp_source_name_10, const_str_plain_X509_NAME_add_entry_by_NID);
        if (tmp_called_name_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 582;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_11 = par_self;
        tmp_args_element_name_13 = LOOKUP_ATTRIBUTE(tmp_source_name_11, const_str_plain__name);
        if (tmp_args_element_name_13 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_7);

            exception_lineno = 583;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_nid);
        tmp_args_element_name_14 = var_nid;
        tmp_mvar_value_15 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_15 == NULL)) {
            tmp_mvar_value_15 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_15 == NULL) {
            Py_DECREF(tmp_called_name_7);
            Py_DECREF(tmp_args_element_name_13);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 583;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_12 = tmp_mvar_value_15;
        tmp_args_element_name_15 = LOOKUP_ATTRIBUTE(tmp_source_name_12, const_str_plain_MBSTRING_UTF8);
        if (tmp_args_element_name_15 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_7);
            Py_DECREF(tmp_args_element_name_13);

            exception_lineno = 583;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_value);
        tmp_args_element_name_16 = par_value;
        tmp_args_element_name_17 = const_int_neg_1;
        tmp_args_element_name_18 = const_int_neg_1;
        tmp_args_element_name_19 = const_int_0;
        frame_53fed2bee792bc330db8eb5d73e6e5ef->m_frame.f_lineno = 582;
        {
            PyObject *call_args[] = {tmp_args_element_name_13, tmp_args_element_name_14, tmp_args_element_name_15, tmp_args_element_name_16, tmp_args_element_name_17, tmp_args_element_name_18, tmp_args_element_name_19};
            tmp_assign_source_10 = CALL_FUNCTION_WITH_ARGS7(tmp_called_name_7, call_args);
        }

        Py_DECREF(tmp_called_name_7);
        Py_DECREF(tmp_args_element_name_13);
        Py_DECREF(tmp_args_element_name_15);
        if (tmp_assign_source_10 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 582;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_add_result == NULL);
        var_add_result = tmp_assign_source_10;
    }
    {
        nuitka_bool tmp_condition_result_7;
        PyObject *tmp_operand_name_2;
        CHECK_OBJECT(var_add_result);
        tmp_operand_name_2 = var_add_result;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 584;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_7 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_7 == NUITKA_BOOL_TRUE) {
            goto branch_yes_7;
        } else {
            goto branch_no_7;
        }
        branch_yes_7:;
        {
            PyObject *tmp_called_name_8;
            PyObject *tmp_mvar_value_16;
            PyObject *tmp_call_result_4;
            tmp_mvar_value_16 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error);

            if (unlikely(tmp_mvar_value_16 == NULL)) {
                tmp_mvar_value_16 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error);
            }

            if (tmp_mvar_value_16 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 0 ], 49, 0);
                exception_tb = NULL;

                exception_lineno = 585;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_8 = tmp_mvar_value_16;
            frame_53fed2bee792bc330db8eb5d73e6e5ef->m_frame.f_lineno = 585;
            tmp_call_result_4 = CALL_FUNCTION_NO_ARGS(tmp_called_name_8);
            if (tmp_call_result_4 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 585;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_4);
        }
        branch_no_7:;
    }

#if 1
    RESTORE_FRAME_EXCEPTION(frame_53fed2bee792bc330db8eb5d73e6e5ef);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION(frame_53fed2bee792bc330db8eb5d73e6e5ef);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION(frame_53fed2bee792bc330db8eb5d73e6e5ef);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_53fed2bee792bc330db8eb5d73e6e5ef, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_53fed2bee792bc330db8eb5d73e6e5ef->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_53fed2bee792bc330db8eb5d73e6e5ef, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_53fed2bee792bc330db8eb5d73e6e5ef,
        type_description_1,
        par_self,
        par_name,
        par_value,
        var_i,
        var_nid,
        var_ent_obj,
        var_ent,
        var_ent_nid,
        var_add_result
    );


    // Release cached frame.
    if (frame_53fed2bee792bc330db8eb5d73e6e5ef == cache_frame_53fed2bee792bc330db8eb5d73e6e5ef) {
        Py_DECREF(frame_53fed2bee792bc330db8eb5d73e6e5ef);
    }
    cache_frame_53fed2bee792bc330db8eb5d73e6e5ef = NULL;

    assertFrameObject(frame_53fed2bee792bc330db8eb5d73e6e5ef);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_27___setattr__);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_i);
    var_i = NULL;

    Py_XDECREF(var_nid);
    var_nid = NULL;

    Py_XDECREF(var_ent_obj);
    var_ent_obj = NULL;

    Py_XDECREF(var_ent);
    var_ent = NULL;

    Py_XDECREF(par_value);
    par_value = NULL;

    Py_XDECREF(var_ent_nid);
    var_ent_nid = NULL;

    Py_XDECREF(var_add_result);
    var_add_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_i);
    var_i = NULL;

    Py_XDECREF(var_nid);
    var_nid = NULL;

    Py_XDECREF(var_ent_obj);
    var_ent_obj = NULL;

    Py_XDECREF(var_ent);
    var_ent = NULL;

    Py_XDECREF(par_value);
    par_value = NULL;

    Py_XDECREF(var_ent_nid);
    var_ent_nid = NULL;

    Py_XDECREF(var_add_result);
    var_add_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_27___setattr__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_name);
    Py_DECREF(par_name);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_name);
    Py_DECREF(par_name);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_28___getattr__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_name = python_pars[1];
    PyObject *var_result_buffer = NULL;
    PyObject *var_data_length = NULL;
    PyObject *var_nid = NULL;
    PyObject *var_result = NULL;
    PyObject *var_entry_index = NULL;
    PyObject *var_entry = NULL;
    PyObject *var_data = NULL;
    struct Nuitka_FrameObject *frame_3731d5a3d74f70f79665c7581fc4f176;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    bool tmp_result;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    static struct Nuitka_FrameObject *cache_frame_3731d5a3d74f70f79665c7581fc4f176 = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_3731d5a3d74f70f79665c7581fc4f176, codeobj_3731d5a3d74f70f79665c7581fc4f176, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_3731d5a3d74f70f79665c7581fc4f176 = cache_frame_3731d5a3d74f70f79665c7581fc4f176;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_3731d5a3d74f70f79665c7581fc4f176);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_3731d5a3d74f70f79665c7581fc4f176) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 594;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_OBJ_txt2nid);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 594;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__byte_string);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__byte_string);
        }

        if (tmp_mvar_value_2 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3511 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 594;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT(par_name);
        tmp_args_element_name_2 = par_name;
        frame_3731d5a3d74f70f79665c7581fc4f176->m_frame.f_lineno = 594;
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_2);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 594;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        frame_3731d5a3d74f70f79665c7581fc4f176->m_frame.f_lineno = 594;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 594;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_nid == NULL);
        var_nid = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        CHECK_OBJECT(var_nid);
        tmp_compexpr_left_1 = var_nid;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 595;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_NID_undef);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 595;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 595;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        // Tried code:
        {
            PyObject *tmp_called_name_3;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_call_result_1;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error);
            }

            if (tmp_mvar_value_4 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 0 ], 49, 0);
                exception_tb = NULL;

                exception_lineno = 602;
                type_description_1 = "ooooooooo";
                goto try_except_handler_2;
            }

            tmp_called_name_3 = tmp_mvar_value_4;
            frame_3731d5a3d74f70f79665c7581fc4f176->m_frame.f_lineno = 602;
            tmp_call_result_1 = CALL_FUNCTION_NO_ARGS(tmp_called_name_3);
            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 602;
                type_description_1 = "ooooooooo";
                goto try_except_handler_2;
            }
            Py_DECREF(tmp_call_result_1);
        }
        goto try_end_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Preserve existing published exception.
        PRESERVE_FRAME_EXCEPTION(frame_3731d5a3d74f70f79665c7581fc4f176);
        if (exception_keeper_tb_1 == NULL) {
            exception_keeper_tb_1 = MAKE_TRACEBACK(frame_3731d5a3d74f70f79665c7581fc4f176, exception_keeper_lineno_1);
        } else if (exception_keeper_lineno_1 != 0) {
            exception_keeper_tb_1 = ADD_TRACEBACK(exception_keeper_tb_1, frame_3731d5a3d74f70f79665c7581fc4f176, exception_keeper_lineno_1);
        }

        NORMALIZE_EXCEPTION(&exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1);
        PUBLISH_EXCEPTION(&exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1);
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_operand_name_1;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_mvar_value_5;
            tmp_compexpr_left_2 = EXC_TYPE(PyThreadState_GET());
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_Error);

            if (unlikely(tmp_mvar_value_5 == NULL)) {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_Error);
            }

            if (tmp_mvar_value_5 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 49 ], 34, 0);
                exception_tb = NULL;

                exception_lineno = 603;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_2 = tmp_mvar_value_5;
            tmp_res = EXCEPTION_MATCH_BOOL(tmp_compexpr_left_2, tmp_compexpr_right_2);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 603;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 603;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
                goto branch_yes_2;
            } else {
                goto branch_no_2;
            }
            branch_yes_2:;
            tmp_result = RERAISE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            if (unlikely(tmp_result == false)) {
                exception_lineno = 601;
            }

            if (exception_tb && exception_tb->tb_frame == &frame_3731d5a3d74f70f79665c7581fc4f176->m_frame) frame_3731d5a3d74f70f79665c7581fc4f176->m_frame.f_lineno = exception_tb->tb_lineno;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
            branch_no_2:;
        }
        goto try_end_1;
        // exception handler codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_28___getattr__);
        return NULL;
        // End of try:
        try_end_1:;
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_type_name_1;
            PyObject *tmp_mvar_value_6;
            PyObject *tmp_object_name_1;
            PyObject *tmp_args_element_name_3;
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Name);

            if (unlikely(tmp_mvar_value_6 == NULL)) {
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Name);
            }

            if (tmp_mvar_value_6 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 1105 ], 37, 0);
                exception_tb = NULL;

                exception_lineno = 605;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_type_name_1 = tmp_mvar_value_6;
            CHECK_OBJECT(par_self);
            tmp_object_name_1 = par_self;
            tmp_called_instance_1 = BUILTIN_SUPER(tmp_type_name_1, tmp_object_name_1);
            if (tmp_called_instance_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 605;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(par_name);
            tmp_args_element_name_3 = par_name;
            frame_3731d5a3d74f70f79665c7581fc4f176->m_frame.f_lineno = 605;
            {
                PyObject *call_args[] = {tmp_args_element_name_3};
                tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain___getattr__, call_args);
            }

            Py_DECREF(tmp_called_instance_1);
            if (tmp_return_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 605;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_source_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_args_element_name_6;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_7 == NULL)) {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_7 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 607;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_7;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_X509_NAME_get_index_by_NID);
        if (tmp_called_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 607;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_4 = par_self;
        tmp_args_element_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain__name);
        if (tmp_args_element_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_4);

            exception_lineno = 607;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_nid);
        tmp_args_element_name_5 = var_nid;
        tmp_args_element_name_6 = const_int_neg_1;
        frame_3731d5a3d74f70f79665c7581fc4f176->m_frame.f_lineno = 607;
        {
            PyObject *call_args[] = {tmp_args_element_name_4, tmp_args_element_name_5, tmp_args_element_name_6};
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_4, call_args);
        }

        Py_DECREF(tmp_called_name_4);
        Py_DECREF(tmp_args_element_name_4);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 607;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_entry_index == NULL);
        var_entry_index = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        CHECK_OBJECT(var_entry_index);
        tmp_compexpr_left_3 = var_entry_index;
        tmp_compexpr_right_3 = const_int_neg_1;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_INT(tmp_compexpr_left_3, tmp_compexpr_right_3);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 608;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
            goto branch_yes_3;
        } else {
            goto branch_no_3;
        }
        branch_yes_3:;
        tmp_return_value = Py_None;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_3:;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_name_5;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_source_name_6;
        PyObject *tmp_args_element_name_8;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_8 == NULL)) {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_8 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 611;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_8;
        tmp_called_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_X509_NAME_get_entry);
        if (tmp_called_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 611;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_6 = par_self;
        tmp_args_element_name_7 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain__name);
        if (tmp_args_element_name_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_5);

            exception_lineno = 611;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_entry_index);
        tmp_args_element_name_8 = var_entry_index;
        frame_3731d5a3d74f70f79665c7581fc4f176->m_frame.f_lineno = 611;
        {
            PyObject *call_args[] = {tmp_args_element_name_7, tmp_args_element_name_8};
            tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_5, call_args);
        }

        Py_DECREF(tmp_called_name_5);
        Py_DECREF(tmp_args_element_name_7);
        if (tmp_assign_source_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 611;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_entry == NULL);
        var_entry = tmp_assign_source_3;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_9;
        PyObject *tmp_args_element_name_9;
        tmp_mvar_value_9 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_9 == NULL)) {
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_9 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 612;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_9;
        CHECK_OBJECT(var_entry);
        tmp_args_element_name_9 = var_entry;
        frame_3731d5a3d74f70f79665c7581fc4f176->m_frame.f_lineno = 612;
        {
            PyObject *call_args[] = {tmp_args_element_name_9};
            tmp_assign_source_4 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_X509_NAME_ENTRY_get_data, call_args);
        }

        if (tmp_assign_source_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 612;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_data == NULL);
        var_data = tmp_assign_source_4;
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_10;
        tmp_mvar_value_10 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_10 == NULL)) {
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_10 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 614;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_3 = tmp_mvar_value_10;
        frame_3731d5a3d74f70f79665c7581fc4f176->m_frame.f_lineno = 614;
        tmp_assign_source_5 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_3, const_str_plain_new, &PyTuple_GET_ITEM(const_tuple_str_digest_5339fa8ff3df372e54ef7b09078767aa_tuple, 0));

        if (tmp_assign_source_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 614;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_result_buffer == NULL);
        var_result_buffer = tmp_assign_source_5;
    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_called_instance_4;
        PyObject *tmp_mvar_value_11;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_args_element_name_11;
        tmp_mvar_value_11 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_11 == NULL)) {
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_11 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 615;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_4 = tmp_mvar_value_11;
        CHECK_OBJECT(var_result_buffer);
        tmp_args_element_name_10 = var_result_buffer;
        CHECK_OBJECT(var_data);
        tmp_args_element_name_11 = var_data;
        frame_3731d5a3d74f70f79665c7581fc4f176->m_frame.f_lineno = 615;
        {
            PyObject *call_args[] = {tmp_args_element_name_10, tmp_args_element_name_11};
            tmp_assign_source_6 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_4, const_str_plain_ASN1_STRING_to_UTF8, call_args);
        }

        if (tmp_assign_source_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 615;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_data_length == NULL);
        var_data_length = tmp_assign_source_6;
    }
    {
        PyObject *tmp_called_name_6;
        PyObject *tmp_mvar_value_12;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_12;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        tmp_mvar_value_12 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_12 == NULL)) {
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_12 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 616;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_6 = tmp_mvar_value_12;
        CHECK_OBJECT(var_data_length);
        tmp_compexpr_left_4 = var_data_length;
        tmp_compexpr_right_4 = const_int_0;
        tmp_args_element_name_12 = RICH_COMPARE_GTE_OBJECT_OBJECT(tmp_compexpr_left_4, tmp_compexpr_right_4);
        if (tmp_args_element_name_12 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 616;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        frame_3731d5a3d74f70f79665c7581fc4f176->m_frame.f_lineno = 616;
        tmp_call_result_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_6, tmp_args_element_name_12);
        Py_DECREF(tmp_args_element_name_12);
        if (tmp_call_result_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 616;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_2);
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_called_instance_5;
        Py_ssize_t tmp_sliceslicedel_index_lower_1;
        Py_ssize_t tmp_slice_index_upper_1;
        PyObject *tmp_slice_source_1;
        PyObject *tmp_called_name_7;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_13;
        PyObject *tmp_args_element_name_13;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_subscript_name_1;
        PyObject *tmp_args_element_name_14;
        tmp_sliceslicedel_index_lower_1 = 0;
        tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
        tmp_mvar_value_13 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_13 == NULL)) {
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_13 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 619;
            type_description_1 = "ooooooooo";
            goto try_except_handler_3;
        }

        tmp_source_name_7 = tmp_mvar_value_13;
        tmp_called_name_7 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain_buffer);
        if (tmp_called_name_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 619;
            type_description_1 = "ooooooooo";
            goto try_except_handler_3;
        }
        CHECK_OBJECT(var_result_buffer);
        tmp_subscribed_name_1 = var_result_buffer;
        tmp_subscript_name_1 = const_int_0;
        tmp_args_element_name_13 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_1, tmp_subscript_name_1, 0);
        if (tmp_args_element_name_13 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_7);

            exception_lineno = 620;
            type_description_1 = "ooooooooo";
            goto try_except_handler_3;
        }
        CHECK_OBJECT(var_data_length);
        tmp_args_element_name_14 = var_data_length;
        frame_3731d5a3d74f70f79665c7581fc4f176->m_frame.f_lineno = 619;
        {
            PyObject *call_args[] = {tmp_args_element_name_13, tmp_args_element_name_14};
            tmp_slice_source_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_7, call_args);
        }

        Py_DECREF(tmp_called_name_7);
        Py_DECREF(tmp_args_element_name_13);
        if (tmp_slice_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 619;
            type_description_1 = "ooooooooo";
            goto try_except_handler_3;
        }
        tmp_called_instance_5 = LOOKUP_INDEX_SLICE(tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1);
        Py_DECREF(tmp_slice_source_1);
        if (tmp_called_instance_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 619;
            type_description_1 = "ooooooooo";
            goto try_except_handler_3;
        }
        frame_3731d5a3d74f70f79665c7581fc4f176->m_frame.f_lineno = 619;
        tmp_assign_source_7 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_5, const_str_plain_decode, &PyTuple_GET_ITEM(const_tuple_str_digest_c075052d723d6707083e869a0e3659bb_tuple, 0));

        Py_DECREF(tmp_called_instance_5);
        if (tmp_assign_source_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 619;
            type_description_1 = "ooooooooo";
            goto try_except_handler_3;
        }
        assert(var_result == NULL);
        var_result = tmp_assign_source_7;
    }
    goto try_end_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    {
        PyObject *tmp_called_name_8;
        PyObject *tmp_source_name_8;
        PyObject *tmp_mvar_value_14;
        PyObject *tmp_call_result_3;
        PyObject *tmp_args_element_name_15;
        PyObject *tmp_subscribed_name_2;
        PyObject *tmp_subscript_name_2;
        tmp_mvar_value_14 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_14 == NULL)) {
            tmp_mvar_value_14 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_14 == NULL) {

            Py_DECREF(exception_keeper_type_2);
            Py_XDECREF(exception_keeper_value_2);
            Py_XDECREF(exception_keeper_tb_2);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 624;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_8 = tmp_mvar_value_14;
        tmp_called_name_8 = LOOKUP_ATTRIBUTE(tmp_source_name_8, const_str_plain_OPENSSL_free);
        if (tmp_called_name_8 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);

            Py_DECREF(exception_keeper_type_2);
            Py_XDECREF(exception_keeper_value_2);
            Py_XDECREF(exception_keeper_tb_2);

            exception_lineno = 624;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_result_buffer);
        tmp_subscribed_name_2 = var_result_buffer;
        tmp_subscript_name_2 = const_int_0;
        tmp_args_element_name_15 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_2, tmp_subscript_name_2, 0);
        if (tmp_args_element_name_15 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_8);
            Py_DECREF(exception_keeper_type_2);
            Py_XDECREF(exception_keeper_value_2);
            Py_XDECREF(exception_keeper_tb_2);

            exception_lineno = 624;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        frame_3731d5a3d74f70f79665c7581fc4f176->m_frame.f_lineno = 624;
        tmp_call_result_3 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_8, tmp_args_element_name_15);
        Py_DECREF(tmp_called_name_8);
        Py_DECREF(tmp_args_element_name_15);
        if (tmp_call_result_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);

            Py_DECREF(exception_keeper_type_2);
            Py_XDECREF(exception_keeper_value_2);
            Py_XDECREF(exception_keeper_tb_2);

            exception_lineno = 624;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_3);
    }
    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    {
        PyObject *tmp_called_name_9;
        PyObject *tmp_source_name_9;
        PyObject *tmp_mvar_value_15;
        PyObject *tmp_call_result_4;
        PyObject *tmp_args_element_name_16;
        PyObject *tmp_subscribed_name_3;
        PyObject *tmp_subscript_name_3;
        tmp_mvar_value_15 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_15 == NULL)) {
            tmp_mvar_value_15 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_15 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 624;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_9 = tmp_mvar_value_15;
        tmp_called_name_9 = LOOKUP_ATTRIBUTE(tmp_source_name_9, const_str_plain_OPENSSL_free);
        if (tmp_called_name_9 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 624;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_result_buffer);
        tmp_subscribed_name_3 = var_result_buffer;
        tmp_subscript_name_3 = const_int_0;
        tmp_args_element_name_16 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_3, tmp_subscript_name_3, 0);
        if (tmp_args_element_name_16 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_9);

            exception_lineno = 624;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        frame_3731d5a3d74f70f79665c7581fc4f176->m_frame.f_lineno = 624;
        tmp_call_result_4 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_9, tmp_args_element_name_16);
        Py_DECREF(tmp_called_name_9);
        Py_DECREF(tmp_args_element_name_16);
        if (tmp_call_result_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 624;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_4);
    }

#if 1
    RESTORE_FRAME_EXCEPTION(frame_3731d5a3d74f70f79665c7581fc4f176);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION(frame_3731d5a3d74f70f79665c7581fc4f176);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION(frame_3731d5a3d74f70f79665c7581fc4f176);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_3731d5a3d74f70f79665c7581fc4f176, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_3731d5a3d74f70f79665c7581fc4f176->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_3731d5a3d74f70f79665c7581fc4f176, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3731d5a3d74f70f79665c7581fc4f176,
        type_description_1,
        par_self,
        par_name,
        var_result_buffer,
        var_data_length,
        var_nid,
        var_result,
        var_entry_index,
        var_entry,
        var_data
    );


    // Release cached frame.
    if (frame_3731d5a3d74f70f79665c7581fc4f176 == cache_frame_3731d5a3d74f70f79665c7581fc4f176) {
        Py_DECREF(frame_3731d5a3d74f70f79665c7581fc4f176);
    }
    cache_frame_3731d5a3d74f70f79665c7581fc4f176 = NULL;

    assertFrameObject(frame_3731d5a3d74f70f79665c7581fc4f176);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT(var_result);
    tmp_return_value = var_result;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_28___getattr__);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_result_buffer);
    var_result_buffer = NULL;

    Py_XDECREF(var_data_length);
    var_data_length = NULL;

    CHECK_OBJECT((PyObject *)var_nid);
    Py_DECREF(var_nid);
    var_nid = NULL;

    Py_XDECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_entry_index);
    var_entry_index = NULL;

    Py_XDECREF(var_entry);
    var_entry = NULL;

    Py_XDECREF(var_data);
    var_data = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_result_buffer);
    var_result_buffer = NULL;

    Py_XDECREF(var_data_length);
    var_data_length = NULL;

    Py_XDECREF(var_nid);
    var_nid = NULL;

    Py_XDECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_entry_index);
    var_entry_index = NULL;

    Py_XDECREF(var_entry);
    var_entry = NULL;

    Py_XDECREF(var_data);
    var_data = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_28___getattr__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_name);
    Py_DECREF(par_name);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_name);
    Py_DECREF(par_name);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_29__cmp(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_op = PyCell_NEW1(python_pars[0]);
    PyObject *var_f = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = MAKE_FUNCTION_OpenSSL$crypto$$$function_29__cmp$$$function_1_f();

        ((struct Nuitka_FunctionObject *)tmp_assign_source_1)->m_closure[0] = par_op;
        Py_INCREF(((struct Nuitka_FunctionObject *)tmp_assign_source_1)->m_closure[0]);


        assert(var_f == NULL);
        var_f = tmp_assign_source_1;
    }
    // Tried code:
    CHECK_OBJECT(var_f);
    tmp_return_value = var_f;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_29__cmp);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_f);
    Py_DECREF(var_f);
    var_f = NULL;

    goto function_return_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_29__cmp);
    return NULL;


function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_op);
    Py_DECREF(par_op);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_29__cmp$$$function_1_f(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_other = python_pars[1];
    PyObject *var_result = NULL;
    struct Nuitka_FrameObject *frame_22beaaaea5c6ee0a49315be496a852c0;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_22beaaaea5c6ee0a49315be496a852c0 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_22beaaaea5c6ee0a49315be496a852c0, codeobj_22beaaaea5c6ee0a49315be496a852c0, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_22beaaaea5c6ee0a49315be496a852c0 = cache_frame_22beaaaea5c6ee0a49315be496a852c0;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_22beaaaea5c6ee0a49315be496a852c0);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_22beaaaea5c6ee0a49315be496a852c0) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_other);
        tmp_isinstance_inst_1 = par_other;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Name);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Name);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1105 ], 37, 0);
            exception_tb = NULL;

            exception_lineno = 629;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 629;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 629;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 631;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_X509_NAME_cmp);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 631;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__name);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 631;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_other);
        tmp_source_name_3 = par_other;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__name);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_element_name_1);

            exception_lineno = 631;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }
        frame_22beaaaea5c6ee0a49315be496a852c0->m_frame.f_lineno = 631;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 631;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }
        assert(var_result == NULL);
        var_result = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        if (PyCell_GET(self->m_closure[0]) == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "op");
            exception_tb = NULL;

            exception_lineno = 632;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = PyCell_GET(self->m_closure[0]);
        CHECK_OBJECT(var_result);
        tmp_args_element_name_3 = var_result;
        tmp_args_element_name_4 = const_int_0;
        frame_22beaaaea5c6ee0a49315be496a852c0->m_frame.f_lineno = 632;
        {
            PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4};
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 632;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_22beaaaea5c6ee0a49315be496a852c0);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_22beaaaea5c6ee0a49315be496a852c0);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_22beaaaea5c6ee0a49315be496a852c0);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_22beaaaea5c6ee0a49315be496a852c0, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_22beaaaea5c6ee0a49315be496a852c0->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_22beaaaea5c6ee0a49315be496a852c0, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_22beaaaea5c6ee0a49315be496a852c0,
        type_description_1,
        par_self,
        par_other,
        var_result,
        self->m_closure[0]
    );


    // Release cached frame.
    if (frame_22beaaaea5c6ee0a49315be496a852c0 == cache_frame_22beaaaea5c6ee0a49315be496a852c0) {
        Py_DECREF(frame_22beaaaea5c6ee0a49315be496a852c0);
    }
    cache_frame_22beaaaea5c6ee0a49315be496a852c0 = NULL;

    assertFrameObject(frame_22beaaaea5c6ee0a49315be496a852c0);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_29__cmp$$$function_1_f);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_result);
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_result);
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_29__cmp$$$function_1_f);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_other);
    Py_DECREF(par_other);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_30___repr__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_result_buffer = NULL;
    PyObject *var_format_result = NULL;
    struct Nuitka_FrameObject *frame_d193f68fff8cd4832932098a276bfaeb;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_d193f68fff8cd4832932098a276bfaeb = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_d193f68fff8cd4832932098a276bfaeb, codeobj_d193f68fff8cd4832932098a276bfaeb, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_d193f68fff8cd4832932098a276bfaeb = cache_frame_d193f68fff8cd4832932098a276bfaeb;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_d193f68fff8cd4832932098a276bfaeb);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_d193f68fff8cd4832932098a276bfaeb) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 648;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_d193f68fff8cd4832932098a276bfaeb->m_frame.f_lineno = 648;
        tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain_new, &PyTuple_GET_ITEM(const_tuple_str_digest_c561652c58984ec0e9541542aa405594_int_pos_512_tuple, 0));

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 648;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_result_buffer == NULL);
        var_result_buffer = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_len_arg_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 649;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_X509_NAME_oneline);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 649;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__name);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 650;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_result_buffer);
        tmp_args_element_name_2 = var_result_buffer;
        CHECK_OBJECT(var_result_buffer);
        tmp_len_arg_1 = var_result_buffer;
        tmp_args_element_name_3 = BUILTIN_LEN(tmp_len_arg_1);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_element_name_1);

            exception_lineno = 650;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_d193f68fff8cd4832932098a276bfaeb->m_frame.f_lineno = 649;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 649;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_format_result == NULL);
        var_format_result = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 651;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_3;
        CHECK_OBJECT(var_format_result);
        tmp_compexpr_left_1 = var_format_result;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 651;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_4;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_NULL);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 651;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_4 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_args_element_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 651;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_d193f68fff8cd4832932098a276bfaeb->m_frame.f_lineno = 651;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_4);
        Py_DECREF(tmp_args_element_name_4);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 651;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_args_element_name_6;
        tmp_left_name_1 = const_str_digest_169aa7f0589e4a3c83203d48f57770af;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__native);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__native);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1954 ], 36, 0);
            exception_tb = NULL;

            exception_lineno = 654;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_5;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_6 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 654;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_6;
        CHECK_OBJECT(var_result_buffer);
        tmp_args_element_name_6 = var_result_buffer;
        frame_d193f68fff8cd4832932098a276bfaeb->m_frame.f_lineno = 654;
        {
            PyObject *call_args[] = {tmp_args_element_name_6};
            tmp_args_element_name_5 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_string, call_args);
        }

        if (tmp_args_element_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 654;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_d193f68fff8cd4832932098a276bfaeb->m_frame.f_lineno = 654;
        tmp_tuple_element_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_3, tmp_args_element_name_5);
        Py_DECREF(tmp_args_element_name_5);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 654;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_right_name_1 = PyTuple_New(1);
        PyTuple_SET_ITEM(tmp_right_name_1, 0, tmp_tuple_element_1);
        tmp_return_value = BINARY_OPERATION_MOD_STR_TUPLE(tmp_left_name_1, tmp_right_name_1);
        Py_DECREF(tmp_right_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 653;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_d193f68fff8cd4832932098a276bfaeb);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_d193f68fff8cd4832932098a276bfaeb);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_d193f68fff8cd4832932098a276bfaeb);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_d193f68fff8cd4832932098a276bfaeb, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_d193f68fff8cd4832932098a276bfaeb->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_d193f68fff8cd4832932098a276bfaeb, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d193f68fff8cd4832932098a276bfaeb,
        type_description_1,
        par_self,
        var_result_buffer,
        var_format_result
    );


    // Release cached frame.
    if (frame_d193f68fff8cd4832932098a276bfaeb == cache_frame_d193f68fff8cd4832932098a276bfaeb) {
        Py_DECREF(frame_d193f68fff8cd4832932098a276bfaeb);
    }
    cache_frame_d193f68fff8cd4832932098a276bfaeb = NULL;

    assertFrameObject(frame_d193f68fff8cd4832932098a276bfaeb);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_30___repr__);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_result_buffer);
    Py_DECREF(var_result_buffer);
    var_result_buffer = NULL;

    CHECK_OBJECT((PyObject *)var_format_result);
    Py_DECREF(var_format_result);
    var_format_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_result_buffer);
    var_result_buffer = NULL;

    Py_XDECREF(var_format_result);
    var_format_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_30___repr__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_31_hash(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_9108a7396152423879c9fb4fd180f6ef;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_9108a7396152423879c9fb4fd180f6ef = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_9108a7396152423879c9fb4fd180f6ef, codeobj_9108a7396152423879c9fb4fd180f6ef, module_OpenSSL$crypto, sizeof(void *));
    frame_9108a7396152423879c9fb4fd180f6ef = cache_frame_9108a7396152423879c9fb4fd180f6ef;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_9108a7396152423879c9fb4fd180f6ef);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_9108a7396152423879c9fb4fd180f6ef) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 666;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_X509_NAME_hash);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 666;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__name);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 666;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_9108a7396152423879c9fb4fd180f6ef->m_frame.f_lineno = 666;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 666;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9108a7396152423879c9fb4fd180f6ef);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_9108a7396152423879c9fb4fd180f6ef);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9108a7396152423879c9fb4fd180f6ef);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_9108a7396152423879c9fb4fd180f6ef, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_9108a7396152423879c9fb4fd180f6ef->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_9108a7396152423879c9fb4fd180f6ef, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9108a7396152423879c9fb4fd180f6ef,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_9108a7396152423879c9fb4fd180f6ef == cache_frame_9108a7396152423879c9fb4fd180f6ef) {
        Py_DECREF(frame_9108a7396152423879c9fb4fd180f6ef);
    }
    cache_frame_9108a7396152423879c9fb4fd180f6ef = NULL;

    assertFrameObject(frame_9108a7396152423879c9fb4fd180f6ef);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_31_hash);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_32_der(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_result_buffer = NULL;
    PyObject *var_string_result = NULL;
    PyObject *var_encode_result = NULL;
    struct Nuitka_FrameObject *frame_fc7001d155a0450e09ea5b4d5d2bc9f9;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_fc7001d155a0450e09ea5b4d5d2bc9f9 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_fc7001d155a0450e09ea5b4d5d2bc9f9, codeobj_fc7001d155a0450e09ea5b4d5d2bc9f9, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_fc7001d155a0450e09ea5b4d5d2bc9f9 = cache_frame_fc7001d155a0450e09ea5b4d5d2bc9f9;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_fc7001d155a0450e09ea5b4d5d2bc9f9);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_fc7001d155a0450e09ea5b4d5d2bc9f9) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 675;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_fc7001d155a0450e09ea5b4d5d2bc9f9->m_frame.f_lineno = 675;
        tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_new, &PyTuple_GET_ITEM(const_tuple_str_digest_5339fa8ff3df372e54ef7b09078767aa_tuple, 0));

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 675;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_result_buffer == NULL);
        var_result_buffer = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 676;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_i2d_X509_NAME);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 676;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__name);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 676;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_result_buffer);
        tmp_args_element_name_2 = var_result_buffer;
        frame_fc7001d155a0450e09ea5b4d5d2bc9f9->m_frame.f_lineno = 676;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 676;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_encode_result == NULL);
        var_encode_result = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 677;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_3;
        CHECK_OBJECT(var_encode_result);
        tmp_compexpr_left_1 = var_encode_result;
        tmp_compexpr_right_1 = const_int_0;
        tmp_args_element_name_3 = RICH_COMPARE_GTE_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 677;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_fc7001d155a0450e09ea5b4d5d2bc9f9->m_frame.f_lineno = 677;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_3);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 677;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_assign_source_3;
        Py_ssize_t tmp_sliceslicedel_index_lower_1;
        Py_ssize_t tmp_slice_index_upper_1;
        PyObject *tmp_slice_source_1;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_subscript_name_1;
        PyObject *tmp_args_element_name_5;
        tmp_sliceslicedel_index_lower_1 = 0;
        tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 679;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_4;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_buffer);
        if (tmp_called_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 679;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_result_buffer);
        tmp_subscribed_name_1 = var_result_buffer;
        tmp_subscript_name_1 = const_int_0;
        tmp_args_element_name_4 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_1, tmp_subscript_name_1, 0);
        if (tmp_args_element_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);

            exception_lineno = 679;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_encode_result);
        tmp_args_element_name_5 = var_encode_result;
        frame_fc7001d155a0450e09ea5b4d5d2bc9f9->m_frame.f_lineno = 679;
        {
            PyObject *call_args[] = {tmp_args_element_name_4, tmp_args_element_name_5};
            tmp_slice_source_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_3, call_args);
        }

        Py_DECREF(tmp_called_name_3);
        Py_DECREF(tmp_args_element_name_4);
        if (tmp_slice_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 679;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_3 = LOOKUP_INDEX_SLICE(tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1);
        Py_DECREF(tmp_slice_source_1);
        if (tmp_assign_source_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 679;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_string_result == NULL);
        var_string_result = tmp_assign_source_3;
    }
    {
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_subscribed_name_2;
        PyObject *tmp_subscript_name_2;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 680;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_5;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_OPENSSL_free);
        if (tmp_called_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 680;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_result_buffer);
        tmp_subscribed_name_2 = var_result_buffer;
        tmp_subscript_name_2 = const_int_0;
        tmp_args_element_name_6 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_2, tmp_subscript_name_2, 0);
        if (tmp_args_element_name_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_4);

            exception_lineno = 680;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_fc7001d155a0450e09ea5b4d5d2bc9f9->m_frame.f_lineno = 680;
        tmp_call_result_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_4, tmp_args_element_name_6);
        Py_DECREF(tmp_called_name_4);
        Py_DECREF(tmp_args_element_name_6);
        if (tmp_call_result_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 680;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_2);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_fc7001d155a0450e09ea5b4d5d2bc9f9);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_fc7001d155a0450e09ea5b4d5d2bc9f9);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_fc7001d155a0450e09ea5b4d5d2bc9f9, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_fc7001d155a0450e09ea5b4d5d2bc9f9->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_fc7001d155a0450e09ea5b4d5d2bc9f9, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_fc7001d155a0450e09ea5b4d5d2bc9f9,
        type_description_1,
        par_self,
        var_result_buffer,
        var_string_result,
        var_encode_result
    );


    // Release cached frame.
    if (frame_fc7001d155a0450e09ea5b4d5d2bc9f9 == cache_frame_fc7001d155a0450e09ea5b4d5d2bc9f9) {
        Py_DECREF(frame_fc7001d155a0450e09ea5b4d5d2bc9f9);
    }
    cache_frame_fc7001d155a0450e09ea5b4d5d2bc9f9 = NULL;

    assertFrameObject(frame_fc7001d155a0450e09ea5b4d5d2bc9f9);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT(var_string_result);
    tmp_return_value = var_string_result;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_32_der);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_result_buffer);
    Py_DECREF(var_result_buffer);
    var_result_buffer = NULL;

    CHECK_OBJECT((PyObject *)var_string_result);
    Py_DECREF(var_string_result);
    var_string_result = NULL;

    CHECK_OBJECT((PyObject *)var_encode_result);
    Py_DECREF(var_encode_result);
    var_encode_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_result_buffer);
    var_result_buffer = NULL;

    Py_XDECREF(var_string_result);
    var_string_result = NULL;

    Py_XDECREF(var_encode_result);
    var_encode_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_32_der);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_33_get_components(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_value = NULL;
    PyObject *var_name = NULL;
    PyObject *var_i = NULL;
    PyObject *var_nid = NULL;
    PyObject *var_fval = NULL;
    PyObject *var_ent = NULL;
    PyObject *var_result = NULL;
    PyObject *var_fname = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_8f12fd3ce35b73023a06827bde816a58;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_8f12fd3ce35b73023a06827bde816a58 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = PyList_New(0);
        assert(var_result == NULL);
        var_result = tmp_assign_source_1;
    }
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_8f12fd3ce35b73023a06827bde816a58, codeobj_8f12fd3ce35b73023a06827bde816a58, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_8f12fd3ce35b73023a06827bde816a58 = cache_frame_8f12fd3ce35b73023a06827bde816a58;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_8f12fd3ce35b73023a06827bde816a58);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_8f12fd3ce35b73023a06827bde816a58) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_range_arg_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 691;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_X509_NAME_entry_count);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 691;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__name);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 691;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        frame_8f12fd3ce35b73023a06827bde816a58->m_frame.f_lineno = 691;
        tmp_range_arg_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_range_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 691;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_iter_arg_1 = BUILTIN_RANGE(tmp_range_arg_1);
        Py_DECREF(tmp_range_arg_1);
        if (tmp_iter_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 691;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_2 = MAKE_ITERATOR(tmp_iter_arg_1);
        Py_DECREF(tmp_iter_arg_1);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 691;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert(tmp_for_loop_1__for_iterator == NULL);
        tmp_for_loop_1__for_iterator = tmp_assign_source_2;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_3;
        CHECK_OBJECT(tmp_for_loop_1__for_iterator);
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_3 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_3 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "ooooooooo";
                exception_lineno = 691;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_3;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_4;
        CHECK_OBJECT(tmp_for_loop_1__iter_value);
        tmp_assign_source_4 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_i;
            var_i = tmp_assign_source_4;
            Py_INCREF(var_i);
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 692;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_X509_NAME_get_entry);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 692;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_4 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain__name);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 692;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT(var_i);
        tmp_args_element_name_3 = var_i;
        frame_8f12fd3ce35b73023a06827bde816a58->m_frame.f_lineno = 692;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assign_source_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 692;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_ent;
            var_ent = tmp_assign_source_5;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 694;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_1 = tmp_mvar_value_3;
        CHECK_OBJECT(var_ent);
        tmp_args_element_name_4 = var_ent;
        frame_8f12fd3ce35b73023a06827bde816a58->m_frame.f_lineno = 694;
        {
            PyObject *call_args[] = {tmp_args_element_name_4};
            tmp_assign_source_6 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_X509_NAME_ENTRY_get_object, call_args);
        }

        if (tmp_assign_source_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 694;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_fname;
            var_fname = tmp_assign_source_6;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_5;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 695;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_2 = tmp_mvar_value_4;
        CHECK_OBJECT(var_ent);
        tmp_args_element_name_5 = var_ent;
        frame_8f12fd3ce35b73023a06827bde816a58->m_frame.f_lineno = 695;
        {
            PyObject *call_args[] = {tmp_args_element_name_5};
            tmp_assign_source_7 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_X509_NAME_ENTRY_get_data, call_args);
        }

        if (tmp_assign_source_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 695;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_fval;
            var_fval = tmp_assign_source_7;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_8;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_6;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 697;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_3 = tmp_mvar_value_5;
        CHECK_OBJECT(var_fname);
        tmp_args_element_name_6 = var_fname;
        frame_8f12fd3ce35b73023a06827bde816a58->m_frame.f_lineno = 697;
        {
            PyObject *call_args[] = {tmp_args_element_name_6};
            tmp_assign_source_8 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_3, const_str_plain_OBJ_obj2nid, call_args);
        }

        if (tmp_assign_source_8 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 697;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_nid;
            var_nid = tmp_assign_source_8;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_9;
        PyObject *tmp_called_instance_4;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_args_element_name_7;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_6 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 698;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_4 = tmp_mvar_value_6;
        CHECK_OBJECT(var_nid);
        tmp_args_element_name_7 = var_nid;
        frame_8f12fd3ce35b73023a06827bde816a58->m_frame.f_lineno = 698;
        {
            PyObject *call_args[] = {tmp_args_element_name_7};
            tmp_assign_source_9 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_4, const_str_plain_OBJ_nid2sn, call_args);
        }

        if (tmp_assign_source_9 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 698;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_name;
            var_name = tmp_assign_source_9;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_10;
        Py_ssize_t tmp_sliceslicedel_index_lower_1;
        Py_ssize_t tmp_slice_index_upper_1;
        PyObject *tmp_slice_source_1;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_called_instance_5;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_called_instance_6;
        PyObject *tmp_mvar_value_9;
        PyObject *tmp_args_element_name_11;
        tmp_sliceslicedel_index_lower_1 = 0;
        tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_7 == NULL)) {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_7 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 702;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }

        tmp_source_name_5 = tmp_mvar_value_7;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_buffer);
        if (tmp_called_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 702;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_8 == NULL)) {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_8 == NULL) {
            Py_DECREF(tmp_called_name_3);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 702;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_5 = tmp_mvar_value_8;
        CHECK_OBJECT(var_fval);
        tmp_args_element_name_9 = var_fval;
        frame_8f12fd3ce35b73023a06827bde816a58->m_frame.f_lineno = 702;
        {
            PyObject *call_args[] = {tmp_args_element_name_9};
            tmp_args_element_name_8 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_5, const_str_plain_ASN1_STRING_data, call_args);
        }

        if (tmp_args_element_name_8 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);

            exception_lineno = 702;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }
        tmp_mvar_value_9 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_9 == NULL)) {
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_9 == NULL) {
            Py_DECREF(tmp_called_name_3);
            Py_DECREF(tmp_args_element_name_8);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 703;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_6 = tmp_mvar_value_9;
        CHECK_OBJECT(var_fval);
        tmp_args_element_name_11 = var_fval;
        frame_8f12fd3ce35b73023a06827bde816a58->m_frame.f_lineno = 703;
        {
            PyObject *call_args[] = {tmp_args_element_name_11};
            tmp_args_element_name_10 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_6, const_str_plain_ASN1_STRING_length, call_args);
        }

        if (tmp_args_element_name_10 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);
            Py_DECREF(tmp_args_element_name_8);

            exception_lineno = 703;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }
        frame_8f12fd3ce35b73023a06827bde816a58->m_frame.f_lineno = 702;
        {
            PyObject *call_args[] = {tmp_args_element_name_8, tmp_args_element_name_10};
            tmp_slice_source_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_3, call_args);
        }

        Py_DECREF(tmp_called_name_3);
        Py_DECREF(tmp_args_element_name_8);
        Py_DECREF(tmp_args_element_name_10);
        if (tmp_slice_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 702;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }
        tmp_assign_source_10 = LOOKUP_INDEX_SLICE(tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1);
        Py_DECREF(tmp_slice_source_1);
        if (tmp_assign_source_10 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 702;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_value;
            var_value = tmp_assign_source_10;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_6;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_12;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_called_instance_7;
        PyObject *tmp_mvar_value_10;
        PyObject *tmp_args_element_name_13;
        CHECK_OBJECT(var_result);
        tmp_source_name_6 = var_result;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_append);
        if (tmp_called_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 704;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }
        tmp_mvar_value_10 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_10 == NULL)) {
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_10 == NULL) {
            Py_DECREF(tmp_called_name_4);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 704;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_7 = tmp_mvar_value_10;
        CHECK_OBJECT(var_name);
        tmp_args_element_name_13 = var_name;
        frame_8f12fd3ce35b73023a06827bde816a58->m_frame.f_lineno = 704;
        {
            PyObject *call_args[] = {tmp_args_element_name_13};
            tmp_tuple_element_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_7, const_str_plain_string, call_args);
        }

        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_4);

            exception_lineno = 704;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }
        tmp_args_element_name_12 = PyTuple_New(2);
        PyTuple_SET_ITEM(tmp_args_element_name_12, 0, tmp_tuple_element_1);
        CHECK_OBJECT(var_value);
        tmp_tuple_element_1 = var_value;
        Py_INCREF(tmp_tuple_element_1);
        PyTuple_SET_ITEM(tmp_args_element_name_12, 1, tmp_tuple_element_1);
        frame_8f12fd3ce35b73023a06827bde816a58->m_frame.f_lineno = 704;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_4, tmp_args_element_name_12);
        Py_DECREF(tmp_called_name_4);
        Py_DECREF(tmp_args_element_name_12);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 704;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }
        Py_DECREF(tmp_call_result_1);
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


        exception_lineno = 691;
        type_description_1 = "ooooooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8f12fd3ce35b73023a06827bde816a58);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8f12fd3ce35b73023a06827bde816a58);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_8f12fd3ce35b73023a06827bde816a58, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_8f12fd3ce35b73023a06827bde816a58->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_8f12fd3ce35b73023a06827bde816a58, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8f12fd3ce35b73023a06827bde816a58,
        type_description_1,
        par_self,
        var_value,
        var_name,
        var_i,
        var_nid,
        var_fval,
        var_ent,
        var_result,
        var_fname
    );


    // Release cached frame.
    if (frame_8f12fd3ce35b73023a06827bde816a58 == cache_frame_8f12fd3ce35b73023a06827bde816a58) {
        Py_DECREF(frame_8f12fd3ce35b73023a06827bde816a58);
    }
    cache_frame_8f12fd3ce35b73023a06827bde816a58 = NULL;

    assertFrameObject(frame_8f12fd3ce35b73023a06827bde816a58);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    CHECK_OBJECT(var_result);
    tmp_return_value = var_result;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_33_get_components);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_value);
    var_value = NULL;

    Py_XDECREF(var_name);
    var_name = NULL;

    Py_XDECREF(var_i);
    var_i = NULL;

    Py_XDECREF(var_nid);
    var_nid = NULL;

    Py_XDECREF(var_fval);
    var_fval = NULL;

    Py_XDECREF(var_ent);
    var_ent = NULL;

    CHECK_OBJECT((PyObject *)var_result);
    Py_DECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_fname);
    var_fname = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_value);
    var_value = NULL;

    Py_XDECREF(var_name);
    var_name = NULL;

    Py_XDECREF(var_i);
    var_i = NULL;

    Py_XDECREF(var_nid);
    var_nid = NULL;

    Py_XDECREF(var_fval);
    var_fval = NULL;

    Py_XDECREF(var_ent);
    var_ent = NULL;

    CHECK_OBJECT((PyObject *)var_result);
    Py_DECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_fname);
    var_fname = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_33_get_components);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_34___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_type_name = python_pars[1];
    PyObject *par_critical = python_pars[2];
    PyObject *par_value = python_pars[3];
    PyObject *par_subject = python_pars[4];
    PyObject *par_issuer = python_pars[5];
    PyObject *var_extension = NULL;
    PyObject *var_ctx = NULL;
    struct Nuitka_FrameObject *frame_454ecf415d37cf2ce7deb60c0cb6fa3d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_454ecf415d37cf2ce7deb60c0cb6fa3d = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_454ecf415d37cf2ce7deb60c0cb6fa3d, codeobj_454ecf415d37cf2ce7deb60c0cb6fa3d, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_454ecf415d37cf2ce7deb60c0cb6fa3d = cache_frame_454ecf415d37cf2ce7deb60c0cb6fa3d;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_454ecf415d37cf2ce7deb60c0cb6fa3d);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_454ecf415d37cf2ce7deb60c0cb6fa3d) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 743;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_454ecf415d37cf2ce7deb60c0cb6fa3d->m_frame.f_lineno = 743;
        tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_new, &PyTuple_GET_ITEM(const_tuple_str_digest_f3b04f8993b30e664e4afacb3d64cdc4_tuple, 0));

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 743;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_ctx == NULL);
        var_ctx = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_args_element_name_6;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 748;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_X509V3_set_ctx);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 748;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_ctx);
        tmp_args_element_name_1 = var_ctx;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_3 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 748;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_NULL);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 748;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_4 == NULL) {
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_element_name_2);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 748;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_4;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_NULL);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_element_name_2);

            exception_lineno = 748;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_5 == NULL) {
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_element_name_2);
            Py_DECREF(tmp_args_element_name_3);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 748;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_5;
        tmp_args_element_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_NULL);
        if (tmp_args_element_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_element_name_2);
            Py_DECREF(tmp_args_element_name_3);

            exception_lineno = 748;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_6 == NULL) {
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_element_name_2);
            Py_DECREF(tmp_args_element_name_3);
            Py_DECREF(tmp_args_element_name_4);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 748;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_6;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_NULL);
        if (tmp_args_element_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_element_name_2);
            Py_DECREF(tmp_args_element_name_3);
            Py_DECREF(tmp_args_element_name_4);

            exception_lineno = 748;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_6 = const_int_0;
        frame_454ecf415d37cf2ce7deb60c0cb6fa3d->m_frame.f_lineno = 748;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5, tmp_args_element_name_6};
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS6(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_2);
        Py_DECREF(tmp_args_element_name_3);
        Py_DECREF(tmp_args_element_name_4);
        Py_DECREF(tmp_args_element_name_5);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 748;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_7;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_7 == NULL)) {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_7 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 752;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_7;
        CHECK_OBJECT(var_ctx);
        tmp_args_element_name_7 = var_ctx;
        frame_454ecf415d37cf2ce7deb60c0cb6fa3d->m_frame.f_lineno = 752;
        {
            PyObject *call_args[] = {tmp_args_element_name_7};
            tmp_call_result_2 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_X509V3_set_ctx_nodb, call_args);
        }

        if (tmp_call_result_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 752;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_2);
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_issuer);
        tmp_compexpr_left_1 = par_issuer;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 != tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_operand_name_1;
            PyObject *tmp_isinstance_inst_1;
            PyObject *tmp_isinstance_cls_1;
            PyObject *tmp_mvar_value_8;
            CHECK_OBJECT(par_issuer);
            tmp_isinstance_inst_1 = par_issuer;
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509);

            if (unlikely(tmp_mvar_value_8 == NULL)) {
                tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509);
            }

            if (tmp_mvar_value_8 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 236 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 759;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_isinstance_cls_1 = tmp_mvar_value_8;
            tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 759;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 759;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
                goto branch_yes_2;
            } else {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_raise_type_1;
                PyObject *tmp_make_exception_arg_1;
                tmp_make_exception_arg_1 = const_str_digest_7163953ad9ff69e46167d396f5625cf7;
                frame_454ecf415d37cf2ce7deb60c0cb6fa3d->m_frame.f_lineno = 760;
                tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
                assert(!(tmp_raise_type_1 == NULL));
                exception_type = tmp_raise_type_1;
                exception_lineno = 760;
                RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            branch_no_2:;
        }
        {
            PyObject *tmp_assattr_name_1;
            PyObject *tmp_source_name_6;
            PyObject *tmp_assattr_target_1;
            CHECK_OBJECT(par_issuer);
            tmp_source_name_6 = par_issuer;
            tmp_assattr_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain__x509);
            if (tmp_assattr_name_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 761;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_ctx);
            tmp_assattr_target_1 = var_ctx;
            tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain_issuer_cert, tmp_assattr_name_1);
            Py_DECREF(tmp_assattr_name_1);
            if (tmp_result == false) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 761;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        CHECK_OBJECT(par_subject);
        tmp_compexpr_left_2 = par_subject;
        tmp_compexpr_right_2 = Py_None;
        tmp_condition_result_3 = (tmp_compexpr_left_2 != tmp_compexpr_right_2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
            goto branch_yes_3;
        } else {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            nuitka_bool tmp_condition_result_4;
            PyObject *tmp_operand_name_2;
            PyObject *tmp_isinstance_inst_2;
            PyObject *tmp_isinstance_cls_2;
            PyObject *tmp_mvar_value_9;
            CHECK_OBJECT(par_subject);
            tmp_isinstance_inst_2 = par_subject;
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509);

            if (unlikely(tmp_mvar_value_9 == NULL)) {
                tmp_mvar_value_9 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509);
            }

            if (tmp_mvar_value_9 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 236 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 763;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_isinstance_cls_2 = tmp_mvar_value_9;
            tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_2, tmp_isinstance_cls_2);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 763;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            tmp_operand_name_2 = (tmp_res != 0) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE(tmp_operand_name_2);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 763;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_4 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_4 == NUITKA_BOOL_TRUE) {
                goto branch_yes_4;
            } else {
                goto branch_no_4;
            }
            branch_yes_4:;
            {
                PyObject *tmp_raise_type_2;
                PyObject *tmp_make_exception_arg_2;
                tmp_make_exception_arg_2 = const_str_digest_3c820c2fc1d76f73132dab0e4e8d3a14;
                frame_454ecf415d37cf2ce7deb60c0cb6fa3d->m_frame.f_lineno = 764;
                tmp_raise_type_2 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_2);
                assert(!(tmp_raise_type_2 == NULL));
                exception_type = tmp_raise_type_2;
                exception_lineno = 764;
                RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            branch_no_4:;
        }
        {
            PyObject *tmp_assattr_name_2;
            PyObject *tmp_source_name_7;
            PyObject *tmp_assattr_target_2;
            CHECK_OBJECT(par_subject);
            tmp_source_name_7 = par_subject;
            tmp_assattr_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain__x509);
            if (tmp_assattr_name_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 765;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_ctx);
            tmp_assattr_target_2 = var_ctx;
            tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain_subject_cert, tmp_assattr_name_2);
            Py_DECREF(tmp_assattr_name_2);
            if (tmp_result == false) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 765;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
        }
        branch_no_3:;
    }
    {
        nuitka_bool tmp_condition_result_5;
        int tmp_truth_name_1;
        CHECK_OBJECT(par_critical);
        tmp_truth_name_1 = CHECK_IF_TRUE(par_critical);
        if (tmp_truth_name_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 767;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_5 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_5 == NUITKA_BOOL_TRUE) {
            goto branch_yes_5;
        } else {
            goto branch_no_5;
        }
        branch_yes_5:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            tmp_left_name_1 = const_str_digest_3c5d018dd809b9a6147c1b47d39e8d31;
            CHECK_OBJECT(par_value);
            tmp_right_name_1 = par_value;
            tmp_assign_source_2 = BINARY_OPERATION_ADD_STR_OBJECT(tmp_left_name_1, tmp_right_name_1);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 775;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_value;
                assert(old != NULL);
                par_value = tmp_assign_source_2;
                Py_DECREF(old);
            }

        }
        branch_no_5:;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_8;
        PyObject *tmp_mvar_value_10;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_source_name_9;
        PyObject *tmp_mvar_value_11;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_args_element_name_11;
        tmp_mvar_value_10 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_10 == NULL)) {
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_10 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 777;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_8 = tmp_mvar_value_10;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_8, const_str_plain_X509V3_EXT_nconf);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 777;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_11 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_11 == NULL)) {
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_11 == NULL) {
            Py_DECREF(tmp_called_name_2);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 777;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_9 = tmp_mvar_value_11;
        tmp_args_element_name_8 = LOOKUP_ATTRIBUTE(tmp_source_name_9, const_str_plain_NULL);
        if (tmp_args_element_name_8 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 777;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_ctx);
        tmp_args_element_name_9 = var_ctx;
        CHECK_OBJECT(par_type_name);
        tmp_args_element_name_10 = par_type_name;
        CHECK_OBJECT(par_value);
        tmp_args_element_name_11 = par_value;
        frame_454ecf415d37cf2ce7deb60c0cb6fa3d->m_frame.f_lineno = 777;
        {
            PyObject *call_args[] = {tmp_args_element_name_8, tmp_args_element_name_9, tmp_args_element_name_10, tmp_args_element_name_11};
            tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS4(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_8);
        if (tmp_assign_source_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 777;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_extension == NULL);
        var_extension = tmp_assign_source_3;
    }
    {
        nuitka_bool tmp_condition_result_6;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_source_name_10;
        PyObject *tmp_mvar_value_12;
        CHECK_OBJECT(var_extension);
        tmp_compexpr_left_3 = var_extension;
        tmp_mvar_value_12 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_12 == NULL)) {
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_12 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 778;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_10 = tmp_mvar_value_12;
        tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE(tmp_source_name_10, const_str_plain_NULL);
        if (tmp_compexpr_right_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 778;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_3, tmp_compexpr_right_3);
        Py_DECREF(tmp_compexpr_right_3);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 778;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_6 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_6 == NUITKA_BOOL_TRUE) {
            goto branch_yes_6;
        } else {
            goto branch_no_6;
        }
        branch_yes_6:;
        {
            PyObject *tmp_called_name_3;
            PyObject *tmp_mvar_value_13;
            PyObject *tmp_call_result_3;
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error);

            if (unlikely(tmp_mvar_value_13 == NULL)) {
                tmp_mvar_value_13 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error);
            }

            if (tmp_mvar_value_13 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 0 ], 49, 0);
                exception_tb = NULL;

                exception_lineno = 779;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_3 = tmp_mvar_value_13;
            frame_454ecf415d37cf2ce7deb60c0cb6fa3d->m_frame.f_lineno = 779;
            tmp_call_result_3 = CALL_FUNCTION_NO_ARGS(tmp_called_name_3);
            if (tmp_call_result_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 779;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_3);
        }
        branch_no_6:;
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_11;
        PyObject *tmp_mvar_value_14;
        PyObject *tmp_args_element_name_12;
        PyObject *tmp_args_element_name_13;
        PyObject *tmp_source_name_12;
        PyObject *tmp_mvar_value_15;
        PyObject *tmp_assattr_target_3;
        tmp_mvar_value_14 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_14 == NULL)) {
            tmp_mvar_value_14 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_14 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 780;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_11 = tmp_mvar_value_14;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_11, const_str_plain_gc);
        if (tmp_called_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 780;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_extension);
        tmp_args_element_name_12 = var_extension;
        tmp_mvar_value_15 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_15 == NULL)) {
            tmp_mvar_value_15 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_15 == NULL) {
            Py_DECREF(tmp_called_name_4);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 780;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_12 = tmp_mvar_value_15;
        tmp_args_element_name_13 = LOOKUP_ATTRIBUTE(tmp_source_name_12, const_str_plain_X509_EXTENSION_free);
        if (tmp_args_element_name_13 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_4);

            exception_lineno = 780;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        frame_454ecf415d37cf2ce7deb60c0cb6fa3d->m_frame.f_lineno = 780;
        {
            PyObject *call_args[] = {tmp_args_element_name_12, tmp_args_element_name_13};
            tmp_assattr_name_3 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_4, call_args);
        }

        Py_DECREF(tmp_called_name_4);
        Py_DECREF(tmp_args_element_name_13);
        if (tmp_assattr_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 780;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_assattr_target_3 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_3, const_str_plain__extension, tmp_assattr_name_3);
        Py_DECREF(tmp_assattr_name_3);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 780;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_454ecf415d37cf2ce7deb60c0cb6fa3d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_454ecf415d37cf2ce7deb60c0cb6fa3d);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_454ecf415d37cf2ce7deb60c0cb6fa3d, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_454ecf415d37cf2ce7deb60c0cb6fa3d->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_454ecf415d37cf2ce7deb60c0cb6fa3d, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_454ecf415d37cf2ce7deb60c0cb6fa3d,
        type_description_1,
        par_self,
        par_type_name,
        par_critical,
        par_value,
        par_subject,
        par_issuer,
        var_extension,
        var_ctx
    );


    // Release cached frame.
    if (frame_454ecf415d37cf2ce7deb60c0cb6fa3d == cache_frame_454ecf415d37cf2ce7deb60c0cb6fa3d) {
        Py_DECREF(frame_454ecf415d37cf2ce7deb60c0cb6fa3d);
    }
    cache_frame_454ecf415d37cf2ce7deb60c0cb6fa3d = NULL;

    assertFrameObject(frame_454ecf415d37cf2ce7deb60c0cb6fa3d);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_34___init__);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_extension);
    Py_DECREF(var_extension);
    var_extension = NULL;

    CHECK_OBJECT((PyObject *)var_ctx);
    Py_DECREF(var_ctx);
    var_ctx = NULL;

    CHECK_OBJECT((PyObject *)par_value);
    Py_DECREF(par_value);
    par_value = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_extension);
    var_extension = NULL;

    Py_XDECREF(var_ctx);
    var_ctx = NULL;

    Py_XDECREF(par_value);
    par_value = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_34___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_type_name);
    Py_DECREF(par_type_name);
    CHECK_OBJECT(par_critical);
    Py_DECREF(par_critical);
    CHECK_OBJECT(par_subject);
    Py_DECREF(par_subject);
    CHECK_OBJECT(par_issuer);
    Py_DECREF(par_issuer);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_type_name);
    Py_DECREF(par_type_name);
    CHECK_OBJECT(par_critical);
    Py_DECREF(par_critical);
    CHECK_OBJECT(par_subject);
    Py_DECREF(par_subject);
    CHECK_OBJECT(par_issuer);
    Py_DECREF(par_issuer);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_35__nid(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_e5f1885b429cf8c4e78efa560593ce5d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_e5f1885b429cf8c4e78efa560593ce5d = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_e5f1885b429cf8c4e78efa560593ce5d, codeobj_e5f1885b429cf8c4e78efa560593ce5d, module_OpenSSL$crypto, sizeof(void *));
    frame_e5f1885b429cf8c4e78efa560593ce5d = cache_frame_e5f1885b429cf8c4e78efa560593ce5d;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_e5f1885b429cf8c4e78efa560593ce5d);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_e5f1885b429cf8c4e78efa560593ce5d) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 784;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_OBJ_obj2nid);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 784;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 785;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_X509_EXTENSION_get_object);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 785;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__extension);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 785;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_e5f1885b429cf8c4e78efa560593ce5d->m_frame.f_lineno = 785;
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_2);
        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 785;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_e5f1885b429cf8c4e78efa560593ce5d->m_frame.f_lineno = 784;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 784;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e5f1885b429cf8c4e78efa560593ce5d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_e5f1885b429cf8c4e78efa560593ce5d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e5f1885b429cf8c4e78efa560593ce5d);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_e5f1885b429cf8c4e78efa560593ce5d, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_e5f1885b429cf8c4e78efa560593ce5d->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_e5f1885b429cf8c4e78efa560593ce5d, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e5f1885b429cf8c4e78efa560593ce5d,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_e5f1885b429cf8c4e78efa560593ce5d == cache_frame_e5f1885b429cf8c4e78efa560593ce5d) {
        Py_DECREF(frame_e5f1885b429cf8c4e78efa560593ce5d);
    }
    cache_frame_e5f1885b429cf8c4e78efa560593ce5d = NULL;

    assertFrameObject(frame_e5f1885b429cf8c4e78efa560593ce5d);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_35__nid);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_36__subjectAltNameString(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_bio = NULL;
    PyObject *var_name = NULL;
    PyObject *var_i = NULL;
    PyObject *var_value = NULL;
    PyObject *var_label = NULL;
    PyObject *var_parts = NULL;
    PyObject *var_names = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *tmp_try_except_1__unhandled_indicator = NULL;
    struct Nuitka_FrameObject *frame_9d20210919ad40c1e8d81a9f37aef9bb;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_res;
    bool tmp_result;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_9d20210919ad40c1e8d81a9f37aef9bb = NULL;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_9d20210919ad40c1e8d81a9f37aef9bb, codeobj_9d20210919ad40c1e8d81a9f37aef9bb, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_9d20210919ad40c1e8d81a9f37aef9bb = cache_frame_9d20210919ad40c1e8d81a9f37aef9bb;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_9d20210919ad40c1e8d81a9f37aef9bb);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_9d20210919ad40c1e8d81a9f37aef9bb) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 795;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_cast);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 795;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_1 = const_str_digest_1dbb147d3e039266688c4d87287eaaad;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 796;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_X509V3_EXT_d2i);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 796;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__extension);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 796;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        frame_9d20210919ad40c1e8d81a9f37aef9bb->m_frame.f_lineno = 796;
        tmp_args_element_name_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_3);
        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 796;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        frame_9d20210919ad40c1e8d81a9f37aef9bb->m_frame.f_lineno = 795;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 795;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_names == NULL);
        var_names = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 799;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_3;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_gc);
        if (tmp_called_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 799;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_names);
        tmp_args_element_name_4 = var_names;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_4 == NULL) {
            Py_DECREF(tmp_called_name_3);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 799;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_4;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_GENERAL_NAMES_free);
        if (tmp_args_element_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);

            exception_lineno = 799;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        frame_9d20210919ad40c1e8d81a9f37aef9bb->m_frame.f_lineno = 799;
        {
            PyObject *call_args[] = {tmp_args_element_name_4, tmp_args_element_name_5};
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_3, call_args);
        }

        Py_DECREF(tmp_called_name_3);
        Py_DECREF(tmp_args_element_name_5);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 799;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var_names;
            assert(old != NULL);
            var_names = tmp_assign_source_2;
            Py_DECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_3;
        tmp_assign_source_3 = PyList_New(0);
        assert(var_parts == NULL);
        var_parts = tmp_assign_source_3;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_range_arg_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_6;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 801;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_5;
        CHECK_OBJECT(var_names);
        tmp_args_element_name_6 = var_names;
        frame_9d20210919ad40c1e8d81a9f37aef9bb->m_frame.f_lineno = 801;
        {
            PyObject *call_args[] = {tmp_args_element_name_6};
            tmp_range_arg_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_sk_GENERAL_NAME_num, call_args);
        }

        if (tmp_range_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 801;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_iter_arg_1 = BUILTIN_RANGE(tmp_range_arg_1);
        Py_DECREF(tmp_range_arg_1);
        if (tmp_iter_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 801;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_4 = MAKE_ITERATOR(tmp_iter_arg_1);
        Py_DECREF(tmp_iter_arg_1);
        if (tmp_assign_source_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 801;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        assert(tmp_for_loop_1__for_iterator == NULL);
        tmp_for_loop_1__for_iterator = tmp_assign_source_4;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_5;
        CHECK_OBJECT(tmp_for_loop_1__for_iterator);
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_5 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_5 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "oooooooo";
                exception_lineno = 801;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_5;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_6;
        CHECK_OBJECT(tmp_for_loop_1__iter_value);
        tmp_assign_source_6 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_i;
            var_i = tmp_assign_source_6;
            Py_INCREF(var_i);
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_args_element_name_8;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_6 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 802;
            type_description_1 = "oooooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_2 = tmp_mvar_value_6;
        CHECK_OBJECT(var_names);
        tmp_args_element_name_7 = var_names;
        CHECK_OBJECT(var_i);
        tmp_args_element_name_8 = var_i;
        frame_9d20210919ad40c1e8d81a9f37aef9bb->m_frame.f_lineno = 802;
        {
            PyObject *call_args[] = {tmp_args_element_name_7, tmp_args_element_name_8};
            tmp_assign_source_7 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_2, const_str_plain_sk_GENERAL_NAME_value, call_args);
        }

        if (tmp_assign_source_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 802;
            type_description_1 = "oooooooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_name;
            var_name = tmp_assign_source_7;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_8;
        tmp_assign_source_8 = Py_True;
        {
            PyObject *old = tmp_try_except_1__unhandled_indicator;
            tmp_try_except_1__unhandled_indicator = tmp_assign_source_8;
            Py_INCREF(tmp_try_except_1__unhandled_indicator);
            Py_XDECREF(old);
        }

    }
    // Tried code:
    // Tried code:
    {
        PyObject *tmp_assign_source_9;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_source_name_6;
        PyObject *tmp_subscript_name_1;
        PyObject *tmp_source_name_7;
        CHECK_OBJECT(par_self);
        tmp_source_name_6 = par_self;
        tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain__prefixes);
        if (tmp_subscribed_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 804;
            type_description_1 = "oooooooo";
            goto try_except_handler_4;
        }
        CHECK_OBJECT(var_name);
        tmp_source_name_7 = var_name;
        tmp_subscript_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain_type);
        if (tmp_subscript_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_subscribed_name_1);

            exception_lineno = 804;
            type_description_1 = "oooooooo";
            goto try_except_handler_4;
        }
        tmp_assign_source_9 = LOOKUP_SUBSCRIPT(tmp_subscribed_name_1, tmp_subscript_name_1);
        Py_DECREF(tmp_subscribed_name_1);
        Py_DECREF(tmp_subscript_name_1);
        if (tmp_assign_source_9 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 804;
            type_description_1 = "oooooooo";
            goto try_except_handler_4;
        }
        {
            PyObject *old = var_label;
            var_label = tmp_assign_source_9;
            Py_XDECREF(old);
        }

    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    {
        PyObject *tmp_assign_source_10;
        tmp_assign_source_10 = Py_False;
        {
            PyObject *old = tmp_try_except_1__unhandled_indicator;
            assert(old != NULL);
            tmp_try_except_1__unhandled_indicator = tmp_assign_source_10;
            Py_INCREF(tmp_try_except_1__unhandled_indicator);
            Py_DECREF(old);
        }

    }
    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION(frame_9d20210919ad40c1e8d81a9f37aef9bb);
    if (exception_keeper_tb_1 == NULL) {
        exception_keeper_tb_1 = MAKE_TRACEBACK(frame_9d20210919ad40c1e8d81a9f37aef9bb, exception_keeper_lineno_1);
    } else if (exception_keeper_lineno_1 != 0) {
        exception_keeper_tb_1 = ADD_TRACEBACK(exception_keeper_tb_1, frame_9d20210919ad40c1e8d81a9f37aef9bb, exception_keeper_lineno_1);
    }

    NORMALIZE_EXCEPTION(&exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1);
    PUBLISH_EXCEPTION(&exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1);
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_compexpr_left_1 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_1 = PyExc_KeyError;
        tmp_res = EXCEPTION_MATCH_BOOL(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 805;
            type_description_1 = "oooooooo";
            goto try_except_handler_3;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_11;
            PyObject *tmp_called_name_4;
            PyObject *tmp_mvar_value_7;
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf);

            if (unlikely(tmp_mvar_value_7 == NULL)) {
                tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf);
            }

            if (tmp_mvar_value_7 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 3591 ], 41, 0);
                exception_tb = NULL;

                exception_lineno = 806;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }

            tmp_called_name_4 = tmp_mvar_value_7;
            frame_9d20210919ad40c1e8d81a9f37aef9bb->m_frame.f_lineno = 806;
            tmp_assign_source_11 = CALL_FUNCTION_NO_ARGS(tmp_called_name_4);
            if (tmp_assign_source_11 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 806;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }
            {
                PyObject *old = var_bio;
                var_bio = tmp_assign_source_11;
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_called_instance_3;
            PyObject *tmp_mvar_value_8;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_9;
            PyObject *tmp_args_element_name_10;
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_8 == NULL)) {
                tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_8 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 807;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }

            tmp_called_instance_3 = tmp_mvar_value_8;
            CHECK_OBJECT(var_bio);
            tmp_args_element_name_9 = var_bio;
            CHECK_OBJECT(var_name);
            tmp_args_element_name_10 = var_name;
            frame_9d20210919ad40c1e8d81a9f37aef9bb->m_frame.f_lineno = 807;
            {
                PyObject *call_args[] = {tmp_args_element_name_9, tmp_args_element_name_10};
                tmp_call_result_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_3, const_str_plain_GENERAL_NAME_print, call_args);
            }

            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 807;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }
            Py_DECREF(tmp_call_result_1);
        }
        {
            PyObject *tmp_called_name_5;
            PyObject *tmp_source_name_8;
            PyObject *tmp_call_result_2;
            PyObject *tmp_args_element_name_11;
            PyObject *tmp_called_name_6;
            PyObject *tmp_mvar_value_9;
            PyObject *tmp_args_element_name_12;
            PyObject *tmp_called_name_7;
            PyObject *tmp_mvar_value_10;
            PyObject *tmp_args_element_name_13;
            CHECK_OBJECT(var_parts);
            tmp_source_name_8 = var_parts;
            tmp_called_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_8, const_str_plain_append);
            if (tmp_called_name_5 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 808;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__native);

            if (unlikely(tmp_mvar_value_9 == NULL)) {
                tmp_mvar_value_9 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__native);
            }

            if (tmp_mvar_value_9 == NULL) {
                Py_DECREF(tmp_called_name_5);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 1954 ], 36, 0);
                exception_tb = NULL;

                exception_lineno = 808;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }

            tmp_called_name_6 = tmp_mvar_value_9;
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__bio_to_string);

            if (unlikely(tmp_mvar_value_10 == NULL)) {
                tmp_mvar_value_10 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__bio_to_string);
            }

            if (tmp_mvar_value_10 == NULL) {
                Py_DECREF(tmp_called_name_5);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 3632 ], 43, 0);
                exception_tb = NULL;

                exception_lineno = 808;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }

            tmp_called_name_7 = tmp_mvar_value_10;
            CHECK_OBJECT(var_bio);
            tmp_args_element_name_13 = var_bio;
            frame_9d20210919ad40c1e8d81a9f37aef9bb->m_frame.f_lineno = 808;
            tmp_args_element_name_12 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_7, tmp_args_element_name_13);
            if (tmp_args_element_name_12 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_5);

                exception_lineno = 808;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }
            frame_9d20210919ad40c1e8d81a9f37aef9bb->m_frame.f_lineno = 808;
            tmp_args_element_name_11 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_6, tmp_args_element_name_12);
            Py_DECREF(tmp_args_element_name_12);
            if (tmp_args_element_name_11 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_5);

                exception_lineno = 808;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }
            frame_9d20210919ad40c1e8d81a9f37aef9bb->m_frame.f_lineno = 808;
            tmp_call_result_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_5, tmp_args_element_name_11);
            Py_DECREF(tmp_called_name_5);
            Py_DECREF(tmp_args_element_name_11);
            if (tmp_call_result_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 808;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }
            Py_DECREF(tmp_call_result_2);
        }
        goto branch_end_1;
        branch_no_1:;
        tmp_result = RERAISE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
        if (unlikely(tmp_result == false)) {
            exception_lineno = 803;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_9d20210919ad40c1e8d81a9f37aef9bb->m_frame) frame_9d20210919ad40c1e8d81a9f37aef9bb->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "oooooooo";
        goto try_except_handler_3;
        branch_end_1:;
    }
    goto try_end_1;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_36__subjectAltNameString);
    return NULL;
    // End of try:
    try_end_1:;
    {
        nuitka_bool tmp_condition_result_2;
        nuitka_bool tmp_compexpr_left_2;
        nuitka_bool tmp_compexpr_right_2;
        int tmp_truth_name_1;
        CHECK_OBJECT(tmp_try_except_1__unhandled_indicator);
        tmp_truth_name_1 = CHECK_IF_TRUE(tmp_try_except_1__unhandled_indicator);
        if (tmp_truth_name_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 803;
            type_description_1 = "oooooooo";
            goto try_except_handler_3;
        }
        tmp_compexpr_left_2 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_compexpr_right_2 = NUITKA_BOOL_TRUE;
        tmp_condition_result_2 = (tmp_compexpr_left_2 == tmp_compexpr_right_2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_12;
            PyObject *tmp_called_name_8;
            PyObject *tmp_mvar_value_11;
            PyObject *tmp_args_element_name_14;
            Py_ssize_t tmp_sliceslicedel_index_lower_1;
            Py_ssize_t tmp_slice_index_upper_1;
            PyObject *tmp_slice_source_1;
            PyObject *tmp_called_name_9;
            PyObject *tmp_source_name_9;
            PyObject *tmp_mvar_value_12;
            PyObject *tmp_args_element_name_15;
            PyObject *tmp_source_name_10;
            PyObject *tmp_source_name_11;
            PyObject *tmp_source_name_12;
            PyObject *tmp_args_element_name_16;
            PyObject *tmp_source_name_13;
            PyObject *tmp_source_name_14;
            PyObject *tmp_source_name_15;
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__native);

            if (unlikely(tmp_mvar_value_11 == NULL)) {
                tmp_mvar_value_11 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__native);
            }

            if (tmp_mvar_value_11 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 1954 ], 36, 0);
                exception_tb = NULL;

                exception_lineno = 810;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }

            tmp_called_name_8 = tmp_mvar_value_11;
            tmp_sliceslicedel_index_lower_1 = 0;
            tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_12 == NULL)) {
                tmp_mvar_value_12 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_12 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 811;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }

            tmp_source_name_9 = tmp_mvar_value_12;
            tmp_called_name_9 = LOOKUP_ATTRIBUTE(tmp_source_name_9, const_str_plain_buffer);
            if (tmp_called_name_9 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 811;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }
            CHECK_OBJECT(var_name);
            tmp_source_name_12 = var_name;
            tmp_source_name_11 = LOOKUP_ATTRIBUTE(tmp_source_name_12, const_str_plain_d);
            if (tmp_source_name_11 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_9);

                exception_lineno = 811;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }
            tmp_source_name_10 = LOOKUP_ATTRIBUTE(tmp_source_name_11, const_str_plain_ia5);
            Py_DECREF(tmp_source_name_11);
            if (tmp_source_name_10 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_9);

                exception_lineno = 811;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }
            tmp_args_element_name_15 = LOOKUP_ATTRIBUTE(tmp_source_name_10, const_str_plain_data);
            Py_DECREF(tmp_source_name_10);
            if (tmp_args_element_name_15 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_9);

                exception_lineno = 811;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }
            CHECK_OBJECT(var_name);
            tmp_source_name_15 = var_name;
            tmp_source_name_14 = LOOKUP_ATTRIBUTE(tmp_source_name_15, const_str_plain_d);
            if (tmp_source_name_14 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_9);
                Py_DECREF(tmp_args_element_name_15);

                exception_lineno = 811;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }
            tmp_source_name_13 = LOOKUP_ATTRIBUTE(tmp_source_name_14, const_str_plain_ia5);
            Py_DECREF(tmp_source_name_14);
            if (tmp_source_name_13 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_9);
                Py_DECREF(tmp_args_element_name_15);

                exception_lineno = 811;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }
            tmp_args_element_name_16 = LOOKUP_ATTRIBUTE(tmp_source_name_13, const_str_plain_length);
            Py_DECREF(tmp_source_name_13);
            if (tmp_args_element_name_16 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_9);
                Py_DECREF(tmp_args_element_name_15);

                exception_lineno = 811;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }
            frame_9d20210919ad40c1e8d81a9f37aef9bb->m_frame.f_lineno = 811;
            {
                PyObject *call_args[] = {tmp_args_element_name_15, tmp_args_element_name_16};
                tmp_slice_source_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_9, call_args);
            }

            Py_DECREF(tmp_called_name_9);
            Py_DECREF(tmp_args_element_name_15);
            Py_DECREF(tmp_args_element_name_16);
            if (tmp_slice_source_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 811;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }
            tmp_args_element_name_14 = LOOKUP_INDEX_SLICE(tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1);
            Py_DECREF(tmp_slice_source_1);
            if (tmp_args_element_name_14 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 811;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }
            frame_9d20210919ad40c1e8d81a9f37aef9bb->m_frame.f_lineno = 810;
            tmp_assign_source_12 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_8, tmp_args_element_name_14);
            Py_DECREF(tmp_args_element_name_14);
            if (tmp_assign_source_12 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 810;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }
            {
                PyObject *old = var_value;
                var_value = tmp_assign_source_12;
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_called_name_10;
            PyObject *tmp_source_name_16;
            PyObject *tmp_call_result_3;
            PyObject *tmp_args_element_name_17;
            PyObject *tmp_left_name_1;
            PyObject *tmp_left_name_2;
            PyObject *tmp_right_name_1;
            PyObject *tmp_right_name_2;
            CHECK_OBJECT(var_parts);
            tmp_source_name_16 = var_parts;
            tmp_called_name_10 = LOOKUP_ATTRIBUTE(tmp_source_name_16, const_str_plain_append);
            if (tmp_called_name_10 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 812;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }
            if (var_label == NULL) {
                Py_DECREF(tmp_called_name_10);
                exception_type = PyExc_UnboundLocalError;
                Py_INCREF(exception_type);
                exception_value = PyString_FromFormat("local variable '%s' referenced before assignment", "label");
                exception_tb = NULL;

                exception_lineno = 812;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }

            tmp_left_name_2 = var_label;
            tmp_right_name_1 = const_str_chr_58;
            tmp_left_name_1 = BINARY_OPERATION_ADD_OBJECT_STR(tmp_left_name_2, tmp_right_name_1);
            if (tmp_left_name_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_10);

                exception_lineno = 812;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }
            CHECK_OBJECT(var_value);
            tmp_right_name_2 = var_value;
            tmp_args_element_name_17 = BINARY_OPERATION_ADD_OBJECT_OBJECT(tmp_left_name_1, tmp_right_name_2);
            Py_DECREF(tmp_left_name_1);
            if (tmp_args_element_name_17 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_10);

                exception_lineno = 812;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }
            frame_9d20210919ad40c1e8d81a9f37aef9bb->m_frame.f_lineno = 812;
            tmp_call_result_3 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_10, tmp_args_element_name_17);
            Py_DECREF(tmp_called_name_10);
            Py_DECREF(tmp_args_element_name_17);
            if (tmp_call_result_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 812;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }
            Py_DECREF(tmp_call_result_3);
        }
        branch_no_2:;
    }
    goto try_end_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_try_except_1__unhandled_indicator);
    tmp_try_except_1__unhandled_indicator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto try_except_handler_2;
    // End of try:
    try_end_2:;
    CHECK_OBJECT((PyObject *)tmp_try_except_1__unhandled_indicator);
    Py_DECREF(tmp_try_except_1__unhandled_indicator);
    tmp_try_except_1__unhandled_indicator = NULL;

    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


        exception_lineno = 801;
        type_description_1 = "oooooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_3;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;
    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    {
        PyObject *tmp_called_instance_4;
        PyObject *tmp_args_element_name_18;
        tmp_called_instance_4 = const_str_digest_db35ab94a03c3cbeb13cbe2a1d728b77;
        CHECK_OBJECT(var_parts);
        tmp_args_element_name_18 = var_parts;
        frame_9d20210919ad40c1e8d81a9f37aef9bb->m_frame.f_lineno = 813;
        {
            PyObject *call_args[] = {tmp_args_element_name_18};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_4, const_str_plain_join, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 813;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 1
    RESTORE_FRAME_EXCEPTION(frame_9d20210919ad40c1e8d81a9f37aef9bb);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION(frame_9d20210919ad40c1e8d81a9f37aef9bb);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION(frame_9d20210919ad40c1e8d81a9f37aef9bb);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_9d20210919ad40c1e8d81a9f37aef9bb, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_9d20210919ad40c1e8d81a9f37aef9bb->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_9d20210919ad40c1e8d81a9f37aef9bb, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9d20210919ad40c1e8d81a9f37aef9bb,
        type_description_1,
        par_self,
        var_bio,
        var_name,
        var_i,
        var_value,
        var_label,
        var_parts,
        var_names
    );


    // Release cached frame.
    if (frame_9d20210919ad40c1e8d81a9f37aef9bb == cache_frame_9d20210919ad40c1e8d81a9f37aef9bb) {
        Py_DECREF(frame_9d20210919ad40c1e8d81a9f37aef9bb);
    }
    cache_frame_9d20210919ad40c1e8d81a9f37aef9bb = NULL;

    assertFrameObject(frame_9d20210919ad40c1e8d81a9f37aef9bb);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_36__subjectAltNameString);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_bio);
    var_bio = NULL;

    Py_XDECREF(var_name);
    var_name = NULL;

    Py_XDECREF(var_i);
    var_i = NULL;

    Py_XDECREF(var_value);
    var_value = NULL;

    Py_XDECREF(var_label);
    var_label = NULL;

    CHECK_OBJECT((PyObject *)var_parts);
    Py_DECREF(var_parts);
    var_parts = NULL;

    CHECK_OBJECT((PyObject *)var_names);
    Py_DECREF(var_names);
    var_names = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_bio);
    var_bio = NULL;

    Py_XDECREF(var_name);
    var_name = NULL;

    Py_XDECREF(var_i);
    var_i = NULL;

    Py_XDECREF(var_value);
    var_value = NULL;

    Py_XDECREF(var_label);
    var_label = NULL;

    Py_XDECREF(var_parts);
    var_parts = NULL;

    Py_XDECREF(var_names);
    var_names = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_36__subjectAltNameString);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_37___str__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_bio = NULL;
    PyObject *var_print_result = NULL;
    struct Nuitka_FrameObject *frame_bc037b68e8bf53563613e38c02309b68;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_bc037b68e8bf53563613e38c02309b68 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_bc037b68e8bf53563613e38c02309b68, codeobj_bc037b68e8bf53563613e38c02309b68, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_bc037b68e8bf53563613e38c02309b68 = cache_frame_bc037b68e8bf53563613e38c02309b68;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_bc037b68e8bf53563613e38c02309b68);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_bc037b68e8bf53563613e38c02309b68) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 819;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_NID_subject_alt_name);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 819;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__nid);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_1);

            exception_lineno = 819;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 819;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_1;
            CHECK_OBJECT(par_self);
            tmp_called_instance_1 = par_self;
            frame_bc037b68e8bf53563613e38c02309b68->m_frame.f_lineno = 820;
            tmp_return_value = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain__subjectAltNameString);
            if (tmp_return_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 820;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3591 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 822;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_2;
        frame_bc037b68e8bf53563613e38c02309b68->m_frame.f_lineno = 822;
        tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS(tmp_called_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 822;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_bio == NULL);
        var_bio = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 823;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_3;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_X509V3_EXT_print);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 823;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_bio);
        tmp_args_element_name_1 = var_bio;
        CHECK_OBJECT(par_self);
        tmp_source_name_4 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain__extension);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 823;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = const_int_0;
        tmp_args_element_name_4 = const_int_0;
        frame_bc037b68e8bf53563613e38c02309b68->m_frame.f_lineno = 823;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4};
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS4(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 823;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_print_result == NULL);
        var_print_result = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 824;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_4;
        CHECK_OBJECT(var_print_result);
        tmp_compexpr_left_2 = var_print_result;
        tmp_compexpr_right_2 = const_int_0;
        tmp_args_element_name_5 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
        if (tmp_args_element_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 824;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_bc037b68e8bf53563613e38c02309b68->m_frame.f_lineno = 824;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_3, tmp_args_element_name_5);
        Py_DECREF(tmp_args_element_name_5);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 824;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_called_name_4;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_called_name_5;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_args_element_name_7;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__native);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__native);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1954 ], 36, 0);
            exception_tb = NULL;

            exception_lineno = 826;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_4 = tmp_mvar_value_5;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__bio_to_string);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__bio_to_string);
        }

        if (tmp_mvar_value_6 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3632 ], 43, 0);
            exception_tb = NULL;

            exception_lineno = 826;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_5 = tmp_mvar_value_6;
        CHECK_OBJECT(var_bio);
        tmp_args_element_name_7 = var_bio;
        frame_bc037b68e8bf53563613e38c02309b68->m_frame.f_lineno = 826;
        tmp_args_element_name_6 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_5, tmp_args_element_name_7);
        if (tmp_args_element_name_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 826;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_bc037b68e8bf53563613e38c02309b68->m_frame.f_lineno = 826;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_4, tmp_args_element_name_6);
        Py_DECREF(tmp_args_element_name_6);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 826;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_bc037b68e8bf53563613e38c02309b68);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_bc037b68e8bf53563613e38c02309b68);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_bc037b68e8bf53563613e38c02309b68);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_bc037b68e8bf53563613e38c02309b68, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_bc037b68e8bf53563613e38c02309b68->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_bc037b68e8bf53563613e38c02309b68, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_bc037b68e8bf53563613e38c02309b68,
        type_description_1,
        par_self,
        var_bio,
        var_print_result
    );


    // Release cached frame.
    if (frame_bc037b68e8bf53563613e38c02309b68 == cache_frame_bc037b68e8bf53563613e38c02309b68) {
        Py_DECREF(frame_bc037b68e8bf53563613e38c02309b68);
    }
    cache_frame_bc037b68e8bf53563613e38c02309b68 = NULL;

    assertFrameObject(frame_bc037b68e8bf53563613e38c02309b68);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_37___str__);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_bio);
    var_bio = NULL;

    Py_XDECREF(var_print_result);
    var_print_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_bio);
    var_bio = NULL;

    Py_XDECREF(var_print_result);
    var_print_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_37___str__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_38_get_critical(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_b100013f16a2576dec9318822455e6e9;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_b100013f16a2576dec9318822455e6e9 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_b100013f16a2576dec9318822455e6e9, codeobj_b100013f16a2576dec9318822455e6e9, module_OpenSSL$crypto, sizeof(void *));
    frame_b100013f16a2576dec9318822455e6e9 = cache_frame_b100013f16a2576dec9318822455e6e9;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_b100013f16a2576dec9318822455e6e9);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_b100013f16a2576dec9318822455e6e9) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 834;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_X509_EXTENSION_get_critical);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 834;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__extension);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 834;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_b100013f16a2576dec9318822455e6e9->m_frame.f_lineno = 834;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 834;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b100013f16a2576dec9318822455e6e9);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_b100013f16a2576dec9318822455e6e9);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b100013f16a2576dec9318822455e6e9);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_b100013f16a2576dec9318822455e6e9, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_b100013f16a2576dec9318822455e6e9->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_b100013f16a2576dec9318822455e6e9, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b100013f16a2576dec9318822455e6e9,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_b100013f16a2576dec9318822455e6e9 == cache_frame_b100013f16a2576dec9318822455e6e9) {
        Py_DECREF(frame_b100013f16a2576dec9318822455e6e9);
    }
    cache_frame_b100013f16a2576dec9318822455e6e9 = NULL;

    assertFrameObject(frame_b100013f16a2576dec9318822455e6e9);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_38_get_critical);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_39_get_short_name(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_obj = NULL;
    PyObject *var_nid = NULL;
    struct Nuitka_FrameObject *frame_ba8c4dae468348f7ff9c62739bc12bc4;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_ba8c4dae468348f7ff9c62739bc12bc4 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_ba8c4dae468348f7ff9c62739bc12bc4, codeobj_ba8c4dae468348f7ff9c62739bc12bc4, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_ba8c4dae468348f7ff9c62739bc12bc4 = cache_frame_ba8c4dae468348f7ff9c62739bc12bc4;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_ba8c4dae468348f7ff9c62739bc12bc4);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_ba8c4dae468348f7ff9c62739bc12bc4) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 847;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_X509_EXTENSION_get_object);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 847;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__extension);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 847;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_ba8c4dae468348f7ff9c62739bc12bc4->m_frame.f_lineno = 847;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 847;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_obj == NULL);
        var_obj = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 848;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_2;
        CHECK_OBJECT(var_obj);
        tmp_args_element_name_2 = var_obj;
        frame_ba8c4dae468348f7ff9c62739bc12bc4->m_frame.f_lineno = 848;
        {
            PyObject *call_args[] = {tmp_args_element_name_2};
            tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_OBJ_obj2nid, call_args);
        }

        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 848;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_nid == NULL);
        var_nid = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 849;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_3;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_string);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 849;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_4 == NULL) {
            Py_DECREF(tmp_called_name_2);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 849;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_4;
        CHECK_OBJECT(var_nid);
        tmp_args_element_name_4 = var_nid;
        frame_ba8c4dae468348f7ff9c62739bc12bc4->m_frame.f_lineno = 849;
        {
            PyObject *call_args[] = {tmp_args_element_name_4};
            tmp_args_element_name_3 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_OBJ_nid2sn, call_args);
        }

        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 849;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_ba8c4dae468348f7ff9c62739bc12bc4->m_frame.f_lineno = 849;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_3);
        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 849;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ba8c4dae468348f7ff9c62739bc12bc4);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_ba8c4dae468348f7ff9c62739bc12bc4);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ba8c4dae468348f7ff9c62739bc12bc4);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_ba8c4dae468348f7ff9c62739bc12bc4, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_ba8c4dae468348f7ff9c62739bc12bc4->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_ba8c4dae468348f7ff9c62739bc12bc4, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ba8c4dae468348f7ff9c62739bc12bc4,
        type_description_1,
        par_self,
        var_obj,
        var_nid
    );


    // Release cached frame.
    if (frame_ba8c4dae468348f7ff9c62739bc12bc4 == cache_frame_ba8c4dae468348f7ff9c62739bc12bc4) {
        Py_DECREF(frame_ba8c4dae468348f7ff9c62739bc12bc4);
    }
    cache_frame_ba8c4dae468348f7ff9c62739bc12bc4 = NULL;

    assertFrameObject(frame_ba8c4dae468348f7ff9c62739bc12bc4);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_39_get_short_name);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_obj);
    Py_DECREF(var_obj);
    var_obj = NULL;

    CHECK_OBJECT((PyObject *)var_nid);
    Py_DECREF(var_nid);
    var_nid = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_obj);
    var_obj = NULL;

    Py_XDECREF(var_nid);
    var_nid = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_39_get_short_name);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_40_get_data(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_char_result = NULL;
    PyObject *var_octet_result = NULL;
    PyObject *var_string_result = NULL;
    PyObject *var_result_length = NULL;
    struct Nuitka_FrameObject *frame_c00a9d5fb891facbacf0fc1ab1c7e398;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_c00a9d5fb891facbacf0fc1ab1c7e398 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_c00a9d5fb891facbacf0fc1ab1c7e398, codeobj_c00a9d5fb891facbacf0fc1ab1c7e398, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_c00a9d5fb891facbacf0fc1ab1c7e398 = cache_frame_c00a9d5fb891facbacf0fc1ab1c7e398;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_c00a9d5fb891facbacf0fc1ab1c7e398);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_c00a9d5fb891facbacf0fc1ab1c7e398) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 860;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_X509_EXTENSION_get_data);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 860;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__extension);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 860;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_c00a9d5fb891facbacf0fc1ab1c7e398->m_frame.f_lineno = 860;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 860;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(var_octet_result == NULL);
        var_octet_result = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 861;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_2;
        tmp_args_element_name_2 = const_str_digest_dc9f0c0121231dfd2bb64dc64aae6cc9;
        CHECK_OBJECT(var_octet_result);
        tmp_args_element_name_3 = var_octet_result;
        frame_c00a9d5fb891facbacf0fc1ab1c7e398->m_frame.f_lineno = 861;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_assign_source_2 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain_cast, call_args);
        }

        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 861;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(var_string_result == NULL);
        var_string_result = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 862;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_3;
        CHECK_OBJECT(var_string_result);
        tmp_args_element_name_4 = var_string_result;
        frame_c00a9d5fb891facbacf0fc1ab1c7e398->m_frame.f_lineno = 862;
        {
            PyObject *call_args[] = {tmp_args_element_name_4};
            tmp_assign_source_3 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_ASN1_STRING_data, call_args);
        }

        if (tmp_assign_source_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 862;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(var_char_result == NULL);
        var_char_result = tmp_assign_source_3;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_5;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 863;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_3 = tmp_mvar_value_4;
        CHECK_OBJECT(var_string_result);
        tmp_args_element_name_5 = var_string_result;
        frame_c00a9d5fb891facbacf0fc1ab1c7e398->m_frame.f_lineno = 863;
        {
            PyObject *call_args[] = {tmp_args_element_name_5};
            tmp_assign_source_4 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_3, const_str_plain_ASN1_STRING_length, call_args);
        }

        if (tmp_assign_source_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 863;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(var_result_length == NULL);
        var_result_length = tmp_assign_source_4;
    }
    {
        Py_ssize_t tmp_sliceslicedel_index_lower_1;
        Py_ssize_t tmp_slice_index_upper_1;
        PyObject *tmp_slice_source_1;
        PyObject *tmp_called_instance_4;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_args_element_name_7;
        tmp_sliceslicedel_index_lower_1 = 0;
        tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 864;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_4 = tmp_mvar_value_5;
        CHECK_OBJECT(var_char_result);
        tmp_args_element_name_6 = var_char_result;
        CHECK_OBJECT(var_result_length);
        tmp_args_element_name_7 = var_result_length;
        frame_c00a9d5fb891facbacf0fc1ab1c7e398->m_frame.f_lineno = 864;
        {
            PyObject *call_args[] = {tmp_args_element_name_6, tmp_args_element_name_7};
            tmp_slice_source_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_4, const_str_plain_buffer, call_args);
        }

        if (tmp_slice_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 864;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = LOOKUP_INDEX_SLICE(tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1);
        Py_DECREF(tmp_slice_source_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 864;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c00a9d5fb891facbacf0fc1ab1c7e398);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_c00a9d5fb891facbacf0fc1ab1c7e398);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c00a9d5fb891facbacf0fc1ab1c7e398);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_c00a9d5fb891facbacf0fc1ab1c7e398, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_c00a9d5fb891facbacf0fc1ab1c7e398->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_c00a9d5fb891facbacf0fc1ab1c7e398, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c00a9d5fb891facbacf0fc1ab1c7e398,
        type_description_1,
        par_self,
        var_char_result,
        var_octet_result,
        var_string_result,
        var_result_length
    );


    // Release cached frame.
    if (frame_c00a9d5fb891facbacf0fc1ab1c7e398 == cache_frame_c00a9d5fb891facbacf0fc1ab1c7e398) {
        Py_DECREF(frame_c00a9d5fb891facbacf0fc1ab1c7e398);
    }
    cache_frame_c00a9d5fb891facbacf0fc1ab1c7e398 = NULL;

    assertFrameObject(frame_c00a9d5fb891facbacf0fc1ab1c7e398);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_40_get_data);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_char_result);
    Py_DECREF(var_char_result);
    var_char_result = NULL;

    CHECK_OBJECT((PyObject *)var_octet_result);
    Py_DECREF(var_octet_result);
    var_octet_result = NULL;

    CHECK_OBJECT((PyObject *)var_string_result);
    Py_DECREF(var_string_result);
    var_string_result = NULL;

    CHECK_OBJECT((PyObject *)var_result_length);
    Py_DECREF(var_result_length);
    var_result_length = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_char_result);
    var_char_result = NULL;

    Py_XDECREF(var_octet_result);
    var_octet_result = NULL;

    Py_XDECREF(var_string_result);
    var_string_result = NULL;

    Py_XDECREF(var_result_length);
    var_result_length = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_40_get_data);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_41___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_req = NULL;
    struct Nuitka_FrameObject *frame_80f015fcfa447ca62d4c55502f1ecad1;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_80f015fcfa447ca62d4c55502f1ecad1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_80f015fcfa447ca62d4c55502f1ecad1, codeobj_80f015fcfa447ca62d4c55502f1ecad1, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *));
    frame_80f015fcfa447ca62d4c55502f1ecad1 = cache_frame_80f015fcfa447ca62d4c55502f1ecad1;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_80f015fcfa447ca62d4c55502f1ecad1);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_80f015fcfa447ca62d4c55502f1ecad1) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 880;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_80f015fcfa447ca62d4c55502f1ecad1->m_frame.f_lineno = 880;
        tmp_assign_source_1 = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_X509_REQ_new);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 880;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert(var_req == NULL);
        var_req = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 881;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_gc);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 881;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_req);
        tmp_args_element_name_1 = var_req;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 881;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_X509_REQ_free);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 881;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_80f015fcfa447ca62d4c55502f1ecad1->m_frame.f_lineno = 881;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 881;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__req, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 881;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_call_result_1;
        CHECK_OBJECT(par_self);
        tmp_called_instance_2 = par_self;
        frame_80f015fcfa447ca62d4c55502f1ecad1->m_frame.f_lineno = 883;
        tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_set_version, &PyTuple_GET_ITEM(const_tuple_int_0_tuple, 0));

        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 883;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_80f015fcfa447ca62d4c55502f1ecad1);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_80f015fcfa447ca62d4c55502f1ecad1);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_80f015fcfa447ca62d4c55502f1ecad1, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_80f015fcfa447ca62d4c55502f1ecad1->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_80f015fcfa447ca62d4c55502f1ecad1, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_80f015fcfa447ca62d4c55502f1ecad1,
        type_description_1,
        par_self,
        var_req
    );


    // Release cached frame.
    if (frame_80f015fcfa447ca62d4c55502f1ecad1 == cache_frame_80f015fcfa447ca62d4c55502f1ecad1) {
        Py_DECREF(frame_80f015fcfa447ca62d4c55502f1ecad1);
    }
    cache_frame_80f015fcfa447ca62d4c55502f1ecad1 = NULL;

    assertFrameObject(frame_80f015fcfa447ca62d4c55502f1ecad1);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_41___init__);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_req);
    Py_DECREF(var_req);
    var_req = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_req);
    var_req = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_41___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_42_to_cryptography(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var__CertificateSigningRequest = NULL;
    PyObject *var_backend = NULL;
    struct Nuitka_FrameObject *frame_183dcbba32fef389a142755b74a73efe;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_183dcbba32fef389a142755b74a73efe = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_183dcbba32fef389a142755b74a73efe, codeobj_183dcbba32fef389a142755b74a73efe, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_183dcbba32fef389a142755b74a73efe = cache_frame_183dcbba32fef389a142755b74a73efe;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_183dcbba32fef389a142755b74a73efe);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_183dcbba32fef389a142755b74a73efe) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_import_name_from_1;
        PyObject *tmp_name_name_1;
        PyObject *tmp_globals_name_1;
        PyObject *tmp_locals_name_1;
        PyObject *tmp_fromlist_name_1;
        tmp_name_name_1 = const_str_digest_2b6a6c0099f1f1dd77d2725acd0722df;
        tmp_globals_name_1 = (PyObject *)moduledict_OpenSSL$crypto;
        tmp_locals_name_1 = Py_None;
        tmp_fromlist_name_1 = const_tuple_str_plain__CertificateSigningRequest_tuple;
        frame_183dcbba32fef389a142755b74a73efe->m_frame.f_lineno = 893;
        tmp_import_name_from_1 = IMPORT_MODULE4(tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1);
        if (tmp_import_name_from_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 893;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_1 = IMPORT_NAME(tmp_import_name_from_1, const_str_plain__CertificateSigningRequest);
        Py_DECREF(tmp_import_name_from_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 893;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var__CertificateSigningRequest == NULL);
        var__CertificateSigningRequest = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__get_backend);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__get_backend);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3241 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 896;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        frame_183dcbba32fef389a142755b74a73efe->m_frame.f_lineno = 896;
        tmp_assign_source_2 = CALL_FUNCTION_NO_ARGS(tmp_called_name_1);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 896;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_backend == NULL);
        var_backend = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(var__CertificateSigningRequest);
        tmp_called_name_2 = var__CertificateSigningRequest;
        CHECK_OBJECT(var_backend);
        tmp_args_element_name_1 = var_backend;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__req);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 897;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_183dcbba32fef389a142755b74a73efe->m_frame.f_lineno = 897;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_args_element_name_2);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 897;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_183dcbba32fef389a142755b74a73efe);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_183dcbba32fef389a142755b74a73efe);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_183dcbba32fef389a142755b74a73efe);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_183dcbba32fef389a142755b74a73efe, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_183dcbba32fef389a142755b74a73efe->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_183dcbba32fef389a142755b74a73efe, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_183dcbba32fef389a142755b74a73efe,
        type_description_1,
        par_self,
        var__CertificateSigningRequest,
        var_backend
    );


    // Release cached frame.
    if (frame_183dcbba32fef389a142755b74a73efe == cache_frame_183dcbba32fef389a142755b74a73efe) {
        Py_DECREF(frame_183dcbba32fef389a142755b74a73efe);
    }
    cache_frame_183dcbba32fef389a142755b74a73efe = NULL;

    assertFrameObject(frame_183dcbba32fef389a142755b74a73efe);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_42_to_cryptography);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var__CertificateSigningRequest);
    Py_DECREF(var__CertificateSigningRequest);
    var__CertificateSigningRequest = NULL;

    CHECK_OBJECT((PyObject *)var_backend);
    Py_DECREF(var_backend);
    var_backend = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var__CertificateSigningRequest);
    var__CertificateSigningRequest = NULL;

    Py_XDECREF(var_backend);
    var_backend = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_42_to_cryptography);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_43_from_cryptography(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_crypto_req = python_pars[1];
    PyObject *var_req = NULL;
    struct Nuitka_FrameObject *frame_d5561b45ad99d14efabf12463381b5d5;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_d5561b45ad99d14efabf12463381b5d5 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_d5561b45ad99d14efabf12463381b5d5, codeobj_d5561b45ad99d14efabf12463381b5d5, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_d5561b45ad99d14efabf12463381b5d5 = cache_frame_d5561b45ad99d14efabf12463381b5d5;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_d5561b45ad99d14efabf12463381b5d5);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_d5561b45ad99d14efabf12463381b5d5) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_crypto_req);
        tmp_isinstance_inst_1 = par_crypto_req;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_x509);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_x509);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3675 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 911;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_isinstance_cls_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_CertificateSigningRequest);
        if (tmp_isinstance_cls_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 911;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        Py_DECREF(tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 911;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 911;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_39641ea33feffed70915f1c391cc979e;
            frame_d5561b45ad99d14efabf12463381b5d5->m_frame.f_lineno = 912;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 912;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        CHECK_OBJECT(par_cls);
        tmp_called_name_1 = par_cls;
        frame_d5561b45ad99d14efabf12463381b5d5->m_frame.f_lineno = 914;
        tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS(tmp_called_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 914;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_req == NULL);
        var_req = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_crypto_req);
        tmp_source_name_2 = par_crypto_req;
        tmp_assattr_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__x509_req);
        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 915;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_req);
        tmp_assattr_target_1 = var_req;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__req, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 915;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_d5561b45ad99d14efabf12463381b5d5);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_d5561b45ad99d14efabf12463381b5d5);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_d5561b45ad99d14efabf12463381b5d5, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_d5561b45ad99d14efabf12463381b5d5->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_d5561b45ad99d14efabf12463381b5d5, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d5561b45ad99d14efabf12463381b5d5,
        type_description_1,
        par_cls,
        par_crypto_req,
        var_req
    );


    // Release cached frame.
    if (frame_d5561b45ad99d14efabf12463381b5d5 == cache_frame_d5561b45ad99d14efabf12463381b5d5) {
        Py_DECREF(frame_d5561b45ad99d14efabf12463381b5d5);
    }
    cache_frame_d5561b45ad99d14efabf12463381b5d5 = NULL;

    assertFrameObject(frame_d5561b45ad99d14efabf12463381b5d5);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT(var_req);
    tmp_return_value = var_req;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_43_from_cryptography);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_req);
    Py_DECREF(var_req);
    var_req = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_req);
    var_req = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_43_from_cryptography);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_crypto_req);
    Py_DECREF(par_crypto_req);
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_crypto_req);
    Py_DECREF(par_crypto_req);
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_44_set_pubkey(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_pkey = python_pars[1];
    PyObject *var_set_result = NULL;
    struct Nuitka_FrameObject *frame_e7a5b9023d1f01cca25bb4c11d94736c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_e7a5b9023d1f01cca25bb4c11d94736c = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_e7a5b9023d1f01cca25bb4c11d94736c, codeobj_e7a5b9023d1f01cca25bb4c11d94736c, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_e7a5b9023d1f01cca25bb4c11d94736c = cache_frame_e7a5b9023d1f01cca25bb4c11d94736c;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_e7a5b9023d1f01cca25bb4c11d94736c);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_e7a5b9023d1f01cca25bb4c11d94736c) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 927;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_X509_REQ_set_pubkey);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 927;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__req);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 927;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_pkey);
        tmp_source_name_3 = par_pkey;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__pkey);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_element_name_1);

            exception_lineno = 927;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_e7a5b9023d1f01cca25bb4c11d94736c->m_frame.f_lineno = 927;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 927;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_set_result == NULL);
        var_set_result = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 928;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT(var_set_result);
        tmp_compexpr_left_1 = var_set_result;
        tmp_compexpr_right_1 = const_int_pos_1;
        tmp_args_element_name_3 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 928;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_e7a5b9023d1f01cca25bb4c11d94736c->m_frame.f_lineno = 928;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_3);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 928;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e7a5b9023d1f01cca25bb4c11d94736c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e7a5b9023d1f01cca25bb4c11d94736c);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_e7a5b9023d1f01cca25bb4c11d94736c, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_e7a5b9023d1f01cca25bb4c11d94736c->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_e7a5b9023d1f01cca25bb4c11d94736c, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e7a5b9023d1f01cca25bb4c11d94736c,
        type_description_1,
        par_self,
        par_pkey,
        var_set_result
    );


    // Release cached frame.
    if (frame_e7a5b9023d1f01cca25bb4c11d94736c == cache_frame_e7a5b9023d1f01cca25bb4c11d94736c) {
        Py_DECREF(frame_e7a5b9023d1f01cca25bb4c11d94736c);
    }
    cache_frame_e7a5b9023d1f01cca25bb4c11d94736c = NULL;

    assertFrameObject(frame_e7a5b9023d1f01cca25bb4c11d94736c);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_44_set_pubkey);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_set_result);
    Py_DECREF(var_set_result);
    var_set_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_set_result);
    var_set_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_44_set_pubkey);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_pkey);
    Py_DECREF(par_pkey);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_pkey);
    Py_DECREF(par_pkey);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_45_get_pubkey(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_pkey = NULL;
    struct Nuitka_FrameObject *frame_7ebcd9852a4c17ff014df7666a66c809;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_7ebcd9852a4c17ff014df7666a66c809 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_7ebcd9852a4c17ff014df7666a66c809, codeobj_7ebcd9852a4c17ff014df7666a66c809, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *));
    frame_7ebcd9852a4c17ff014df7666a66c809 = cache_frame_7ebcd9852a4c17ff014df7666a66c809;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_7ebcd9852a4c17ff014df7666a66c809);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_7ebcd9852a4c17ff014df7666a66c809) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 978 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 937;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain___new__);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 937;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey);
        }

        if (tmp_mvar_value_2 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 978 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 937;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = tmp_mvar_value_2;
        frame_7ebcd9852a4c17ff014df7666a66c809->m_frame.f_lineno = 937;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 937;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert(var_pkey == NULL);
        var_pkey = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 938;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_X509_REQ_get_pubkey);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 938;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__req);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 938;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_7ebcd9852a4c17ff014df7666a66c809->m_frame.f_lineno = 938;
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_2);
        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 938;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_pkey);
        tmp_assattr_target_1 = var_pkey;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__pkey, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 938;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_4;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_5;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 939;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_4;
        CHECK_OBJECT(var_pkey);
        tmp_source_name_4 = var_pkey;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain__pkey);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 939;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_5 == NULL) {
            Py_DECREF(tmp_compexpr_left_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 939;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_5;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_NULL);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_1);

            exception_lineno = 939;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 939;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_7ebcd9852a4c17ff014df7666a66c809->m_frame.f_lineno = 939;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_3, tmp_args_element_name_3);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 939;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_source_name_7;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_8;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_assattr_target_2;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_6 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 940;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_6;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_gc);
        if (tmp_called_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 940;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_pkey);
        tmp_source_name_7 = var_pkey;
        tmp_args_element_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain__pkey);
        if (tmp_args_element_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_4);

            exception_lineno = 940;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_7 == NULL)) {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_7 == NULL) {
            Py_DECREF(tmp_called_name_4);
            Py_DECREF(tmp_args_element_name_4);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 940;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_8 = tmp_mvar_value_7;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_8, const_str_plain_EVP_PKEY_free);
        if (tmp_args_element_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_4);
            Py_DECREF(tmp_args_element_name_4);

            exception_lineno = 940;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_7ebcd9852a4c17ff014df7666a66c809->m_frame.f_lineno = 940;
        {
            PyObject *call_args[] = {tmp_args_element_name_4, tmp_args_element_name_5};
            tmp_assattr_name_2 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_4, call_args);
        }

        Py_DECREF(tmp_called_name_4);
        Py_DECREF(tmp_args_element_name_4);
        Py_DECREF(tmp_args_element_name_5);
        if (tmp_assattr_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 940;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_pkey);
        tmp_assattr_target_2 = var_pkey;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain__pkey, tmp_assattr_name_2);
        Py_DECREF(tmp_assattr_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 940;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_assattr_target_3;
        tmp_assattr_name_3 = Py_True;
        CHECK_OBJECT(var_pkey);
        tmp_assattr_target_3 = var_pkey;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_3, const_str_plain__only_public, tmp_assattr_name_3);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 941;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_7ebcd9852a4c17ff014df7666a66c809);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_7ebcd9852a4c17ff014df7666a66c809);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_7ebcd9852a4c17ff014df7666a66c809, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_7ebcd9852a4c17ff014df7666a66c809->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_7ebcd9852a4c17ff014df7666a66c809, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7ebcd9852a4c17ff014df7666a66c809,
        type_description_1,
        par_self,
        var_pkey
    );


    // Release cached frame.
    if (frame_7ebcd9852a4c17ff014df7666a66c809 == cache_frame_7ebcd9852a4c17ff014df7666a66c809) {
        Py_DECREF(frame_7ebcd9852a4c17ff014df7666a66c809);
    }
    cache_frame_7ebcd9852a4c17ff014df7666a66c809 = NULL;

    assertFrameObject(frame_7ebcd9852a4c17ff014df7666a66c809);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT(var_pkey);
    tmp_return_value = var_pkey;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_45_get_pubkey);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_pkey);
    Py_DECREF(var_pkey);
    var_pkey = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_pkey);
    var_pkey = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_45_get_pubkey);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_46_set_version(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_version = python_pars[1];
    PyObject *var_set_result = NULL;
    struct Nuitka_FrameObject *frame_80d62758301ca388b22f45ed7f965aa4;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_80d62758301ca388b22f45ed7f965aa4 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_80d62758301ca388b22f45ed7f965aa4, codeobj_80d62758301ca388b22f45ed7f965aa4, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_80d62758301ca388b22f45ed7f965aa4 = cache_frame_80d62758301ca388b22f45ed7f965aa4;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_80d62758301ca388b22f45ed7f965aa4);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_80d62758301ca388b22f45ed7f965aa4) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 952;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_X509_REQ_set_version);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 952;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__req);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 952;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_version);
        tmp_args_element_name_2 = par_version;
        frame_80d62758301ca388b22f45ed7f965aa4->m_frame.f_lineno = 952;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 952;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_set_result == NULL);
        var_set_result = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 953;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT(var_set_result);
        tmp_compexpr_left_1 = var_set_result;
        tmp_compexpr_right_1 = const_int_pos_1;
        tmp_args_element_name_3 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 953;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_80d62758301ca388b22f45ed7f965aa4->m_frame.f_lineno = 953;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_3);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 953;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_80d62758301ca388b22f45ed7f965aa4);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_80d62758301ca388b22f45ed7f965aa4);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_80d62758301ca388b22f45ed7f965aa4, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_80d62758301ca388b22f45ed7f965aa4->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_80d62758301ca388b22f45ed7f965aa4, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_80d62758301ca388b22f45ed7f965aa4,
        type_description_1,
        par_self,
        par_version,
        var_set_result
    );


    // Release cached frame.
    if (frame_80d62758301ca388b22f45ed7f965aa4 == cache_frame_80d62758301ca388b22f45ed7f965aa4) {
        Py_DECREF(frame_80d62758301ca388b22f45ed7f965aa4);
    }
    cache_frame_80d62758301ca388b22f45ed7f965aa4 = NULL;

    assertFrameObject(frame_80d62758301ca388b22f45ed7f965aa4);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_46_set_version);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_set_result);
    Py_DECREF(var_set_result);
    var_set_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_set_result);
    var_set_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_46_set_version);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_version);
    Py_DECREF(par_version);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_version);
    Py_DECREF(par_version);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_47_get_version(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_638f670f35af3781de5f2f4c9835741e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_638f670f35af3781de5f2f4c9835741e = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_638f670f35af3781de5f2f4c9835741e, codeobj_638f670f35af3781de5f2f4c9835741e, module_OpenSSL$crypto, sizeof(void *));
    frame_638f670f35af3781de5f2f4c9835741e = cache_frame_638f670f35af3781de5f2f4c9835741e;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_638f670f35af3781de5f2f4c9835741e);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_638f670f35af3781de5f2f4c9835741e) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 963;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_X509_REQ_get_version);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 963;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__req);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 963;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_638f670f35af3781de5f2f4c9835741e->m_frame.f_lineno = 963;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 963;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_638f670f35af3781de5f2f4c9835741e);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_638f670f35af3781de5f2f4c9835741e);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_638f670f35af3781de5f2f4c9835741e);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_638f670f35af3781de5f2f4c9835741e, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_638f670f35af3781de5f2f4c9835741e->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_638f670f35af3781de5f2f4c9835741e, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_638f670f35af3781de5f2f4c9835741e,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_638f670f35af3781de5f2f4c9835741e == cache_frame_638f670f35af3781de5f2f4c9835741e) {
        Py_DECREF(frame_638f670f35af3781de5f2f4c9835741e);
    }
    cache_frame_638f670f35af3781de5f2f4c9835741e = NULL;

    assertFrameObject(frame_638f670f35af3781de5f2f4c9835741e);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_47_get_version);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_48_get_subject(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_name = NULL;
    struct Nuitka_FrameObject *frame_ab9238934dc2a850ec08f1603c825e21;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_ab9238934dc2a850ec08f1603c825e21 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_ab9238934dc2a850ec08f1603c825e21, codeobj_ab9238934dc2a850ec08f1603c825e21, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *));
    frame_ab9238934dc2a850ec08f1603c825e21 = cache_frame_ab9238934dc2a850ec08f1603c825e21;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_ab9238934dc2a850ec08f1603c825e21);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_ab9238934dc2a850ec08f1603c825e21) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Name);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Name);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1105 ], 37, 0);
            exception_tb = NULL;

            exception_lineno = 977;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain___new__);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 977;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Name);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Name);
        }

        if (tmp_mvar_value_2 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1105 ], 37, 0);
            exception_tb = NULL;

            exception_lineno = 977;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = tmp_mvar_value_2;
        frame_ab9238934dc2a850ec08f1603c825e21->m_frame.f_lineno = 977;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 977;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert(var_name == NULL);
        var_name = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 978;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_X509_REQ_get_subject_name);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 978;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__req);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 978;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_ab9238934dc2a850ec08f1603c825e21->m_frame.f_lineno = 978;
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_2);
        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 978;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_name);
        tmp_assattr_target_1 = var_name;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__name, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 978;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_4;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_5;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 979;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_4;
        CHECK_OBJECT(var_name);
        tmp_source_name_4 = var_name;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain__name);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 979;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_5 == NULL) {
            Py_DECREF(tmp_compexpr_left_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 979;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_5;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_NULL);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_1);

            exception_lineno = 979;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 979;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_ab9238934dc2a850ec08f1603c825e21->m_frame.f_lineno = 979;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_3, tmp_args_element_name_3);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 979;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT(par_self);
        tmp_assattr_name_2 = par_self;
        CHECK_OBJECT(var_name);
        tmp_assattr_target_2 = var_name;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain__owner, tmp_assattr_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 983;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ab9238934dc2a850ec08f1603c825e21);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ab9238934dc2a850ec08f1603c825e21);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_ab9238934dc2a850ec08f1603c825e21, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_ab9238934dc2a850ec08f1603c825e21->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_ab9238934dc2a850ec08f1603c825e21, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ab9238934dc2a850ec08f1603c825e21,
        type_description_1,
        par_self,
        var_name
    );


    // Release cached frame.
    if (frame_ab9238934dc2a850ec08f1603c825e21 == cache_frame_ab9238934dc2a850ec08f1603c825e21) {
        Py_DECREF(frame_ab9238934dc2a850ec08f1603c825e21);
    }
    cache_frame_ab9238934dc2a850ec08f1603c825e21 = NULL;

    assertFrameObject(frame_ab9238934dc2a850ec08f1603c825e21);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT(var_name);
    tmp_return_value = var_name;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_48_get_subject);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_name);
    Py_DECREF(var_name);
    var_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_name);
    var_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_48_get_subject);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_49_add_extensions(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_extensions = python_pars[1];
    PyObject *var_ext = NULL;
    PyObject *var_stack = NULL;
    PyObject *var_add_result = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_23a2727bfec75a11d2ac8664eefa517a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_23a2727bfec75a11d2ac8664eefa517a = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_23a2727bfec75a11d2ac8664eefa517a, codeobj_23a2727bfec75a11d2ac8664eefa517a, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_23a2727bfec75a11d2ac8664eefa517a = cache_frame_23a2727bfec75a11d2ac8664eefa517a;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_23a2727bfec75a11d2ac8664eefa517a);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_23a2727bfec75a11d2ac8664eefa517a) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 995;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_23a2727bfec75a11d2ac8664eefa517a->m_frame.f_lineno = 995;
        tmp_assign_source_1 = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_sk_X509_EXTENSION_new_null);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 995;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(var_stack == NULL);
        var_stack = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 996;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_2;
        CHECK_OBJECT(var_stack);
        tmp_compexpr_left_1 = var_stack;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 996;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_3;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_NULL);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 996;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_1 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 996;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_23a2727bfec75a11d2ac8664eefa517a->m_frame.f_lineno = 996;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 996;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_5;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 998;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_4;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_gc);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 998;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_stack);
        tmp_args_element_name_2 = var_stack;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_5 == NULL) {
            Py_DECREF(tmp_called_name_2);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 998;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_5;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_sk_X509_EXTENSION_free);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 998;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_23a2727bfec75a11d2ac8664eefa517a->m_frame.f_lineno = 998;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 998;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var_stack;
            assert(old != NULL);
            var_stack = tmp_assign_source_2;
            Py_DECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_iter_arg_1;
        CHECK_OBJECT(par_extensions);
        tmp_iter_arg_1 = par_extensions;
        tmp_assign_source_3 = MAKE_ITERATOR(tmp_iter_arg_1);
        if (tmp_assign_source_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1000;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(tmp_for_loop_1__for_iterator == NULL);
        tmp_for_loop_1__for_iterator = tmp_assign_source_3;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_4;
        CHECK_OBJECT(tmp_for_loop_1__for_iterator);
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_4 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_4 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "ooooo";
                exception_lineno = 1000;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_4;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_5;
        CHECK_OBJECT(tmp_for_loop_1__iter_value);
        tmp_assign_source_5 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_ext;
            var_ext = tmp_assign_source_5;
            Py_INCREF(var_ext);
            Py_XDECREF(old);
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_6;
        CHECK_OBJECT(var_ext);
        tmp_isinstance_inst_1 = var_ext;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Extension);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Extension);
        }

        if (tmp_mvar_value_6 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3708 ], 42, 0);
            exception_tb = NULL;

            exception_lineno = 1001;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_6;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1001;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1001;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_c57795fb6a9ac3d47e928f9a8b608571;
            frame_23a2727bfec75a11d2ac8664eefa517a->m_frame.f_lineno = 1002;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1002;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_5;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_7 == NULL)) {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_7 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1005;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }

        tmp_source_name_4 = tmp_mvar_value_7;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_sk_X509_EXTENSION_push);
        if (tmp_called_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1005;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT(var_stack);
        tmp_args_element_name_4 = var_stack;
        CHECK_OBJECT(var_ext);
        tmp_source_name_5 = var_ext;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain__extension);
        if (tmp_args_element_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);

            exception_lineno = 1005;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
        frame_23a2727bfec75a11d2ac8664eefa517a->m_frame.f_lineno = 1005;
        {
            PyObject *call_args[] = {tmp_args_element_name_4, tmp_args_element_name_5};
            tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_3, call_args);
        }

        Py_DECREF(tmp_called_name_3);
        Py_DECREF(tmp_args_element_name_5);
        if (tmp_call_result_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1005;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
        Py_DECREF(tmp_call_result_2);
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


        exception_lineno = 1000;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_source_name_7;
        PyObject *tmp_args_element_name_7;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_8 == NULL)) {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_8 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1007;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_8;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_X509_REQ_add_extensions);
        if (tmp_called_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1007;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_7 = par_self;
        tmp_args_element_name_6 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain__req);
        if (tmp_args_element_name_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_4);

            exception_lineno = 1007;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_stack);
        tmp_args_element_name_7 = var_stack;
        frame_23a2727bfec75a11d2ac8664eefa517a->m_frame.f_lineno = 1007;
        {
            PyObject *call_args[] = {tmp_args_element_name_6, tmp_args_element_name_7};
            tmp_assign_source_6 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_4, call_args);
        }

        Py_DECREF(tmp_called_name_4);
        Py_DECREF(tmp_args_element_name_6);
        if (tmp_assign_source_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1007;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(var_add_result == NULL);
        var_add_result = tmp_assign_source_6;
    }
    {
        PyObject *tmp_called_name_5;
        PyObject *tmp_mvar_value_9;
        PyObject *tmp_call_result_3;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        tmp_mvar_value_9 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_9 == NULL)) {
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_9 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 1008;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_5 = tmp_mvar_value_9;
        CHECK_OBJECT(var_add_result);
        tmp_compexpr_left_2 = var_add_result;
        tmp_compexpr_right_2 = const_int_pos_1;
        tmp_args_element_name_8 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
        if (tmp_args_element_name_8 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1008;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_23a2727bfec75a11d2ac8664eefa517a->m_frame.f_lineno = 1008;
        tmp_call_result_3 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_5, tmp_args_element_name_8);
        Py_DECREF(tmp_args_element_name_8);
        if (tmp_call_result_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1008;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_3);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_23a2727bfec75a11d2ac8664eefa517a);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_23a2727bfec75a11d2ac8664eefa517a);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_23a2727bfec75a11d2ac8664eefa517a, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_23a2727bfec75a11d2ac8664eefa517a->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_23a2727bfec75a11d2ac8664eefa517a, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_23a2727bfec75a11d2ac8664eefa517a,
        type_description_1,
        par_self,
        par_extensions,
        var_ext,
        var_stack,
        var_add_result
    );


    // Release cached frame.
    if (frame_23a2727bfec75a11d2ac8664eefa517a == cache_frame_23a2727bfec75a11d2ac8664eefa517a) {
        Py_DECREF(frame_23a2727bfec75a11d2ac8664eefa517a);
    }
    cache_frame_23a2727bfec75a11d2ac8664eefa517a = NULL;

    assertFrameObject(frame_23a2727bfec75a11d2ac8664eefa517a);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_49_add_extensions);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_ext);
    var_ext = NULL;

    CHECK_OBJECT((PyObject *)var_stack);
    Py_DECREF(var_stack);
    var_stack = NULL;

    CHECK_OBJECT((PyObject *)var_add_result);
    Py_DECREF(var_add_result);
    var_add_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_ext);
    var_ext = NULL;

    Py_XDECREF(var_stack);
    var_stack = NULL;

    Py_XDECREF(var_add_result);
    var_add_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_49_add_extensions);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_extensions);
    Py_DECREF(par_extensions);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_extensions);
    Py_DECREF(par_extensions);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_50_get_extensions(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_i = NULL;
    PyObject *var_ext = NULL;
    PyObject *var_exts = NULL;
    PyObject *var_native_exts_obj = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_45711045417d5734fe1ffb353cc7753b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_45711045417d5734fe1ffb353cc7753b = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = PyList_New(0);
        assert(var_exts == NULL);
        var_exts = tmp_assign_source_1;
    }
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_45711045417d5734fe1ffb353cc7753b, codeobj_45711045417d5734fe1ffb353cc7753b, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_45711045417d5734fe1ffb353cc7753b = cache_frame_45711045417d5734fe1ffb353cc7753b;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_45711045417d5734fe1ffb353cc7753b);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_45711045417d5734fe1ffb353cc7753b) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1020;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_X509_REQ_get_extensions);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1020;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__req);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1020;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_45711045417d5734fe1ffb353cc7753b->m_frame.f_lineno = 1020;
        tmp_assign_source_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1020;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(var_native_exts_obj == NULL);
        var_native_exts_obj = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_range_arg_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1021;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_2;
        CHECK_OBJECT(var_native_exts_obj);
        tmp_args_element_name_2 = var_native_exts_obj;
        frame_45711045417d5734fe1ffb353cc7753b->m_frame.f_lineno = 1021;
        {
            PyObject *call_args[] = {tmp_args_element_name_2};
            tmp_range_arg_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_sk_X509_EXTENSION_num, call_args);
        }

        if (tmp_range_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1021;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_iter_arg_1 = BUILTIN_RANGE(tmp_range_arg_1);
        Py_DECREF(tmp_range_arg_1);
        if (tmp_iter_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1021;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_3 = MAKE_ITERATOR(tmp_iter_arg_1);
        Py_DECREF(tmp_iter_arg_1);
        if (tmp_assign_source_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1021;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(tmp_for_loop_1__for_iterator == NULL);
        tmp_for_loop_1__for_iterator = tmp_assign_source_3;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_4;
        CHECK_OBJECT(tmp_for_loop_1__for_iterator);
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_4 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_4 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "ooooo";
                exception_lineno = 1021;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_4;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_5;
        CHECK_OBJECT(tmp_for_loop_1__iter_value);
        tmp_assign_source_5 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_i;
            var_i = tmp_assign_source_5;
            Py_INCREF(var_i);
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_mvar_value_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Extension);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Extension);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3708 ], 42, 0);
            exception_tb = NULL;

            exception_lineno = 1022;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }

        tmp_source_name_3 = tmp_mvar_value_3;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain___new__);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1022;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Extension);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Extension);
        }

        if (tmp_mvar_value_4 == NULL) {
            Py_DECREF(tmp_called_name_2);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3708 ], 42, 0);
            exception_tb = NULL;

            exception_lineno = 1022;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }

        tmp_args_element_name_3 = tmp_mvar_value_4;
        frame_45711045417d5734fe1ffb353cc7753b->m_frame.f_lineno = 1022;
        tmp_assign_source_6 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_3);
        Py_DECREF(tmp_called_name_2);
        if (tmp_assign_source_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1022;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_ext;
            var_ext = tmp_assign_source_6;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1023;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_2 = tmp_mvar_value_5;
        CHECK_OBJECT(var_native_exts_obj);
        tmp_args_element_name_4 = var_native_exts_obj;
        CHECK_OBJECT(var_i);
        tmp_args_element_name_5 = var_i;
        frame_45711045417d5734fe1ffb353cc7753b->m_frame.f_lineno = 1023;
        {
            PyObject *call_args[] = {tmp_args_element_name_4, tmp_args_element_name_5};
            tmp_assattr_name_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_2, const_str_plain_sk_X509_EXTENSION_value, call_args);
        }

        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1023;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT(var_ext);
        tmp_assattr_target_1 = var_ext;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__extension, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1023;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
    }
    {
        PyObject *tmp_called_instance_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_6;
        CHECK_OBJECT(var_exts);
        tmp_called_instance_3 = var_exts;
        CHECK_OBJECT(var_ext);
        tmp_args_element_name_6 = var_ext;
        frame_45711045417d5734fe1ffb353cc7753b->m_frame.f_lineno = 1024;
        {
            PyObject *call_args[] = {tmp_args_element_name_6};
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_3, const_str_plain_append, call_args);
        }

        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1024;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
        Py_DECREF(tmp_call_result_1);
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


        exception_lineno = 1021;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_45711045417d5734fe1ffb353cc7753b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_45711045417d5734fe1ffb353cc7753b);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_45711045417d5734fe1ffb353cc7753b, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_45711045417d5734fe1ffb353cc7753b->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_45711045417d5734fe1ffb353cc7753b, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_45711045417d5734fe1ffb353cc7753b,
        type_description_1,
        par_self,
        var_i,
        var_ext,
        var_exts,
        var_native_exts_obj
    );


    // Release cached frame.
    if (frame_45711045417d5734fe1ffb353cc7753b == cache_frame_45711045417d5734fe1ffb353cc7753b) {
        Py_DECREF(frame_45711045417d5734fe1ffb353cc7753b);
    }
    cache_frame_45711045417d5734fe1ffb353cc7753b = NULL;

    assertFrameObject(frame_45711045417d5734fe1ffb353cc7753b);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    CHECK_OBJECT(var_exts);
    tmp_return_value = var_exts;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_50_get_extensions);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_i);
    var_i = NULL;

    Py_XDECREF(var_ext);
    var_ext = NULL;

    CHECK_OBJECT((PyObject *)var_exts);
    Py_DECREF(var_exts);
    var_exts = NULL;

    CHECK_OBJECT((PyObject *)var_native_exts_obj);
    Py_DECREF(var_native_exts_obj);
    var_native_exts_obj = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_i);
    var_i = NULL;

    Py_XDECREF(var_ext);
    var_ext = NULL;

    CHECK_OBJECT((PyObject *)var_exts);
    Py_DECREF(var_exts);
    var_exts = NULL;

    Py_XDECREF(var_native_exts_obj);
    var_native_exts_obj = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_50_get_extensions);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_51_sign(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_pkey = python_pars[1];
    PyObject *par_digest = python_pars[2];
    PyObject *var_digest_obj = NULL;
    PyObject *var_sign_result = NULL;
    struct Nuitka_FrameObject *frame_c91f46b1da28091dae5fe2a35b791807;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_c91f46b1da28091dae5fe2a35b791807 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_c91f46b1da28091dae5fe2a35b791807, codeobj_c91f46b1da28091dae5fe2a35b791807, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_c91f46b1da28091dae5fe2a35b791807 = cache_frame_c91f46b1da28091dae5fe2a35b791807;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_c91f46b1da28091dae5fe2a35b791807);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_c91f46b1da28091dae5fe2a35b791807) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_attribute_value_1;
        int tmp_truth_name_1;
        CHECK_OBJECT(par_pkey);
        tmp_source_name_1 = par_pkey;
        tmp_attribute_value_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__only_public);
        if (tmp_attribute_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1038;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE(tmp_attribute_value_1);
        if (tmp_truth_name_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_attribute_value_1);

            exception_lineno = 1038;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_attribute_value_1);
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_8aae826f04ca2a5df2a0de1a103a1f13;
            frame_c91f46b1da28091dae5fe2a35b791807->m_frame.f_lineno = 1039;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1039;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_pkey);
        tmp_source_name_2 = par_pkey;
        tmp_operand_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__initialized);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1041;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1041;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            tmp_make_exception_arg_2 = const_str_digest_d84b19202bfdec9cc8e6f9577d4fac5e;
            frame_c91f46b1da28091dae5fe2a35b791807->m_frame.f_lineno = 1042;
            tmp_raise_type_2 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_2);
            assert(!(tmp_raise_type_2 == NULL));
            exception_type = tmp_raise_type_2;
            exception_lineno = 1042;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1044;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_EVP_get_digestbyname);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1044;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__byte_string);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__byte_string);
        }

        if (tmp_mvar_value_2 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3511 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 1044;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT(par_digest);
        tmp_args_element_name_2 = par_digest;
        frame_c91f46b1da28091dae5fe2a35b791807->m_frame.f_lineno = 1044;
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_2);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1044;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_c91f46b1da28091dae5fe2a35b791807->m_frame.f_lineno = 1044;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1044;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(var_digest_obj == NULL);
        var_digest_obj = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_3;
        CHECK_OBJECT(var_digest_obj);
        tmp_compexpr_left_1 = var_digest_obj;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1045;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_3;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_NULL);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1045;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1045;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
            goto branch_yes_3;
        } else {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_raise_type_3;
            PyObject *tmp_make_exception_arg_3;
            tmp_make_exception_arg_3 = const_str_digest_500f278b67471fc0f770fccc80d65d95;
            frame_c91f46b1da28091dae5fe2a35b791807->m_frame.f_lineno = 1046;
            tmp_raise_type_3 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_3);
            assert(!(tmp_raise_type_3 == NULL));
            exception_type = tmp_raise_type_3;
            exception_lineno = 1046;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        branch_no_3:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_6;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_source_name_7;
        PyObject *tmp_args_element_name_5;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1048;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_4;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_X509_REQ_sign);
        if (tmp_called_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1048;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_6 = par_self;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain__req);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);

            exception_lineno = 1048;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_pkey);
        tmp_source_name_7 = par_pkey;
        tmp_args_element_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain__pkey);
        if (tmp_args_element_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);
            Py_DECREF(tmp_args_element_name_3);

            exception_lineno = 1048;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_digest_obj);
        tmp_args_element_name_5 = var_digest_obj;
        frame_c91f46b1da28091dae5fe2a35b791807->m_frame.f_lineno = 1048;
        {
            PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5};
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_3, call_args);
        }

        Py_DECREF(tmp_called_name_3);
        Py_DECREF(tmp_args_element_name_3);
        Py_DECREF(tmp_args_element_name_4);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1048;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(var_sign_result == NULL);
        var_sign_result = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_name_4;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 1049;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_4 = tmp_mvar_value_5;
        CHECK_OBJECT(var_sign_result);
        tmp_compexpr_left_2 = var_sign_result;
        tmp_compexpr_right_2 = const_int_0;
        tmp_args_element_name_6 = RICH_COMPARE_GT_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
        if (tmp_args_element_name_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1049;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_c91f46b1da28091dae5fe2a35b791807->m_frame.f_lineno = 1049;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_4, tmp_args_element_name_6);
        Py_DECREF(tmp_args_element_name_6);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1049;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c91f46b1da28091dae5fe2a35b791807);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c91f46b1da28091dae5fe2a35b791807);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_c91f46b1da28091dae5fe2a35b791807, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_c91f46b1da28091dae5fe2a35b791807->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_c91f46b1da28091dae5fe2a35b791807, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c91f46b1da28091dae5fe2a35b791807,
        type_description_1,
        par_self,
        par_pkey,
        par_digest,
        var_digest_obj,
        var_sign_result
    );


    // Release cached frame.
    if (frame_c91f46b1da28091dae5fe2a35b791807 == cache_frame_c91f46b1da28091dae5fe2a35b791807) {
        Py_DECREF(frame_c91f46b1da28091dae5fe2a35b791807);
    }
    cache_frame_c91f46b1da28091dae5fe2a35b791807 = NULL;

    assertFrameObject(frame_c91f46b1da28091dae5fe2a35b791807);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_51_sign);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_digest_obj);
    Py_DECREF(var_digest_obj);
    var_digest_obj = NULL;

    CHECK_OBJECT((PyObject *)var_sign_result);
    Py_DECREF(var_sign_result);
    var_sign_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_digest_obj);
    var_digest_obj = NULL;

    Py_XDECREF(var_sign_result);
    var_sign_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_51_sign);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_pkey);
    Py_DECREF(par_pkey);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_digest);
    Py_DECREF(par_digest);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_pkey);
    Py_DECREF(par_pkey);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_digest);
    Py_DECREF(par_digest);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_52_verify(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_pkey = python_pars[1];
    PyObject *var_result = NULL;
    struct Nuitka_FrameObject *frame_a6f140d90bf737cea4d50cfd537ab5e2;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_a6f140d90bf737cea4d50cfd537ab5e2 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_a6f140d90bf737cea4d50cfd537ab5e2, codeobj_a6f140d90bf737cea4d50cfd537ab5e2, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_a6f140d90bf737cea4d50cfd537ab5e2 = cache_frame_a6f140d90bf737cea4d50cfd537ab5e2;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_a6f140d90bf737cea4d50cfd537ab5e2);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_a6f140d90bf737cea4d50cfd537ab5e2) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_pkey);
        tmp_isinstance_inst_1 = par_pkey;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 978 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1063;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1063;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1063;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_499043b9b2da602637f07b1aa101ddfb;
            frame_a6f140d90bf737cea4d50cfd537ab5e2->m_frame.f_lineno = 1064;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1064;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1066;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_X509_REQ_verify);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1066;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__req);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1066;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_pkey);
        tmp_source_name_3 = par_pkey;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__pkey);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_element_name_1);

            exception_lineno = 1066;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_a6f140d90bf737cea4d50cfd537ab5e2->m_frame.f_lineno = 1066;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1066;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_result == NULL);
        var_result = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(var_result);
        tmp_compexpr_left_1 = var_result;
        tmp_compexpr_right_1 = const_int_0;
        tmp_res = RICH_COMPARE_BOOL_LTE_OBJECT_INT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1067;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_called_name_2;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_call_result_1;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error);
            }

            if (tmp_mvar_value_3 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 0 ], 49, 0);
                exception_tb = NULL;

                exception_lineno = 1068;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_2 = tmp_mvar_value_3;
            frame_a6f140d90bf737cea4d50cfd537ab5e2->m_frame.f_lineno = 1068;
            tmp_call_result_1 = CALL_FUNCTION_NO_ARGS(tmp_called_name_2);
            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1068;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_1);
        }
        branch_no_2:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a6f140d90bf737cea4d50cfd537ab5e2);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a6f140d90bf737cea4d50cfd537ab5e2);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_a6f140d90bf737cea4d50cfd537ab5e2, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_a6f140d90bf737cea4d50cfd537ab5e2->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_a6f140d90bf737cea4d50cfd537ab5e2, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a6f140d90bf737cea4d50cfd537ab5e2,
        type_description_1,
        par_self,
        par_pkey,
        var_result
    );


    // Release cached frame.
    if (frame_a6f140d90bf737cea4d50cfd537ab5e2 == cache_frame_a6f140d90bf737cea4d50cfd537ab5e2) {
        Py_DECREF(frame_a6f140d90bf737cea4d50cfd537ab5e2);
    }
    cache_frame_a6f140d90bf737cea4d50cfd537ab5e2 = NULL;

    assertFrameObject(frame_a6f140d90bf737cea4d50cfd537ab5e2);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT(var_result);
    tmp_return_value = var_result;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_52_verify);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_result);
    Py_DECREF(var_result);
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_result);
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_52_verify);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_pkey);
    Py_DECREF(par_pkey);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_pkey);
    Py_DECREF(par_pkey);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_53___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_x509 = NULL;
    struct Nuitka_FrameObject *frame_464dcdbbc2ccc429632456551d5ba288;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_464dcdbbc2ccc429632456551d5ba288 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_464dcdbbc2ccc429632456551d5ba288, codeobj_464dcdbbc2ccc429632456551d5ba288, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *));
    frame_464dcdbbc2ccc429632456551d5ba288 = cache_frame_464dcdbbc2ccc429632456551d5ba288;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_464dcdbbc2ccc429632456551d5ba288);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_464dcdbbc2ccc429632456551d5ba288) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1085;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_464dcdbbc2ccc429632456551d5ba288->m_frame.f_lineno = 1085;
        tmp_assign_source_1 = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_X509_new);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1085;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert(var_x509 == NULL);
        var_x509 = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 1086;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_2;
        CHECK_OBJECT(var_x509);
        tmp_compexpr_left_1 = var_x509;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1086;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_3;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_NULL);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1086;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_1 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1086;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_464dcdbbc2ccc429632456551d5ba288->m_frame.f_lineno = 1086;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1086;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1087;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_4;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_gc);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1087;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_x509);
        tmp_args_element_name_2 = var_x509;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_5 == NULL) {
            Py_DECREF(tmp_called_name_2);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1087;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_5;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_X509_free);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 1087;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_464dcdbbc2ccc429632456551d5ba288->m_frame.f_lineno = 1087;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1087;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__x509, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1087;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_assattr_target_2;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__X509NameInvalidator);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__X509NameInvalidator);
        }

        if (tmp_mvar_value_6 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3750 ], 49, 0);
            exception_tb = NULL;

            exception_lineno = 1089;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_6;
        frame_464dcdbbc2ccc429632456551d5ba288->m_frame.f_lineno = 1089;
        tmp_assattr_name_2 = CALL_FUNCTION_NO_ARGS(tmp_called_name_3);
        if (tmp_assattr_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1089;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain__issuer_invalidator, tmp_assattr_name_2);
        Py_DECREF(tmp_assattr_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1089;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_called_name_4;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_assattr_target_3;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__X509NameInvalidator);

        if (unlikely(tmp_mvar_value_7 == NULL)) {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__X509NameInvalidator);
        }

        if (tmp_mvar_value_7 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3750 ], 49, 0);
            exception_tb = NULL;

            exception_lineno = 1090;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_4 = tmp_mvar_value_7;
        frame_464dcdbbc2ccc429632456551d5ba288->m_frame.f_lineno = 1090;
        tmp_assattr_name_3 = CALL_FUNCTION_NO_ARGS(tmp_called_name_4);
        if (tmp_assattr_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1090;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_assattr_target_3 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_3, const_str_plain__subject_invalidator, tmp_assattr_name_3);
        Py_DECREF(tmp_assattr_name_3);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1090;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_464dcdbbc2ccc429632456551d5ba288);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_464dcdbbc2ccc429632456551d5ba288);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_464dcdbbc2ccc429632456551d5ba288, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_464dcdbbc2ccc429632456551d5ba288->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_464dcdbbc2ccc429632456551d5ba288, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_464dcdbbc2ccc429632456551d5ba288,
        type_description_1,
        par_self,
        var_x509
    );


    // Release cached frame.
    if (frame_464dcdbbc2ccc429632456551d5ba288 == cache_frame_464dcdbbc2ccc429632456551d5ba288) {
        Py_DECREF(frame_464dcdbbc2ccc429632456551d5ba288);
    }
    cache_frame_464dcdbbc2ccc429632456551d5ba288 = NULL;

    assertFrameObject(frame_464dcdbbc2ccc429632456551d5ba288);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_53___init__);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_x509);
    Py_DECREF(var_x509);
    var_x509 = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_x509);
    var_x509 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_53___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_54__from_raw_x509_ptr(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_x509 = python_pars[1];
    PyObject *var_cert = NULL;
    struct Nuitka_FrameObject *frame_f994384600d98651e10407a7de0bb709;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_f994384600d98651e10407a7de0bb709 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_f994384600d98651e10407a7de0bb709, codeobj_f994384600d98651e10407a7de0bb709, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_f994384600d98651e10407a7de0bb709 = cache_frame_f994384600d98651e10407a7de0bb709;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_f994384600d98651e10407a7de0bb709);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_f994384600d98651e10407a7de0bb709) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_cls);
        tmp_called_instance_1 = par_cls;
        CHECK_OBJECT(par_cls);
        tmp_args_element_name_1 = par_cls;
        frame_f994384600d98651e10407a7de0bb709->m_frame.f_lineno = 1094;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain___new__, call_args);
        }

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1094;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_cert == NULL);
        var_cert = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1095;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_gc);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1095;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_x509);
        tmp_args_element_name_2 = par_x509;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1095;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_X509_free);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1095;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_f994384600d98651e10407a7de0bb709->m_frame.f_lineno = 1095;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1095;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_cert);
        tmp_assattr_target_1 = var_cert;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__x509, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1095;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_assattr_target_2;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__X509NameInvalidator);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__X509NameInvalidator);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3750 ], 49, 0);
            exception_tb = NULL;

            exception_lineno = 1096;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_3;
        frame_f994384600d98651e10407a7de0bb709->m_frame.f_lineno = 1096;
        tmp_assattr_name_2 = CALL_FUNCTION_NO_ARGS(tmp_called_name_2);
        if (tmp_assattr_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1096;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_cert);
        tmp_assattr_target_2 = var_cert;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain__issuer_invalidator, tmp_assattr_name_2);
        Py_DECREF(tmp_assattr_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1096;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_assattr_target_3;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__X509NameInvalidator);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__X509NameInvalidator);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3750 ], 49, 0);
            exception_tb = NULL;

            exception_lineno = 1097;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_4;
        frame_f994384600d98651e10407a7de0bb709->m_frame.f_lineno = 1097;
        tmp_assattr_name_3 = CALL_FUNCTION_NO_ARGS(tmp_called_name_3);
        if (tmp_assattr_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1097;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_cert);
        tmp_assattr_target_3 = var_cert;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_3, const_str_plain__subject_invalidator, tmp_assattr_name_3);
        Py_DECREF(tmp_assattr_name_3);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1097;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_f994384600d98651e10407a7de0bb709);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_f994384600d98651e10407a7de0bb709);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_f994384600d98651e10407a7de0bb709, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_f994384600d98651e10407a7de0bb709->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_f994384600d98651e10407a7de0bb709, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f994384600d98651e10407a7de0bb709,
        type_description_1,
        par_cls,
        par_x509,
        var_cert
    );


    // Release cached frame.
    if (frame_f994384600d98651e10407a7de0bb709 == cache_frame_f994384600d98651e10407a7de0bb709) {
        Py_DECREF(frame_f994384600d98651e10407a7de0bb709);
    }
    cache_frame_f994384600d98651e10407a7de0bb709 = NULL;

    assertFrameObject(frame_f994384600d98651e10407a7de0bb709);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT(var_cert);
    tmp_return_value = var_cert;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_54__from_raw_x509_ptr);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_cert);
    Py_DECREF(var_cert);
    var_cert = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_cert);
    var_cert = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_54__from_raw_x509_ptr);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_x509);
    Py_DECREF(par_x509);
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_x509);
    Py_DECREF(par_x509);
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_55_to_cryptography(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var__Certificate = NULL;
    PyObject *var_backend = NULL;
    struct Nuitka_FrameObject *frame_97f156a5c2f4577fd55162ed1d43b342;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_97f156a5c2f4577fd55162ed1d43b342 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_97f156a5c2f4577fd55162ed1d43b342, codeobj_97f156a5c2f4577fd55162ed1d43b342, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_97f156a5c2f4577fd55162ed1d43b342 = cache_frame_97f156a5c2f4577fd55162ed1d43b342;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_97f156a5c2f4577fd55162ed1d43b342);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_97f156a5c2f4577fd55162ed1d43b342) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_import_name_from_1;
        PyObject *tmp_name_name_1;
        PyObject *tmp_globals_name_1;
        PyObject *tmp_locals_name_1;
        PyObject *tmp_fromlist_name_1;
        tmp_name_name_1 = const_str_digest_2b6a6c0099f1f1dd77d2725acd0722df;
        tmp_globals_name_1 = (PyObject *)moduledict_OpenSSL$crypto;
        tmp_locals_name_1 = Py_None;
        tmp_fromlist_name_1 = const_tuple_str_plain__Certificate_tuple;
        frame_97f156a5c2f4577fd55162ed1d43b342->m_frame.f_lineno = 1108;
        tmp_import_name_from_1 = IMPORT_MODULE4(tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1);
        if (tmp_import_name_from_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1108;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_1 = IMPORT_NAME(tmp_import_name_from_1, const_str_plain__Certificate);
        Py_DECREF(tmp_import_name_from_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1108;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var__Certificate == NULL);
        var__Certificate = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__get_backend);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__get_backend);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3241 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 1109;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        frame_97f156a5c2f4577fd55162ed1d43b342->m_frame.f_lineno = 1109;
        tmp_assign_source_2 = CALL_FUNCTION_NO_ARGS(tmp_called_name_1);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1109;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_backend == NULL);
        var_backend = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(var__Certificate);
        tmp_called_name_2 = var__Certificate;
        CHECK_OBJECT(var_backend);
        tmp_args_element_name_1 = var_backend;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__x509);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1110;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_97f156a5c2f4577fd55162ed1d43b342->m_frame.f_lineno = 1110;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_args_element_name_2);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1110;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_97f156a5c2f4577fd55162ed1d43b342);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_97f156a5c2f4577fd55162ed1d43b342);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_97f156a5c2f4577fd55162ed1d43b342);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_97f156a5c2f4577fd55162ed1d43b342, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_97f156a5c2f4577fd55162ed1d43b342->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_97f156a5c2f4577fd55162ed1d43b342, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_97f156a5c2f4577fd55162ed1d43b342,
        type_description_1,
        par_self,
        var__Certificate,
        var_backend
    );


    // Release cached frame.
    if (frame_97f156a5c2f4577fd55162ed1d43b342 == cache_frame_97f156a5c2f4577fd55162ed1d43b342) {
        Py_DECREF(frame_97f156a5c2f4577fd55162ed1d43b342);
    }
    cache_frame_97f156a5c2f4577fd55162ed1d43b342 = NULL;

    assertFrameObject(frame_97f156a5c2f4577fd55162ed1d43b342);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_55_to_cryptography);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var__Certificate);
    Py_DECREF(var__Certificate);
    var__Certificate = NULL;

    CHECK_OBJECT((PyObject *)var_backend);
    Py_DECREF(var_backend);
    var_backend = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var__Certificate);
    var__Certificate = NULL;

    Py_XDECREF(var_backend);
    var_backend = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_55_to_cryptography);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_56_from_cryptography(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_crypto_cert = python_pars[1];
    PyObject *var_cert = NULL;
    struct Nuitka_FrameObject *frame_1427e696c3581db99d7e88aa6e2d20e2;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_1427e696c3581db99d7e88aa6e2d20e2 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_1427e696c3581db99d7e88aa6e2d20e2, codeobj_1427e696c3581db99d7e88aa6e2d20e2, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_1427e696c3581db99d7e88aa6e2d20e2 = cache_frame_1427e696c3581db99d7e88aa6e2d20e2;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_1427e696c3581db99d7e88aa6e2d20e2);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_1427e696c3581db99d7e88aa6e2d20e2) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_crypto_cert);
        tmp_isinstance_inst_1 = par_crypto_cert;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_x509);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_x509);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3675 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1124;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_isinstance_cls_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_Certificate);
        if (tmp_isinstance_cls_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1124;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        Py_DECREF(tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1124;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1124;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_6674ab14e1178de501dfb968278a50b9;
            frame_1427e696c3581db99d7e88aa6e2d20e2->m_frame.f_lineno = 1125;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1125;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        CHECK_OBJECT(par_cls);
        tmp_called_name_1 = par_cls;
        frame_1427e696c3581db99d7e88aa6e2d20e2->m_frame.f_lineno = 1127;
        tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS(tmp_called_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1127;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_cert == NULL);
        var_cert = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_crypto_cert);
        tmp_source_name_2 = par_crypto_cert;
        tmp_assattr_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__x509);
        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1128;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_cert);
        tmp_assattr_target_1 = var_cert;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__x509, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1128;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_1427e696c3581db99d7e88aa6e2d20e2);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_1427e696c3581db99d7e88aa6e2d20e2);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_1427e696c3581db99d7e88aa6e2d20e2, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_1427e696c3581db99d7e88aa6e2d20e2->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_1427e696c3581db99d7e88aa6e2d20e2, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1427e696c3581db99d7e88aa6e2d20e2,
        type_description_1,
        par_cls,
        par_crypto_cert,
        var_cert
    );


    // Release cached frame.
    if (frame_1427e696c3581db99d7e88aa6e2d20e2 == cache_frame_1427e696c3581db99d7e88aa6e2d20e2) {
        Py_DECREF(frame_1427e696c3581db99d7e88aa6e2d20e2);
    }
    cache_frame_1427e696c3581db99d7e88aa6e2d20e2 = NULL;

    assertFrameObject(frame_1427e696c3581db99d7e88aa6e2d20e2);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT(var_cert);
    tmp_return_value = var_cert;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_56_from_cryptography);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_cert);
    Py_DECREF(var_cert);
    var_cert = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_cert);
    var_cert = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_56_from_cryptography);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_crypto_cert);
    Py_DECREF(par_crypto_cert);
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_crypto_cert);
    Py_DECREF(par_crypto_cert);
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_57_set_version(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_version = python_pars[1];
    struct Nuitka_FrameObject *frame_3e08719da027c8ef5763e0014ecff43a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_3e08719da027c8ef5763e0014ecff43a = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_3e08719da027c8ef5763e0014ecff43a, codeobj_3e08719da027c8ef5763e0014ecff43a, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *));
    frame_3e08719da027c8ef5763e0014ecff43a = cache_frame_3e08719da027c8ef5763e0014ecff43a;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_3e08719da027c8ef5763e0014ecff43a);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_3e08719da027c8ef5763e0014ecff43a) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        CHECK_OBJECT(par_version);
        tmp_isinstance_inst_1 = par_version;
        tmp_isinstance_cls_1 = (PyObject *)&PyInt_Type;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1141;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1141;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_2dbcbe3e7da77178b4a9da40244d072a;
            frame_3e08719da027c8ef5763e0014ecff43a->m_frame.f_lineno = 1142;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1142;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1144;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_X509_set_version);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1144;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__x509);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1144;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_version);
        tmp_args_element_name_2 = par_version;
        frame_3e08719da027c8ef5763e0014ecff43a->m_frame.f_lineno = 1144;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1144;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3e08719da027c8ef5763e0014ecff43a);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3e08719da027c8ef5763e0014ecff43a);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_3e08719da027c8ef5763e0014ecff43a, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_3e08719da027c8ef5763e0014ecff43a->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_3e08719da027c8ef5763e0014ecff43a, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3e08719da027c8ef5763e0014ecff43a,
        type_description_1,
        par_self,
        par_version
    );


    // Release cached frame.
    if (frame_3e08719da027c8ef5763e0014ecff43a == cache_frame_3e08719da027c8ef5763e0014ecff43a) {
        Py_DECREF(frame_3e08719da027c8ef5763e0014ecff43a);
    }
    cache_frame_3e08719da027c8ef5763e0014ecff43a = NULL;

    assertFrameObject(frame_3e08719da027c8ef5763e0014ecff43a);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_57_set_version);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_version);
    Py_DECREF(par_version);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_version);
    Py_DECREF(par_version);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_58_get_version(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_fcdc69651d69daf00844268634ce9361;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_fcdc69651d69daf00844268634ce9361 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_fcdc69651d69daf00844268634ce9361, codeobj_fcdc69651d69daf00844268634ce9361, module_OpenSSL$crypto, sizeof(void *));
    frame_fcdc69651d69daf00844268634ce9361 = cache_frame_fcdc69651d69daf00844268634ce9361;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_fcdc69651d69daf00844268634ce9361);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_fcdc69651d69daf00844268634ce9361) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1153;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_X509_get_version);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1153;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__x509);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1153;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_fcdc69651d69daf00844268634ce9361->m_frame.f_lineno = 1153;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1153;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_fcdc69651d69daf00844268634ce9361);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_fcdc69651d69daf00844268634ce9361);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_fcdc69651d69daf00844268634ce9361);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_fcdc69651d69daf00844268634ce9361, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_fcdc69651d69daf00844268634ce9361->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_fcdc69651d69daf00844268634ce9361, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_fcdc69651d69daf00844268634ce9361,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_fcdc69651d69daf00844268634ce9361 == cache_frame_fcdc69651d69daf00844268634ce9361) {
        Py_DECREF(frame_fcdc69651d69daf00844268634ce9361);
    }
    cache_frame_fcdc69651d69daf00844268634ce9361 = NULL;

    assertFrameObject(frame_fcdc69651d69daf00844268634ce9361);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_58_get_version);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_59_get_pubkey(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_pkey = NULL;
    struct Nuitka_FrameObject *frame_b2d34b562f393e96bd01c8d2200fd8b0;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_b2d34b562f393e96bd01c8d2200fd8b0 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_b2d34b562f393e96bd01c8d2200fd8b0, codeobj_b2d34b562f393e96bd01c8d2200fd8b0, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *));
    frame_b2d34b562f393e96bd01c8d2200fd8b0 = cache_frame_b2d34b562f393e96bd01c8d2200fd8b0;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_b2d34b562f393e96bd01c8d2200fd8b0);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_b2d34b562f393e96bd01c8d2200fd8b0) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 978 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1162;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain___new__);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1162;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey);
        }

        if (tmp_mvar_value_2 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 978 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1162;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = tmp_mvar_value_2;
        frame_b2d34b562f393e96bd01c8d2200fd8b0->m_frame.f_lineno = 1162;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1162;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert(var_pkey == NULL);
        var_pkey = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1163;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_X509_get_pubkey);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1163;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__x509);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 1163;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_b2d34b562f393e96bd01c8d2200fd8b0->m_frame.f_lineno = 1163;
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_2);
        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1163;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_pkey);
        tmp_assattr_target_1 = var_pkey;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__pkey, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1163;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_4;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_4;
        CHECK_OBJECT(var_pkey);
        tmp_source_name_4 = var_pkey;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain__pkey);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1164;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_4 == NULL) {
            Py_DECREF(tmp_compexpr_left_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1164;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_4;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_NULL);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_1);

            exception_lineno = 1164;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1164;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_name_3;
            PyObject *tmp_mvar_value_5;
            PyObject *tmp_call_result_1;
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error);

            if (unlikely(tmp_mvar_value_5 == NULL)) {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error);
            }

            if (tmp_mvar_value_5 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 0 ], 49, 0);
                exception_tb = NULL;

                exception_lineno = 1165;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_3 = tmp_mvar_value_5;
            frame_b2d34b562f393e96bd01c8d2200fd8b0->m_frame.f_lineno = 1165;
            tmp_call_result_1 = CALL_FUNCTION_NO_ARGS(tmp_called_name_3);
            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1165;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_1);
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_7;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_source_name_8;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_assattr_target_2;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_6 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1166;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_6;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_gc);
        if (tmp_called_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1166;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_pkey);
        tmp_source_name_7 = var_pkey;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain__pkey);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_4);

            exception_lineno = 1166;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_7 == NULL)) {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_7 == NULL) {
            Py_DECREF(tmp_called_name_4);
            Py_DECREF(tmp_args_element_name_3);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1166;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_8 = tmp_mvar_value_7;
        tmp_args_element_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_8, const_str_plain_EVP_PKEY_free);
        if (tmp_args_element_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_4);
            Py_DECREF(tmp_args_element_name_3);

            exception_lineno = 1166;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_b2d34b562f393e96bd01c8d2200fd8b0->m_frame.f_lineno = 1166;
        {
            PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4};
            tmp_assattr_name_2 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_4, call_args);
        }

        Py_DECREF(tmp_called_name_4);
        Py_DECREF(tmp_args_element_name_3);
        Py_DECREF(tmp_args_element_name_4);
        if (tmp_assattr_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1166;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_pkey);
        tmp_assattr_target_2 = var_pkey;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain__pkey, tmp_assattr_name_2);
        Py_DECREF(tmp_assattr_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1166;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_assattr_target_3;
        tmp_assattr_name_3 = Py_True;
        CHECK_OBJECT(var_pkey);
        tmp_assattr_target_3 = var_pkey;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_3, const_str_plain__only_public, tmp_assattr_name_3);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1167;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b2d34b562f393e96bd01c8d2200fd8b0);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b2d34b562f393e96bd01c8d2200fd8b0);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_b2d34b562f393e96bd01c8d2200fd8b0, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_b2d34b562f393e96bd01c8d2200fd8b0->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_b2d34b562f393e96bd01c8d2200fd8b0, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b2d34b562f393e96bd01c8d2200fd8b0,
        type_description_1,
        par_self,
        var_pkey
    );


    // Release cached frame.
    if (frame_b2d34b562f393e96bd01c8d2200fd8b0 == cache_frame_b2d34b562f393e96bd01c8d2200fd8b0) {
        Py_DECREF(frame_b2d34b562f393e96bd01c8d2200fd8b0);
    }
    cache_frame_b2d34b562f393e96bd01c8d2200fd8b0 = NULL;

    assertFrameObject(frame_b2d34b562f393e96bd01c8d2200fd8b0);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT(var_pkey);
    tmp_return_value = var_pkey;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_59_get_pubkey);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_pkey);
    Py_DECREF(var_pkey);
    var_pkey = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_pkey);
    var_pkey = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_59_get_pubkey);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_60_set_pubkey(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_pkey = python_pars[1];
    PyObject *var_set_result = NULL;
    struct Nuitka_FrameObject *frame_144ee34ca155af9932b2f45dad52e660;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_144ee34ca155af9932b2f45dad52e660 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_144ee34ca155af9932b2f45dad52e660, codeobj_144ee34ca155af9932b2f45dad52e660, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_144ee34ca155af9932b2f45dad52e660 = cache_frame_144ee34ca155af9932b2f45dad52e660;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_144ee34ca155af9932b2f45dad52e660);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_144ee34ca155af9932b2f45dad52e660) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_pkey);
        tmp_isinstance_inst_1 = par_pkey;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 978 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1179;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1179;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1179;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_499043b9b2da602637f07b1aa101ddfb;
            frame_144ee34ca155af9932b2f45dad52e660->m_frame.f_lineno = 1180;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1180;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1182;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_X509_set_pubkey);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1182;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__x509);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1182;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_pkey);
        tmp_source_name_3 = par_pkey;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__pkey);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_element_name_1);

            exception_lineno = 1182;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_144ee34ca155af9932b2f45dad52e660->m_frame.f_lineno = 1182;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1182;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_set_result == NULL);
        var_set_result = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 1183;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_3;
        CHECK_OBJECT(var_set_result);
        tmp_compexpr_left_1 = var_set_result;
        tmp_compexpr_right_1 = const_int_pos_1;
        tmp_args_element_name_3 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1183;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_144ee34ca155af9932b2f45dad52e660->m_frame.f_lineno = 1183;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_3);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1183;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_144ee34ca155af9932b2f45dad52e660);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_144ee34ca155af9932b2f45dad52e660);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_144ee34ca155af9932b2f45dad52e660, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_144ee34ca155af9932b2f45dad52e660->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_144ee34ca155af9932b2f45dad52e660, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_144ee34ca155af9932b2f45dad52e660,
        type_description_1,
        par_self,
        par_pkey,
        var_set_result
    );


    // Release cached frame.
    if (frame_144ee34ca155af9932b2f45dad52e660 == cache_frame_144ee34ca155af9932b2f45dad52e660) {
        Py_DECREF(frame_144ee34ca155af9932b2f45dad52e660);
    }
    cache_frame_144ee34ca155af9932b2f45dad52e660 = NULL;

    assertFrameObject(frame_144ee34ca155af9932b2f45dad52e660);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_60_set_pubkey);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_set_result);
    Py_DECREF(var_set_result);
    var_set_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_set_result);
    var_set_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_60_set_pubkey);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_pkey);
    Py_DECREF(par_pkey);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_pkey);
    Py_DECREF(par_pkey);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_61_sign(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_pkey = python_pars[1];
    PyObject *par_digest = python_pars[2];
    PyObject *var_sign_result = NULL;
    PyObject *var_evp_md = NULL;
    struct Nuitka_FrameObject *frame_4f6e8e494b7d709f425892031ee6c86e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_4f6e8e494b7d709f425892031ee6c86e = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_4f6e8e494b7d709f425892031ee6c86e, codeobj_4f6e8e494b7d709f425892031ee6c86e, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_4f6e8e494b7d709f425892031ee6c86e = cache_frame_4f6e8e494b7d709f425892031ee6c86e;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_4f6e8e494b7d709f425892031ee6c86e);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_4f6e8e494b7d709f425892031ee6c86e) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_pkey);
        tmp_isinstance_inst_1 = par_pkey;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 978 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1197;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1197;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1197;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_499043b9b2da602637f07b1aa101ddfb;
            frame_4f6e8e494b7d709f425892031ee6c86e->m_frame.f_lineno = 1198;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1198;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_attribute_value_1;
        int tmp_truth_name_1;
        CHECK_OBJECT(par_pkey);
        tmp_source_name_1 = par_pkey;
        tmp_attribute_value_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__only_public);
        if (tmp_attribute_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1200;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE(tmp_attribute_value_1);
        if (tmp_truth_name_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_attribute_value_1);

            exception_lineno = 1200;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_attribute_value_1);
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            tmp_make_exception_arg_2 = const_str_digest_dc44ec2c02bcac7fac23b8eea57aa5d6;
            frame_4f6e8e494b7d709f425892031ee6c86e->m_frame.f_lineno = 1201;
            tmp_raise_type_2 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_2);
            assert(!(tmp_raise_type_2 == NULL));
            exception_type = tmp_raise_type_2;
            exception_lineno = 1201;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_operand_name_2;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_pkey);
        tmp_source_name_2 = par_pkey;
        tmp_operand_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__initialized);
        if (tmp_operand_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1203;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_2);
        Py_DECREF(tmp_operand_name_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1203;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
            goto branch_yes_3;
        } else {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_raise_type_3;
            PyObject *tmp_make_exception_arg_3;
            tmp_make_exception_arg_3 = const_str_digest_d84b19202bfdec9cc8e6f9577d4fac5e;
            frame_4f6e8e494b7d709f425892031ee6c86e->m_frame.f_lineno = 1204;
            tmp_raise_type_3 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_3);
            assert(!(tmp_raise_type_3 == NULL));
            exception_type = tmp_raise_type_3;
            exception_lineno = 1204;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        branch_no_3:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1206;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_EVP_get_digestbyname);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1206;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__byte_string);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__byte_string);
        }

        if (tmp_mvar_value_3 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3511 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 1206;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_3;
        CHECK_OBJECT(par_digest);
        tmp_args_element_name_2 = par_digest;
        frame_4f6e8e494b7d709f425892031ee6c86e->m_frame.f_lineno = 1206;
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_2);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1206;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_4f6e8e494b7d709f425892031ee6c86e->m_frame.f_lineno = 1206;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1206;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(var_evp_md == NULL);
        var_evp_md = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_4;
        CHECK_OBJECT(var_evp_md);
        tmp_compexpr_left_1 = var_evp_md;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1207;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_4;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_NULL);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1207;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1207;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_4 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_4 == NUITKA_BOOL_TRUE) {
            goto branch_yes_4;
        } else {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_raise_type_4;
            PyObject *tmp_make_exception_arg_4;
            tmp_make_exception_arg_4 = const_str_digest_500f278b67471fc0f770fccc80d65d95;
            frame_4f6e8e494b7d709f425892031ee6c86e->m_frame.f_lineno = 1208;
            tmp_raise_type_4 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_4);
            assert(!(tmp_raise_type_4 == NULL));
            exception_type = tmp_raise_type_4;
            exception_lineno = 1208;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        branch_no_4:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_6;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_source_name_7;
        PyObject *tmp_args_element_name_5;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1210;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_5;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_X509_sign);
        if (tmp_called_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1210;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_6 = par_self;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain__x509);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);

            exception_lineno = 1210;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_pkey);
        tmp_source_name_7 = par_pkey;
        tmp_args_element_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain__pkey);
        if (tmp_args_element_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);
            Py_DECREF(tmp_args_element_name_3);

            exception_lineno = 1210;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_evp_md);
        tmp_args_element_name_5 = var_evp_md;
        frame_4f6e8e494b7d709f425892031ee6c86e->m_frame.f_lineno = 1210;
        {
            PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5};
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_3, call_args);
        }

        Py_DECREF(tmp_called_name_3);
        Py_DECREF(tmp_args_element_name_3);
        Py_DECREF(tmp_args_element_name_4);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1210;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(var_sign_result == NULL);
        var_sign_result = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_name_4;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_6 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 1211;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_4 = tmp_mvar_value_6;
        CHECK_OBJECT(var_sign_result);
        tmp_compexpr_left_2 = var_sign_result;
        tmp_compexpr_right_2 = const_int_0;
        tmp_args_element_name_6 = RICH_COMPARE_GT_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
        if (tmp_args_element_name_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1211;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_4f6e8e494b7d709f425892031ee6c86e->m_frame.f_lineno = 1211;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_4, tmp_args_element_name_6);
        Py_DECREF(tmp_args_element_name_6);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1211;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_4f6e8e494b7d709f425892031ee6c86e);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_4f6e8e494b7d709f425892031ee6c86e);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_4f6e8e494b7d709f425892031ee6c86e, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_4f6e8e494b7d709f425892031ee6c86e->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_4f6e8e494b7d709f425892031ee6c86e, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4f6e8e494b7d709f425892031ee6c86e,
        type_description_1,
        par_self,
        par_pkey,
        par_digest,
        var_sign_result,
        var_evp_md
    );


    // Release cached frame.
    if (frame_4f6e8e494b7d709f425892031ee6c86e == cache_frame_4f6e8e494b7d709f425892031ee6c86e) {
        Py_DECREF(frame_4f6e8e494b7d709f425892031ee6c86e);
    }
    cache_frame_4f6e8e494b7d709f425892031ee6c86e = NULL;

    assertFrameObject(frame_4f6e8e494b7d709f425892031ee6c86e);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_61_sign);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_sign_result);
    Py_DECREF(var_sign_result);
    var_sign_result = NULL;

    CHECK_OBJECT((PyObject *)var_evp_md);
    Py_DECREF(var_evp_md);
    var_evp_md = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_sign_result);
    var_sign_result = NULL;

    Py_XDECREF(var_evp_md);
    var_evp_md = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_61_sign);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_pkey);
    Py_DECREF(par_pkey);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_digest);
    Py_DECREF(par_digest);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_pkey);
    Py_DECREF(par_pkey);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_digest);
    Py_DECREF(par_digest);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_62_get_signature_algorithm(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_algor = NULL;
    PyObject *var_nid = NULL;
    struct Nuitka_FrameObject *frame_cdc94e00f8d570018ee7361d163914a9;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_cdc94e00f8d570018ee7361d163914a9 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_cdc94e00f8d570018ee7361d163914a9, codeobj_cdc94e00f8d570018ee7361d163914a9, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_cdc94e00f8d570018ee7361d163914a9 = cache_frame_cdc94e00f8d570018ee7361d163914a9;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_cdc94e00f8d570018ee7361d163914a9);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_cdc94e00f8d570018ee7361d163914a9) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1224;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_X509_get0_tbs_sigalg);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1224;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__x509);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1224;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_cdc94e00f8d570018ee7361d163914a9->m_frame.f_lineno = 1224;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1224;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_algor == NULL);
        var_algor = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_4;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1225;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_OBJ_obj2nid);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1225;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_algor);
        tmp_source_name_4 = var_algor;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_algorithm);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 1225;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_cdc94e00f8d570018ee7361d163914a9->m_frame.f_lineno = 1225;
        tmp_assign_source_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_2);
        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1225;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_nid == NULL);
        var_nid = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_3;
        CHECK_OBJECT(var_nid);
        tmp_compexpr_left_1 = var_nid;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1226;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_3;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_NID_undef);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1226;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1226;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_79dac080796da8f8fc9c66ebe460ce2f;
            frame_cdc94e00f8d570018ee7361d163914a9->m_frame.f_lineno = 1227;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1227;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1228;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_4;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_string);
        if (tmp_called_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1228;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_5 == NULL) {
            Py_DECREF(tmp_called_name_3);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1228;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_5;
        CHECK_OBJECT(var_nid);
        tmp_args_element_name_4 = var_nid;
        frame_cdc94e00f8d570018ee7361d163914a9->m_frame.f_lineno = 1228;
        {
            PyObject *call_args[] = {tmp_args_element_name_4};
            tmp_args_element_name_3 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_OBJ_nid2ln, call_args);
        }

        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);

            exception_lineno = 1228;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_cdc94e00f8d570018ee7361d163914a9->m_frame.f_lineno = 1228;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_3, tmp_args_element_name_3);
        Py_DECREF(tmp_called_name_3);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1228;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_cdc94e00f8d570018ee7361d163914a9);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_cdc94e00f8d570018ee7361d163914a9);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_cdc94e00f8d570018ee7361d163914a9);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_cdc94e00f8d570018ee7361d163914a9, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_cdc94e00f8d570018ee7361d163914a9->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_cdc94e00f8d570018ee7361d163914a9, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_cdc94e00f8d570018ee7361d163914a9,
        type_description_1,
        par_self,
        var_algor,
        var_nid
    );


    // Release cached frame.
    if (frame_cdc94e00f8d570018ee7361d163914a9 == cache_frame_cdc94e00f8d570018ee7361d163914a9) {
        Py_DECREF(frame_cdc94e00f8d570018ee7361d163914a9);
    }
    cache_frame_cdc94e00f8d570018ee7361d163914a9 = NULL;

    assertFrameObject(frame_cdc94e00f8d570018ee7361d163914a9);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_62_get_signature_algorithm);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_algor);
    Py_DECREF(var_algor);
    var_algor = NULL;

    CHECK_OBJECT((PyObject *)var_nid);
    Py_DECREF(var_nid);
    var_nid = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_algor);
    var_algor = NULL;

    Py_XDECREF(var_nid);
    var_nid = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_62_get_signature_algorithm);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_63_digest(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_digest_name = python_pars[1];
    PyObject *var_digest_result = NULL;
    PyObject *var_ch = NULL;
    PyObject *var_result_length = NULL;
    PyObject *var_result_buffer = NULL;
    PyObject *var_digest = NULL;
    PyObject *tmp_list_contraction_1__$0 = NULL;
    PyObject *tmp_list_contraction_1__contraction_result = NULL;
    PyObject *tmp_list_contraction_1__iter_value_0 = NULL;
    struct Nuitka_FrameObject *frame_4f7104a5c773de3617ea99428a718a9f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_4f7104a5c773de3617ea99428a718a9f = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_4f7104a5c773de3617ea99428a718a9f, codeobj_4f7104a5c773de3617ea99428a718a9f, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_4f7104a5c773de3617ea99428a718a9f = cache_frame_4f7104a5c773de3617ea99428a718a9f;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_4f7104a5c773de3617ea99428a718a9f);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_4f7104a5c773de3617ea99428a718a9f) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1241;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_EVP_get_digestbyname);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1241;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__byte_string);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__byte_string);
        }

        if (tmp_mvar_value_2 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3511 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 1241;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT(par_digest_name);
        tmp_args_element_name_2 = par_digest_name;
        frame_4f7104a5c773de3617ea99428a718a9f->m_frame.f_lineno = 1241;
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_2);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1241;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        frame_4f7104a5c773de3617ea99428a718a9f->m_frame.f_lineno = 1241;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1241;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_digest == NULL);
        var_digest = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        CHECK_OBJECT(var_digest);
        tmp_compexpr_left_1 = var_digest;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1242;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_NULL);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1242;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1242;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_500f278b67471fc0f770fccc80d65d95;
            frame_4f7104a5c773de3617ea99428a718a9f->m_frame.f_lineno = 1243;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1243;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_5;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1245;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_4;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_new);
        if (tmp_called_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1245;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = const_str_digest_81f1b0dfcc7a862e6940580ec4cc42d3;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_5 == NULL) {
            Py_DECREF(tmp_called_name_3);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1245;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_5;
        tmp_args_element_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_EVP_MAX_MD_SIZE);
        if (tmp_args_element_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);

            exception_lineno = 1245;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        frame_4f7104a5c773de3617ea99428a718a9f->m_frame.f_lineno = 1245;
        {
            PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4};
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_3, call_args);
        }

        Py_DECREF(tmp_called_name_3);
        Py_DECREF(tmp_args_element_name_4);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1245;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_result_buffer == NULL);
        var_result_buffer = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_6;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_6 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1246;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_6;
        frame_4f7104a5c773de3617ea99428a718a9f->m_frame.f_lineno = 1246;
        tmp_assign_source_3 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain_new, &PyTuple_GET_ITEM(const_tuple_str_digest_bc7a2d385ac0b4ca6f6caa64ccb6a3b9_int_pos_1_tuple, 0));

        if (tmp_assign_source_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1246;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_result_length == NULL);
        var_result_length = tmp_assign_source_3;
    }
    {
        PyObject *tmp_ass_subvalue_1;
        PyObject *tmp_len_arg_1;
        PyObject *tmp_ass_subscribed_1;
        PyObject *tmp_ass_subscript_1;
        int tmp_ass_subscript_res_1;
        CHECK_OBJECT(var_result_buffer);
        tmp_len_arg_1 = var_result_buffer;
        tmp_ass_subvalue_1 = BUILTIN_LEN(tmp_len_arg_1);
        if (tmp_ass_subvalue_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1247;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_result_length);
        tmp_ass_subscribed_1 = var_result_length;
        tmp_ass_subscript_1 = const_int_0;
        tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST(tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1);
        Py_DECREF(tmp_ass_subvalue_1);
        if (tmp_ass_subscript_res_1 == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1247;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_6;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_args_element_name_8;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_7 == NULL)) {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_7 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1249;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_7;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_X509_digest);
        if (tmp_called_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1249;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_6 = par_self;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain__x509);
        if (tmp_args_element_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_4);

            exception_lineno = 1250;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_digest);
        tmp_args_element_name_6 = var_digest;
        CHECK_OBJECT(var_result_buffer);
        tmp_args_element_name_7 = var_result_buffer;
        CHECK_OBJECT(var_result_length);
        tmp_args_element_name_8 = var_result_length;
        frame_4f7104a5c773de3617ea99428a718a9f->m_frame.f_lineno = 1249;
        {
            PyObject *call_args[] = {tmp_args_element_name_5, tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8};
            tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS4(tmp_called_name_4, call_args);
        }

        Py_DECREF(tmp_called_name_4);
        Py_DECREF(tmp_args_element_name_5);
        if (tmp_assign_source_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1249;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_digest_result == NULL);
        var_digest_result = tmp_assign_source_4;
    }
    {
        PyObject *tmp_called_name_5;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_8 == NULL)) {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_8 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 1251;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_5 = tmp_mvar_value_8;
        CHECK_OBJECT(var_digest_result);
        tmp_compexpr_left_2 = var_digest_result;
        tmp_compexpr_right_2 = const_int_pos_1;
        tmp_args_element_name_9 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
        if (tmp_args_element_name_9 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1251;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        frame_4f7104a5c773de3617ea99428a718a9f->m_frame.f_lineno = 1251;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_5, tmp_args_element_name_9);
        Py_DECREF(tmp_args_element_name_9);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1251;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_called_name_6;
        PyObject *tmp_source_name_7;
        PyObject *tmp_args_element_name_10;
        tmp_source_name_7 = const_str_chr_58;
        tmp_called_name_6 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain_join);
        assert(!(tmp_called_name_6 == NULL));
        // Tried code:
        {
            PyObject *tmp_assign_source_5;
            PyObject *tmp_iter_arg_1;
            PyObject *tmp_called_name_7;
            PyObject *tmp_source_name_8;
            PyObject *tmp_mvar_value_9;
            PyObject *tmp_args_element_name_11;
            PyObject *tmp_args_element_name_12;
            PyObject *tmp_subscribed_name_1;
            PyObject *tmp_subscript_name_1;
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_9 == NULL)) {
                tmp_mvar_value_9 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_9 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1255;
                type_description_1 = "ooooooo";
                goto try_except_handler_2;
            }

            tmp_source_name_8 = tmp_mvar_value_9;
            tmp_called_name_7 = LOOKUP_ATTRIBUTE(tmp_source_name_8, const_str_plain_buffer);
            if (tmp_called_name_7 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1255;
                type_description_1 = "ooooooo";
                goto try_except_handler_2;
            }
            CHECK_OBJECT(var_result_buffer);
            tmp_args_element_name_11 = var_result_buffer;
            CHECK_OBJECT(var_result_length);
            tmp_subscribed_name_1 = var_result_length;
            tmp_subscript_name_1 = const_int_0;
            tmp_args_element_name_12 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_1, tmp_subscript_name_1, 0);
            if (tmp_args_element_name_12 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_7);

                exception_lineno = 1255;
                type_description_1 = "ooooooo";
                goto try_except_handler_2;
            }
            frame_4f7104a5c773de3617ea99428a718a9f->m_frame.f_lineno = 1255;
            {
                PyObject *call_args[] = {tmp_args_element_name_11, tmp_args_element_name_12};
                tmp_iter_arg_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_7, call_args);
            }

            Py_DECREF(tmp_called_name_7);
            Py_DECREF(tmp_args_element_name_12);
            if (tmp_iter_arg_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1255;
                type_description_1 = "ooooooo";
                goto try_except_handler_2;
            }
            tmp_assign_source_5 = MAKE_ITERATOR(tmp_iter_arg_1);
            Py_DECREF(tmp_iter_arg_1);
            if (tmp_assign_source_5 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1254;
                type_description_1 = "ooooooo";
                goto try_except_handler_2;
            }
            assert(tmp_list_contraction_1__$0 == NULL);
            tmp_list_contraction_1__$0 = tmp_assign_source_5;
        }
        {
            PyObject *tmp_assign_source_6;
            tmp_assign_source_6 = PyList_New(0);
            assert(tmp_list_contraction_1__contraction_result == NULL);
            tmp_list_contraction_1__contraction_result = tmp_assign_source_6;
        }
        loop_start_1:;
        {
            PyObject *tmp_next_source_1;
            PyObject *tmp_assign_source_7;
            CHECK_OBJECT(tmp_list_contraction_1__$0);
            tmp_next_source_1 = tmp_list_contraction_1__$0;
            tmp_assign_source_7 = ITERATOR_NEXT(tmp_next_source_1);
            if (tmp_assign_source_7 == NULL) {
                if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                    goto loop_end_1;
                } else {

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    type_description_1 = "ooooooo";
                    exception_lineno = 1254;
                    goto try_except_handler_2;
                }
            }

            {
                PyObject *old = tmp_list_contraction_1__iter_value_0;
                tmp_list_contraction_1__iter_value_0 = tmp_assign_source_7;
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_assign_source_8;
            CHECK_OBJECT(tmp_list_contraction_1__iter_value_0);
            tmp_assign_source_8 = tmp_list_contraction_1__iter_value_0;
            {
                PyObject *old = var_ch;
                var_ch = tmp_assign_source_8;
                Py_INCREF(var_ch);
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_append_list_1;
            PyObject *tmp_append_value_1;
            PyObject *tmp_called_instance_2;
            PyObject *tmp_called_name_8;
            PyObject *tmp_mvar_value_10;
            PyObject *tmp_args_element_name_13;
            CHECK_OBJECT(tmp_list_contraction_1__contraction_result);
            tmp_append_list_1 = tmp_list_contraction_1__contraction_result;
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_b16encode);

            if (unlikely(tmp_mvar_value_10 == NULL)) {
                tmp_mvar_value_10 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_b16encode);
            }

            if (tmp_mvar_value_10 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 3799 ], 38, 0);
                exception_tb = NULL;

                exception_lineno = 1254;
                type_description_1 = "ooooooo";
                goto try_except_handler_2;
            }

            tmp_called_name_8 = tmp_mvar_value_10;
            CHECK_OBJECT(var_ch);
            tmp_args_element_name_13 = var_ch;
            frame_4f7104a5c773de3617ea99428a718a9f->m_frame.f_lineno = 1254;
            tmp_called_instance_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_8, tmp_args_element_name_13);
            if (tmp_called_instance_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1254;
                type_description_1 = "ooooooo";
                goto try_except_handler_2;
            }
            frame_4f7104a5c773de3617ea99428a718a9f->m_frame.f_lineno = 1254;
            tmp_append_value_1 = CALL_METHOD_NO_ARGS(tmp_called_instance_2, const_str_plain_upper);
            Py_DECREF(tmp_called_instance_2);
            if (tmp_append_value_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1254;
                type_description_1 = "ooooooo";
                goto try_except_handler_2;
            }
            assert(PyList_Check(tmp_append_list_1));
            tmp_res = PyList_Append(tmp_append_list_1, tmp_append_value_1);
            Py_DECREF(tmp_append_value_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1254;
                type_description_1 = "ooooooo";
                goto try_except_handler_2;
            }
        }
        if (CONSIDER_THREADING() == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1254;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
        goto loop_start_1;
        loop_end_1:;
        CHECK_OBJECT(tmp_list_contraction_1__contraction_result);
        tmp_args_element_name_10 = tmp_list_contraction_1__contraction_result;
        Py_INCREF(tmp_args_element_name_10);
        goto try_return_handler_2;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_63_digest);
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        CHECK_OBJECT((PyObject *)tmp_list_contraction_1__$0);
        Py_DECREF(tmp_list_contraction_1__$0);
        tmp_list_contraction_1__$0 = NULL;

        CHECK_OBJECT((PyObject *)tmp_list_contraction_1__contraction_result);
        Py_DECREF(tmp_list_contraction_1__contraction_result);
        tmp_list_contraction_1__contraction_result = NULL;

        Py_XDECREF(tmp_list_contraction_1__iter_value_0);
        tmp_list_contraction_1__iter_value_0 = NULL;

        goto outline_result_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF(tmp_list_contraction_1__$0);
        tmp_list_contraction_1__$0 = NULL;

        Py_XDECREF(tmp_list_contraction_1__contraction_result);
        tmp_list_contraction_1__contraction_result = NULL;

        Py_XDECREF(tmp_list_contraction_1__iter_value_0);
        tmp_list_contraction_1__iter_value_0 = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto frame_exception_exit_1;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_63_digest);
        return NULL;
        outline_result_1:;
        frame_4f7104a5c773de3617ea99428a718a9f->m_frame.f_lineno = 1253;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_6, tmp_args_element_name_10);
        Py_DECREF(tmp_called_name_6);
        Py_DECREF(tmp_args_element_name_10);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1253;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_4f7104a5c773de3617ea99428a718a9f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_4f7104a5c773de3617ea99428a718a9f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_4f7104a5c773de3617ea99428a718a9f);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_4f7104a5c773de3617ea99428a718a9f, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_4f7104a5c773de3617ea99428a718a9f->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_4f7104a5c773de3617ea99428a718a9f, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4f7104a5c773de3617ea99428a718a9f,
        type_description_1,
        par_self,
        par_digest_name,
        var_digest_result,
        var_ch,
        var_result_length,
        var_result_buffer,
        var_digest
    );


    // Release cached frame.
    if (frame_4f7104a5c773de3617ea99428a718a9f == cache_frame_4f7104a5c773de3617ea99428a718a9f) {
        Py_DECREF(frame_4f7104a5c773de3617ea99428a718a9f);
    }
    cache_frame_4f7104a5c773de3617ea99428a718a9f = NULL;

    assertFrameObject(frame_4f7104a5c773de3617ea99428a718a9f);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_63_digest);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_digest_result);
    Py_DECREF(var_digest_result);
    var_digest_result = NULL;

    Py_XDECREF(var_ch);
    var_ch = NULL;

    CHECK_OBJECT((PyObject *)var_result_length);
    Py_DECREF(var_result_length);
    var_result_length = NULL;

    CHECK_OBJECT((PyObject *)var_result_buffer);
    Py_DECREF(var_result_buffer);
    var_result_buffer = NULL;

    CHECK_OBJECT((PyObject *)var_digest);
    Py_DECREF(var_digest);
    var_digest = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_digest_result);
    var_digest_result = NULL;

    Py_XDECREF(var_ch);
    var_ch = NULL;

    Py_XDECREF(var_result_length);
    var_result_length = NULL;

    Py_XDECREF(var_result_buffer);
    var_result_buffer = NULL;

    Py_XDECREF(var_digest);
    var_digest = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_63_digest);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_digest_name);
    Py_DECREF(par_digest_name);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_digest_name);
    Py_DECREF(par_digest_name);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_64_subject_name_hash(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_bff0f237096588ea8e24a7bf1bb681f0;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_bff0f237096588ea8e24a7bf1bb681f0 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_bff0f237096588ea8e24a7bf1bb681f0, codeobj_bff0f237096588ea8e24a7bf1bb681f0, module_OpenSSL$crypto, sizeof(void *));
    frame_bff0f237096588ea8e24a7bf1bb681f0 = cache_frame_bff0f237096588ea8e24a7bf1bb681f0;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_bff0f237096588ea8e24a7bf1bb681f0);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_bff0f237096588ea8e24a7bf1bb681f0) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1264;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_X509_subject_name_hash);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1264;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__x509);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1264;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_bff0f237096588ea8e24a7bf1bb681f0->m_frame.f_lineno = 1264;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1264;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_bff0f237096588ea8e24a7bf1bb681f0);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_bff0f237096588ea8e24a7bf1bb681f0);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_bff0f237096588ea8e24a7bf1bb681f0);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_bff0f237096588ea8e24a7bf1bb681f0, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_bff0f237096588ea8e24a7bf1bb681f0->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_bff0f237096588ea8e24a7bf1bb681f0, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_bff0f237096588ea8e24a7bf1bb681f0,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_bff0f237096588ea8e24a7bf1bb681f0 == cache_frame_bff0f237096588ea8e24a7bf1bb681f0) {
        Py_DECREF(frame_bff0f237096588ea8e24a7bf1bb681f0);
    }
    cache_frame_bff0f237096588ea8e24a7bf1bb681f0 = NULL;

    assertFrameObject(frame_bff0f237096588ea8e24a7bf1bb681f0);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_64_subject_name_hash);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_65_set_serial_number(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_serial = python_pars[1];
    PyObject *var_asn1_serial = NULL;
    PyObject *var_bignum_serial = NULL;
    PyObject *var_set_result = NULL;
    PyObject *var_small_serial = NULL;
    PyObject *var_hex_serial = NULL;
    struct Nuitka_FrameObject *frame_f86a27bee71853ffe2494335d054f9c2;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_f86a27bee71853ffe2494335d054f9c2 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_f86a27bee71853ffe2494335d054f9c2, codeobj_f86a27bee71853ffe2494335d054f9c2, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_f86a27bee71853ffe2494335d054f9c2 = cache_frame_f86a27bee71853ffe2494335d054f9c2;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_f86a27bee71853ffe2494335d054f9c2);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_f86a27bee71853ffe2494335d054f9c2) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_serial);
        tmp_isinstance_inst_1 = par_serial;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__integer_types);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__integer_types);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3837 ], 43, 0);
            exception_tb = NULL;

            exception_lineno = 1275;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1275;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1275;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_b1f5a355e1403668d0044e1a65ec29ce;
            frame_f86a27bee71853ffe2494335d054f9c2->m_frame.f_lineno = 1276;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1276;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        Py_ssize_t tmp_sliceslicedel_index_lower_1;
        Py_ssize_t tmp_slice_index_upper_1;
        PyObject *tmp_slice_source_1;
        PyObject *tmp_hex_arg_1;
        tmp_sliceslicedel_index_lower_1 = 2;
        tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
        CHECK_OBJECT(par_serial);
        tmp_hex_arg_1 = par_serial;
        tmp_slice_source_1 = BUILTIN_HEX(tmp_hex_arg_1);
        if (tmp_slice_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1278;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_1 = LOOKUP_INDEX_SLICE(tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1);
        Py_DECREF(tmp_slice_source_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1278;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_hex_serial == NULL);
        var_hex_serial = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_2;
        PyObject *tmp_isinstance_inst_2;
        PyObject *tmp_isinstance_cls_2;
        CHECK_OBJECT(var_hex_serial);
        tmp_isinstance_inst_2 = var_hex_serial;
        tmp_isinstance_cls_2 = (PyObject *)&PyString_Type;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_2, tmp_isinstance_cls_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1279;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_2 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1279;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_called_instance_1;
            CHECK_OBJECT(var_hex_serial);
            tmp_called_instance_1 = var_hex_serial;
            frame_f86a27bee71853ffe2494335d054f9c2->m_frame.f_lineno = 1280;
            tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_encode, &PyTuple_GET_ITEM(const_tuple_str_plain_ascii_tuple, 0));

            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1280;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = var_hex_serial;
                assert(old != NULL);
                var_hex_serial = tmp_assign_source_2;
                Py_DECREF(old);
            }

        }
        branch_no_2:;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1282;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_2;
        frame_f86a27bee71853ffe2494335d054f9c2->m_frame.f_lineno = 1282;
        tmp_assign_source_3 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_new, &PyTuple_GET_ITEM(const_tuple_str_digest_80438074180d95b1a2291874613077b5_tuple, 0));

        if (tmp_assign_source_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1282;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_bignum_serial == NULL);
        var_bignum_serial = tmp_assign_source_3;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1287;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_3 = tmp_mvar_value_3;
        CHECK_OBJECT(var_bignum_serial);
        tmp_args_element_name_1 = var_bignum_serial;
        CHECK_OBJECT(var_hex_serial);
        tmp_args_element_name_2 = var_hex_serial;
        frame_f86a27bee71853ffe2494335d054f9c2->m_frame.f_lineno = 1287;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_4 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_3, const_str_plain_BN_hex2bn, call_args);
        }

        if (tmp_assign_source_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1287;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_small_serial == NULL);
        var_small_serial = tmp_assign_source_4;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_subscript_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_4;
        CHECK_OBJECT(var_bignum_serial);
        tmp_subscribed_name_1 = var_bignum_serial;
        tmp_subscript_name_1 = const_int_0;
        tmp_compexpr_left_1 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_1, tmp_subscript_name_1, 0);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1289;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_4 == NULL) {
            Py_DECREF(tmp_compexpr_left_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1289;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_4;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_NULL);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_1);

            exception_lineno = 1289;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1289;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
            goto branch_yes_3;
        } else {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_assign_source_5;
            PyObject *tmp_called_name_1;
            PyObject *tmp_source_name_2;
            PyObject *tmp_mvar_value_5;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_3;
            PyObject *tmp_mvar_value_6;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_source_name_4;
            PyObject *tmp_args_element_name_5;
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_5 == NULL)) {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_5 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1290;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_2 = tmp_mvar_value_5;
            tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_ASN1_INTEGER_set);
            if (tmp_called_name_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1290;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_6 == NULL)) {
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_6 == NULL) {
                Py_DECREF(tmp_called_name_1);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1291;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_3 = tmp_mvar_value_6;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_X509_get_serialNumber);
            if (tmp_called_name_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_1);

                exception_lineno = 1291;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(par_self);
            tmp_source_name_4 = par_self;
            tmp_args_element_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain__x509);
            if (tmp_args_element_name_4 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_1);
                Py_DECREF(tmp_called_name_2);

                exception_lineno = 1291;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            frame_f86a27bee71853ffe2494335d054f9c2->m_frame.f_lineno = 1291;
            tmp_args_element_name_3 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_4);
            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_4);
            if (tmp_args_element_name_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_1);

                exception_lineno = 1291;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_small_serial);
            tmp_args_element_name_5 = var_small_serial;
            frame_f86a27bee71853ffe2494335d054f9c2->m_frame.f_lineno = 1290;
            {
                PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_5};
                tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
            }

            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_element_name_3);
            if (tmp_assign_source_5 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1290;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            assert(var_set_result == NULL);
            var_set_result = tmp_assign_source_5;
        }
        {
            nuitka_bool tmp_condition_result_4;
            int tmp_truth_name_1;
            CHECK_OBJECT(var_set_result);
            tmp_truth_name_1 = CHECK_IF_TRUE(var_set_result);
            if (tmp_truth_name_1 == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1292;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_4 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_4 == NUITKA_BOOL_TRUE) {
                goto branch_yes_4;
            } else {
                goto branch_no_4;
            }
            branch_yes_4:;
            {
                PyObject *tmp_called_name_3;
                PyObject *tmp_mvar_value_7;
                PyObject *tmp_call_result_1;
                tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error);

                if (unlikely(tmp_mvar_value_7 == NULL)) {
                    tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error);
                }

                if (tmp_mvar_value_7 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 0 ], 49, 0);
                    exception_tb = NULL;

                    exception_lineno = 1294;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_name_3 = tmp_mvar_value_7;
                frame_f86a27bee71853ffe2494335d054f9c2->m_frame.f_lineno = 1294;
                tmp_call_result_1 = CALL_FUNCTION_NO_ARGS(tmp_called_name_3);
                if (tmp_call_result_1 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 1294;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                Py_DECREF(tmp_call_result_1);
            }
            branch_no_4:;
        }
        goto branch_end_3;
        branch_no_3:;
        {
            PyObject *tmp_assign_source_6;
            PyObject *tmp_called_name_4;
            PyObject *tmp_source_name_5;
            PyObject *tmp_mvar_value_8;
            PyObject *tmp_args_element_name_6;
            PyObject *tmp_subscribed_name_2;
            PyObject *tmp_subscript_name_2;
            PyObject *tmp_args_element_name_7;
            PyObject *tmp_source_name_6;
            PyObject *tmp_mvar_value_9;
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_8 == NULL)) {
                tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_8 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1296;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_5 = tmp_mvar_value_8;
            tmp_called_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_BN_to_ASN1_INTEGER);
            if (tmp_called_name_4 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1296;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_bignum_serial);
            tmp_subscribed_name_2 = var_bignum_serial;
            tmp_subscript_name_2 = const_int_0;
            tmp_args_element_name_6 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_2, tmp_subscript_name_2, 0);
            if (tmp_args_element_name_6 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_4);

                exception_lineno = 1296;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_9 == NULL)) {
                tmp_mvar_value_9 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_9 == NULL) {
                Py_DECREF(tmp_called_name_4);
                Py_DECREF(tmp_args_element_name_6);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1296;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_6 = tmp_mvar_value_9;
            tmp_args_element_name_7 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_NULL);
            if (tmp_args_element_name_7 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_4);
                Py_DECREF(tmp_args_element_name_6);

                exception_lineno = 1296;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            frame_f86a27bee71853ffe2494335d054f9c2->m_frame.f_lineno = 1296;
            {
                PyObject *call_args[] = {tmp_args_element_name_6, tmp_args_element_name_7};
                tmp_assign_source_6 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_4, call_args);
            }

            Py_DECREF(tmp_called_name_4);
            Py_DECREF(tmp_args_element_name_6);
            Py_DECREF(tmp_args_element_name_7);
            if (tmp_assign_source_6 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1296;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            assert(var_asn1_serial == NULL);
            var_asn1_serial = tmp_assign_source_6;
        }
        {
            PyObject *tmp_called_name_5;
            PyObject *tmp_source_name_7;
            PyObject *tmp_mvar_value_10;
            PyObject *tmp_call_result_2;
            PyObject *tmp_args_element_name_8;
            PyObject *tmp_subscribed_name_3;
            PyObject *tmp_subscript_name_3;
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_10 == NULL)) {
                tmp_mvar_value_10 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_10 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1297;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_7 = tmp_mvar_value_10;
            tmp_called_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain_BN_free);
            if (tmp_called_name_5 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1297;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_bignum_serial);
            tmp_subscribed_name_3 = var_bignum_serial;
            tmp_subscript_name_3 = const_int_0;
            tmp_args_element_name_8 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_3, tmp_subscript_name_3, 0);
            if (tmp_args_element_name_8 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_5);

                exception_lineno = 1297;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            frame_f86a27bee71853ffe2494335d054f9c2->m_frame.f_lineno = 1297;
            tmp_call_result_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_5, tmp_args_element_name_8);
            Py_DECREF(tmp_called_name_5);
            Py_DECREF(tmp_args_element_name_8);
            if (tmp_call_result_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1297;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_2);
        }
        {
            nuitka_bool tmp_condition_result_5;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_source_name_8;
            PyObject *tmp_mvar_value_11;
            CHECK_OBJECT(var_asn1_serial);
            tmp_compexpr_left_2 = var_asn1_serial;
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_11 == NULL)) {
                tmp_mvar_value_11 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_11 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1298;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_8 = tmp_mvar_value_11;
            tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE(tmp_source_name_8, const_str_plain_NULL);
            if (tmp_compexpr_right_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1298;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
            Py_DECREF(tmp_compexpr_right_2);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1298;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_5 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_5 == NUITKA_BOOL_TRUE) {
                goto branch_yes_5;
            } else {
                goto branch_no_5;
            }
            branch_yes_5:;
            {
                PyObject *tmp_called_name_6;
                PyObject *tmp_mvar_value_12;
                PyObject *tmp_call_result_3;
                tmp_mvar_value_12 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error);

                if (unlikely(tmp_mvar_value_12 == NULL)) {
                    tmp_mvar_value_12 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error);
                }

                if (tmp_mvar_value_12 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 0 ], 49, 0);
                    exception_tb = NULL;

                    exception_lineno = 1300;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_name_6 = tmp_mvar_value_12;
                frame_f86a27bee71853ffe2494335d054f9c2->m_frame.f_lineno = 1300;
                tmp_call_result_3 = CALL_FUNCTION_NO_ARGS(tmp_called_name_6);
                if (tmp_call_result_3 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 1300;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                Py_DECREF(tmp_call_result_3);
            }
            branch_no_5:;
        }
        {
            PyObject *tmp_assign_source_7;
            PyObject *tmp_called_name_7;
            PyObject *tmp_source_name_9;
            PyObject *tmp_mvar_value_13;
            PyObject *tmp_args_element_name_9;
            PyObject *tmp_args_element_name_10;
            PyObject *tmp_source_name_10;
            PyObject *tmp_mvar_value_14;
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_13 == NULL)) {
                tmp_mvar_value_13 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_13 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1301;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_9 = tmp_mvar_value_13;
            tmp_called_name_7 = LOOKUP_ATTRIBUTE(tmp_source_name_9, const_str_plain_gc);
            if (tmp_called_name_7 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1301;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_asn1_serial);
            tmp_args_element_name_9 = var_asn1_serial;
            tmp_mvar_value_14 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_14 == NULL)) {
                tmp_mvar_value_14 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_14 == NULL) {
                Py_DECREF(tmp_called_name_7);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1301;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_10 = tmp_mvar_value_14;
            tmp_args_element_name_10 = LOOKUP_ATTRIBUTE(tmp_source_name_10, const_str_plain_ASN1_INTEGER_free);
            if (tmp_args_element_name_10 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_7);

                exception_lineno = 1301;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            frame_f86a27bee71853ffe2494335d054f9c2->m_frame.f_lineno = 1301;
            {
                PyObject *call_args[] = {tmp_args_element_name_9, tmp_args_element_name_10};
                tmp_assign_source_7 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_7, call_args);
            }

            Py_DECREF(tmp_called_name_7);
            Py_DECREF(tmp_args_element_name_10);
            if (tmp_assign_source_7 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1301;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = var_asn1_serial;
                assert(old != NULL);
                var_asn1_serial = tmp_assign_source_7;
                Py_DECREF(old);
            }

        }
        {
            PyObject *tmp_assign_source_8;
            PyObject *tmp_called_name_8;
            PyObject *tmp_source_name_11;
            PyObject *tmp_mvar_value_15;
            PyObject *tmp_args_element_name_11;
            PyObject *tmp_source_name_12;
            PyObject *tmp_args_element_name_12;
            tmp_mvar_value_15 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_15 == NULL)) {
                tmp_mvar_value_15 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_15 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1302;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_11 = tmp_mvar_value_15;
            tmp_called_name_8 = LOOKUP_ATTRIBUTE(tmp_source_name_11, const_str_plain_X509_set_serialNumber);
            if (tmp_called_name_8 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1302;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(par_self);
            tmp_source_name_12 = par_self;
            tmp_args_element_name_11 = LOOKUP_ATTRIBUTE(tmp_source_name_12, const_str_plain__x509);
            if (tmp_args_element_name_11 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_8);

                exception_lineno = 1302;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_asn1_serial);
            tmp_args_element_name_12 = var_asn1_serial;
            frame_f86a27bee71853ffe2494335d054f9c2->m_frame.f_lineno = 1302;
            {
                PyObject *call_args[] = {tmp_args_element_name_11, tmp_args_element_name_12};
                tmp_assign_source_8 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_8, call_args);
            }

            Py_DECREF(tmp_called_name_8);
            Py_DECREF(tmp_args_element_name_11);
            if (tmp_assign_source_8 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1302;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            assert(var_set_result == NULL);
            var_set_result = tmp_assign_source_8;
        }
        {
            PyObject *tmp_called_name_9;
            PyObject *tmp_mvar_value_16;
            PyObject *tmp_call_result_4;
            PyObject *tmp_args_element_name_13;
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            tmp_mvar_value_16 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

            if (unlikely(tmp_mvar_value_16 == NULL)) {
                tmp_mvar_value_16 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
            }

            if (tmp_mvar_value_16 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
                exception_tb = NULL;

                exception_lineno = 1303;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_9 = tmp_mvar_value_16;
            CHECK_OBJECT(var_set_result);
            tmp_compexpr_left_3 = var_set_result;
            tmp_compexpr_right_3 = const_int_pos_1;
            tmp_args_element_name_13 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_3, tmp_compexpr_right_3);
            if (tmp_args_element_name_13 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1303;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            frame_f86a27bee71853ffe2494335d054f9c2->m_frame.f_lineno = 1303;
            tmp_call_result_4 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_9, tmp_args_element_name_13);
            Py_DECREF(tmp_args_element_name_13);
            if (tmp_call_result_4 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1303;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_4);
        }
        branch_end_3:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_f86a27bee71853ffe2494335d054f9c2);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_f86a27bee71853ffe2494335d054f9c2);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_f86a27bee71853ffe2494335d054f9c2, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_f86a27bee71853ffe2494335d054f9c2->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_f86a27bee71853ffe2494335d054f9c2, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f86a27bee71853ffe2494335d054f9c2,
        type_description_1,
        par_self,
        par_serial,
        var_asn1_serial,
        var_bignum_serial,
        var_set_result,
        var_small_serial,
        var_hex_serial
    );


    // Release cached frame.
    if (frame_f86a27bee71853ffe2494335d054f9c2 == cache_frame_f86a27bee71853ffe2494335d054f9c2) {
        Py_DECREF(frame_f86a27bee71853ffe2494335d054f9c2);
    }
    cache_frame_f86a27bee71853ffe2494335d054f9c2 = NULL;

    assertFrameObject(frame_f86a27bee71853ffe2494335d054f9c2);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_65_set_serial_number);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_asn1_serial);
    var_asn1_serial = NULL;

    CHECK_OBJECT((PyObject *)var_bignum_serial);
    Py_DECREF(var_bignum_serial);
    var_bignum_serial = NULL;

    CHECK_OBJECT((PyObject *)var_set_result);
    Py_DECREF(var_set_result);
    var_set_result = NULL;

    CHECK_OBJECT((PyObject *)var_small_serial);
    Py_DECREF(var_small_serial);
    var_small_serial = NULL;

    CHECK_OBJECT((PyObject *)var_hex_serial);
    Py_DECREF(var_hex_serial);
    var_hex_serial = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_asn1_serial);
    var_asn1_serial = NULL;

    Py_XDECREF(var_bignum_serial);
    var_bignum_serial = NULL;

    Py_XDECREF(var_set_result);
    var_set_result = NULL;

    Py_XDECREF(var_small_serial);
    var_small_serial = NULL;

    Py_XDECREF(var_hex_serial);
    var_hex_serial = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_65_set_serial_number);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_serial);
    Py_DECREF(par_serial);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_serial);
    Py_DECREF(par_serial);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_66_get_serial_number(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_bignum_serial = NULL;
    PyObject *var_hexstring_serial = NULL;
    PyObject *var_asn1_serial = NULL;
    PyObject *var_hex_serial = NULL;
    PyObject *var_serial = NULL;
    struct Nuitka_FrameObject *frame_62f5aa8a8fda43f2d7f41809819c949c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    static struct Nuitka_FrameObject *cache_frame_62f5aa8a8fda43f2d7f41809819c949c = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_62f5aa8a8fda43f2d7f41809819c949c, codeobj_62f5aa8a8fda43f2d7f41809819c949c, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_62f5aa8a8fda43f2d7f41809819c949c = cache_frame_62f5aa8a8fda43f2d7f41809819c949c;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_62f5aa8a8fda43f2d7f41809819c949c);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_62f5aa8a8fda43f2d7f41809819c949c) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1312;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_X509_get_serialNumber);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1312;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__x509);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1312;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_62f5aa8a8fda43f2d7f41809819c949c->m_frame.f_lineno = 1312;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1312;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert(var_asn1_serial == NULL);
        var_asn1_serial = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1313;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_ASN1_INTEGER_to_BN);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1313;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_asn1_serial);
        tmp_args_element_name_2 = var_asn1_serial;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_3 == NULL) {
            Py_DECREF(tmp_called_name_2);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1313;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_3;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_NULL);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 1313;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_62f5aa8a8fda43f2d7f41809819c949c->m_frame.f_lineno = 1313;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1313;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert(var_bignum_serial == NULL);
        var_bignum_serial = tmp_assign_source_2;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1315;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_1 = tmp_mvar_value_4;
        CHECK_OBJECT(var_bignum_serial);
        tmp_args_element_name_4 = var_bignum_serial;
        frame_62f5aa8a8fda43f2d7f41809819c949c->m_frame.f_lineno = 1315;
        {
            PyObject *call_args[] = {tmp_args_element_name_4};
            tmp_assign_source_3 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_BN_bn2hex, call_args);
        }

        if (tmp_assign_source_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1315;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }
        assert(var_hex_serial == NULL);
        var_hex_serial = tmp_assign_source_3;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_5;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1317;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }

        tmp_called_instance_2 = tmp_mvar_value_5;
        CHECK_OBJECT(var_hex_serial);
        tmp_args_element_name_5 = var_hex_serial;
        frame_62f5aa8a8fda43f2d7f41809819c949c->m_frame.f_lineno = 1317;
        {
            PyObject *call_args[] = {tmp_args_element_name_5};
            tmp_assign_source_4 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_string, call_args);
        }

        if (tmp_assign_source_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1317;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }
        assert(var_hexstring_serial == NULL);
        var_hexstring_serial = tmp_assign_source_4;
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_value_name_1;
        PyObject *tmp_base_name_1;
        CHECK_OBJECT(var_hexstring_serial);
        tmp_value_name_1 = var_hexstring_serial;
        tmp_base_name_1 = const_int_pos_16;
        tmp_assign_source_5 = BUILTIN_INT2(tmp_value_name_1, tmp_base_name_1);
        if (tmp_assign_source_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1318;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }
        assert(var_serial == NULL);
        var_serial = tmp_assign_source_5;
    }
    CHECK_OBJECT(var_serial);
    tmp_return_value = var_serial;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_3;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_66_get_serial_number);
    return NULL;
    // Return handler code:
    try_return_handler_3:;
    {
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_6;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_6 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1321;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_3 = tmp_mvar_value_6;
        CHECK_OBJECT(var_hex_serial);
        tmp_args_element_name_6 = var_hex_serial;
        frame_62f5aa8a8fda43f2d7f41809819c949c->m_frame.f_lineno = 1321;
        {
            PyObject *call_args[] = {tmp_args_element_name_6};
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_3, const_str_plain_OPENSSL_free, call_args);
        }

        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1321;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }
        Py_DECREF(tmp_call_result_1);
    }
    goto try_return_handler_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    {
        PyObject *tmp_called_instance_4;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_7;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_7 == NULL)) {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_7 == NULL) {

            Py_DECREF(exception_keeper_type_1);
            Py_XDECREF(exception_keeper_value_1);
            Py_XDECREF(exception_keeper_tb_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1321;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_4 = tmp_mvar_value_7;
        CHECK_OBJECT(var_hex_serial);
        tmp_args_element_name_7 = var_hex_serial;
        frame_62f5aa8a8fda43f2d7f41809819c949c->m_frame.f_lineno = 1321;
        {
            PyObject *call_args[] = {tmp_args_element_name_7};
            tmp_call_result_2 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_4, const_str_plain_OPENSSL_free, call_args);
        }

        if (tmp_call_result_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);

            Py_DECREF(exception_keeper_type_1);
            Py_XDECREF(exception_keeper_value_1);
            Py_XDECREF(exception_keeper_tb_1);

            exception_lineno = 1321;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }
        Py_DECREF(tmp_call_result_2);
    }
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    // End of try:
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_66_get_serial_number);
    return NULL;
    // Return handler code:
    try_return_handler_2:;
    {
        PyObject *tmp_called_instance_5;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_call_result_3;
        PyObject *tmp_args_element_name_8;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_8 == NULL)) {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_8 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1323;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_5 = tmp_mvar_value_8;
        CHECK_OBJECT(var_bignum_serial);
        tmp_args_element_name_8 = var_bignum_serial;
        frame_62f5aa8a8fda43f2d7f41809819c949c->m_frame.f_lineno = 1323;
        {
            PyObject *call_args[] = {tmp_args_element_name_8};
            tmp_call_result_3 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_5, const_str_plain_BN_free, call_args);
        }

        if (tmp_call_result_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1323;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_3);
    }
    goto frame_return_exit_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    {
        PyObject *tmp_called_instance_6;
        PyObject *tmp_mvar_value_9;
        PyObject *tmp_call_result_4;
        PyObject *tmp_args_element_name_9;
        tmp_mvar_value_9 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_9 == NULL)) {
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_9 == NULL) {

            Py_DECREF(exception_keeper_type_2);
            Py_XDECREF(exception_keeper_value_2);
            Py_XDECREF(exception_keeper_tb_2);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1323;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_6 = tmp_mvar_value_9;
        CHECK_OBJECT(var_bignum_serial);
        tmp_args_element_name_9 = var_bignum_serial;
        frame_62f5aa8a8fda43f2d7f41809819c949c->m_frame.f_lineno = 1323;
        {
            PyObject *call_args[] = {tmp_args_element_name_9};
            tmp_call_result_4 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_6, const_str_plain_BN_free, call_args);
        }

        if (tmp_call_result_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);

            Py_DECREF(exception_keeper_type_2);
            Py_XDECREF(exception_keeper_value_2);
            Py_XDECREF(exception_keeper_tb_2);

            exception_lineno = 1323;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_4);
    }
    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:

#if 0
    RESTORE_FRAME_EXCEPTION(frame_62f5aa8a8fda43f2d7f41809819c949c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_62f5aa8a8fda43f2d7f41809819c949c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_62f5aa8a8fda43f2d7f41809819c949c);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_62f5aa8a8fda43f2d7f41809819c949c, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_62f5aa8a8fda43f2d7f41809819c949c->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_62f5aa8a8fda43f2d7f41809819c949c, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_62f5aa8a8fda43f2d7f41809819c949c,
        type_description_1,
        par_self,
        var_bignum_serial,
        var_hexstring_serial,
        var_asn1_serial,
        var_hex_serial,
        var_serial
    );


    // Release cached frame.
    if (frame_62f5aa8a8fda43f2d7f41809819c949c == cache_frame_62f5aa8a8fda43f2d7f41809819c949c) {
        Py_DECREF(frame_62f5aa8a8fda43f2d7f41809819c949c);
    }
    cache_frame_62f5aa8a8fda43f2d7f41809819c949c = NULL;

    assertFrameObject(frame_62f5aa8a8fda43f2d7f41809819c949c);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_66_get_serial_number);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_bignum_serial);
    Py_DECREF(var_bignum_serial);
    var_bignum_serial = NULL;

    CHECK_OBJECT((PyObject *)var_hexstring_serial);
    Py_DECREF(var_hexstring_serial);
    var_hexstring_serial = NULL;

    CHECK_OBJECT((PyObject *)var_asn1_serial);
    Py_DECREF(var_asn1_serial);
    var_asn1_serial = NULL;

    CHECK_OBJECT((PyObject *)var_hex_serial);
    Py_DECREF(var_hex_serial);
    var_hex_serial = NULL;

    CHECK_OBJECT((PyObject *)var_serial);
    Py_DECREF(var_serial);
    var_serial = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_bignum_serial);
    var_bignum_serial = NULL;

    Py_XDECREF(var_hexstring_serial);
    var_hexstring_serial = NULL;

    Py_XDECREF(var_asn1_serial);
    var_asn1_serial = NULL;

    Py_XDECREF(var_hex_serial);
    var_hex_serial = NULL;

    Py_XDECREF(var_serial);
    var_serial = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_66_get_serial_number);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_67_gmtime_adj_notAfter(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_amount = python_pars[1];
    PyObject *var_notAfter = NULL;
    struct Nuitka_FrameObject *frame_4de131a75c684fec0469c48115745d08;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_4de131a75c684fec0469c48115745d08 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_4de131a75c684fec0469c48115745d08, codeobj_4de131a75c684fec0469c48115745d08, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_4de131a75c684fec0469c48115745d08 = cache_frame_4de131a75c684fec0469c48115745d08;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_4de131a75c684fec0469c48115745d08);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_4de131a75c684fec0469c48115745d08) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        CHECK_OBJECT(par_amount);
        tmp_isinstance_inst_1 = par_amount;
        tmp_isinstance_cls_1 = (PyObject *)&PyInt_Type;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1333;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1333;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_117006b03ff8e10f330ac900a6cd41e8;
            frame_4de131a75c684fec0469c48115745d08->m_frame.f_lineno = 1334;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1334;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1336;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_X509_get_notAfter);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1336;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__x509);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1336;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_4de131a75c684fec0469c48115745d08->m_frame.f_lineno = 1336;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1336;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_notAfter == NULL);
        var_notAfter = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1337;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_2;
        CHECK_OBJECT(var_notAfter);
        tmp_args_element_name_2 = var_notAfter;
        CHECK_OBJECT(par_amount);
        tmp_args_element_name_3 = par_amount;
        frame_4de131a75c684fec0469c48115745d08->m_frame.f_lineno = 1337;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain_X509_gmtime_adj, call_args);
        }

        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1337;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_4de131a75c684fec0469c48115745d08);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_4de131a75c684fec0469c48115745d08);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_4de131a75c684fec0469c48115745d08, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_4de131a75c684fec0469c48115745d08->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_4de131a75c684fec0469c48115745d08, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4de131a75c684fec0469c48115745d08,
        type_description_1,
        par_self,
        par_amount,
        var_notAfter
    );


    // Release cached frame.
    if (frame_4de131a75c684fec0469c48115745d08 == cache_frame_4de131a75c684fec0469c48115745d08) {
        Py_DECREF(frame_4de131a75c684fec0469c48115745d08);
    }
    cache_frame_4de131a75c684fec0469c48115745d08 = NULL;

    assertFrameObject(frame_4de131a75c684fec0469c48115745d08);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_67_gmtime_adj_notAfter);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_notAfter);
    Py_DECREF(var_notAfter);
    var_notAfter = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_notAfter);
    var_notAfter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_67_gmtime_adj_notAfter);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_amount);
    Py_DECREF(par_amount);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_amount);
    Py_DECREF(par_amount);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_68_gmtime_adj_notBefore(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_amount = python_pars[1];
    PyObject *var_notBefore = NULL;
    struct Nuitka_FrameObject *frame_50ee192f9d0e8e84633297c994f58a6a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_50ee192f9d0e8e84633297c994f58a6a = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_50ee192f9d0e8e84633297c994f58a6a, codeobj_50ee192f9d0e8e84633297c994f58a6a, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_50ee192f9d0e8e84633297c994f58a6a = cache_frame_50ee192f9d0e8e84633297c994f58a6a;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_50ee192f9d0e8e84633297c994f58a6a);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_50ee192f9d0e8e84633297c994f58a6a) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        CHECK_OBJECT(par_amount);
        tmp_isinstance_inst_1 = par_amount;
        tmp_isinstance_cls_1 = (PyObject *)&PyInt_Type;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1346;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1346;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_117006b03ff8e10f330ac900a6cd41e8;
            frame_50ee192f9d0e8e84633297c994f58a6a->m_frame.f_lineno = 1347;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1347;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1349;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_X509_get_notBefore);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1349;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__x509);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1349;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_50ee192f9d0e8e84633297c994f58a6a->m_frame.f_lineno = 1349;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1349;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_notBefore == NULL);
        var_notBefore = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1350;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_2;
        CHECK_OBJECT(var_notBefore);
        tmp_args_element_name_2 = var_notBefore;
        CHECK_OBJECT(par_amount);
        tmp_args_element_name_3 = par_amount;
        frame_50ee192f9d0e8e84633297c994f58a6a->m_frame.f_lineno = 1350;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain_X509_gmtime_adj, call_args);
        }

        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1350;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_50ee192f9d0e8e84633297c994f58a6a);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_50ee192f9d0e8e84633297c994f58a6a);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_50ee192f9d0e8e84633297c994f58a6a, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_50ee192f9d0e8e84633297c994f58a6a->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_50ee192f9d0e8e84633297c994f58a6a, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_50ee192f9d0e8e84633297c994f58a6a,
        type_description_1,
        par_self,
        par_amount,
        var_notBefore
    );


    // Release cached frame.
    if (frame_50ee192f9d0e8e84633297c994f58a6a == cache_frame_50ee192f9d0e8e84633297c994f58a6a) {
        Py_DECREF(frame_50ee192f9d0e8e84633297c994f58a6a);
    }
    cache_frame_50ee192f9d0e8e84633297c994f58a6a = NULL;

    assertFrameObject(frame_50ee192f9d0e8e84633297c994f58a6a);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_68_gmtime_adj_notBefore);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_notBefore);
    Py_DECREF(var_notBefore);
    var_notBefore = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_notBefore);
    var_notBefore = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_68_gmtime_adj_notBefore);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_amount);
    Py_DECREF(par_amount);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_amount);
    Py_DECREF(par_amount);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_69_has_expired(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_not_after = NULL;
    PyObject *var_time_string = NULL;
    struct Nuitka_FrameObject *frame_fbdfdccccf232276b858abd51cb882bb;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_fbdfdccccf232276b858abd51cb882bb = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_fbdfdccccf232276b858abd51cb882bb, codeobj_fbdfdccccf232276b858abd51cb882bb, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_fbdfdccccf232276b858abd51cb882bb = cache_frame_fbdfdccccf232276b858abd51cb882bb;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_fbdfdccccf232276b858abd51cb882bb);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_fbdfdccccf232276b858abd51cb882bb) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_instance_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__native);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__native);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1954 ], 36, 0);
            exception_tb = NULL;

            exception_lineno = 1359;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        frame_fbdfdccccf232276b858abd51cb882bb->m_frame.f_lineno = 1359;
        tmp_args_element_name_1 = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_get_notAfter);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1359;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_fbdfdccccf232276b858abd51cb882bb->m_frame.f_lineno = 1359;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1359;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_time_string == NULL);
        var_time_string = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_datetime);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_datetime);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3880 ], 37, 0);
            exception_tb = NULL;

            exception_lineno = 1360;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_instance_2 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_datetime);
        if (tmp_called_instance_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1360;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_time_string);
        tmp_args_element_name_2 = var_time_string;
        tmp_args_element_name_3 = const_str_digest_9838c39bdf9fdb401c17b0106d8660a3;
        frame_fbdfdccccf232276b858abd51cb882bb->m_frame.f_lineno = 1360;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_assign_source_2 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_2, const_str_plain_strptime, call_args);
        }

        Py_DECREF(tmp_called_instance_2);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1360;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_not_after == NULL);
        var_not_after = tmp_assign_source_2;
    }
    {
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        CHECK_OBJECT(var_not_after);
        tmp_compexpr_left_1 = var_not_after;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_datetime);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_datetime);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3880 ], 37, 0);
            exception_tb = NULL;

            exception_lineno = 1362;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_called_instance_3 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_datetime);
        if (tmp_called_instance_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1362;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_fbdfdccccf232276b858abd51cb882bb->m_frame.f_lineno = 1362;
        tmp_compexpr_right_1 = CALL_METHOD_NO_ARGS(tmp_called_instance_3, const_str_plain_utcnow);
        Py_DECREF(tmp_called_instance_3);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1362;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = RICH_COMPARE_LT_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1362;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_fbdfdccccf232276b858abd51cb882bb);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_fbdfdccccf232276b858abd51cb882bb);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_fbdfdccccf232276b858abd51cb882bb);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_fbdfdccccf232276b858abd51cb882bb, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_fbdfdccccf232276b858abd51cb882bb->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_fbdfdccccf232276b858abd51cb882bb, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_fbdfdccccf232276b858abd51cb882bb,
        type_description_1,
        par_self,
        var_not_after,
        var_time_string
    );


    // Release cached frame.
    if (frame_fbdfdccccf232276b858abd51cb882bb == cache_frame_fbdfdccccf232276b858abd51cb882bb) {
        Py_DECREF(frame_fbdfdccccf232276b858abd51cb882bb);
    }
    cache_frame_fbdfdccccf232276b858abd51cb882bb = NULL;

    assertFrameObject(frame_fbdfdccccf232276b858abd51cb882bb);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_69_has_expired);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_not_after);
    Py_DECREF(var_not_after);
    var_not_after = NULL;

    CHECK_OBJECT((PyObject *)var_time_string);
    Py_DECREF(var_time_string);
    var_time_string = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_not_after);
    var_not_after = NULL;

    Py_XDECREF(var_time_string);
    var_time_string = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_69_has_expired);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_70__get_boundary_time(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_which = python_pars[1];
    struct Nuitka_FrameObject *frame_901f14040af7aac06f554767a4550324;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_901f14040af7aac06f554767a4550324 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_901f14040af7aac06f554767a4550324, codeobj_901f14040af7aac06f554767a4550324, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *));
    frame_901f14040af7aac06f554767a4550324 = cache_frame_901f14040af7aac06f554767a4550324;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_901f14040af7aac06f554767a4550324);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_901f14040af7aac06f554767a4550324) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__get_asn1_time);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__get_asn1_time);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3917 ], 43, 0);
            exception_tb = NULL;

            exception_lineno = 1365;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT(par_which);
        tmp_called_name_2 = par_which;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__x509);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1365;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_901f14040af7aac06f554767a4550324->m_frame.f_lineno = 1365;
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_2);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1365;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_901f14040af7aac06f554767a4550324->m_frame.f_lineno = 1365;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1365;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_901f14040af7aac06f554767a4550324);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_901f14040af7aac06f554767a4550324);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_901f14040af7aac06f554767a4550324);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_901f14040af7aac06f554767a4550324, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_901f14040af7aac06f554767a4550324->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_901f14040af7aac06f554767a4550324, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_901f14040af7aac06f554767a4550324,
        type_description_1,
        par_self,
        par_which
    );


    // Release cached frame.
    if (frame_901f14040af7aac06f554767a4550324 == cache_frame_901f14040af7aac06f554767a4550324) {
        Py_DECREF(frame_901f14040af7aac06f554767a4550324);
    }
    cache_frame_901f14040af7aac06f554767a4550324 = NULL;

    assertFrameObject(frame_901f14040af7aac06f554767a4550324);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_70__get_boundary_time);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_which);
    Py_DECREF(par_which);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_which);
    Py_DECREF(par_which);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_71_get_notBefore(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_38e0d057067d90e2fbb10ff012ac6d82;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_38e0d057067d90e2fbb10ff012ac6d82 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_38e0d057067d90e2fbb10ff012ac6d82, codeobj_38e0d057067d90e2fbb10ff012ac6d82, module_OpenSSL$crypto, sizeof(void *));
    frame_38e0d057067d90e2fbb10ff012ac6d82 = cache_frame_38e0d057067d90e2fbb10ff012ac6d82;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_38e0d057067d90e2fbb10ff012ac6d82);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_38e0d057067d90e2fbb10ff012ac6d82) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__get_boundary_time);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1378;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1378;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_1;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_X509_get_notBefore);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1378;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_38e0d057067d90e2fbb10ff012ac6d82->m_frame.f_lineno = 1378;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1378;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_38e0d057067d90e2fbb10ff012ac6d82);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_38e0d057067d90e2fbb10ff012ac6d82);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_38e0d057067d90e2fbb10ff012ac6d82);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_38e0d057067d90e2fbb10ff012ac6d82, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_38e0d057067d90e2fbb10ff012ac6d82->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_38e0d057067d90e2fbb10ff012ac6d82, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_38e0d057067d90e2fbb10ff012ac6d82,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_38e0d057067d90e2fbb10ff012ac6d82 == cache_frame_38e0d057067d90e2fbb10ff012ac6d82) {
        Py_DECREF(frame_38e0d057067d90e2fbb10ff012ac6d82);
    }
    cache_frame_38e0d057067d90e2fbb10ff012ac6d82 = NULL;

    assertFrameObject(frame_38e0d057067d90e2fbb10ff012ac6d82);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_71_get_notBefore);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_72__set_boundary_time(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_which = python_pars[1];
    PyObject *par_when = python_pars[2];
    struct Nuitka_FrameObject *frame_cb358a0ddff832515567a748ef6af7f5;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_cb358a0ddff832515567a748ef6af7f5 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_cb358a0ddff832515567a748ef6af7f5, codeobj_cb358a0ddff832515567a748ef6af7f5, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_cb358a0ddff832515567a748ef6af7f5 = cache_frame_cb358a0ddff832515567a748ef6af7f5;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_cb358a0ddff832515567a748ef6af7f5);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_cb358a0ddff832515567a748ef6af7f5) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__set_asn1_time);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__set_asn1_time);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3960 ], 43, 0);
            exception_tb = NULL;

            exception_lineno = 1381;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT(par_which);
        tmp_called_name_2 = par_which;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__x509);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1381;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_cb358a0ddff832515567a748ef6af7f5->m_frame.f_lineno = 1381;
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_2);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1381;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_when);
        tmp_args_element_name_3 = par_when;
        frame_cb358a0ddff832515567a748ef6af7f5->m_frame.f_lineno = 1381;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_3};
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1381;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_cb358a0ddff832515567a748ef6af7f5);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_cb358a0ddff832515567a748ef6af7f5);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_cb358a0ddff832515567a748ef6af7f5);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_cb358a0ddff832515567a748ef6af7f5, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_cb358a0ddff832515567a748ef6af7f5->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_cb358a0ddff832515567a748ef6af7f5, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_cb358a0ddff832515567a748ef6af7f5,
        type_description_1,
        par_self,
        par_which,
        par_when
    );


    // Release cached frame.
    if (frame_cb358a0ddff832515567a748ef6af7f5 == cache_frame_cb358a0ddff832515567a748ef6af7f5) {
        Py_DECREF(frame_cb358a0ddff832515567a748ef6af7f5);
    }
    cache_frame_cb358a0ddff832515567a748ef6af7f5 = NULL;

    assertFrameObject(frame_cb358a0ddff832515567a748ef6af7f5);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_72__set_boundary_time);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_when);
    Py_DECREF(par_when);
    CHECK_OBJECT(par_which);
    Py_DECREF(par_which);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_when);
    Py_DECREF(par_when);
    CHECK_OBJECT(par_which);
    Py_DECREF(par_which);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_73_set_notBefore(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_when = python_pars[1];
    struct Nuitka_FrameObject *frame_f85802ded5ad9e24c28efb6d7f3ae0de;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_f85802ded5ad9e24c28efb6d7f3ae0de = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_f85802ded5ad9e24c28efb6d7f3ae0de, codeobj_f85802ded5ad9e24c28efb6d7f3ae0de, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *));
    frame_f85802ded5ad9e24c28efb6d7f3ae0de = cache_frame_f85802ded5ad9e24c28efb6d7f3ae0de;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_f85802ded5ad9e24c28efb6d7f3ae0de);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_f85802ded5ad9e24c28efb6d7f3ae0de) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__set_boundary_time);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1394;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1394;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_1;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_X509_get_notBefore);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1394;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_when);
        tmp_args_element_name_2 = par_when;
        frame_f85802ded5ad9e24c28efb6d7f3ae0de->m_frame.f_lineno = 1394;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1394;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_f85802ded5ad9e24c28efb6d7f3ae0de);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_f85802ded5ad9e24c28efb6d7f3ae0de);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_f85802ded5ad9e24c28efb6d7f3ae0de);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_f85802ded5ad9e24c28efb6d7f3ae0de, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_f85802ded5ad9e24c28efb6d7f3ae0de->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_f85802ded5ad9e24c28efb6d7f3ae0de, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f85802ded5ad9e24c28efb6d7f3ae0de,
        type_description_1,
        par_self,
        par_when
    );


    // Release cached frame.
    if (frame_f85802ded5ad9e24c28efb6d7f3ae0de == cache_frame_f85802ded5ad9e24c28efb6d7f3ae0de) {
        Py_DECREF(frame_f85802ded5ad9e24c28efb6d7f3ae0de);
    }
    cache_frame_f85802ded5ad9e24c28efb6d7f3ae0de = NULL;

    assertFrameObject(frame_f85802ded5ad9e24c28efb6d7f3ae0de);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_73_set_notBefore);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_when);
    Py_DECREF(par_when);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_when);
    Py_DECREF(par_when);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_74_get_notAfter(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_a7d4834ead0a1a60fe3119338536d0f3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_a7d4834ead0a1a60fe3119338536d0f3 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_a7d4834ead0a1a60fe3119338536d0f3, codeobj_a7d4834ead0a1a60fe3119338536d0f3, module_OpenSSL$crypto, sizeof(void *));
    frame_a7d4834ead0a1a60fe3119338536d0f3 = cache_frame_a7d4834ead0a1a60fe3119338536d0f3;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_a7d4834ead0a1a60fe3119338536d0f3);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_a7d4834ead0a1a60fe3119338536d0f3) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__get_boundary_time);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1407;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1407;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_1;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_X509_get_notAfter);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1407;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_a7d4834ead0a1a60fe3119338536d0f3->m_frame.f_lineno = 1407;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1407;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a7d4834ead0a1a60fe3119338536d0f3);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_a7d4834ead0a1a60fe3119338536d0f3);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a7d4834ead0a1a60fe3119338536d0f3);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_a7d4834ead0a1a60fe3119338536d0f3, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_a7d4834ead0a1a60fe3119338536d0f3->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_a7d4834ead0a1a60fe3119338536d0f3, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a7d4834ead0a1a60fe3119338536d0f3,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_a7d4834ead0a1a60fe3119338536d0f3 == cache_frame_a7d4834ead0a1a60fe3119338536d0f3) {
        Py_DECREF(frame_a7d4834ead0a1a60fe3119338536d0f3);
    }
    cache_frame_a7d4834ead0a1a60fe3119338536d0f3 = NULL;

    assertFrameObject(frame_a7d4834ead0a1a60fe3119338536d0f3);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_74_get_notAfter);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_75_set_notAfter(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_when = python_pars[1];
    struct Nuitka_FrameObject *frame_7d3a859e1d891c970bd1bda57166fb91;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_7d3a859e1d891c970bd1bda57166fb91 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_7d3a859e1d891c970bd1bda57166fb91, codeobj_7d3a859e1d891c970bd1bda57166fb91, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *));
    frame_7d3a859e1d891c970bd1bda57166fb91 = cache_frame_7d3a859e1d891c970bd1bda57166fb91;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_7d3a859e1d891c970bd1bda57166fb91);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_7d3a859e1d891c970bd1bda57166fb91) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__set_boundary_time);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1420;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1420;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_1;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_X509_get_notAfter);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1420;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_when);
        tmp_args_element_name_2 = par_when;
        frame_7d3a859e1d891c970bd1bda57166fb91->m_frame.f_lineno = 1420;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1420;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_7d3a859e1d891c970bd1bda57166fb91);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_7d3a859e1d891c970bd1bda57166fb91);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_7d3a859e1d891c970bd1bda57166fb91);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_7d3a859e1d891c970bd1bda57166fb91, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_7d3a859e1d891c970bd1bda57166fb91->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_7d3a859e1d891c970bd1bda57166fb91, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7d3a859e1d891c970bd1bda57166fb91,
        type_description_1,
        par_self,
        par_when
    );


    // Release cached frame.
    if (frame_7d3a859e1d891c970bd1bda57166fb91 == cache_frame_7d3a859e1d891c970bd1bda57166fb91) {
        Py_DECREF(frame_7d3a859e1d891c970bd1bda57166fb91);
    }
    cache_frame_7d3a859e1d891c970bd1bda57166fb91 = NULL;

    assertFrameObject(frame_7d3a859e1d891c970bd1bda57166fb91);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_75_set_notAfter);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_when);
    Py_DECREF(par_when);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_when);
    Py_DECREF(par_when);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_76__get_name(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_which = python_pars[1];
    PyObject *var_name = NULL;
    struct Nuitka_FrameObject *frame_80105bd3cbfef104f47288369fe3a34c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_80105bd3cbfef104f47288369fe3a34c = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_80105bd3cbfef104f47288369fe3a34c, codeobj_80105bd3cbfef104f47288369fe3a34c, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_80105bd3cbfef104f47288369fe3a34c = cache_frame_80105bd3cbfef104f47288369fe3a34c;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_80105bd3cbfef104f47288369fe3a34c);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_80105bd3cbfef104f47288369fe3a34c) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Name);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Name);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1105 ], 37, 0);
            exception_tb = NULL;

            exception_lineno = 1423;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain___new__);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1423;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Name);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Name);
        }

        if (tmp_mvar_value_2 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1105 ], 37, 0);
            exception_tb = NULL;

            exception_lineno = 1423;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = tmp_mvar_value_2;
        frame_80105bd3cbfef104f47288369fe3a34c->m_frame.f_lineno = 1423;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1423;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_name == NULL);
        var_name = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_which);
        tmp_called_name_2 = par_which;
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__x509);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1424;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_80105bd3cbfef104f47288369fe3a34c->m_frame.f_lineno = 1424;
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_2);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1424;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_name);
        tmp_assattr_target_1 = var_name;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__name, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1424;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 1425;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_3;
        CHECK_OBJECT(var_name);
        tmp_source_name_3 = var_name;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__name);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1425;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_4 == NULL) {
            Py_DECREF(tmp_compexpr_left_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1425;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_4;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_NULL);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_1);

            exception_lineno = 1425;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1425;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_80105bd3cbfef104f47288369fe3a34c->m_frame.f_lineno = 1425;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_3, tmp_args_element_name_3);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1425;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT(par_self);
        tmp_assattr_name_2 = par_self;
        CHECK_OBJECT(var_name);
        tmp_assattr_target_2 = var_name;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain__owner, tmp_assattr_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1429;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_80105bd3cbfef104f47288369fe3a34c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_80105bd3cbfef104f47288369fe3a34c);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_80105bd3cbfef104f47288369fe3a34c, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_80105bd3cbfef104f47288369fe3a34c->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_80105bd3cbfef104f47288369fe3a34c, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_80105bd3cbfef104f47288369fe3a34c,
        type_description_1,
        par_self,
        par_which,
        var_name
    );


    // Release cached frame.
    if (frame_80105bd3cbfef104f47288369fe3a34c == cache_frame_80105bd3cbfef104f47288369fe3a34c) {
        Py_DECREF(frame_80105bd3cbfef104f47288369fe3a34c);
    }
    cache_frame_80105bd3cbfef104f47288369fe3a34c = NULL;

    assertFrameObject(frame_80105bd3cbfef104f47288369fe3a34c);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT(var_name);
    tmp_return_value = var_name;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_76__get_name);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_name);
    Py_DECREF(var_name);
    var_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_name);
    var_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_76__get_name);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_which);
    Py_DECREF(par_which);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_which);
    Py_DECREF(par_which);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_77__set_name(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_which = python_pars[1];
    PyObject *par_name = python_pars[2];
    PyObject *var_set_result = NULL;
    struct Nuitka_FrameObject *frame_a985957de3abbe239f1f1229dc888507;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_a985957de3abbe239f1f1229dc888507 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_a985957de3abbe239f1f1229dc888507, codeobj_a985957de3abbe239f1f1229dc888507, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_a985957de3abbe239f1f1229dc888507 = cache_frame_a985957de3abbe239f1f1229dc888507;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_a985957de3abbe239f1f1229dc888507);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_a985957de3abbe239f1f1229dc888507) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_name);
        tmp_isinstance_inst_1 = par_name;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Name);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Name);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1105 ], 37, 0);
            exception_tb = NULL;

            exception_lineno = 1434;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1434;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1434;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_b3f225987bb27e065a500d7fe8bd7c70;
            frame_a985957de3abbe239f1f1229dc888507->m_frame.f_lineno = 1435;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1435;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_which);
        tmp_called_name_1 = par_which;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__x509);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1436;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_name);
        tmp_source_name_2 = par_name;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__name);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_args_element_name_1);

            exception_lineno = 1436;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_a985957de3abbe239f1f1229dc888507->m_frame.f_lineno = 1436;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_args_element_name_1);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1436;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_set_result == NULL);
        var_set_result = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 1437;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT(var_set_result);
        tmp_compexpr_left_1 = var_set_result;
        tmp_compexpr_right_1 = const_int_pos_1;
        tmp_args_element_name_3 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1437;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_a985957de3abbe239f1f1229dc888507->m_frame.f_lineno = 1437;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_3);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1437;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a985957de3abbe239f1f1229dc888507);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a985957de3abbe239f1f1229dc888507);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_a985957de3abbe239f1f1229dc888507, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_a985957de3abbe239f1f1229dc888507->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_a985957de3abbe239f1f1229dc888507, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a985957de3abbe239f1f1229dc888507,
        type_description_1,
        par_self,
        par_which,
        par_name,
        var_set_result
    );


    // Release cached frame.
    if (frame_a985957de3abbe239f1f1229dc888507 == cache_frame_a985957de3abbe239f1f1229dc888507) {
        Py_DECREF(frame_a985957de3abbe239f1f1229dc888507);
    }
    cache_frame_a985957de3abbe239f1f1229dc888507 = NULL;

    assertFrameObject(frame_a985957de3abbe239f1f1229dc888507);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_77__set_name);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_set_result);
    Py_DECREF(var_set_result);
    var_set_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_set_result);
    var_set_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_77__set_name);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_name);
    Py_DECREF(par_name);
    CHECK_OBJECT(par_which);
    Py_DECREF(par_which);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_name);
    Py_DECREF(par_name);
    CHECK_OBJECT(par_which);
    Py_DECREF(par_which);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_78_get_issuer(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_name = NULL;
    struct Nuitka_FrameObject *frame_c92bad46c4a7152b022309b9441ca8ed;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_c92bad46c4a7152b022309b9441ca8ed = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_c92bad46c4a7152b022309b9441ca8ed, codeobj_c92bad46c4a7152b022309b9441ca8ed, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *));
    frame_c92bad46c4a7152b022309b9441ca8ed = cache_frame_c92bad46c4a7152b022309b9441ca8ed;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_c92bad46c4a7152b022309b9441ca8ed);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_c92bad46c4a7152b022309b9441ca8ed) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__get_name);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1451;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1451;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_1;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_X509_get_issuer_name);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1451;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_c92bad46c4a7152b022309b9441ca8ed->m_frame.f_lineno = 1451;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1451;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert(var_name == NULL);
        var_name = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__issuer_invalidator);
        if (tmp_called_instance_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1452;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_name);
        tmp_args_element_name_2 = var_name;
        frame_c92bad46c4a7152b022309b9441ca8ed->m_frame.f_lineno = 1452;
        {
            PyObject *call_args[] = {tmp_args_element_name_2};
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_add, call_args);
        }

        Py_DECREF(tmp_called_instance_1);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1452;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c92bad46c4a7152b022309b9441ca8ed);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c92bad46c4a7152b022309b9441ca8ed);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_c92bad46c4a7152b022309b9441ca8ed, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_c92bad46c4a7152b022309b9441ca8ed->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_c92bad46c4a7152b022309b9441ca8ed, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c92bad46c4a7152b022309b9441ca8ed,
        type_description_1,
        par_self,
        var_name
    );


    // Release cached frame.
    if (frame_c92bad46c4a7152b022309b9441ca8ed == cache_frame_c92bad46c4a7152b022309b9441ca8ed) {
        Py_DECREF(frame_c92bad46c4a7152b022309b9441ca8ed);
    }
    cache_frame_c92bad46c4a7152b022309b9441ca8ed = NULL;

    assertFrameObject(frame_c92bad46c4a7152b022309b9441ca8ed);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT(var_name);
    tmp_return_value = var_name;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_78_get_issuer);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_name);
    Py_DECREF(var_name);
    var_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_name);
    var_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_78_get_issuer);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_79_set_issuer(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_issuer = python_pars[1];
    struct Nuitka_FrameObject *frame_7b28dcc872c0fc1e599bc7f4fd0593c7;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_7b28dcc872c0fc1e599bc7f4fd0593c7 = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_7b28dcc872c0fc1e599bc7f4fd0593c7, codeobj_7b28dcc872c0fc1e599bc7f4fd0593c7, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *));
    frame_7b28dcc872c0fc1e599bc7f4fd0593c7 = cache_frame_7b28dcc872c0fc1e599bc7f4fd0593c7;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_7b28dcc872c0fc1e599bc7f4fd0593c7);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_7b28dcc872c0fc1e599bc7f4fd0593c7) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__set_name);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1464;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1464;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_1;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_X509_set_issuer_name);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1464;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_issuer);
        tmp_args_element_name_2 = par_issuer;
        frame_7b28dcc872c0fc1e599bc7f4fd0593c7->m_frame.f_lineno = 1464;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1464;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_call_result_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__issuer_invalidator);
        if (tmp_called_instance_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1465;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_7b28dcc872c0fc1e599bc7f4fd0593c7->m_frame.f_lineno = 1465;
        tmp_call_result_2 = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_clear);
        Py_DECREF(tmp_called_instance_1);
        if (tmp_call_result_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1465;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_2);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_7b28dcc872c0fc1e599bc7f4fd0593c7);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_7b28dcc872c0fc1e599bc7f4fd0593c7);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_7b28dcc872c0fc1e599bc7f4fd0593c7, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_7b28dcc872c0fc1e599bc7f4fd0593c7->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_7b28dcc872c0fc1e599bc7f4fd0593c7, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7b28dcc872c0fc1e599bc7f4fd0593c7,
        type_description_1,
        par_self,
        par_issuer
    );


    // Release cached frame.
    if (frame_7b28dcc872c0fc1e599bc7f4fd0593c7 == cache_frame_7b28dcc872c0fc1e599bc7f4fd0593c7) {
        Py_DECREF(frame_7b28dcc872c0fc1e599bc7f4fd0593c7);
    }
    cache_frame_7b28dcc872c0fc1e599bc7f4fd0593c7 = NULL;

    assertFrameObject(frame_7b28dcc872c0fc1e599bc7f4fd0593c7);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_79_set_issuer);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_issuer);
    Py_DECREF(par_issuer);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_issuer);
    Py_DECREF(par_issuer);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_80_get_subject(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_name = NULL;
    struct Nuitka_FrameObject *frame_0167861cea57ebc738ecf400cc04ebfa;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_0167861cea57ebc738ecf400cc04ebfa = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_0167861cea57ebc738ecf400cc04ebfa, codeobj_0167861cea57ebc738ecf400cc04ebfa, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *));
    frame_0167861cea57ebc738ecf400cc04ebfa = cache_frame_0167861cea57ebc738ecf400cc04ebfa;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_0167861cea57ebc738ecf400cc04ebfa);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_0167861cea57ebc738ecf400cc04ebfa) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__get_name);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1479;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1479;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_1;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_X509_get_subject_name);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1479;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_0167861cea57ebc738ecf400cc04ebfa->m_frame.f_lineno = 1479;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1479;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert(var_name == NULL);
        var_name = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__subject_invalidator);
        if (tmp_called_instance_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1480;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_name);
        tmp_args_element_name_2 = var_name;
        frame_0167861cea57ebc738ecf400cc04ebfa->m_frame.f_lineno = 1480;
        {
            PyObject *call_args[] = {tmp_args_element_name_2};
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_add, call_args);
        }

        Py_DECREF(tmp_called_instance_1);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1480;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0167861cea57ebc738ecf400cc04ebfa);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0167861cea57ebc738ecf400cc04ebfa);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_0167861cea57ebc738ecf400cc04ebfa, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_0167861cea57ebc738ecf400cc04ebfa->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_0167861cea57ebc738ecf400cc04ebfa, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0167861cea57ebc738ecf400cc04ebfa,
        type_description_1,
        par_self,
        var_name
    );


    // Release cached frame.
    if (frame_0167861cea57ebc738ecf400cc04ebfa == cache_frame_0167861cea57ebc738ecf400cc04ebfa) {
        Py_DECREF(frame_0167861cea57ebc738ecf400cc04ebfa);
    }
    cache_frame_0167861cea57ebc738ecf400cc04ebfa = NULL;

    assertFrameObject(frame_0167861cea57ebc738ecf400cc04ebfa);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT(var_name);
    tmp_return_value = var_name;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_80_get_subject);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_name);
    Py_DECREF(var_name);
    var_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_name);
    var_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_80_get_subject);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_81_set_subject(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_subject = python_pars[1];
    struct Nuitka_FrameObject *frame_555e64665b36c5489cfa1aab914f4b68;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_555e64665b36c5489cfa1aab914f4b68 = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_555e64665b36c5489cfa1aab914f4b68, codeobj_555e64665b36c5489cfa1aab914f4b68, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *));
    frame_555e64665b36c5489cfa1aab914f4b68 = cache_frame_555e64665b36c5489cfa1aab914f4b68;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_555e64665b36c5489cfa1aab914f4b68);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_555e64665b36c5489cfa1aab914f4b68) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__set_name);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1492;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1492;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_1;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_X509_set_subject_name);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1492;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_subject);
        tmp_args_element_name_2 = par_subject;
        frame_555e64665b36c5489cfa1aab914f4b68->m_frame.f_lineno = 1492;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1492;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_call_result_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__subject_invalidator);
        if (tmp_called_instance_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1493;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_555e64665b36c5489cfa1aab914f4b68->m_frame.f_lineno = 1493;
        tmp_call_result_2 = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_clear);
        Py_DECREF(tmp_called_instance_1);
        if (tmp_call_result_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1493;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_2);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_555e64665b36c5489cfa1aab914f4b68);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_555e64665b36c5489cfa1aab914f4b68);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_555e64665b36c5489cfa1aab914f4b68, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_555e64665b36c5489cfa1aab914f4b68->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_555e64665b36c5489cfa1aab914f4b68, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_555e64665b36c5489cfa1aab914f4b68,
        type_description_1,
        par_self,
        par_subject
    );


    // Release cached frame.
    if (frame_555e64665b36c5489cfa1aab914f4b68 == cache_frame_555e64665b36c5489cfa1aab914f4b68) {
        Py_DECREF(frame_555e64665b36c5489cfa1aab914f4b68);
    }
    cache_frame_555e64665b36c5489cfa1aab914f4b68 = NULL;

    assertFrameObject(frame_555e64665b36c5489cfa1aab914f4b68);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_81_set_subject);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_subject);
    Py_DECREF(par_subject);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_subject);
    Py_DECREF(par_subject);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_82_get_extension_count(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_a3d6ff1e9626c3f8ac77d23bb924b11c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_a3d6ff1e9626c3f8ac77d23bb924b11c = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_a3d6ff1e9626c3f8ac77d23bb924b11c, codeobj_a3d6ff1e9626c3f8ac77d23bb924b11c, module_OpenSSL$crypto, sizeof(void *));
    frame_a3d6ff1e9626c3f8ac77d23bb924b11c = cache_frame_a3d6ff1e9626c3f8ac77d23bb924b11c;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_a3d6ff1e9626c3f8ac77d23bb924b11c);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_a3d6ff1e9626c3f8ac77d23bb924b11c) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1504;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_X509_get_ext_count);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1504;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__x509);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1504;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_a3d6ff1e9626c3f8ac77d23bb924b11c->m_frame.f_lineno = 1504;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1504;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a3d6ff1e9626c3f8ac77d23bb924b11c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_a3d6ff1e9626c3f8ac77d23bb924b11c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a3d6ff1e9626c3f8ac77d23bb924b11c);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_a3d6ff1e9626c3f8ac77d23bb924b11c, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_a3d6ff1e9626c3f8ac77d23bb924b11c->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_a3d6ff1e9626c3f8ac77d23bb924b11c, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a3d6ff1e9626c3f8ac77d23bb924b11c,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_a3d6ff1e9626c3f8ac77d23bb924b11c == cache_frame_a3d6ff1e9626c3f8ac77d23bb924b11c) {
        Py_DECREF(frame_a3d6ff1e9626c3f8ac77d23bb924b11c);
    }
    cache_frame_a3d6ff1e9626c3f8ac77d23bb924b11c = NULL;

    assertFrameObject(frame_a3d6ff1e9626c3f8ac77d23bb924b11c);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_82_get_extension_count);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_83_add_extensions(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_extensions = python_pars[1];
    PyObject *var_ext = NULL;
    PyObject *var_add_result = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_1e39bc936ea94807eaf0b02a24efd7e5;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_1e39bc936ea94807eaf0b02a24efd7e5 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_1e39bc936ea94807eaf0b02a24efd7e5, codeobj_1e39bc936ea94807eaf0b02a24efd7e5, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_1e39bc936ea94807eaf0b02a24efd7e5 = cache_frame_1e39bc936ea94807eaf0b02a24efd7e5;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_1e39bc936ea94807eaf0b02a24efd7e5);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_1e39bc936ea94807eaf0b02a24efd7e5) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_iter_arg_1;
        CHECK_OBJECT(par_extensions);
        tmp_iter_arg_1 = par_extensions;
        tmp_assign_source_1 = MAKE_ITERATOR(tmp_iter_arg_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1514;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(tmp_for_loop_1__for_iterator == NULL);
        tmp_for_loop_1__for_iterator = tmp_assign_source_1;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT(tmp_for_loop_1__for_iterator);
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_2 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_2 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "oooo";
                exception_lineno = 1514;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_2;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_3;
        CHECK_OBJECT(tmp_for_loop_1__iter_value);
        tmp_assign_source_3 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_ext;
            var_ext = tmp_assign_source_3;
            Py_INCREF(var_ext);
            Py_XDECREF(old);
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(var_ext);
        tmp_isinstance_inst_1 = var_ext;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Extension);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Extension);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3708 ], 42, 0);
            exception_tb = NULL;

            exception_lineno = 1515;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1515;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1515;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_c57795fb6a9ac3d47e928f9a8b608571;
            frame_1e39bc936ea94807eaf0b02a24efd7e5->m_frame.f_lineno = 1516;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1516;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1518;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_X509_add_ext);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1518;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__x509);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1518;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT(var_ext);
        tmp_source_name_3 = var_ext;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__extension);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_element_name_1);

            exception_lineno = 1518;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        tmp_args_element_name_3 = const_int_neg_1;
        frame_1e39bc936ea94807eaf0b02a24efd7e5->m_frame.f_lineno = 1518;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assign_source_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1518;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_add_result;
            var_add_result = tmp_assign_source_4;
            Py_XDECREF(old);
        }

    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_2;
        CHECK_OBJECT(var_add_result);
        tmp_operand_name_2 = var_add_result;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1519;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        tmp_condition_result_2 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_called_name_2;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_call_result_1;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error);
            }

            if (tmp_mvar_value_3 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 0 ], 49, 0);
                exception_tb = NULL;

                exception_lineno = 1520;
                type_description_1 = "oooo";
                goto try_except_handler_2;
            }

            tmp_called_name_2 = tmp_mvar_value_3;
            frame_1e39bc936ea94807eaf0b02a24efd7e5->m_frame.f_lineno = 1520;
            tmp_call_result_1 = CALL_FUNCTION_NO_ARGS(tmp_called_name_2);
            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1520;
                type_description_1 = "oooo";
                goto try_except_handler_2;
            }
            Py_DECREF(tmp_call_result_1);
        }
        branch_no_2:;
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


        exception_lineno = 1514;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_1e39bc936ea94807eaf0b02a24efd7e5);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_1e39bc936ea94807eaf0b02a24efd7e5);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_1e39bc936ea94807eaf0b02a24efd7e5, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_1e39bc936ea94807eaf0b02a24efd7e5->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_1e39bc936ea94807eaf0b02a24efd7e5, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1e39bc936ea94807eaf0b02a24efd7e5,
        type_description_1,
        par_self,
        par_extensions,
        var_ext,
        var_add_result
    );


    // Release cached frame.
    if (frame_1e39bc936ea94807eaf0b02a24efd7e5 == cache_frame_1e39bc936ea94807eaf0b02a24efd7e5) {
        Py_DECREF(frame_1e39bc936ea94807eaf0b02a24efd7e5);
    }
    cache_frame_1e39bc936ea94807eaf0b02a24efd7e5 = NULL;

    assertFrameObject(frame_1e39bc936ea94807eaf0b02a24efd7e5);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_83_add_extensions);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_ext);
    var_ext = NULL;

    Py_XDECREF(var_add_result);
    var_add_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_ext);
    var_ext = NULL;

    Py_XDECREF(var_add_result);
    var_add_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_83_add_extensions);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_extensions);
    Py_DECREF(par_extensions);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_extensions);
    Py_DECREF(par_extensions);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_84_get_extension(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_index = python_pars[1];
    PyObject *var_ext = NULL;
    PyObject *var_extension = NULL;
    struct Nuitka_FrameObject *frame_2f6eda6ffd4b44390873f4f24070482e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_2f6eda6ffd4b44390873f4f24070482e = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_2f6eda6ffd4b44390873f4f24070482e, codeobj_2f6eda6ffd4b44390873f4f24070482e, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_2f6eda6ffd4b44390873f4f24070482e = cache_frame_2f6eda6ffd4b44390873f4f24070482e;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_2f6eda6ffd4b44390873f4f24070482e);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_2f6eda6ffd4b44390873f4f24070482e) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Extension);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Extension);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3708 ], 42, 0);
            exception_tb = NULL;

            exception_lineno = 1536;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain___new__);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1536;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Extension);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Extension);
        }

        if (tmp_mvar_value_2 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3708 ], 42, 0);
            exception_tb = NULL;

            exception_lineno = 1536;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = tmp_mvar_value_2;
        frame_2f6eda6ffd4b44390873f4f24070482e->m_frame.f_lineno = 1536;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1536;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_ext == NULL);
        var_ext = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1537;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_X509_get_ext);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1537;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__x509);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 1537;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_index);
        tmp_args_element_name_3 = par_index;
        frame_2f6eda6ffd4b44390873f4f24070482e->m_frame.f_lineno = 1537;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1537;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_ext);
        tmp_assattr_target_1 = var_ext;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__extension, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1537;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_4;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_4;
        CHECK_OBJECT(var_ext);
        tmp_source_name_4 = var_ext;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain__extension);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1538;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_4 == NULL) {
            Py_DECREF(tmp_compexpr_left_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1538;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_4;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_NULL);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_1);

            exception_lineno = 1538;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1538;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_7a5005a2e44b5258634f5b2837cd8b81;
            frame_2f6eda6ffd4b44390873f4f24070482e->m_frame.f_lineno = 1539;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_IndexError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1539;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_source_name_7;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1541;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_5;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_X509_EXTENSION_dup);
        if (tmp_called_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1541;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_ext);
        tmp_source_name_7 = var_ext;
        tmp_args_element_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain__extension);
        if (tmp_args_element_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);

            exception_lineno = 1541;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_2f6eda6ffd4b44390873f4f24070482e->m_frame.f_lineno = 1541;
        tmp_assign_source_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_3, tmp_args_element_name_4);
        Py_DECREF(tmp_called_name_3);
        Py_DECREF(tmp_args_element_name_4);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1541;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_extension == NULL);
        var_extension = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_8;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_source_name_9;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_assattr_target_2;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_6 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1542;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_8 = tmp_mvar_value_6;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_8, const_str_plain_gc);
        if (tmp_called_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1542;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_extension);
        tmp_args_element_name_5 = var_extension;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_7 == NULL)) {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_7 == NULL) {
            Py_DECREF(tmp_called_name_4);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1542;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_9 = tmp_mvar_value_7;
        tmp_args_element_name_6 = LOOKUP_ATTRIBUTE(tmp_source_name_9, const_str_plain_X509_EXTENSION_free);
        if (tmp_args_element_name_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_4);

            exception_lineno = 1542;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_2f6eda6ffd4b44390873f4f24070482e->m_frame.f_lineno = 1542;
        {
            PyObject *call_args[] = {tmp_args_element_name_5, tmp_args_element_name_6};
            tmp_assattr_name_2 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_4, call_args);
        }

        Py_DECREF(tmp_called_name_4);
        Py_DECREF(tmp_args_element_name_6);
        if (tmp_assattr_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1542;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_ext);
        tmp_assattr_target_2 = var_ext;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain__extension, tmp_assattr_name_2);
        Py_DECREF(tmp_assattr_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1542;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2f6eda6ffd4b44390873f4f24070482e);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2f6eda6ffd4b44390873f4f24070482e);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_2f6eda6ffd4b44390873f4f24070482e, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_2f6eda6ffd4b44390873f4f24070482e->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_2f6eda6ffd4b44390873f4f24070482e, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2f6eda6ffd4b44390873f4f24070482e,
        type_description_1,
        par_self,
        par_index,
        var_ext,
        var_extension
    );


    // Release cached frame.
    if (frame_2f6eda6ffd4b44390873f4f24070482e == cache_frame_2f6eda6ffd4b44390873f4f24070482e) {
        Py_DECREF(frame_2f6eda6ffd4b44390873f4f24070482e);
    }
    cache_frame_2f6eda6ffd4b44390873f4f24070482e = NULL;

    assertFrameObject(frame_2f6eda6ffd4b44390873f4f24070482e);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT(var_ext);
    tmp_return_value = var_ext;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_84_get_extension);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_ext);
    Py_DECREF(var_ext);
    var_ext = NULL;

    CHECK_OBJECT((PyObject *)var_extension);
    Py_DECREF(var_extension);
    var_extension = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_ext);
    var_ext = NULL;

    Py_XDECREF(var_extension);
    var_extension = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_84_get_extension);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_index);
    Py_DECREF(par_index);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_index);
    Py_DECREF(par_index);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_85___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_store = NULL;
    struct Nuitka_FrameObject *frame_d7eda580e48a4e0112100f560fb2f9fd;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_d7eda580e48a4e0112100f560fb2f9fd = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_d7eda580e48a4e0112100f560fb2f9fd, codeobj_d7eda580e48a4e0112100f560fb2f9fd, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *));
    frame_d7eda580e48a4e0112100f560fb2f9fd = cache_frame_d7eda580e48a4e0112100f560fb2f9fd;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_d7eda580e48a4e0112100f560fb2f9fd);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_d7eda580e48a4e0112100f560fb2f9fd) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1591;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_d7eda580e48a4e0112100f560fb2f9fd->m_frame.f_lineno = 1591;
        tmp_assign_source_1 = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_X509_STORE_new);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1591;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert(var_store == NULL);
        var_store = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1592;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_gc);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1592;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_store);
        tmp_args_element_name_1 = var_store;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1592;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_X509_STORE_free);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1592;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_d7eda580e48a4e0112100f560fb2f9fd->m_frame.f_lineno = 1592;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1592;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__store, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1592;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_d7eda580e48a4e0112100f560fb2f9fd);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_d7eda580e48a4e0112100f560fb2f9fd);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_d7eda580e48a4e0112100f560fb2f9fd, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_d7eda580e48a4e0112100f560fb2f9fd->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_d7eda580e48a4e0112100f560fb2f9fd, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d7eda580e48a4e0112100f560fb2f9fd,
        type_description_1,
        par_self,
        var_store
    );


    // Release cached frame.
    if (frame_d7eda580e48a4e0112100f560fb2f9fd == cache_frame_d7eda580e48a4e0112100f560fb2f9fd) {
        Py_DECREF(frame_d7eda580e48a4e0112100f560fb2f9fd);
    }
    cache_frame_d7eda580e48a4e0112100f560fb2f9fd = NULL;

    assertFrameObject(frame_d7eda580e48a4e0112100f560fb2f9fd);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_85___init__);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_store);
    Py_DECREF(var_store);
    var_store = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_store);
    var_store = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_85___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_86_add_cert(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_cert = python_pars[1];
    PyObject *var_code = NULL;
    PyObject *var_err_reason = NULL;
    struct Nuitka_FrameObject *frame_457f951bde44f2371cea4fa29a1876af;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_457f951bde44f2371cea4fa29a1876af = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_457f951bde44f2371cea4fa29a1876af, codeobj_457f951bde44f2371cea4fa29a1876af, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_457f951bde44f2371cea4fa29a1876af = cache_frame_457f951bde44f2371cea4fa29a1876af;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_457f951bde44f2371cea4fa29a1876af);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_457f951bde44f2371cea4fa29a1876af) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_cert);
        tmp_isinstance_inst_1 = par_cert;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 236 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1610;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1610;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1610;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            frame_457f951bde44f2371cea4fa29a1876af->m_frame.f_lineno = 1611;
            tmp_raise_type_1 = CALL_FUNCTION_NO_ARGS(PyExc_TypeError);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1611;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1616;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_X509_STORE_add_cert);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1616;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__store);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1616;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_cert);
        tmp_source_name_3 = par_cert;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__x509);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_element_name_1);

            exception_lineno = 1616;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_457f951bde44f2371cea4fa29a1876af->m_frame.f_lineno = 1616;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_compexpr_left_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1616;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = const_int_0;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_INT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1616;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_mvar_value_3;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_3 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1617;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_1 = tmp_mvar_value_3;
            frame_457f951bde44f2371cea4fa29a1876af->m_frame.f_lineno = 1617;
            tmp_assign_source_1 = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_ERR_peek_error);
            if (tmp_assign_source_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1617;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            assert(var_code == NULL);
            var_code = tmp_assign_source_1;
        }
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_called_instance_2;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_args_element_name_3;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_4 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1618;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_2 = tmp_mvar_value_4;
            CHECK_OBJECT(var_code);
            tmp_args_element_name_3 = var_code;
            frame_457f951bde44f2371cea4fa29a1876af->m_frame.f_lineno = 1618;
            {
                PyObject *call_args[] = {tmp_args_element_name_3};
                tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_ERR_GET_REASON, call_args);
            }

            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1618;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            assert(var_err_reason == NULL);
            var_err_reason = tmp_assign_source_2;
        }
        {
            PyObject *tmp_called_name_2;
            PyObject *tmp_mvar_value_5;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_source_name_4;
            PyObject *tmp_mvar_value_6;
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

            if (unlikely(tmp_mvar_value_5 == NULL)) {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
            }

            if (tmp_mvar_value_5 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
                exception_tb = NULL;

                exception_lineno = 1619;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_2 = tmp_mvar_value_5;
            CHECK_OBJECT(var_err_reason);
            tmp_compexpr_left_2 = var_err_reason;
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_6 == NULL)) {
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_6 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1620;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_4 = tmp_mvar_value_6;
            tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_X509_R_CERT_ALREADY_IN_HASH_TABLE);
            if (tmp_compexpr_right_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1620;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            tmp_args_element_name_4 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
            Py_DECREF(tmp_compexpr_right_2);
            if (tmp_args_element_name_4 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1620;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            frame_457f951bde44f2371cea4fa29a1876af->m_frame.f_lineno = 1619;
            tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_4);
            Py_DECREF(tmp_args_element_name_4);
            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1619;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_1);
        }
        {
            PyObject *tmp_called_instance_3;
            PyObject *tmp_mvar_value_7;
            PyObject *tmp_call_result_2;
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_7 == NULL)) {
                tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_7 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1622;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_3 = tmp_mvar_value_7;
            frame_457f951bde44f2371cea4fa29a1876af->m_frame.f_lineno = 1622;
            tmp_call_result_2 = CALL_METHOD_NO_ARGS(tmp_called_instance_3, const_str_plain_ERR_clear_error);
            if (tmp_call_result_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1622;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_2);
        }
        branch_no_2:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_457f951bde44f2371cea4fa29a1876af);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_457f951bde44f2371cea4fa29a1876af);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_457f951bde44f2371cea4fa29a1876af, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_457f951bde44f2371cea4fa29a1876af->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_457f951bde44f2371cea4fa29a1876af, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_457f951bde44f2371cea4fa29a1876af,
        type_description_1,
        par_self,
        par_cert,
        var_code,
        var_err_reason
    );


    // Release cached frame.
    if (frame_457f951bde44f2371cea4fa29a1876af == cache_frame_457f951bde44f2371cea4fa29a1876af) {
        Py_DECREF(frame_457f951bde44f2371cea4fa29a1876af);
    }
    cache_frame_457f951bde44f2371cea4fa29a1876af = NULL;

    assertFrameObject(frame_457f951bde44f2371cea4fa29a1876af);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_86_add_cert);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_code);
    var_code = NULL;

    Py_XDECREF(var_err_reason);
    var_err_reason = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_code);
    var_code = NULL;

    Py_XDECREF(var_err_reason);
    var_err_reason = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_86_add_cert);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_cert);
    Py_DECREF(par_cert);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_cert);
    Py_DECREF(par_cert);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_87_add_crl(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_crl = python_pars[1];
    struct Nuitka_FrameObject *frame_98c960373d8e9f9023212df2b317530b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_98c960373d8e9f9023212df2b317530b = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_98c960373d8e9f9023212df2b317530b, codeobj_98c960373d8e9f9023212df2b317530b, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *));
    frame_98c960373d8e9f9023212df2b317530b = cache_frame_98c960373d8e9f9023212df2b317530b;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_98c960373d8e9f9023212df2b317530b);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_98c960373d8e9f9023212df2b317530b) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 1638;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1638;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_X509_STORE_add_crl);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1638;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__store);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 1638;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_crl);
        tmp_source_name_3 = par_crl;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__crl);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_2);

            exception_lineno = 1638;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_98c960373d8e9f9023212df2b317530b->m_frame.f_lineno = 1638;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_compexpr_left_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_2);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1638;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = const_int_0;
        tmp_args_element_name_1 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1638;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_98c960373d8e9f9023212df2b317530b->m_frame.f_lineno = 1638;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1638;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_98c960373d8e9f9023212df2b317530b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_98c960373d8e9f9023212df2b317530b);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_98c960373d8e9f9023212df2b317530b, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_98c960373d8e9f9023212df2b317530b->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_98c960373d8e9f9023212df2b317530b, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_98c960373d8e9f9023212df2b317530b,
        type_description_1,
        par_self,
        par_crl
    );


    // Release cached frame.
    if (frame_98c960373d8e9f9023212df2b317530b == cache_frame_98c960373d8e9f9023212df2b317530b) {
        Py_DECREF(frame_98c960373d8e9f9023212df2b317530b);
    }
    cache_frame_98c960373d8e9f9023212df2b317530b = NULL;

    assertFrameObject(frame_98c960373d8e9f9023212df2b317530b);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_87_add_crl);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_crl);
    Py_DECREF(par_crl);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_crl);
    Py_DECREF(par_crl);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_88_set_flags(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_flags = python_pars[1];
    struct Nuitka_FrameObject *frame_60b024772fde8ae0bc098cb534c29ad5;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_60b024772fde8ae0bc098cb534c29ad5 = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_60b024772fde8ae0bc098cb534c29ad5, codeobj_60b024772fde8ae0bc098cb534c29ad5, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *));
    frame_60b024772fde8ae0bc098cb534c29ad5 = cache_frame_60b024772fde8ae0bc098cb534c29ad5;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_60b024772fde8ae0bc098cb534c29ad5);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_60b024772fde8ae0bc098cb534c29ad5) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 1662;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1662;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_X509_STORE_set_flags);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1662;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__store);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 1662;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_flags);
        tmp_args_element_name_3 = par_flags;
        frame_60b024772fde8ae0bc098cb534c29ad5->m_frame.f_lineno = 1662;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_compexpr_left_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1662;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = const_int_0;
        tmp_args_element_name_1 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1662;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_60b024772fde8ae0bc098cb534c29ad5->m_frame.f_lineno = 1662;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1662;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_60b024772fde8ae0bc098cb534c29ad5);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_60b024772fde8ae0bc098cb534c29ad5);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_60b024772fde8ae0bc098cb534c29ad5, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_60b024772fde8ae0bc098cb534c29ad5->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_60b024772fde8ae0bc098cb534c29ad5, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_60b024772fde8ae0bc098cb534c29ad5,
        type_description_1,
        par_self,
        par_flags
    );


    // Release cached frame.
    if (frame_60b024772fde8ae0bc098cb534c29ad5 == cache_frame_60b024772fde8ae0bc098cb534c29ad5) {
        Py_DECREF(frame_60b024772fde8ae0bc098cb534c29ad5);
    }
    cache_frame_60b024772fde8ae0bc098cb534c29ad5 = NULL;

    assertFrameObject(frame_60b024772fde8ae0bc098cb534c29ad5);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_88_set_flags);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_flags);
    Py_DECREF(par_flags);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_flags);
    Py_DECREF(par_flags);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_89_set_time(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_vfy_time = python_pars[1];
    PyObject *var_param = NULL;
    struct Nuitka_FrameObject *frame_5206be546a6fa8e25a02dc839db5f52a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_5206be546a6fa8e25a02dc839db5f52a = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_5206be546a6fa8e25a02dc839db5f52a, codeobj_5206be546a6fa8e25a02dc839db5f52a, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_5206be546a6fa8e25a02dc839db5f52a = cache_frame_5206be546a6fa8e25a02dc839db5f52a;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_5206be546a6fa8e25a02dc839db5f52a);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_5206be546a6fa8e25a02dc839db5f52a) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1680;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_5206be546a6fa8e25a02dc839db5f52a->m_frame.f_lineno = 1680;
        tmp_assign_source_1 = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_X509_VERIFY_PARAM_new);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1680;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_param == NULL);
        var_param = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1681;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_gc);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1681;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_param);
        tmp_args_element_name_1 = var_param;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1681;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_X509_VERIFY_PARAM_free);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1681;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_5206be546a6fa8e25a02dc839db5f52a->m_frame.f_lineno = 1681;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1681;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var_param;
            assert(old != NULL);
            var_param = tmp_assign_source_2;
            Py_DECREF(old);
        }

    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_int_arg_1;
        PyObject *tmp_called_instance_2;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1683;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_4;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_X509_VERIFY_PARAM_set_time);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1683;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_param);
        tmp_args_element_name_3 = var_param;
        CHECK_OBJECT(par_vfy_time);
        tmp_called_instance_2 = par_vfy_time;
        frame_5206be546a6fa8e25a02dc839db5f52a->m_frame.f_lineno = 1683;
        tmp_int_arg_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_strftime, &PyTuple_GET_ITEM(const_tuple_str_digest_eee7b0934fe224b34ba6722d84ccd2bf_tuple, 0));

        if (tmp_int_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 1683;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_4 = PyNumber_Int(tmp_int_arg_1);
        Py_DECREF(tmp_int_arg_1);
        if (tmp_args_element_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 1683;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_5206be546a6fa8e25a02dc839db5f52a->m_frame.f_lineno = 1683;
        {
            PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4};
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_4);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1683;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_source_name_5;
        PyObject *tmp_args_element_name_7;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 1684;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_5;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_6 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1684;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_6;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_X509_STORE_set1_param);
        if (tmp_called_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1684;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_5 = par_self;
        tmp_args_element_name_6 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain__store);
        if (tmp_args_element_name_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_4);

            exception_lineno = 1684;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_param);
        tmp_args_element_name_7 = var_param;
        frame_5206be546a6fa8e25a02dc839db5f52a->m_frame.f_lineno = 1684;
        {
            PyObject *call_args[] = {tmp_args_element_name_6, tmp_args_element_name_7};
            tmp_compexpr_left_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_4, call_args);
        }

        Py_DECREF(tmp_called_name_4);
        Py_DECREF(tmp_args_element_name_6);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1684;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = const_int_0;
        tmp_args_element_name_5 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        if (tmp_args_element_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1684;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_5206be546a6fa8e25a02dc839db5f52a->m_frame.f_lineno = 1684;
        tmp_call_result_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_3, tmp_args_element_name_5);
        Py_DECREF(tmp_args_element_name_5);
        if (tmp_call_result_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1684;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_2);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5206be546a6fa8e25a02dc839db5f52a);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5206be546a6fa8e25a02dc839db5f52a);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_5206be546a6fa8e25a02dc839db5f52a, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_5206be546a6fa8e25a02dc839db5f52a->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_5206be546a6fa8e25a02dc839db5f52a, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5206be546a6fa8e25a02dc839db5f52a,
        type_description_1,
        par_self,
        par_vfy_time,
        var_param
    );


    // Release cached frame.
    if (frame_5206be546a6fa8e25a02dc839db5f52a == cache_frame_5206be546a6fa8e25a02dc839db5f52a) {
        Py_DECREF(frame_5206be546a6fa8e25a02dc839db5f52a);
    }
    cache_frame_5206be546a6fa8e25a02dc839db5f52a = NULL;

    assertFrameObject(frame_5206be546a6fa8e25a02dc839db5f52a);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_89_set_time);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_param);
    Py_DECREF(var_param);
    var_param = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_param);
    var_param = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_89_set_time);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_vfy_time);
    Py_DECREF(par_vfy_time);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_vfy_time);
    Py_DECREF(par_vfy_time);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_90___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_message = python_pars[1];
    PyObject *par_certificate = python_pars[2];
    struct Nuitka_FrameObject *frame_8f2729c6c39bb67f3ed78460f5e5408b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_8f2729c6c39bb67f3ed78460f5e5408b = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_8f2729c6c39bb67f3ed78460f5e5408b, codeobj_8f2729c6c39bb67f3ed78460f5e5408b, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_8f2729c6c39bb67f3ed78460f5e5408b = cache_frame_8f2729c6c39bb67f3ed78460f5e5408b;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_8f2729c6c39bb67f3ed78460f5e5408b);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_8f2729c6c39bb67f3ed78460f5e5408b) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_type_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_object_name_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509StoreContextError);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509StoreContextError);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 4003 ], 50, 0);
            exception_tb = NULL;

            exception_lineno = 1704;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_type_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT(par_self);
        tmp_object_name_1 = par_self;
        tmp_called_instance_1 = BUILTIN_SUPER(tmp_type_name_1, tmp_object_name_1);
        if (tmp_called_instance_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1704;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_message);
        tmp_args_element_name_1 = par_message;
        frame_8f2729c6c39bb67f3ed78460f5e5408b->m_frame.f_lineno = 1704;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain___init__, call_args);
        }

        Py_DECREF(tmp_called_instance_1);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1704;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_certificate);
        tmp_assattr_name_1 = par_certificate;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain_certificate, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1705;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8f2729c6c39bb67f3ed78460f5e5408b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8f2729c6c39bb67f3ed78460f5e5408b);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_8f2729c6c39bb67f3ed78460f5e5408b, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_8f2729c6c39bb67f3ed78460f5e5408b->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_8f2729c6c39bb67f3ed78460f5e5408b, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8f2729c6c39bb67f3ed78460f5e5408b,
        type_description_1,
        par_self,
        par_message,
        par_certificate
    );


    // Release cached frame.
    if (frame_8f2729c6c39bb67f3ed78460f5e5408b == cache_frame_8f2729c6c39bb67f3ed78460f5e5408b) {
        Py_DECREF(frame_8f2729c6c39bb67f3ed78460f5e5408b);
    }
    cache_frame_8f2729c6c39bb67f3ed78460f5e5408b = NULL;

    assertFrameObject(frame_8f2729c6c39bb67f3ed78460f5e5408b);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_90___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_message);
    Py_DECREF(par_message);
    CHECK_OBJECT(par_certificate);
    Py_DECREF(par_certificate);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_message);
    Py_DECREF(par_message);
    CHECK_OBJECT(par_certificate);
    Py_DECREF(par_certificate);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_91___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_store = python_pars[1];
    PyObject *par_certificate = python_pars[2];
    PyObject *var_store_ctx = NULL;
    struct Nuitka_FrameObject *frame_3f33b64820845ae325979d13781edcfd;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_3f33b64820845ae325979d13781edcfd = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_3f33b64820845ae325979d13781edcfd, codeobj_3f33b64820845ae325979d13781edcfd, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_3f33b64820845ae325979d13781edcfd = cache_frame_3f33b64820845ae325979d13781edcfd;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_3f33b64820845ae325979d13781edcfd);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_3f33b64820845ae325979d13781edcfd) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1727;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_3f33b64820845ae325979d13781edcfd->m_frame.f_lineno = 1727;
        tmp_assign_source_1 = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_X509_STORE_CTX_new);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1727;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_store_ctx == NULL);
        var_store_ctx = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1728;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_gc);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1728;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_store_ctx);
        tmp_args_element_name_1 = var_store_ctx;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1728;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_X509_STORE_CTX_free);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1728;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_3f33b64820845ae325979d13781edcfd->m_frame.f_lineno = 1728;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1728;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__store_ctx, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1728;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT(par_store);
        tmp_assattr_name_2 = par_store;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain__store, tmp_assattr_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1729;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_assattr_target_3;
        CHECK_OBJECT(par_certificate);
        tmp_assattr_name_3 = par_certificate;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_3 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_3, const_str_plain__cert, tmp_assattr_name_3);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1730;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_call_result_1;
        CHECK_OBJECT(par_self);
        tmp_called_instance_2 = par_self;
        frame_3f33b64820845ae325979d13781edcfd->m_frame.f_lineno = 1734;
        tmp_call_result_1 = CALL_METHOD_NO_ARGS(tmp_called_instance_2, const_str_plain__init);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1734;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3f33b64820845ae325979d13781edcfd);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3f33b64820845ae325979d13781edcfd);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_3f33b64820845ae325979d13781edcfd, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_3f33b64820845ae325979d13781edcfd->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_3f33b64820845ae325979d13781edcfd, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3f33b64820845ae325979d13781edcfd,
        type_description_1,
        par_self,
        par_store,
        par_certificate,
        var_store_ctx
    );


    // Release cached frame.
    if (frame_3f33b64820845ae325979d13781edcfd == cache_frame_3f33b64820845ae325979d13781edcfd) {
        Py_DECREF(frame_3f33b64820845ae325979d13781edcfd);
    }
    cache_frame_3f33b64820845ae325979d13781edcfd = NULL;

    assertFrameObject(frame_3f33b64820845ae325979d13781edcfd);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_91___init__);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_store_ctx);
    Py_DECREF(var_store_ctx);
    var_store_ctx = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_store_ctx);
    var_store_ctx = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_91___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_certificate);
    Py_DECREF(par_certificate);
    CHECK_OBJECT(par_store);
    Py_DECREF(par_store);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_certificate);
    Py_DECREF(par_certificate);
    CHECK_OBJECT(par_store);
    Py_DECREF(par_store);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_92__init(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_ret = NULL;
    struct Nuitka_FrameObject *frame_00371fda50c01bb4d85c5c5a04406452;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_00371fda50c01bb4d85c5c5a04406452 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_00371fda50c01bb4d85c5c5a04406452, codeobj_00371fda50c01bb4d85c5c5a04406452, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *));
    frame_00371fda50c01bb4d85c5c5a04406452 = cache_frame_00371fda50c01bb4d85c5c5a04406452;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_00371fda50c01bb4d85c5c5a04406452);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_00371fda50c01bb4d85c5c5a04406452) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_source_name_4;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_5;
        PyObject *tmp_source_name_6;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1743;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_X509_STORE_CTX_init);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1743;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__store_ctx);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1744;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_4 = par_self;
        tmp_source_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain__store);
        if (tmp_source_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_element_name_1);

            exception_lineno = 1744;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__store);
        Py_DECREF(tmp_source_name_3);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_element_name_1);

            exception_lineno = 1744;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_6 = par_self;
        tmp_source_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain__cert);
        if (tmp_source_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_element_name_1);
            Py_DECREF(tmp_args_element_name_2);

            exception_lineno = 1744;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain__x509);
        Py_DECREF(tmp_source_name_5);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_element_name_1);
            Py_DECREF(tmp_args_element_name_2);

            exception_lineno = 1744;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_2 == NULL) {
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_element_name_1);
            Py_DECREF(tmp_args_element_name_2);
            Py_DECREF(tmp_args_element_name_3);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1744;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = tmp_mvar_value_2;
        tmp_args_element_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain_NULL);
        if (tmp_args_element_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_element_name_1);
            Py_DECREF(tmp_args_element_name_2);
            Py_DECREF(tmp_args_element_name_3);

            exception_lineno = 1744;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_00371fda50c01bb4d85c5c5a04406452->m_frame.f_lineno = 1743;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4};
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS4(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        Py_DECREF(tmp_args_element_name_2);
        Py_DECREF(tmp_args_element_name_3);
        Py_DECREF(tmp_args_element_name_4);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1743;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert(var_ret == NULL);
        var_ret = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(var_ret);
        tmp_compexpr_left_1 = var_ret;
        tmp_compexpr_right_1 = const_int_0;
        tmp_res = RICH_COMPARE_BOOL_LTE_OBJECT_INT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1746;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_name_2;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_call_result_1;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error);
            }

            if (tmp_mvar_value_3 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 0 ], 49, 0);
                exception_tb = NULL;

                exception_lineno = 1747;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_2 = tmp_mvar_value_3;
            frame_00371fda50c01bb4d85c5c5a04406452->m_frame.f_lineno = 1747;
            tmp_call_result_1 = CALL_FUNCTION_NO_ARGS(tmp_called_name_2);
            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1747;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_1);
        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_00371fda50c01bb4d85c5c5a04406452);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_00371fda50c01bb4d85c5c5a04406452);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_00371fda50c01bb4d85c5c5a04406452, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_00371fda50c01bb4d85c5c5a04406452->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_00371fda50c01bb4d85c5c5a04406452, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_00371fda50c01bb4d85c5c5a04406452,
        type_description_1,
        par_self,
        var_ret
    );


    // Release cached frame.
    if (frame_00371fda50c01bb4d85c5c5a04406452 == cache_frame_00371fda50c01bb4d85c5c5a04406452) {
        Py_DECREF(frame_00371fda50c01bb4d85c5c5a04406452);
    }
    cache_frame_00371fda50c01bb4d85c5c5a04406452 = NULL;

    assertFrameObject(frame_00371fda50c01bb4d85c5c5a04406452);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_92__init);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_ret);
    Py_DECREF(var_ret);
    var_ret = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_ret);
    var_ret = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_92__init);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_93__cleanup(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_66c965dc3bd160a9871b648a43656817;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_66c965dc3bd160a9871b648a43656817 = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_66c965dc3bd160a9871b648a43656817, codeobj_66c965dc3bd160a9871b648a43656817, module_OpenSSL$crypto, sizeof(void *));
    frame_66c965dc3bd160a9871b648a43656817 = cache_frame_66c965dc3bd160a9871b648a43656817;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_66c965dc3bd160a9871b648a43656817);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_66c965dc3bd160a9871b648a43656817) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1755;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_X509_STORE_CTX_cleanup);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1755;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__store_ctx);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1755;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_66c965dc3bd160a9871b648a43656817->m_frame.f_lineno = 1755;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1755;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_66c965dc3bd160a9871b648a43656817);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_66c965dc3bd160a9871b648a43656817);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_66c965dc3bd160a9871b648a43656817, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_66c965dc3bd160a9871b648a43656817->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_66c965dc3bd160a9871b648a43656817, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_66c965dc3bd160a9871b648a43656817,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_66c965dc3bd160a9871b648a43656817 == cache_frame_66c965dc3bd160a9871b648a43656817) {
        Py_DECREF(frame_66c965dc3bd160a9871b648a43656817);
    }
    cache_frame_66c965dc3bd160a9871b648a43656817 = NULL;

    assertFrameObject(frame_66c965dc3bd160a9871b648a43656817);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_93__cleanup);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_94__exception_from_context(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_errors = NULL;
    PyObject *var__cert = NULL;
    PyObject *var_pycert = NULL;
    PyObject *var__x509 = NULL;
    struct Nuitka_FrameObject *frame_3891a493a4dd850f62e56c17ddb5ee47;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_3891a493a4dd850f62e56c17ddb5ee47 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_3891a493a4dd850f62e56c17ddb5ee47, codeobj_3891a493a4dd850f62e56c17ddb5ee47, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_3891a493a4dd850f62e56c17ddb5ee47 = cache_frame_3891a493a4dd850f62e56c17ddb5ee47;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_3891a493a4dd850f62e56c17ddb5ee47);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_3891a493a4dd850f62e56c17ddb5ee47) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_list_element_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_called_name_5;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_called_name_6;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_source_name_8;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1766;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_X509_STORE_CTX_get_error);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1766;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__store_ctx);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1766;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_3891a493a4dd850f62e56c17ddb5ee47->m_frame.f_lineno = 1766;
        tmp_list_element_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_list_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1766;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_1 = PyList_New(3);
        PyList_SET_ITEM(tmp_assign_source_1, 0, tmp_list_element_1);
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {
            Py_DECREF(tmp_assign_source_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1767;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_X509_STORE_CTX_get_error_depth);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_assign_source_1);

            exception_lineno = 1767;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_4 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain__store_ctx);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_assign_source_1);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 1767;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_3891a493a4dd850f62e56c17ddb5ee47->m_frame.f_lineno = 1767;
        tmp_list_element_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_2);
        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_list_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_assign_source_1);

            exception_lineno = 1767;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        PyList_SET_ITEM(tmp_assign_source_1, 1, tmp_list_element_1);
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__native);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__native);
        }

        if (tmp_mvar_value_3 == NULL) {
            Py_DECREF(tmp_assign_source_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1954 ], 36, 0);
            exception_tb = NULL;

            exception_lineno = 1768;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_3;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_4 == NULL) {
            Py_DECREF(tmp_assign_source_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1768;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_4;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_string);
        if (tmp_called_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_assign_source_1);

            exception_lineno = 1768;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_5 == NULL) {
            Py_DECREF(tmp_assign_source_1);
            Py_DECREF(tmp_called_name_4);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1768;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_5;
        tmp_called_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_X509_verify_cert_error_string);
        if (tmp_called_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_assign_source_1);
            Py_DECREF(tmp_called_name_4);

            exception_lineno = 1768;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_6 == NULL) {
            Py_DECREF(tmp_assign_source_1);
            Py_DECREF(tmp_called_name_4);
            Py_DECREF(tmp_called_name_5);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1769;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = tmp_mvar_value_6;
        tmp_called_name_6 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain_X509_STORE_CTX_get_error);
        if (tmp_called_name_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_assign_source_1);
            Py_DECREF(tmp_called_name_4);
            Py_DECREF(tmp_called_name_5);

            exception_lineno = 1769;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_8 = par_self;
        tmp_args_element_name_6 = LOOKUP_ATTRIBUTE(tmp_source_name_8, const_str_plain__store_ctx);
        if (tmp_args_element_name_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_assign_source_1);
            Py_DECREF(tmp_called_name_4);
            Py_DECREF(tmp_called_name_5);
            Py_DECREF(tmp_called_name_6);

            exception_lineno = 1769;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_3891a493a4dd850f62e56c17ddb5ee47->m_frame.f_lineno = 1769;
        tmp_args_element_name_5 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_6, tmp_args_element_name_6);
        Py_DECREF(tmp_called_name_6);
        Py_DECREF(tmp_args_element_name_6);
        if (tmp_args_element_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_assign_source_1);
            Py_DECREF(tmp_called_name_4);
            Py_DECREF(tmp_called_name_5);

            exception_lineno = 1769;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_3891a493a4dd850f62e56c17ddb5ee47->m_frame.f_lineno = 1768;
        tmp_args_element_name_4 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_5, tmp_args_element_name_5);
        Py_DECREF(tmp_called_name_5);
        Py_DECREF(tmp_args_element_name_5);
        if (tmp_args_element_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_assign_source_1);
            Py_DECREF(tmp_called_name_4);

            exception_lineno = 1768;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_3891a493a4dd850f62e56c17ddb5ee47->m_frame.f_lineno = 1768;
        tmp_args_element_name_3 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_4, tmp_args_element_name_4);
        Py_DECREF(tmp_called_name_4);
        Py_DECREF(tmp_args_element_name_4);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_assign_source_1);

            exception_lineno = 1768;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_3891a493a4dd850f62e56c17ddb5ee47->m_frame.f_lineno = 1768;
        tmp_list_element_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_3, tmp_args_element_name_3);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_list_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_assign_source_1);

            exception_lineno = 1768;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        PyList_SET_ITEM(tmp_assign_source_1, 2, tmp_list_element_1);
        assert(var_errors == NULL);
        var_errors = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_7;
        PyObject *tmp_source_name_9;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_source_name_10;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_7 == NULL)) {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_7 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1773;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_9 = tmp_mvar_value_7;
        tmp_called_name_7 = LOOKUP_ATTRIBUTE(tmp_source_name_9, const_str_plain_X509_STORE_CTX_get_current_cert);
        if (tmp_called_name_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1773;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_10 = par_self;
        tmp_args_element_name_7 = LOOKUP_ATTRIBUTE(tmp_source_name_10, const_str_plain__store_ctx);
        if (tmp_args_element_name_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_7);

            exception_lineno = 1773;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_3891a493a4dd850f62e56c17ddb5ee47->m_frame.f_lineno = 1773;
        tmp_assign_source_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_7, tmp_args_element_name_7);
        Py_DECREF(tmp_called_name_7);
        Py_DECREF(tmp_args_element_name_7);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1773;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(var__x509 == NULL);
        var__x509 = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_args_element_name_8;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_8 == NULL)) {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_8 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1774;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_8;
        CHECK_OBJECT(var__x509);
        tmp_args_element_name_8 = var__x509;
        frame_3891a493a4dd850f62e56c17ddb5ee47->m_frame.f_lineno = 1774;
        {
            PyObject *call_args[] = {tmp_args_element_name_8};
            tmp_assign_source_3 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_X509_dup, call_args);
        }

        if (tmp_assign_source_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1774;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(var__cert == NULL);
        var__cert = tmp_assign_source_3;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_9;
        PyObject *tmp_args_element_name_9;
        tmp_mvar_value_9 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509);

        if (unlikely(tmp_mvar_value_9 == NULL)) {
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509);
        }

        if (tmp_mvar_value_9 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 236 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1775;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_9;
        CHECK_OBJECT(var__cert);
        tmp_args_element_name_9 = var__cert;
        frame_3891a493a4dd850f62e56c17ddb5ee47->m_frame.f_lineno = 1775;
        {
            PyObject *call_args[] = {tmp_args_element_name_9};
            tmp_assign_source_4 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain__from_raw_x509_ptr, call_args);
        }

        if (tmp_assign_source_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1775;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(var_pycert == NULL);
        var_pycert = tmp_assign_source_4;
    }
    {
        PyObject *tmp_called_name_8;
        PyObject *tmp_mvar_value_10;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_args_element_name_11;
        tmp_mvar_value_10 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509StoreContextError);

        if (unlikely(tmp_mvar_value_10 == NULL)) {
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509StoreContextError);
        }

        if (tmp_mvar_value_10 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 4003 ], 50, 0);
            exception_tb = NULL;

            exception_lineno = 1776;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_8 = tmp_mvar_value_10;
        CHECK_OBJECT(var_errors);
        tmp_args_element_name_10 = var_errors;
        CHECK_OBJECT(var_pycert);
        tmp_args_element_name_11 = var_pycert;
        frame_3891a493a4dd850f62e56c17ddb5ee47->m_frame.f_lineno = 1776;
        {
            PyObject *call_args[] = {tmp_args_element_name_10, tmp_args_element_name_11};
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_8, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1776;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3891a493a4dd850f62e56c17ddb5ee47);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_3891a493a4dd850f62e56c17ddb5ee47);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3891a493a4dd850f62e56c17ddb5ee47);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_3891a493a4dd850f62e56c17ddb5ee47, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_3891a493a4dd850f62e56c17ddb5ee47->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_3891a493a4dd850f62e56c17ddb5ee47, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3891a493a4dd850f62e56c17ddb5ee47,
        type_description_1,
        par_self,
        var_errors,
        var__cert,
        var_pycert,
        var__x509
    );


    // Release cached frame.
    if (frame_3891a493a4dd850f62e56c17ddb5ee47 == cache_frame_3891a493a4dd850f62e56c17ddb5ee47) {
        Py_DECREF(frame_3891a493a4dd850f62e56c17ddb5ee47);
    }
    cache_frame_3891a493a4dd850f62e56c17ddb5ee47 = NULL;

    assertFrameObject(frame_3891a493a4dd850f62e56c17ddb5ee47);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_94__exception_from_context);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_errors);
    Py_DECREF(var_errors);
    var_errors = NULL;

    CHECK_OBJECT((PyObject *)var__cert);
    Py_DECREF(var__cert);
    var__cert = NULL;

    CHECK_OBJECT((PyObject *)var_pycert);
    Py_DECREF(var_pycert);
    var_pycert = NULL;

    CHECK_OBJECT((PyObject *)var__x509);
    Py_DECREF(var__x509);
    var__x509 = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_errors);
    var_errors = NULL;

    Py_XDECREF(var__cert);
    var__cert = NULL;

    Py_XDECREF(var_pycert);
    var_pycert = NULL;

    Py_XDECREF(var__x509);
    var__x509 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_94__exception_from_context);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_95_set_store(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_store = python_pars[1];
    struct Nuitka_FrameObject *frame_5ed9e5e6e97c4656f6c19f9fb33742ec;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_5ed9e5e6e97c4656f6c19f9fb33742ec = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_5ed9e5e6e97c4656f6c19f9fb33742ec, codeobj_5ed9e5e6e97c4656f6c19f9fb33742ec, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *));
    frame_5ed9e5e6e97c4656f6c19f9fb33742ec = cache_frame_5ed9e5e6e97c4656f6c19f9fb33742ec;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_5ed9e5e6e97c4656f6c19f9fb33742ec);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_5ed9e5e6e97c4656f6c19f9fb33742ec) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_store);
        tmp_assattr_name_1 = par_store;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__store, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1787;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5ed9e5e6e97c4656f6c19f9fb33742ec);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5ed9e5e6e97c4656f6c19f9fb33742ec);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_5ed9e5e6e97c4656f6c19f9fb33742ec, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_5ed9e5e6e97c4656f6c19f9fb33742ec->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_5ed9e5e6e97c4656f6c19f9fb33742ec, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5ed9e5e6e97c4656f6c19f9fb33742ec,
        type_description_1,
        par_self,
        par_store
    );


    // Release cached frame.
    if (frame_5ed9e5e6e97c4656f6c19f9fb33742ec == cache_frame_5ed9e5e6e97c4656f6c19f9fb33742ec) {
        Py_DECREF(frame_5ed9e5e6e97c4656f6c19f9fb33742ec);
    }
    cache_frame_5ed9e5e6e97c4656f6c19f9fb33742ec = NULL;

    assertFrameObject(frame_5ed9e5e6e97c4656f6c19f9fb33742ec);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_95_set_store);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_store);
    Py_DECREF(par_store);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_store);
    Py_DECREF(par_store);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_96_verify_certificate(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_ret = NULL;
    struct Nuitka_FrameObject *frame_cf70a0fe535b0c265515473726b4c514;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_cf70a0fe535b0c265515473726b4c514 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_cf70a0fe535b0c265515473726b4c514, codeobj_cf70a0fe535b0c265515473726b4c514, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *));
    frame_cf70a0fe535b0c265515473726b4c514 = cache_frame_cf70a0fe535b0c265515473726b4c514;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_cf70a0fe535b0c265515473726b4c514);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_cf70a0fe535b0c265515473726b4c514) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        frame_cf70a0fe535b0c265515473726b4c514->m_frame.f_lineno = 1804;
        tmp_call_result_1 = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain__cleanup);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1804;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_call_result_2;
        CHECK_OBJECT(par_self);
        tmp_called_instance_2 = par_self;
        frame_cf70a0fe535b0c265515473726b4c514->m_frame.f_lineno = 1805;
        tmp_call_result_2 = CALL_METHOD_NO_ARGS(tmp_called_instance_2, const_str_plain__init);
        if (tmp_call_result_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1805;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_2);
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1806;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_X509_verify_cert);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1806;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__store_ctx);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1806;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_cf70a0fe535b0c265515473726b4c514->m_frame.f_lineno = 1806;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1806;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert(var_ret == NULL);
        var_ret = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_instance_3;
        PyObject *tmp_call_result_3;
        CHECK_OBJECT(par_self);
        tmp_called_instance_3 = par_self;
        frame_cf70a0fe535b0c265515473726b4c514->m_frame.f_lineno = 1807;
        tmp_call_result_3 = CALL_METHOD_NO_ARGS(tmp_called_instance_3, const_str_plain__cleanup);
        if (tmp_call_result_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1807;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_3);
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(var_ret);
        tmp_compexpr_left_1 = var_ret;
        tmp_compexpr_right_1 = const_int_0;
        tmp_res = RICH_COMPARE_BOOL_LTE_OBJECT_INT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1808;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_called_instance_4;
            CHECK_OBJECT(par_self);
            tmp_called_instance_4 = par_self;
            frame_cf70a0fe535b0c265515473726b4c514->m_frame.f_lineno = 1809;
            tmp_raise_type_1 = CALL_METHOD_NO_ARGS(tmp_called_instance_4, const_str_plain__exception_from_context);
            if (tmp_raise_type_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1809;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            exception_type = tmp_raise_type_1;
            exception_lineno = 1809;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_cf70a0fe535b0c265515473726b4c514);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_cf70a0fe535b0c265515473726b4c514);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_cf70a0fe535b0c265515473726b4c514, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_cf70a0fe535b0c265515473726b4c514->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_cf70a0fe535b0c265515473726b4c514, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_cf70a0fe535b0c265515473726b4c514,
        type_description_1,
        par_self,
        var_ret
    );


    // Release cached frame.
    if (frame_cf70a0fe535b0c265515473726b4c514 == cache_frame_cf70a0fe535b0c265515473726b4c514) {
        Py_DECREF(frame_cf70a0fe535b0c265515473726b4c514);
    }
    cache_frame_cf70a0fe535b0c265515473726b4c514 = NULL;

    assertFrameObject(frame_cf70a0fe535b0c265515473726b4c514);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_96_verify_certificate);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_ret);
    Py_DECREF(var_ret);
    var_ret = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_ret);
    var_ret = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_96_verify_certificate);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_97_load_certificate(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_type = python_pars[0];
    PyObject *par_buffer = python_pars[1];
    PyObject *var_bio = NULL;
    PyObject *var_x509 = NULL;
    struct Nuitka_FrameObject *frame_3ba03b4a83863db0211776596d7369dc;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_3ba03b4a83863db0211776596d7369dc = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_3ba03b4a83863db0211776596d7369dc, codeobj_3ba03b4a83863db0211776596d7369dc, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_3ba03b4a83863db0211776596d7369dc = cache_frame_3ba03b4a83863db0211776596d7369dc;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_3ba03b4a83863db0211776596d7369dc);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_3ba03b4a83863db0211776596d7369dc) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_buffer);
        tmp_isinstance_inst_1 = par_buffer;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__text_type);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__text_type);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3552 ], 39, 0);
            exception_tb = NULL;

            exception_lineno = 1823;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1823;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_called_instance_1;
            CHECK_OBJECT(par_buffer);
            tmp_called_instance_1 = par_buffer;
            frame_3ba03b4a83863db0211776596d7369dc->m_frame.f_lineno = 1824;
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_encode, &PyTuple_GET_ITEM(const_tuple_str_plain_ascii_tuple, 0));

            if (tmp_assign_source_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1824;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_buffer;
                assert(old != NULL);
                par_buffer = tmp_assign_source_1;
                Py_DECREF(old);
            }

        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3591 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 1826;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_2;
        CHECK_OBJECT(par_buffer);
        tmp_args_element_name_1 = par_buffer;
        frame_3ba03b4a83863db0211776596d7369dc->m_frame.f_lineno = 1826;
        tmp_assign_source_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1826;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_bio == NULL);
        var_bio = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_3;
        CHECK_OBJECT(par_type);
        tmp_compexpr_left_1 = par_type;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 632 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 1828;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_3;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1828;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_1;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_source_name_2;
            PyObject *tmp_mvar_value_5;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_source_name_3;
            PyObject *tmp_mvar_value_6;
            PyObject *tmp_args_element_name_5;
            PyObject *tmp_source_name_4;
            PyObject *tmp_mvar_value_7;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_4 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1829;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_1 = tmp_mvar_value_4;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_PEM_read_bio_X509);
            if (tmp_called_name_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1829;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_bio);
            tmp_args_element_name_2 = var_bio;
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_5 == NULL)) {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_5 == NULL) {
                Py_DECREF(tmp_called_name_2);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1829;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_2 = tmp_mvar_value_5;
            tmp_args_element_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_NULL);
            if (tmp_args_element_name_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_2);

                exception_lineno = 1829;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_6 == NULL)) {
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_6 == NULL) {
                Py_DECREF(tmp_called_name_2);
                Py_DECREF(tmp_args_element_name_3);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1829;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_3 = tmp_mvar_value_6;
            tmp_args_element_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_NULL);
            if (tmp_args_element_name_4 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_2);
                Py_DECREF(tmp_args_element_name_3);

                exception_lineno = 1829;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_7 == NULL)) {
                tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_7 == NULL) {
                Py_DECREF(tmp_called_name_2);
                Py_DECREF(tmp_args_element_name_3);
                Py_DECREF(tmp_args_element_name_4);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1829;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_4 = tmp_mvar_value_7;
            tmp_args_element_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_NULL);
            if (tmp_args_element_name_5 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_2);
                Py_DECREF(tmp_args_element_name_3);
                Py_DECREF(tmp_args_element_name_4);

                exception_lineno = 1829;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            frame_3ba03b4a83863db0211776596d7369dc->m_frame.f_lineno = 1829;
            {
                PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5};
                tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS4(tmp_called_name_2, call_args);
            }

            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_3);
            Py_DECREF(tmp_args_element_name_4);
            Py_DECREF(tmp_args_element_name_5);
            if (tmp_assign_source_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1829;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            assert(var_x509 == NULL);
            var_x509 = tmp_assign_source_3;
        }
        goto branch_end_2;
        branch_no_2:;
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_mvar_value_8;
            CHECK_OBJECT(par_type);
            tmp_compexpr_left_2 = par_type;
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1);

            if (unlikely(tmp_mvar_value_8 == NULL)) {
                tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1);
            }

            if (tmp_mvar_value_8 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 4053 ], 42, 0);
                exception_tb = NULL;

                exception_lineno = 1830;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_2 = tmp_mvar_value_8;
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1830;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_3 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
                goto branch_yes_3;
            } else {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_assign_source_4;
                PyObject *tmp_called_name_3;
                PyObject *tmp_source_name_5;
                PyObject *tmp_mvar_value_9;
                PyObject *tmp_args_element_name_6;
                PyObject *tmp_args_element_name_7;
                PyObject *tmp_source_name_6;
                PyObject *tmp_mvar_value_10;
                tmp_mvar_value_9 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

                if (unlikely(tmp_mvar_value_9 == NULL)) {
                    tmp_mvar_value_9 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
                }

                if (tmp_mvar_value_9 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 1831;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_5 = tmp_mvar_value_9;
                tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_d2i_X509_bio);
                if (tmp_called_name_3 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 1831;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT(var_bio);
                tmp_args_element_name_6 = var_bio;
                tmp_mvar_value_10 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

                if (unlikely(tmp_mvar_value_10 == NULL)) {
                    tmp_mvar_value_10 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
                }

                if (tmp_mvar_value_10 == NULL) {
                    Py_DECREF(tmp_called_name_3);
                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 1831;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_6 = tmp_mvar_value_10;
                tmp_args_element_name_7 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_NULL);
                if (tmp_args_element_name_7 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    Py_DECREF(tmp_called_name_3);

                    exception_lineno = 1831;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                frame_3ba03b4a83863db0211776596d7369dc->m_frame.f_lineno = 1831;
                {
                    PyObject *call_args[] = {tmp_args_element_name_6, tmp_args_element_name_7};
                    tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_3, call_args);
                }

                Py_DECREF(tmp_called_name_3);
                Py_DECREF(tmp_args_element_name_7);
                if (tmp_assign_source_4 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 1831;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                assert(var_x509 == NULL);
                var_x509 = tmp_assign_source_4;
            }
            goto branch_end_3;
            branch_no_3:;
            {
                PyObject *tmp_raise_type_1;
                PyObject *tmp_make_exception_arg_1;
                tmp_make_exception_arg_1 = const_str_digest_f019d8c1ebbf58631ace92b4423b3aad;
                frame_3ba03b4a83863db0211776596d7369dc->m_frame.f_lineno = 1833;
                tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_1);
                assert(!(tmp_raise_type_1 == NULL));
                exception_type = tmp_raise_type_1;
                exception_lineno = 1833;
                RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            branch_end_3:;
        }
        branch_end_2:;
    }
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_11;
        if (var_x509 == NULL) {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("local variable '%s' referenced before assignment", "x509");
            exception_tb = NULL;

            exception_lineno = 1836;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_left_3 = var_x509;
        tmp_mvar_value_11 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_11 == NULL)) {
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_11 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1836;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = tmp_mvar_value_11;
        tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain_NULL);
        if (tmp_compexpr_right_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1836;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_3, tmp_compexpr_right_3);
        Py_DECREF(tmp_compexpr_right_3);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1836;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_4 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_4 == NUITKA_BOOL_TRUE) {
            goto branch_yes_4;
        } else {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_called_name_4;
            PyObject *tmp_mvar_value_12;
            PyObject *tmp_call_result_1;
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error);

            if (unlikely(tmp_mvar_value_12 == NULL)) {
                tmp_mvar_value_12 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error);
            }

            if (tmp_mvar_value_12 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 0 ], 49, 0);
                exception_tb = NULL;

                exception_lineno = 1837;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_4 = tmp_mvar_value_12;
            frame_3ba03b4a83863db0211776596d7369dc->m_frame.f_lineno = 1837;
            tmp_call_result_1 = CALL_FUNCTION_NO_ARGS(tmp_called_name_4);
            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1837;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_1);
        }
        branch_no_4:;
    }
    {
        PyObject *tmp_called_name_5;
        PyObject *tmp_source_name_8;
        PyObject *tmp_mvar_value_13;
        PyObject *tmp_args_element_name_8;
        tmp_mvar_value_13 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509);

        if (unlikely(tmp_mvar_value_13 == NULL)) {
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509);
        }

        if (tmp_mvar_value_13 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 236 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1839;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_8 = tmp_mvar_value_13;
        tmp_called_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_8, const_str_plain__from_raw_x509_ptr);
        if (tmp_called_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1839;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        if (var_x509 == NULL) {
            Py_DECREF(tmp_called_name_5);
            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("local variable '%s' referenced before assignment", "x509");
            exception_tb = NULL;

            exception_lineno = 1839;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_8 = var_x509;
        frame_3ba03b4a83863db0211776596d7369dc->m_frame.f_lineno = 1839;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_5, tmp_args_element_name_8);
        Py_DECREF(tmp_called_name_5);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1839;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3ba03b4a83863db0211776596d7369dc);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_3ba03b4a83863db0211776596d7369dc);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3ba03b4a83863db0211776596d7369dc);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_3ba03b4a83863db0211776596d7369dc, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_3ba03b4a83863db0211776596d7369dc->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_3ba03b4a83863db0211776596d7369dc, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3ba03b4a83863db0211776596d7369dc,
        type_description_1,
        par_type,
        par_buffer,
        var_bio,
        var_x509
    );


    // Release cached frame.
    if (frame_3ba03b4a83863db0211776596d7369dc == cache_frame_3ba03b4a83863db0211776596d7369dc) {
        Py_DECREF(frame_3ba03b4a83863db0211776596d7369dc);
    }
    cache_frame_3ba03b4a83863db0211776596d7369dc = NULL;

    assertFrameObject(frame_3ba03b4a83863db0211776596d7369dc);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_97_load_certificate);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)par_buffer);
    Py_DECREF(par_buffer);
    par_buffer = NULL;

    CHECK_OBJECT((PyObject *)var_bio);
    Py_DECREF(var_bio);
    var_bio = NULL;

    Py_XDECREF(var_x509);
    var_x509 = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(par_buffer);
    par_buffer = NULL;

    Py_XDECREF(var_bio);
    var_bio = NULL;

    Py_XDECREF(var_x509);
    var_x509 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_97_load_certificate);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_98_dump_certificate(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_type = python_pars[0];
    PyObject *par_cert = python_pars[1];
    PyObject *var_bio = NULL;
    PyObject *var_result_code = NULL;
    struct Nuitka_FrameObject *frame_549d02a6f8fe9c9053e01fafd28ef642;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_549d02a6f8fe9c9053e01fafd28ef642 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_549d02a6f8fe9c9053e01fafd28ef642, codeobj_549d02a6f8fe9c9053e01fafd28ef642, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_549d02a6f8fe9c9053e01fafd28ef642 = cache_frame_549d02a6f8fe9c9053e01fafd28ef642;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_549d02a6f8fe9c9053e01fafd28ef642);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_549d02a6f8fe9c9053e01fafd28ef642) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3591 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 1852;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        frame_549d02a6f8fe9c9053e01fafd28ef642->m_frame.f_lineno = 1852;
        tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS(tmp_called_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1852;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_bio == NULL);
        var_bio = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT(par_type);
        tmp_compexpr_left_1 = par_type;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 632 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 1854;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_2;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1854;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_1;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_source_name_2;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_3 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1855;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_1 = tmp_mvar_value_3;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_PEM_write_bio_X509);
            if (tmp_called_name_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1855;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_bio);
            tmp_args_element_name_1 = var_bio;
            CHECK_OBJECT(par_cert);
            tmp_source_name_2 = par_cert;
            tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__x509);
            if (tmp_args_element_name_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_2);

                exception_lineno = 1855;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            frame_549d02a6f8fe9c9053e01fafd28ef642->m_frame.f_lineno = 1855;
            {
                PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
                tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
            }

            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_2);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1855;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            assert(var_result_code == NULL);
            var_result_code = tmp_assign_source_2;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_mvar_value_4;
            CHECK_OBJECT(par_type);
            tmp_compexpr_left_2 = par_type;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1);
            }

            if (tmp_mvar_value_4 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 4053 ], 42, 0);
                exception_tb = NULL;

                exception_lineno = 1856;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_2 = tmp_mvar_value_4;
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1856;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
                goto branch_yes_2;
            } else {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_assign_source_3;
                PyObject *tmp_called_name_3;
                PyObject *tmp_source_name_3;
                PyObject *tmp_mvar_value_5;
                PyObject *tmp_args_element_name_3;
                PyObject *tmp_args_element_name_4;
                PyObject *tmp_source_name_4;
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

                if (unlikely(tmp_mvar_value_5 == NULL)) {
                    tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
                }

                if (tmp_mvar_value_5 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 1857;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_3 = tmp_mvar_value_5;
                tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_i2d_X509_bio);
                if (tmp_called_name_3 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 1857;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT(var_bio);
                tmp_args_element_name_3 = var_bio;
                CHECK_OBJECT(par_cert);
                tmp_source_name_4 = par_cert;
                tmp_args_element_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain__x509);
                if (tmp_args_element_name_4 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    Py_DECREF(tmp_called_name_3);

                    exception_lineno = 1857;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                frame_549d02a6f8fe9c9053e01fafd28ef642->m_frame.f_lineno = 1857;
                {
                    PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4};
                    tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_3, call_args);
                }

                Py_DECREF(tmp_called_name_3);
                Py_DECREF(tmp_args_element_name_4);
                if (tmp_assign_source_3 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 1857;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                assert(var_result_code == NULL);
                var_result_code = tmp_assign_source_3;
            }
            goto branch_end_2;
            branch_no_2:;
            {
                nuitka_bool tmp_condition_result_3;
                PyObject *tmp_compexpr_left_3;
                PyObject *tmp_compexpr_right_3;
                PyObject *tmp_mvar_value_6;
                CHECK_OBJECT(par_type);
                tmp_compexpr_left_3 = par_type;
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_TEXT);

                if (unlikely(tmp_mvar_value_6 == NULL)) {
                    tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_TEXT);
                }

                if (tmp_mvar_value_6 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 4095 ], 42, 0);
                    exception_tb = NULL;

                    exception_lineno = 1858;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }

                tmp_compexpr_right_3 = tmp_mvar_value_6;
                tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_3, tmp_compexpr_right_3);
                if (tmp_res == -1) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 1858;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                tmp_condition_result_3 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
                    goto branch_yes_3;
                } else {
                    goto branch_no_3;
                }
                branch_yes_3:;
                {
                    PyObject *tmp_assign_source_4;
                    PyObject *tmp_called_name_4;
                    PyObject *tmp_source_name_5;
                    PyObject *tmp_mvar_value_7;
                    PyObject *tmp_args_element_name_5;
                    PyObject *tmp_args_element_name_6;
                    PyObject *tmp_source_name_6;
                    PyObject *tmp_args_element_name_7;
                    PyObject *tmp_args_element_name_8;
                    tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

                    if (unlikely(tmp_mvar_value_7 == NULL)) {
                        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
                    }

                    if (tmp_mvar_value_7 == NULL) {

                        exception_type = PyExc_NameError;
                        Py_INCREF(exception_type);
                        exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                        exception_tb = NULL;

                        exception_lineno = 1859;
                        type_description_1 = "oooo";
                        goto frame_exception_exit_1;
                    }

                    tmp_source_name_5 = tmp_mvar_value_7;
                    tmp_called_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_X509_print_ex);
                    if (tmp_called_name_4 == NULL) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                        exception_lineno = 1859;
                        type_description_1 = "oooo";
                        goto frame_exception_exit_1;
                    }
                    CHECK_OBJECT(var_bio);
                    tmp_args_element_name_5 = var_bio;
                    CHECK_OBJECT(par_cert);
                    tmp_source_name_6 = par_cert;
                    tmp_args_element_name_6 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain__x509);
                    if (tmp_args_element_name_6 == NULL) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                        Py_DECREF(tmp_called_name_4);

                        exception_lineno = 1859;
                        type_description_1 = "oooo";
                        goto frame_exception_exit_1;
                    }
                    tmp_args_element_name_7 = const_int_0;
                    tmp_args_element_name_8 = const_int_0;
                    frame_549d02a6f8fe9c9053e01fafd28ef642->m_frame.f_lineno = 1859;
                    {
                        PyObject *call_args[] = {tmp_args_element_name_5, tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8};
                        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS4(tmp_called_name_4, call_args);
                    }

                    Py_DECREF(tmp_called_name_4);
                    Py_DECREF(tmp_args_element_name_6);
                    if (tmp_assign_source_4 == NULL) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                        exception_lineno = 1859;
                        type_description_1 = "oooo";
                        goto frame_exception_exit_1;
                    }
                    assert(var_result_code == NULL);
                    var_result_code = tmp_assign_source_4;
                }
                goto branch_end_3;
                branch_no_3:;
                {
                    PyObject *tmp_raise_type_1;
                    PyObject *tmp_make_exception_arg_1;
                    tmp_make_exception_arg_1 = const_str_digest_11c225ccbab9acffc38107dee9691702;
                    frame_549d02a6f8fe9c9053e01fafd28ef642->m_frame.f_lineno = 1861;
                    tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_1);
                    assert(!(tmp_raise_type_1 == NULL));
                    exception_type = tmp_raise_type_1;
                    exception_lineno = 1861;
                    RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                branch_end_3:;
            }
            branch_end_2:;
        }
        branch_end_1:;
    }
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        if (var_result_code == NULL) {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("local variable '%s' referenced before assignment", "result_code");
            exception_tb = NULL;

            exception_lineno = 1865;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_left_4 = var_result_code;
        tmp_compexpr_right_4 = const_int_pos_1;
        tmp_operand_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_4, tmp_compexpr_right_4);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1865;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1865;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_4 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_4 == NUITKA_BOOL_TRUE) {
            goto branch_yes_4;
        } else {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_raise_type_2;
            tmp_raise_type_2 = PyExc_AssertionError;
            exception_type = tmp_raise_type_2;
            Py_INCREF(tmp_raise_type_2);
            exception_lineno = 1865;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        branch_no_4:;
    }
    {
        PyObject *tmp_called_name_5;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_args_element_name_9;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__bio_to_string);

        if (unlikely(tmp_mvar_value_8 == NULL)) {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__bio_to_string);
        }

        if (tmp_mvar_value_8 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3632 ], 43, 0);
            exception_tb = NULL;

            exception_lineno = 1866;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_5 = tmp_mvar_value_8;
        CHECK_OBJECT(var_bio);
        tmp_args_element_name_9 = var_bio;
        frame_549d02a6f8fe9c9053e01fafd28ef642->m_frame.f_lineno = 1866;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_5, tmp_args_element_name_9);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1866;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_549d02a6f8fe9c9053e01fafd28ef642);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_549d02a6f8fe9c9053e01fafd28ef642);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_549d02a6f8fe9c9053e01fafd28ef642);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_549d02a6f8fe9c9053e01fafd28ef642, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_549d02a6f8fe9c9053e01fafd28ef642->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_549d02a6f8fe9c9053e01fafd28ef642, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_549d02a6f8fe9c9053e01fafd28ef642,
        type_description_1,
        par_type,
        par_cert,
        var_bio,
        var_result_code
    );


    // Release cached frame.
    if (frame_549d02a6f8fe9c9053e01fafd28ef642 == cache_frame_549d02a6f8fe9c9053e01fafd28ef642) {
        Py_DECREF(frame_549d02a6f8fe9c9053e01fafd28ef642);
    }
    cache_frame_549d02a6f8fe9c9053e01fafd28ef642 = NULL;

    assertFrameObject(frame_549d02a6f8fe9c9053e01fafd28ef642);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_98_dump_certificate);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_bio);
    Py_DECREF(var_bio);
    var_bio = NULL;

    Py_XDECREF(var_result_code);
    var_result_code = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_bio);
    var_bio = NULL;

    Py_XDECREF(var_result_code);
    var_result_code = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_98_dump_certificate);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_cert);
    Py_DECREF(par_cert);
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_cert);
    Py_DECREF(par_cert);
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_99_dump_publickey(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_type = python_pars[0];
    PyObject *par_pkey = python_pars[1];
    PyObject *var_write_bio = NULL;
    PyObject *var_result_code = NULL;
    PyObject *var_bio = NULL;
    struct Nuitka_FrameObject *frame_ac78feb39cb3a4f1fcd5ca3fb25b3cc6;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_ac78feb39cb3a4f1fcd5ca3fb25b3cc6 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_ac78feb39cb3a4f1fcd5ca3fb25b3cc6, codeobj_ac78feb39cb3a4f1fcd5ca3fb25b3cc6, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_ac78feb39cb3a4f1fcd5ca3fb25b3cc6 = cache_frame_ac78feb39cb3a4f1fcd5ca3fb25b3cc6;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_ac78feb39cb3a4f1fcd5ca3fb25b3cc6);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_ac78feb39cb3a4f1fcd5ca3fb25b3cc6) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3591 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 1879;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        frame_ac78feb39cb3a4f1fcd5ca3fb25b3cc6->m_frame.f_lineno = 1879;
        tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS(tmp_called_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1879;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(var_bio == NULL);
        var_bio = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT(par_type);
        tmp_compexpr_left_1 = par_type;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 632 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 1880;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_2;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1880;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_source_name_1;
            PyObject *tmp_mvar_value_3;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_3 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1881;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_1 = tmp_mvar_value_3;
            tmp_assign_source_2 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_PEM_write_bio_PUBKEY);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1881;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            assert(var_write_bio == NULL);
            var_write_bio = tmp_assign_source_2;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_mvar_value_4;
            CHECK_OBJECT(par_type);
            tmp_compexpr_left_2 = par_type;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1);
            }

            if (tmp_mvar_value_4 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 4053 ], 42, 0);
                exception_tb = NULL;

                exception_lineno = 1882;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_2 = tmp_mvar_value_4;
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1882;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
                goto branch_yes_2;
            } else {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_assign_source_3;
                PyObject *tmp_source_name_2;
                PyObject *tmp_mvar_value_5;
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

                if (unlikely(tmp_mvar_value_5 == NULL)) {
                    tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
                }

                if (tmp_mvar_value_5 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 1883;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_2 = tmp_mvar_value_5;
                tmp_assign_source_3 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_i2d_PUBKEY_bio);
                if (tmp_assign_source_3 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 1883;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                assert(var_write_bio == NULL);
                var_write_bio = tmp_assign_source_3;
            }
            goto branch_end_2;
            branch_no_2:;
            {
                PyObject *tmp_raise_type_1;
                PyObject *tmp_make_exception_arg_1;
                tmp_make_exception_arg_1 = const_str_digest_f019d8c1ebbf58631ace92b4423b3aad;
                frame_ac78feb39cb3a4f1fcd5ca3fb25b3cc6->m_frame.f_lineno = 1885;
                tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_1);
                assert(!(tmp_raise_type_1 == NULL));
                exception_type = tmp_raise_type_1;
                exception_lineno = 1885;
                RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            branch_end_2:;
        }
        branch_end_1:;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_name_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        if (var_write_bio == NULL) {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("local variable '%s' referenced before assignment", "write_bio");
            exception_tb = NULL;

            exception_lineno = 1887;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = var_write_bio;
        CHECK_OBJECT(var_bio);
        tmp_args_element_name_1 = var_bio;
        CHECK_OBJECT(par_pkey);
        tmp_source_name_3 = par_pkey;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__pkey);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1887;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_ac78feb39cb3a4f1fcd5ca3fb25b3cc6->m_frame.f_lineno = 1887;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assign_source_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1887;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(var_result_code == NULL);
        var_result_code = tmp_assign_source_4;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        CHECK_OBJECT(var_result_code);
        tmp_compexpr_left_3 = var_result_code;
        tmp_compexpr_right_3 = const_int_pos_1;
        tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_INT(tmp_compexpr_left_3, tmp_compexpr_right_3);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1888;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
            goto branch_yes_3;
        } else {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_called_name_3;
            PyObject *tmp_mvar_value_6;
            PyObject *tmp_call_result_1;
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error);

            if (unlikely(tmp_mvar_value_6 == NULL)) {
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error);
            }

            if (tmp_mvar_value_6 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 0 ], 49, 0);
                exception_tb = NULL;

                exception_lineno = 1889;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_3 = tmp_mvar_value_6;
            frame_ac78feb39cb3a4f1fcd5ca3fb25b3cc6->m_frame.f_lineno = 1889;
            tmp_call_result_1 = CALL_FUNCTION_NO_ARGS(tmp_called_name_3);
            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1889;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_1);
        }
        branch_no_3:;
    }
    {
        PyObject *tmp_called_name_4;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__bio_to_string);

        if (unlikely(tmp_mvar_value_7 == NULL)) {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__bio_to_string);
        }

        if (tmp_mvar_value_7 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3632 ], 43, 0);
            exception_tb = NULL;

            exception_lineno = 1891;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_4 = tmp_mvar_value_7;
        CHECK_OBJECT(var_bio);
        tmp_args_element_name_3 = var_bio;
        frame_ac78feb39cb3a4f1fcd5ca3fb25b3cc6->m_frame.f_lineno = 1891;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_4, tmp_args_element_name_3);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1891;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ac78feb39cb3a4f1fcd5ca3fb25b3cc6);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_ac78feb39cb3a4f1fcd5ca3fb25b3cc6);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ac78feb39cb3a4f1fcd5ca3fb25b3cc6);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_ac78feb39cb3a4f1fcd5ca3fb25b3cc6, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_ac78feb39cb3a4f1fcd5ca3fb25b3cc6->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_ac78feb39cb3a4f1fcd5ca3fb25b3cc6, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ac78feb39cb3a4f1fcd5ca3fb25b3cc6,
        type_description_1,
        par_type,
        par_pkey,
        var_write_bio,
        var_result_code,
        var_bio
    );


    // Release cached frame.
    if (frame_ac78feb39cb3a4f1fcd5ca3fb25b3cc6 == cache_frame_ac78feb39cb3a4f1fcd5ca3fb25b3cc6) {
        Py_DECREF(frame_ac78feb39cb3a4f1fcd5ca3fb25b3cc6);
    }
    cache_frame_ac78feb39cb3a4f1fcd5ca3fb25b3cc6 = NULL;

    assertFrameObject(frame_ac78feb39cb3a4f1fcd5ca3fb25b3cc6);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_99_dump_publickey);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_write_bio);
    var_write_bio = NULL;

    CHECK_OBJECT((PyObject *)var_result_code);
    Py_DECREF(var_result_code);
    var_result_code = NULL;

    CHECK_OBJECT((PyObject *)var_bio);
    Py_DECREF(var_bio);
    var_bio = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_write_bio);
    var_write_bio = NULL;

    Py_XDECREF(var_result_code);
    var_result_code = NULL;

    Py_XDECREF(var_bio);
    var_bio = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_99_dump_publickey);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_pkey);
    Py_DECREF(par_pkey);
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_pkey);
    Py_DECREF(par_pkey);
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_100_dump_privatekey(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_type = python_pars[0];
    PyObject *par_pkey = python_pars[1];
    PyObject *par_cipher = python_pars[2];
    PyObject *par_passphrase = python_pars[3];
    PyObject *var_helper = NULL;
    PyObject *var_bio = NULL;
    PyObject *var_cipher_obj = NULL;
    PyObject *var_rsa = NULL;
    PyObject *var_result_code = NULL;
    struct Nuitka_FrameObject *frame_87202647bd1de477b2de0eb2aa352e4f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_87202647bd1de477b2de0eb2aa352e4f = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_87202647bd1de477b2de0eb2aa352e4f, codeobj_87202647bd1de477b2de0eb2aa352e4f, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_87202647bd1de477b2de0eb2aa352e4f = cache_frame_87202647bd1de477b2de0eb2aa352e4f;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_87202647bd1de477b2de0eb2aa352e4f);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_87202647bd1de477b2de0eb2aa352e4f) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3591 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 1910;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        frame_87202647bd1de477b2de0eb2aa352e4f->m_frame.f_lineno = 1910;
        tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS(tmp_called_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1910;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_bio == NULL);
        var_bio = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT(par_pkey);
        tmp_isinstance_inst_1 = par_pkey;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 978 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1912;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_2;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1912;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1912;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_bb334a0dc943b8e820be149d2c515af0;
            frame_87202647bd1de477b2de0eb2aa352e4f->m_frame.f_lineno = 1913;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1913;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_cipher);
        tmp_compexpr_left_1 = par_cipher;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_2 = (tmp_compexpr_left_1 != tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            CHECK_OBJECT(par_passphrase);
            tmp_compexpr_left_2 = par_passphrase;
            tmp_compexpr_right_2 = Py_None;
            tmp_condition_result_3 = (tmp_compexpr_left_2 == tmp_compexpr_right_2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
                goto branch_yes_3;
            } else {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_raise_type_2;
                PyObject *tmp_make_exception_arg_2;
                tmp_make_exception_arg_2 = const_str_digest_014a797afcc3e1ad4f3e6e9aa4631a8a;
                frame_87202647bd1de477b2de0eb2aa352e4f->m_frame.f_lineno = 1917;
                tmp_raise_type_2 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_2);
                assert(!(tmp_raise_type_2 == NULL));
                exception_type = tmp_raise_type_2;
                exception_lineno = 1917;
                RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            branch_no_3:;
        }
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_1;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_called_name_3;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_args_element_name_2;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_3 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1920;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_1 = tmp_mvar_value_3;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_EVP_get_cipherbyname);
            if (tmp_called_name_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1920;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__byte_string);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__byte_string);
            }

            if (tmp_mvar_value_4 == NULL) {
                Py_DECREF(tmp_called_name_2);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 3511 ], 41, 0);
                exception_tb = NULL;

                exception_lineno = 1920;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_3 = tmp_mvar_value_4;
            CHECK_OBJECT(par_cipher);
            tmp_args_element_name_2 = par_cipher;
            frame_87202647bd1de477b2de0eb2aa352e4f->m_frame.f_lineno = 1920;
            tmp_args_element_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_3, tmp_args_element_name_2);
            if (tmp_args_element_name_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_2);

                exception_lineno = 1920;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            frame_87202647bd1de477b2de0eb2aa352e4f->m_frame.f_lineno = 1920;
            tmp_assign_source_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_1);
            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_1);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1920;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            assert(var_cipher_obj == NULL);
            var_cipher_obj = tmp_assign_source_2;
        }
        {
            nuitka_bool tmp_condition_result_4;
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            PyObject *tmp_source_name_2;
            PyObject *tmp_mvar_value_5;
            CHECK_OBJECT(var_cipher_obj);
            tmp_compexpr_left_3 = var_cipher_obj;
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_5 == NULL)) {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_5 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1921;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_2 = tmp_mvar_value_5;
            tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_NULL);
            if (tmp_compexpr_right_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1921;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_3, tmp_compexpr_right_3);
            Py_DECREF(tmp_compexpr_right_3);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1921;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_4 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_4 == NUITKA_BOOL_TRUE) {
                goto branch_yes_4;
            } else {
                goto branch_no_4;
            }
            branch_yes_4:;
            {
                PyObject *tmp_raise_type_3;
                PyObject *tmp_make_exception_arg_3;
                tmp_make_exception_arg_3 = const_str_digest_fb60d21f52ae521da77e61851d566364;
                frame_87202647bd1de477b2de0eb2aa352e4f->m_frame.f_lineno = 1922;
                tmp_raise_type_3 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_3);
                assert(!(tmp_raise_type_3 == NULL));
                exception_type = tmp_raise_type_3;
                exception_lineno = 1922;
                RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            branch_no_4:;
        }
        goto branch_end_2;
        branch_no_2:;
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_source_name_3;
            PyObject *tmp_mvar_value_6;
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_6 == NULL)) {
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_6 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1924;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_3 = tmp_mvar_value_6;
            tmp_assign_source_3 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_NULL);
            if (tmp_assign_source_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1924;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            assert(var_cipher_obj == NULL);
            var_cipher_obj = tmp_assign_source_3;
        }
        branch_end_2:;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_name_4;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__PassphraseHelper);

        if (unlikely(tmp_mvar_value_7 == NULL)) {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__PassphraseHelper);
        }

        if (tmp_mvar_value_7 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 586 ], 46, 0);
            exception_tb = NULL;

            exception_lineno = 1926;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_4 = tmp_mvar_value_7;
        CHECK_OBJECT(par_type);
        tmp_args_element_name_3 = par_type;
        CHECK_OBJECT(par_passphrase);
        tmp_args_element_name_4 = par_passphrase;
        frame_87202647bd1de477b2de0eb2aa352e4f->m_frame.f_lineno = 1926;
        {
            PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4};
            tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_4, call_args);
        }

        if (tmp_assign_source_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1926;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_helper == NULL);
        var_helper = tmp_assign_source_4;
    }
    {
        nuitka_bool tmp_condition_result_5;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        PyObject *tmp_mvar_value_8;
        CHECK_OBJECT(par_type);
        tmp_compexpr_left_4 = par_type;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM);

        if (unlikely(tmp_mvar_value_8 == NULL)) {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM);
        }

        if (tmp_mvar_value_8 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 632 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 1927;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_4 = tmp_mvar_value_8;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_4, tmp_compexpr_right_4);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1927;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_5 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_5 == NUITKA_BOOL_TRUE) {
            goto branch_yes_5;
        } else {
            goto branch_no_5;
        }
        branch_yes_5:;
        {
            PyObject *tmp_assign_source_5;
            PyObject *tmp_called_name_5;
            PyObject *tmp_source_name_4;
            PyObject *tmp_mvar_value_9;
            PyObject *tmp_args_element_name_5;
            PyObject *tmp_args_element_name_6;
            PyObject *tmp_source_name_5;
            PyObject *tmp_args_element_name_7;
            PyObject *tmp_args_element_name_8;
            PyObject *tmp_source_name_6;
            PyObject *tmp_mvar_value_10;
            PyObject *tmp_args_element_name_9;
            PyObject *tmp_args_element_name_10;
            PyObject *tmp_source_name_7;
            PyObject *tmp_args_element_name_11;
            PyObject *tmp_source_name_8;
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_9 == NULL)) {
                tmp_mvar_value_9 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_9 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1928;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_4 = tmp_mvar_value_9;
            tmp_called_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_PEM_write_bio_PrivateKey);
            if (tmp_called_name_5 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1928;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_bio);
            tmp_args_element_name_5 = var_bio;
            CHECK_OBJECT(par_pkey);
            tmp_source_name_5 = par_pkey;
            tmp_args_element_name_6 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain__pkey);
            if (tmp_args_element_name_6 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_5);

                exception_lineno = 1929;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_cipher_obj);
            tmp_args_element_name_7 = var_cipher_obj;
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_10 == NULL)) {
                tmp_mvar_value_10 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_10 == NULL) {
                Py_DECREF(tmp_called_name_5);
                Py_DECREF(tmp_args_element_name_6);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1929;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_6 = tmp_mvar_value_10;
            tmp_args_element_name_8 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_NULL);
            if (tmp_args_element_name_8 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_5);
                Py_DECREF(tmp_args_element_name_6);

                exception_lineno = 1929;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_args_element_name_9 = const_int_0;
            CHECK_OBJECT(var_helper);
            tmp_source_name_7 = var_helper;
            tmp_args_element_name_10 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain_callback);
            if (tmp_args_element_name_10 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_5);
                Py_DECREF(tmp_args_element_name_6);
                Py_DECREF(tmp_args_element_name_8);

                exception_lineno = 1930;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_helper);
            tmp_source_name_8 = var_helper;
            tmp_args_element_name_11 = LOOKUP_ATTRIBUTE(tmp_source_name_8, const_str_plain_callback_args);
            if (tmp_args_element_name_11 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_5);
                Py_DECREF(tmp_args_element_name_6);
                Py_DECREF(tmp_args_element_name_8);
                Py_DECREF(tmp_args_element_name_10);

                exception_lineno = 1930;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            frame_87202647bd1de477b2de0eb2aa352e4f->m_frame.f_lineno = 1928;
            {
                PyObject *call_args[] = {tmp_args_element_name_5, tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8, tmp_args_element_name_9, tmp_args_element_name_10, tmp_args_element_name_11};
                tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS7(tmp_called_name_5, call_args);
            }

            Py_DECREF(tmp_called_name_5);
            Py_DECREF(tmp_args_element_name_6);
            Py_DECREF(tmp_args_element_name_8);
            Py_DECREF(tmp_args_element_name_10);
            Py_DECREF(tmp_args_element_name_11);
            if (tmp_assign_source_5 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1928;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            assert(var_result_code == NULL);
            var_result_code = tmp_assign_source_5;
        }
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_call_result_1;
            CHECK_OBJECT(var_helper);
            tmp_called_instance_1 = var_helper;
            frame_87202647bd1de477b2de0eb2aa352e4f->m_frame.f_lineno = 1931;
            tmp_call_result_1 = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_raise_if_problem);
            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1931;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_1);
        }
        goto branch_end_5;
        branch_no_5:;
        {
            nuitka_bool tmp_condition_result_6;
            PyObject *tmp_compexpr_left_5;
            PyObject *tmp_compexpr_right_5;
            PyObject *tmp_mvar_value_11;
            CHECK_OBJECT(par_type);
            tmp_compexpr_left_5 = par_type;
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1);

            if (unlikely(tmp_mvar_value_11 == NULL)) {
                tmp_mvar_value_11 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1);
            }

            if (tmp_mvar_value_11 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 4053 ], 42, 0);
                exception_tb = NULL;

                exception_lineno = 1932;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_5 = tmp_mvar_value_11;
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_5, tmp_compexpr_right_5);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1932;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_6 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_6 == NUITKA_BOOL_TRUE) {
                goto branch_yes_6;
            } else {
                goto branch_no_6;
            }
            branch_yes_6:;
            {
                PyObject *tmp_assign_source_6;
                PyObject *tmp_called_name_6;
                PyObject *tmp_source_name_9;
                PyObject *tmp_mvar_value_12;
                PyObject *tmp_args_element_name_12;
                PyObject *tmp_args_element_name_13;
                PyObject *tmp_source_name_10;
                tmp_mvar_value_12 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

                if (unlikely(tmp_mvar_value_12 == NULL)) {
                    tmp_mvar_value_12 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
                }

                if (tmp_mvar_value_12 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 1933;
                    type_description_1 = "ooooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_9 = tmp_mvar_value_12;
                tmp_called_name_6 = LOOKUP_ATTRIBUTE(tmp_source_name_9, const_str_plain_i2d_PrivateKey_bio);
                if (tmp_called_name_6 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 1933;
                    type_description_1 = "ooooooooo";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT(var_bio);
                tmp_args_element_name_12 = var_bio;
                CHECK_OBJECT(par_pkey);
                tmp_source_name_10 = par_pkey;
                tmp_args_element_name_13 = LOOKUP_ATTRIBUTE(tmp_source_name_10, const_str_plain__pkey);
                if (tmp_args_element_name_13 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    Py_DECREF(tmp_called_name_6);

                    exception_lineno = 1933;
                    type_description_1 = "ooooooooo";
                    goto frame_exception_exit_1;
                }
                frame_87202647bd1de477b2de0eb2aa352e4f->m_frame.f_lineno = 1933;
                {
                    PyObject *call_args[] = {tmp_args_element_name_12, tmp_args_element_name_13};
                    tmp_assign_source_6 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_6, call_args);
                }

                Py_DECREF(tmp_called_name_6);
                Py_DECREF(tmp_args_element_name_13);
                if (tmp_assign_source_6 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 1933;
                    type_description_1 = "ooooooooo";
                    goto frame_exception_exit_1;
                }
                assert(var_result_code == NULL);
                var_result_code = tmp_assign_source_6;
            }
            goto branch_end_6;
            branch_no_6:;
            {
                nuitka_bool tmp_condition_result_7;
                PyObject *tmp_compexpr_left_6;
                PyObject *tmp_compexpr_right_6;
                PyObject *tmp_mvar_value_13;
                CHECK_OBJECT(par_type);
                tmp_compexpr_left_6 = par_type;
                tmp_mvar_value_13 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_TEXT);

                if (unlikely(tmp_mvar_value_13 == NULL)) {
                    tmp_mvar_value_13 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_TEXT);
                }

                if (tmp_mvar_value_13 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 4095 ], 42, 0);
                    exception_tb = NULL;

                    exception_lineno = 1934;
                    type_description_1 = "ooooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_compexpr_right_6 = tmp_mvar_value_13;
                tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_6, tmp_compexpr_right_6);
                if (tmp_res == -1) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 1934;
                    type_description_1 = "ooooooooo";
                    goto frame_exception_exit_1;
                }
                tmp_condition_result_7 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                if (tmp_condition_result_7 == NUITKA_BOOL_TRUE) {
                    goto branch_yes_7;
                } else {
                    goto branch_no_7;
                }
                branch_yes_7:;
                {
                    nuitka_bool tmp_condition_result_8;
                    PyObject *tmp_compexpr_left_7;
                    PyObject *tmp_compexpr_right_7;
                    PyObject *tmp_called_name_7;
                    PyObject *tmp_source_name_11;
                    PyObject *tmp_mvar_value_14;
                    PyObject *tmp_args_element_name_14;
                    PyObject *tmp_source_name_12;
                    PyObject *tmp_source_name_13;
                    PyObject *tmp_mvar_value_15;
                    tmp_mvar_value_14 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

                    if (unlikely(tmp_mvar_value_14 == NULL)) {
                        tmp_mvar_value_14 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
                    }

                    if (tmp_mvar_value_14 == NULL) {

                        exception_type = PyExc_NameError;
                        Py_INCREF(exception_type);
                        exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                        exception_tb = NULL;

                        exception_lineno = 1935;
                        type_description_1 = "ooooooooo";
                        goto frame_exception_exit_1;
                    }

                    tmp_source_name_11 = tmp_mvar_value_14;
                    tmp_called_name_7 = LOOKUP_ATTRIBUTE(tmp_source_name_11, const_str_plain_EVP_PKEY_id);
                    if (tmp_called_name_7 == NULL) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                        exception_lineno = 1935;
                        type_description_1 = "ooooooooo";
                        goto frame_exception_exit_1;
                    }
                    CHECK_OBJECT(par_pkey);
                    tmp_source_name_12 = par_pkey;
                    tmp_args_element_name_14 = LOOKUP_ATTRIBUTE(tmp_source_name_12, const_str_plain__pkey);
                    if (tmp_args_element_name_14 == NULL) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                        Py_DECREF(tmp_called_name_7);

                        exception_lineno = 1935;
                        type_description_1 = "ooooooooo";
                        goto frame_exception_exit_1;
                    }
                    frame_87202647bd1de477b2de0eb2aa352e4f->m_frame.f_lineno = 1935;
                    tmp_compexpr_left_7 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_7, tmp_args_element_name_14);
                    Py_DECREF(tmp_called_name_7);
                    Py_DECREF(tmp_args_element_name_14);
                    if (tmp_compexpr_left_7 == NULL) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                        exception_lineno = 1935;
                        type_description_1 = "ooooooooo";
                        goto frame_exception_exit_1;
                    }
                    tmp_mvar_value_15 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

                    if (unlikely(tmp_mvar_value_15 == NULL)) {
                        tmp_mvar_value_15 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
                    }

                    if (tmp_mvar_value_15 == NULL) {
                        Py_DECREF(tmp_compexpr_left_7);
                        exception_type = PyExc_NameError;
                        Py_INCREF(exception_type);
                        exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                        exception_tb = NULL;

                        exception_lineno = 1935;
                        type_description_1 = "ooooooooo";
                        goto frame_exception_exit_1;
                    }

                    tmp_source_name_13 = tmp_mvar_value_15;
                    tmp_compexpr_right_7 = LOOKUP_ATTRIBUTE(tmp_source_name_13, const_str_plain_EVP_PKEY_RSA);
                    if (tmp_compexpr_right_7 == NULL) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                        Py_DECREF(tmp_compexpr_left_7);

                        exception_lineno = 1935;
                        type_description_1 = "ooooooooo";
                        goto frame_exception_exit_1;
                    }
                    tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_7, tmp_compexpr_right_7);
                    Py_DECREF(tmp_compexpr_left_7);
                    Py_DECREF(tmp_compexpr_right_7);
                    if (tmp_res == -1) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                        exception_lineno = 1935;
                        type_description_1 = "ooooooooo";
                        goto frame_exception_exit_1;
                    }
                    tmp_condition_result_8 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                    if (tmp_condition_result_8 == NUITKA_BOOL_TRUE) {
                        goto branch_yes_8;
                    } else {
                        goto branch_no_8;
                    }
                    branch_yes_8:;
                    {
                        PyObject *tmp_raise_type_4;
                        PyObject *tmp_make_exception_arg_4;
                        tmp_make_exception_arg_4 = const_str_digest_3a45faa244ca861d389c340b29a28988;
                        frame_87202647bd1de477b2de0eb2aa352e4f->m_frame.f_lineno = 1936;
                        tmp_raise_type_4 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_4);
                        assert(!(tmp_raise_type_4 == NULL));
                        exception_type = tmp_raise_type_4;
                        exception_lineno = 1936;
                        RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                        type_description_1 = "ooooooooo";
                        goto frame_exception_exit_1;
                    }
                    branch_no_8:;
                }
                {
                    PyObject *tmp_assign_source_7;
                    PyObject *tmp_called_name_8;
                    PyObject *tmp_source_name_14;
                    PyObject *tmp_mvar_value_16;
                    PyObject *tmp_args_element_name_15;
                    PyObject *tmp_called_name_9;
                    PyObject *tmp_source_name_15;
                    PyObject *tmp_mvar_value_17;
                    PyObject *tmp_args_element_name_16;
                    PyObject *tmp_source_name_16;
                    PyObject *tmp_args_element_name_17;
                    PyObject *tmp_source_name_17;
                    PyObject *tmp_mvar_value_18;
                    tmp_mvar_value_16 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

                    if (unlikely(tmp_mvar_value_16 == NULL)) {
                        tmp_mvar_value_16 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
                    }

                    if (tmp_mvar_value_16 == NULL) {

                        exception_type = PyExc_NameError;
                        Py_INCREF(exception_type);
                        exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                        exception_tb = NULL;

                        exception_lineno = 1938;
                        type_description_1 = "ooooooooo";
                        goto frame_exception_exit_1;
                    }

                    tmp_source_name_14 = tmp_mvar_value_16;
                    tmp_called_name_8 = LOOKUP_ATTRIBUTE(tmp_source_name_14, const_str_plain_gc);
                    if (tmp_called_name_8 == NULL) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                        exception_lineno = 1938;
                        type_description_1 = "ooooooooo";
                        goto frame_exception_exit_1;
                    }
                    tmp_mvar_value_17 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

                    if (unlikely(tmp_mvar_value_17 == NULL)) {
                        tmp_mvar_value_17 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
                    }

                    if (tmp_mvar_value_17 == NULL) {
                        Py_DECREF(tmp_called_name_8);
                        exception_type = PyExc_NameError;
                        Py_INCREF(exception_type);
                        exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                        exception_tb = NULL;

                        exception_lineno = 1939;
                        type_description_1 = "ooooooooo";
                        goto frame_exception_exit_1;
                    }

                    tmp_source_name_15 = tmp_mvar_value_17;
                    tmp_called_name_9 = LOOKUP_ATTRIBUTE(tmp_source_name_15, const_str_plain_EVP_PKEY_get1_RSA);
                    if (tmp_called_name_9 == NULL) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                        Py_DECREF(tmp_called_name_8);

                        exception_lineno = 1939;
                        type_description_1 = "ooooooooo";
                        goto frame_exception_exit_1;
                    }
                    CHECK_OBJECT(par_pkey);
                    tmp_source_name_16 = par_pkey;
                    tmp_args_element_name_16 = LOOKUP_ATTRIBUTE(tmp_source_name_16, const_str_plain__pkey);
                    if (tmp_args_element_name_16 == NULL) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                        Py_DECREF(tmp_called_name_8);
                        Py_DECREF(tmp_called_name_9);

                        exception_lineno = 1939;
                        type_description_1 = "ooooooooo";
                        goto frame_exception_exit_1;
                    }
                    frame_87202647bd1de477b2de0eb2aa352e4f->m_frame.f_lineno = 1939;
                    tmp_args_element_name_15 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_9, tmp_args_element_name_16);
                    Py_DECREF(tmp_called_name_9);
                    Py_DECREF(tmp_args_element_name_16);
                    if (tmp_args_element_name_15 == NULL) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                        Py_DECREF(tmp_called_name_8);

                        exception_lineno = 1939;
                        type_description_1 = "ooooooooo";
                        goto frame_exception_exit_1;
                    }
                    tmp_mvar_value_18 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

                    if (unlikely(tmp_mvar_value_18 == NULL)) {
                        tmp_mvar_value_18 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
                    }

                    if (tmp_mvar_value_18 == NULL) {
                        Py_DECREF(tmp_called_name_8);
                        Py_DECREF(tmp_args_element_name_15);
                        exception_type = PyExc_NameError;
                        Py_INCREF(exception_type);
                        exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                        exception_tb = NULL;

                        exception_lineno = 1940;
                        type_description_1 = "ooooooooo";
                        goto frame_exception_exit_1;
                    }

                    tmp_source_name_17 = tmp_mvar_value_18;
                    tmp_args_element_name_17 = LOOKUP_ATTRIBUTE(tmp_source_name_17, const_str_plain_RSA_free);
                    if (tmp_args_element_name_17 == NULL) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                        Py_DECREF(tmp_called_name_8);
                        Py_DECREF(tmp_args_element_name_15);

                        exception_lineno = 1940;
                        type_description_1 = "ooooooooo";
                        goto frame_exception_exit_1;
                    }
                    frame_87202647bd1de477b2de0eb2aa352e4f->m_frame.f_lineno = 1938;
                    {
                        PyObject *call_args[] = {tmp_args_element_name_15, tmp_args_element_name_17};
                        tmp_assign_source_7 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_8, call_args);
                    }

                    Py_DECREF(tmp_called_name_8);
                    Py_DECREF(tmp_args_element_name_15);
                    Py_DECREF(tmp_args_element_name_17);
                    if (tmp_assign_source_7 == NULL) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                        exception_lineno = 1938;
                        type_description_1 = "ooooooooo";
                        goto frame_exception_exit_1;
                    }
                    assert(var_rsa == NULL);
                    var_rsa = tmp_assign_source_7;
                }
                {
                    PyObject *tmp_assign_source_8;
                    PyObject *tmp_called_instance_2;
                    PyObject *tmp_mvar_value_19;
                    PyObject *tmp_args_element_name_18;
                    PyObject *tmp_args_element_name_19;
                    PyObject *tmp_args_element_name_20;
                    tmp_mvar_value_19 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

                    if (unlikely(tmp_mvar_value_19 == NULL)) {
                        tmp_mvar_value_19 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
                    }

                    if (tmp_mvar_value_19 == NULL) {

                        exception_type = PyExc_NameError;
                        Py_INCREF(exception_type);
                        exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                        exception_tb = NULL;

                        exception_lineno = 1942;
                        type_description_1 = "ooooooooo";
                        goto frame_exception_exit_1;
                    }

                    tmp_called_instance_2 = tmp_mvar_value_19;
                    CHECK_OBJECT(var_bio);
                    tmp_args_element_name_18 = var_bio;
                    CHECK_OBJECT(var_rsa);
                    tmp_args_element_name_19 = var_rsa;
                    tmp_args_element_name_20 = const_int_0;
                    frame_87202647bd1de477b2de0eb2aa352e4f->m_frame.f_lineno = 1942;
                    {
                        PyObject *call_args[] = {tmp_args_element_name_18, tmp_args_element_name_19, tmp_args_element_name_20};
                        tmp_assign_source_8 = CALL_METHOD_WITH_ARGS3(tmp_called_instance_2, const_str_plain_RSA_print, call_args);
                    }

                    if (tmp_assign_source_8 == NULL) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                        exception_lineno = 1942;
                        type_description_1 = "ooooooooo";
                        goto frame_exception_exit_1;
                    }
                    assert(var_result_code == NULL);
                    var_result_code = tmp_assign_source_8;
                }
                goto branch_end_7;
                branch_no_7:;
                {
                    PyObject *tmp_raise_type_5;
                    PyObject *tmp_make_exception_arg_5;
                    tmp_make_exception_arg_5 = const_str_digest_11c225ccbab9acffc38107dee9691702;
                    frame_87202647bd1de477b2de0eb2aa352e4f->m_frame.f_lineno = 1944;
                    tmp_raise_type_5 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_5);
                    assert(!(tmp_raise_type_5 == NULL));
                    exception_type = tmp_raise_type_5;
                    exception_lineno = 1944;
                    RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                    type_description_1 = "ooooooooo";
                    goto frame_exception_exit_1;
                }
                branch_end_7:;
            }
            branch_end_6:;
        }
        branch_end_5:;
    }
    {
        PyObject *tmp_called_name_10;
        PyObject *tmp_mvar_value_20;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_21;
        PyObject *tmp_compexpr_left_8;
        PyObject *tmp_compexpr_right_8;
        tmp_mvar_value_20 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_20 == NULL)) {
            tmp_mvar_value_20 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_20 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 1948;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_10 = tmp_mvar_value_20;
        if (var_result_code == NULL) {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("local variable '%s' referenced before assignment", "result_code");
            exception_tb = NULL;

            exception_lineno = 1948;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_left_8 = var_result_code;
        tmp_compexpr_right_8 = const_int_0;
        tmp_args_element_name_21 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_8, tmp_compexpr_right_8);
        if (tmp_args_element_name_21 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1948;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        frame_87202647bd1de477b2de0eb2aa352e4f->m_frame.f_lineno = 1948;
        tmp_call_result_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_10, tmp_args_element_name_21);
        Py_DECREF(tmp_args_element_name_21);
        if (tmp_call_result_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1948;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_2);
    }
    {
        PyObject *tmp_called_name_11;
        PyObject *tmp_mvar_value_21;
        PyObject *tmp_args_element_name_22;
        tmp_mvar_value_21 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__bio_to_string);

        if (unlikely(tmp_mvar_value_21 == NULL)) {
            tmp_mvar_value_21 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__bio_to_string);
        }

        if (tmp_mvar_value_21 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3632 ], 43, 0);
            exception_tb = NULL;

            exception_lineno = 1950;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_11 = tmp_mvar_value_21;
        CHECK_OBJECT(var_bio);
        tmp_args_element_name_22 = var_bio;
        frame_87202647bd1de477b2de0eb2aa352e4f->m_frame.f_lineno = 1950;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_11, tmp_args_element_name_22);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1950;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_87202647bd1de477b2de0eb2aa352e4f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_87202647bd1de477b2de0eb2aa352e4f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_87202647bd1de477b2de0eb2aa352e4f);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_87202647bd1de477b2de0eb2aa352e4f, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_87202647bd1de477b2de0eb2aa352e4f->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_87202647bd1de477b2de0eb2aa352e4f, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_87202647bd1de477b2de0eb2aa352e4f,
        type_description_1,
        par_type,
        par_pkey,
        par_cipher,
        par_passphrase,
        var_helper,
        var_bio,
        var_cipher_obj,
        var_rsa,
        var_result_code
    );


    // Release cached frame.
    if (frame_87202647bd1de477b2de0eb2aa352e4f == cache_frame_87202647bd1de477b2de0eb2aa352e4f) {
        Py_DECREF(frame_87202647bd1de477b2de0eb2aa352e4f);
    }
    cache_frame_87202647bd1de477b2de0eb2aa352e4f = NULL;

    assertFrameObject(frame_87202647bd1de477b2de0eb2aa352e4f);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_100_dump_privatekey);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_helper);
    Py_DECREF(var_helper);
    var_helper = NULL;

    CHECK_OBJECT((PyObject *)var_bio);
    Py_DECREF(var_bio);
    var_bio = NULL;

    CHECK_OBJECT((PyObject *)var_cipher_obj);
    Py_DECREF(var_cipher_obj);
    var_cipher_obj = NULL;

    Py_XDECREF(var_rsa);
    var_rsa = NULL;

    Py_XDECREF(var_result_code);
    var_result_code = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_helper);
    var_helper = NULL;

    Py_XDECREF(var_bio);
    var_bio = NULL;

    Py_XDECREF(var_cipher_obj);
    var_cipher_obj = NULL;

    Py_XDECREF(var_rsa);
    var_rsa = NULL;

    Py_XDECREF(var_result_code);
    var_result_code = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_100_dump_privatekey);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_pkey);
    Py_DECREF(par_pkey);
    CHECK_OBJECT(par_cipher);
    Py_DECREF(par_cipher);
    CHECK_OBJECT(par_passphrase);
    Py_DECREF(par_passphrase);
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_pkey);
    Py_DECREF(par_pkey);
    CHECK_OBJECT(par_cipher);
    Py_DECREF(par_cipher);
    CHECK_OBJECT(par_passphrase);
    Py_DECREF(par_passphrase);
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_101___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_revoked = NULL;
    struct Nuitka_FrameObject *frame_b23a0f51f84827c54de24c1656bcf51f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_b23a0f51f84827c54de24c1656bcf51f = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_b23a0f51f84827c54de24c1656bcf51f, codeobj_b23a0f51f84827c54de24c1656bcf51f, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *));
    frame_b23a0f51f84827c54de24c1656bcf51f = cache_frame_b23a0f51f84827c54de24c1656bcf51f;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_b23a0f51f84827c54de24c1656bcf51f);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_b23a0f51f84827c54de24c1656bcf51f) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1973;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_b23a0f51f84827c54de24c1656bcf51f->m_frame.f_lineno = 1973;
        tmp_assign_source_1 = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_X509_REVOKED_new);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1973;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert(var_revoked == NULL);
        var_revoked = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1974;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_gc);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1974;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_revoked);
        tmp_args_element_name_1 = var_revoked;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1974;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_X509_REVOKED_free);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1974;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_b23a0f51f84827c54de24c1656bcf51f->m_frame.f_lineno = 1974;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1974;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__revoked, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1974;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b23a0f51f84827c54de24c1656bcf51f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b23a0f51f84827c54de24c1656bcf51f);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_b23a0f51f84827c54de24c1656bcf51f, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_b23a0f51f84827c54de24c1656bcf51f->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_b23a0f51f84827c54de24c1656bcf51f, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b23a0f51f84827c54de24c1656bcf51f,
        type_description_1,
        par_self,
        var_revoked
    );


    // Release cached frame.
    if (frame_b23a0f51f84827c54de24c1656bcf51f == cache_frame_b23a0f51f84827c54de24c1656bcf51f) {
        Py_DECREF(frame_b23a0f51f84827c54de24c1656bcf51f);
    }
    cache_frame_b23a0f51f84827c54de24c1656bcf51f = NULL;

    assertFrameObject(frame_b23a0f51f84827c54de24c1656bcf51f);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_101___init__);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_revoked);
    Py_DECREF(var_revoked);
    var_revoked = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_revoked);
    var_revoked = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_101___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_102_set_serial(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_hex_str = python_pars[1];
    PyObject *var_bignum_serial = NULL;
    PyObject *var_asn1_serial = NULL;
    PyObject *var_bn_result = NULL;
    PyObject *var_bignum_ptr = NULL;
    struct Nuitka_FrameObject *frame_5654d7a7e7e1d262193996dc0e844779;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_5654d7a7e7e1d262193996dc0e844779 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_5654d7a7e7e1d262193996dc0e844779, codeobj_5654d7a7e7e1d262193996dc0e844779, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_5654d7a7e7e1d262193996dc0e844779 = cache_frame_5654d7a7e7e1d262193996dc0e844779;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_5654d7a7e7e1d262193996dc0e844779);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_5654d7a7e7e1d262193996dc0e844779) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1987;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_gc);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1987;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1987;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_2;
        frame_5654d7a7e7e1d262193996dc0e844779->m_frame.f_lineno = 1987;
        tmp_args_element_name_1 = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_BN_new);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1987;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_element_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1987;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_BN_free);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_element_name_1);

            exception_lineno = 1987;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_5654d7a7e7e1d262193996dc0e844779->m_frame.f_lineno = 1987;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1987;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert(var_bignum_serial == NULL);
        var_bignum_serial = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_4;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1988;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_4;
        frame_5654d7a7e7e1d262193996dc0e844779->m_frame.f_lineno = 1988;
        tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_new, &PyTuple_GET_ITEM(const_tuple_str_digest_80438074180d95b1a2291874613077b5_tuple, 0));

        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1988;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert(var_bignum_ptr == NULL);
        var_bignum_ptr = tmp_assign_source_2;
    }
    {
        PyObject *tmp_ass_subvalue_1;
        PyObject *tmp_ass_subscribed_1;
        PyObject *tmp_ass_subscript_1;
        int tmp_ass_subscript_res_1;
        CHECK_OBJECT(var_bignum_serial);
        tmp_ass_subvalue_1 = var_bignum_serial;
        CHECK_OBJECT(var_bignum_ptr);
        tmp_ass_subscribed_1 = var_bignum_ptr;
        tmp_ass_subscript_1 = const_int_0;
        tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST(tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1);
        if (tmp_ass_subscript_res_1 == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1989;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1990;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_3 = tmp_mvar_value_5;
        CHECK_OBJECT(var_bignum_ptr);
        tmp_args_element_name_3 = var_bignum_ptr;
        CHECK_OBJECT(par_hex_str);
        tmp_args_element_name_4 = par_hex_str;
        frame_5654d7a7e7e1d262193996dc0e844779->m_frame.f_lineno = 1990;
        {
            PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4};
            tmp_assign_source_3 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_3, const_str_plain_BN_hex2bn, call_args);
        }

        if (tmp_assign_source_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1990;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert(var_bn_result == NULL);
        var_bn_result = tmp_assign_source_3;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        CHECK_OBJECT(var_bn_result);
        tmp_operand_name_1 = var_bn_result;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1991;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_340717166d8c6af86f5d8a6e35ed5a7f;
            frame_5654d7a7e7e1d262193996dc0e844779->m_frame.f_lineno = 1992;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1992;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_9;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_6 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1994;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_6;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_gc);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1994;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_7 == NULL)) {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_7 == NULL) {
            Py_DECREF(tmp_called_name_2);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1995;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_7;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_BN_to_ASN1_INTEGER);
        if (tmp_called_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 1995;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_bignum_serial);
        tmp_args_element_name_6 = var_bignum_serial;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_8 == NULL)) {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_8 == NULL) {
            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_called_name_3);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1995;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_8;
        tmp_args_element_name_7 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_NULL);
        if (tmp_args_element_name_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_called_name_3);

            exception_lineno = 1995;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_5654d7a7e7e1d262193996dc0e844779->m_frame.f_lineno = 1995;
        {
            PyObject *call_args[] = {tmp_args_element_name_6, tmp_args_element_name_7};
            tmp_args_element_name_5 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_3, call_args);
        }

        Py_DECREF(tmp_called_name_3);
        Py_DECREF(tmp_args_element_name_7);
        if (tmp_args_element_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 1995;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_9 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_9 == NULL)) {
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_9 == NULL) {
            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_5);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1996;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_9;
        tmp_args_element_name_8 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_ASN1_INTEGER_free);
        if (tmp_args_element_name_8 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_5);

            exception_lineno = 1996;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_5654d7a7e7e1d262193996dc0e844779->m_frame.f_lineno = 1994;
        {
            PyObject *call_args[] = {tmp_args_element_name_5, tmp_args_element_name_8};
            tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_5);
        Py_DECREF(tmp_args_element_name_8);
        if (tmp_assign_source_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1994;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert(var_asn1_serial == NULL);
        var_asn1_serial = tmp_assign_source_4;
    }
    {
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_10;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_source_name_8;
        PyObject *tmp_args_element_name_10;
        tmp_mvar_value_10 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_10 == NULL)) {
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_10 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1997;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = tmp_mvar_value_10;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain_X509_REVOKED_set_serialNumber);
        if (tmp_called_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1997;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_8 = par_self;
        tmp_args_element_name_9 = LOOKUP_ATTRIBUTE(tmp_source_name_8, const_str_plain__revoked);
        if (tmp_args_element_name_9 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_4);

            exception_lineno = 1997;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_asn1_serial);
        tmp_args_element_name_10 = var_asn1_serial;
        frame_5654d7a7e7e1d262193996dc0e844779->m_frame.f_lineno = 1997;
        {
            PyObject *call_args[] = {tmp_args_element_name_9, tmp_args_element_name_10};
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_4, call_args);
        }

        Py_DECREF(tmp_called_name_4);
        Py_DECREF(tmp_args_element_name_9);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1997;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5654d7a7e7e1d262193996dc0e844779);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5654d7a7e7e1d262193996dc0e844779);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_5654d7a7e7e1d262193996dc0e844779, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_5654d7a7e7e1d262193996dc0e844779->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_5654d7a7e7e1d262193996dc0e844779, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5654d7a7e7e1d262193996dc0e844779,
        type_description_1,
        par_self,
        par_hex_str,
        var_bignum_serial,
        var_asn1_serial,
        var_bn_result,
        var_bignum_ptr
    );


    // Release cached frame.
    if (frame_5654d7a7e7e1d262193996dc0e844779 == cache_frame_5654d7a7e7e1d262193996dc0e844779) {
        Py_DECREF(frame_5654d7a7e7e1d262193996dc0e844779);
    }
    cache_frame_5654d7a7e7e1d262193996dc0e844779 = NULL;

    assertFrameObject(frame_5654d7a7e7e1d262193996dc0e844779);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_102_set_serial);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_bignum_serial);
    Py_DECREF(var_bignum_serial);
    var_bignum_serial = NULL;

    CHECK_OBJECT((PyObject *)var_asn1_serial);
    Py_DECREF(var_asn1_serial);
    var_asn1_serial = NULL;

    CHECK_OBJECT((PyObject *)var_bn_result);
    Py_DECREF(var_bn_result);
    var_bn_result = NULL;

    CHECK_OBJECT((PyObject *)var_bignum_ptr);
    Py_DECREF(var_bignum_ptr);
    var_bignum_ptr = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_bignum_serial);
    var_bignum_serial = NULL;

    Py_XDECREF(var_asn1_serial);
    var_asn1_serial = NULL;

    Py_XDECREF(var_bn_result);
    var_bn_result = NULL;

    Py_XDECREF(var_bignum_ptr);
    var_bignum_ptr = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_102_set_serial);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_hex_str);
    Py_DECREF(par_hex_str);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_hex_str);
    Py_DECREF(par_hex_str);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_103_get_serial(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_bio = NULL;
    PyObject *var_result = NULL;
    PyObject *var_asn1_int = NULL;
    struct Nuitka_FrameObject *frame_368e52860340c0239edd479ec201e937;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_368e52860340c0239edd479ec201e937 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_368e52860340c0239edd479ec201e937, codeobj_368e52860340c0239edd479ec201e937, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_368e52860340c0239edd479ec201e937 = cache_frame_368e52860340c0239edd479ec201e937;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_368e52860340c0239edd479ec201e937);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_368e52860340c0239edd479ec201e937) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3591 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 2009;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        frame_368e52860340c0239edd479ec201e937->m_frame.f_lineno = 2009;
        tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS(tmp_called_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2009;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_bio == NULL);
        var_bio = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2011;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_X509_REVOKED_get0_serialNumber);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2011;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__revoked);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 2011;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_368e52860340c0239edd479ec201e937->m_frame.f_lineno = 2011;
        tmp_assign_source_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2011;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_asn1_int == NULL);
        var_asn1_int = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 2012;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_3;
        CHECK_OBJECT(var_asn1_int);
        tmp_compexpr_left_1 = var_asn1_int;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2012;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_4;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_NULL);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2012;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_2 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2012;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_368e52860340c0239edd479ec201e937->m_frame.f_lineno = 2012;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_3, tmp_args_element_name_2);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2012;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2013;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_5;
        CHECK_OBJECT(var_bio);
        tmp_args_element_name_3 = var_bio;
        CHECK_OBJECT(var_asn1_int);
        tmp_args_element_name_4 = var_asn1_int;
        frame_368e52860340c0239edd479ec201e937->m_frame.f_lineno = 2013;
        {
            PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4};
            tmp_assign_source_3 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain_i2a_ASN1_INTEGER, call_args);
        }

        if (tmp_assign_source_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2013;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_result == NULL);
        var_result = tmp_assign_source_3;
    }
    {
        PyObject *tmp_called_name_4;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_6 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 2014;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_4 = tmp_mvar_value_6;
        CHECK_OBJECT(var_result);
        tmp_compexpr_left_2 = var_result;
        tmp_compexpr_right_2 = const_int_0;
        tmp_args_element_name_5 = RICH_COMPARE_GTE_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
        if (tmp_args_element_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2014;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_368e52860340c0239edd479ec201e937->m_frame.f_lineno = 2014;
        tmp_call_result_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_4, tmp_args_element_name_5);
        Py_DECREF(tmp_args_element_name_5);
        if (tmp_call_result_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2014;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_2);
    }
    {
        PyObject *tmp_called_name_5;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_args_element_name_6;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__bio_to_string);

        if (unlikely(tmp_mvar_value_7 == NULL)) {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__bio_to_string);
        }

        if (tmp_mvar_value_7 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3632 ], 43, 0);
            exception_tb = NULL;

            exception_lineno = 2015;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_5 = tmp_mvar_value_7;
        CHECK_OBJECT(var_bio);
        tmp_args_element_name_6 = var_bio;
        frame_368e52860340c0239edd479ec201e937->m_frame.f_lineno = 2015;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_5, tmp_args_element_name_6);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2015;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_368e52860340c0239edd479ec201e937);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_368e52860340c0239edd479ec201e937);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_368e52860340c0239edd479ec201e937);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_368e52860340c0239edd479ec201e937, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_368e52860340c0239edd479ec201e937->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_368e52860340c0239edd479ec201e937, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_368e52860340c0239edd479ec201e937,
        type_description_1,
        par_self,
        var_bio,
        var_result,
        var_asn1_int
    );


    // Release cached frame.
    if (frame_368e52860340c0239edd479ec201e937 == cache_frame_368e52860340c0239edd479ec201e937) {
        Py_DECREF(frame_368e52860340c0239edd479ec201e937);
    }
    cache_frame_368e52860340c0239edd479ec201e937 = NULL;

    assertFrameObject(frame_368e52860340c0239edd479ec201e937);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_103_get_serial);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_bio);
    Py_DECREF(var_bio);
    var_bio = NULL;

    CHECK_OBJECT((PyObject *)var_result);
    Py_DECREF(var_result);
    var_result = NULL;

    CHECK_OBJECT((PyObject *)var_asn1_int);
    Py_DECREF(var_asn1_int);
    var_asn1_int = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_bio);
    var_bio = NULL;

    Py_XDECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_asn1_int);
    var_asn1_int = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_103_get_serial);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_104__delete_reason(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_i = NULL;
    PyObject *var_obj = NULL;
    PyObject *var_ext = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_5cabe66b4bd10e5fcd686ac603345ff9;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_5cabe66b4bd10e5fcd686ac603345ff9 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_5cabe66b4bd10e5fcd686ac603345ff9, codeobj_5cabe66b4bd10e5fcd686ac603345ff9, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_5cabe66b4bd10e5fcd686ac603345ff9 = cache_frame_5cabe66b4bd10e5fcd686ac603345ff9;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_5cabe66b4bd10e5fcd686ac603345ff9);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_5cabe66b4bd10e5fcd686ac603345ff9) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_range_arg_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2018;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_X509_REVOKED_get_ext_count);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2018;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__revoked);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2018;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_5cabe66b4bd10e5fcd686ac603345ff9->m_frame.f_lineno = 2018;
        tmp_range_arg_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_range_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2018;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_iter_arg_1 = BUILTIN_RANGE(tmp_range_arg_1);
        Py_DECREF(tmp_range_arg_1);
        if (tmp_iter_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2018;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_1 = MAKE_ITERATOR(tmp_iter_arg_1);
        Py_DECREF(tmp_iter_arg_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2018;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(tmp_for_loop_1__for_iterator == NULL);
        tmp_for_loop_1__for_iterator = tmp_assign_source_1;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT(tmp_for_loop_1__for_iterator);
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_2 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_2 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "oooo";
                exception_lineno = 2018;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_2;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_3;
        CHECK_OBJECT(tmp_for_loop_1__iter_value);
        tmp_assign_source_3 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_i;
            var_i = tmp_assign_source_3;
            Py_INCREF(var_i);
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2019;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_X509_REVOKED_get_ext);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2019;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_4 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain__revoked);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 2019;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT(var_i);
        tmp_args_element_name_3 = var_i;
        frame_5cabe66b4bd10e5fcd686ac603345ff9->m_frame.f_lineno = 2019;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assign_source_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2019;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_ext;
            var_ext = tmp_assign_source_4;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2020;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_1 = tmp_mvar_value_3;
        CHECK_OBJECT(var_ext);
        tmp_args_element_name_4 = var_ext;
        frame_5cabe66b4bd10e5fcd686ac603345ff9->m_frame.f_lineno = 2020;
        {
            PyObject *call_args[] = {tmp_args_element_name_4};
            tmp_assign_source_5 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_X509_EXTENSION_get_object, call_args);
        }

        if (tmp_assign_source_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2020;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_obj;
            var_obj = tmp_assign_source_5;
            Py_XDECREF(old);
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_5;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2021;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_2 = tmp_mvar_value_4;
        CHECK_OBJECT(var_obj);
        tmp_args_element_name_5 = var_obj;
        frame_5cabe66b4bd10e5fcd686ac603345ff9->m_frame.f_lineno = 2021;
        {
            PyObject *call_args[] = {tmp_args_element_name_5};
            tmp_compexpr_left_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_OBJ_obj2nid, call_args);
        }

        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2021;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_5 == NULL) {
            Py_DECREF(tmp_compexpr_left_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2021;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }

        tmp_source_name_5 = tmp_mvar_value_5;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_NID_crl_reason);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_1);

            exception_lineno = 2021;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2021;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_3;
            PyObject *tmp_mvar_value_6;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_6;
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_6 == NULL)) {
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_6 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 2022;
                type_description_1 = "oooo";
                goto try_except_handler_2;
            }

            tmp_called_instance_3 = tmp_mvar_value_6;
            CHECK_OBJECT(var_ext);
            tmp_args_element_name_6 = var_ext;
            frame_5cabe66b4bd10e5fcd686ac603345ff9->m_frame.f_lineno = 2022;
            {
                PyObject *call_args[] = {tmp_args_element_name_6};
                tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_3, const_str_plain_X509_EXTENSION_free, call_args);
            }

            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2022;
                type_description_1 = "oooo";
                goto try_except_handler_2;
            }
            Py_DECREF(tmp_call_result_1);
        }
        {
            PyObject *tmp_called_name_3;
            PyObject *tmp_source_name_6;
            PyObject *tmp_mvar_value_7;
            PyObject *tmp_call_result_2;
            PyObject *tmp_args_element_name_7;
            PyObject *tmp_source_name_7;
            PyObject *tmp_args_element_name_8;
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_7 == NULL)) {
                tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_7 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 2023;
                type_description_1 = "oooo";
                goto try_except_handler_2;
            }

            tmp_source_name_6 = tmp_mvar_value_7;
            tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_X509_REVOKED_delete_ext);
            if (tmp_called_name_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2023;
                type_description_1 = "oooo";
                goto try_except_handler_2;
            }
            CHECK_OBJECT(par_self);
            tmp_source_name_7 = par_self;
            tmp_args_element_name_7 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain__revoked);
            if (tmp_args_element_name_7 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_3);

                exception_lineno = 2023;
                type_description_1 = "oooo";
                goto try_except_handler_2;
            }
            CHECK_OBJECT(var_i);
            tmp_args_element_name_8 = var_i;
            frame_5cabe66b4bd10e5fcd686ac603345ff9->m_frame.f_lineno = 2023;
            {
                PyObject *call_args[] = {tmp_args_element_name_7, tmp_args_element_name_8};
                tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_3, call_args);
            }

            Py_DECREF(tmp_called_name_3);
            Py_DECREF(tmp_args_element_name_7);
            if (tmp_call_result_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2023;
                type_description_1 = "oooo";
                goto try_except_handler_2;
            }
            Py_DECREF(tmp_call_result_2);
        }
        goto loop_end_1;
        branch_no_1:;
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


        exception_lineno = 2018;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5cabe66b4bd10e5fcd686ac603345ff9);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5cabe66b4bd10e5fcd686ac603345ff9);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_5cabe66b4bd10e5fcd686ac603345ff9, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_5cabe66b4bd10e5fcd686ac603345ff9->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_5cabe66b4bd10e5fcd686ac603345ff9, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5cabe66b4bd10e5fcd686ac603345ff9,
        type_description_1,
        par_self,
        var_i,
        var_obj,
        var_ext
    );


    // Release cached frame.
    if (frame_5cabe66b4bd10e5fcd686ac603345ff9 == cache_frame_5cabe66b4bd10e5fcd686ac603345ff9) {
        Py_DECREF(frame_5cabe66b4bd10e5fcd686ac603345ff9);
    }
    cache_frame_5cabe66b4bd10e5fcd686ac603345ff9 = NULL;

    assertFrameObject(frame_5cabe66b4bd10e5fcd686ac603345ff9);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_104__delete_reason);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_i);
    var_i = NULL;

    Py_XDECREF(var_obj);
    var_obj = NULL;

    Py_XDECREF(var_ext);
    var_ext = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_i);
    var_i = NULL;

    Py_XDECREF(var_obj);
    var_obj = NULL;

    Py_XDECREF(var_ext);
    var_ext = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_104__delete_reason);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_105_set_reason(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_reason = python_pars[1];
    PyObject *var_reason_code = NULL;
    PyObject *var_set_result = NULL;
    PyObject *var_r = NULL;
    PyObject *var_add_result = NULL;
    PyObject *var_new_reason_ext = NULL;
    PyObject *tmp_list_contraction_1__$0 = NULL;
    PyObject *tmp_list_contraction_1__contraction_result = NULL;
    PyObject *tmp_list_contraction_1__iter_value_0 = NULL;
    struct Nuitka_FrameObject *frame_69ba33aac22465dc3e11fe94f2672358;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_69ba33aac22465dc3e11fe94f2672358 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_69ba33aac22465dc3e11fe94f2672358, codeobj_69ba33aac22465dc3e11fe94f2672358, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_69ba33aac22465dc3e11fe94f2672358 = cache_frame_69ba33aac22465dc3e11fe94f2672358;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_69ba33aac22465dc3e11fe94f2672358);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_69ba33aac22465dc3e11fe94f2672358) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_reason);
        tmp_compexpr_left_1 = par_reason;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_call_result_1;
            CHECK_OBJECT(par_self);
            tmp_called_instance_1 = par_self;
            frame_69ba33aac22465dc3e11fe94f2672358->m_frame.f_lineno = 2043;
            tmp_call_result_1 = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain__delete_reason);
            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2043;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_1);
        }
        goto branch_end_1;
        branch_no_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_operand_name_1;
            PyObject *tmp_isinstance_inst_1;
            PyObject *tmp_isinstance_cls_1;
            CHECK_OBJECT(par_reason);
            tmp_isinstance_inst_1 = par_reason;
            tmp_isinstance_cls_1 = (PyObject *)&PyString_Type;
            tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2044;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2044;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
                goto branch_yes_2;
            } else {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_raise_type_1;
                PyObject *tmp_make_exception_arg_1;
                tmp_make_exception_arg_1 = const_str_digest_9ae52cddf69d053d9518f458a81ffa1b;
                frame_69ba33aac22465dc3e11fe94f2672358->m_frame.f_lineno = 2045;
                tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
                assert(!(tmp_raise_type_1 == NULL));
                exception_type = tmp_raise_type_1;
                exception_lineno = 2045;
                RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            goto branch_end_2;
            branch_no_2:;
            {
                PyObject *tmp_assign_source_1;
                PyObject *tmp_called_instance_2;
                PyObject *tmp_called_instance_3;
                CHECK_OBJECT(par_reason);
                tmp_called_instance_3 = par_reason;
                frame_69ba33aac22465dc3e11fe94f2672358->m_frame.f_lineno = 2047;
                tmp_called_instance_2 = CALL_METHOD_NO_ARGS(tmp_called_instance_3, const_str_plain_lower);
                if (tmp_called_instance_2 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2047;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                frame_69ba33aac22465dc3e11fe94f2672358->m_frame.f_lineno = 2047;
                tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_2, const_str_plain_replace, &PyTuple_GET_ITEM(const_tuple_str_space_str_empty_tuple, 0));

                Py_DECREF(tmp_called_instance_2);
                if (tmp_assign_source_1 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2047;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                {
                    PyObject *old = par_reason;
                    assert(old != NULL);
                    par_reason = tmp_assign_source_1;
                    Py_DECREF(old);
                }

            }
            {
                PyObject *tmp_assign_source_2;
                PyObject *tmp_called_instance_4;
                PyObject *tmp_args_element_name_1;
                // Tried code:
                {
                    PyObject *tmp_assign_source_3;
                    PyObject *tmp_iter_arg_1;
                    PyObject *tmp_source_name_1;
                    CHECK_OBJECT(par_self);
                    tmp_source_name_1 = par_self;
                    tmp_iter_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__crl_reasons);
                    if (tmp_iter_arg_1 == NULL) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                        exception_lineno = 2048;
                        type_description_1 = "ooooooo";
                        goto try_except_handler_2;
                    }
                    tmp_assign_source_3 = MAKE_ITERATOR(tmp_iter_arg_1);
                    Py_DECREF(tmp_iter_arg_1);
                    if (tmp_assign_source_3 == NULL) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                        exception_lineno = 2048;
                        type_description_1 = "ooooooo";
                        goto try_except_handler_2;
                    }
                    assert(tmp_list_contraction_1__$0 == NULL);
                    tmp_list_contraction_1__$0 = tmp_assign_source_3;
                }
                {
                    PyObject *tmp_assign_source_4;
                    tmp_assign_source_4 = PyList_New(0);
                    assert(tmp_list_contraction_1__contraction_result == NULL);
                    tmp_list_contraction_1__contraction_result = tmp_assign_source_4;
                }
                loop_start_1:;
                {
                    PyObject *tmp_next_source_1;
                    PyObject *tmp_assign_source_5;
                    CHECK_OBJECT(tmp_list_contraction_1__$0);
                    tmp_next_source_1 = tmp_list_contraction_1__$0;
                    tmp_assign_source_5 = ITERATOR_NEXT(tmp_next_source_1);
                    if (tmp_assign_source_5 == NULL) {
                        if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                            goto loop_end_1;
                        } else {

                            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                            type_description_1 = "ooooooo";
                            exception_lineno = 2048;
                            goto try_except_handler_2;
                        }
                    }

                    {
                        PyObject *old = tmp_list_contraction_1__iter_value_0;
                        tmp_list_contraction_1__iter_value_0 = tmp_assign_source_5;
                        Py_XDECREF(old);
                    }

                }
                {
                    PyObject *tmp_assign_source_6;
                    CHECK_OBJECT(tmp_list_contraction_1__iter_value_0);
                    tmp_assign_source_6 = tmp_list_contraction_1__iter_value_0;
                    {
                        PyObject *old = var_r;
                        var_r = tmp_assign_source_6;
                        Py_INCREF(var_r);
                        Py_XDECREF(old);
                    }

                }
                {
                    PyObject *tmp_append_list_1;
                    PyObject *tmp_append_value_1;
                    PyObject *tmp_called_instance_5;
                    CHECK_OBJECT(tmp_list_contraction_1__contraction_result);
                    tmp_append_list_1 = tmp_list_contraction_1__contraction_result;
                    CHECK_OBJECT(var_r);
                    tmp_called_instance_5 = var_r;
                    frame_69ba33aac22465dc3e11fe94f2672358->m_frame.f_lineno = 2048;
                    tmp_append_value_1 = CALL_METHOD_NO_ARGS(tmp_called_instance_5, const_str_plain_lower);
                    if (tmp_append_value_1 == NULL) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                        exception_lineno = 2048;
                        type_description_1 = "ooooooo";
                        goto try_except_handler_2;
                    }
                    assert(PyList_Check(tmp_append_list_1));
                    tmp_res = PyList_Append(tmp_append_list_1, tmp_append_value_1);
                    Py_DECREF(tmp_append_value_1);
                    if (tmp_res == -1) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                        exception_lineno = 2048;
                        type_description_1 = "ooooooo";
                        goto try_except_handler_2;
                    }
                }
                if (CONSIDER_THREADING() == false) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2048;
                    type_description_1 = "ooooooo";
                    goto try_except_handler_2;
                }
                goto loop_start_1;
                loop_end_1:;
                CHECK_OBJECT(tmp_list_contraction_1__contraction_result);
                tmp_called_instance_4 = tmp_list_contraction_1__contraction_result;
                Py_INCREF(tmp_called_instance_4);
                goto try_return_handler_2;
                // tried codes exits in all cases
                NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_105_set_reason);
                return NULL;
                // Return handler code:
                try_return_handler_2:;
                CHECK_OBJECT((PyObject *)tmp_list_contraction_1__$0);
                Py_DECREF(tmp_list_contraction_1__$0);
                tmp_list_contraction_1__$0 = NULL;

                CHECK_OBJECT((PyObject *)tmp_list_contraction_1__contraction_result);
                Py_DECREF(tmp_list_contraction_1__contraction_result);
                tmp_list_contraction_1__contraction_result = NULL;

                Py_XDECREF(tmp_list_contraction_1__iter_value_0);
                tmp_list_contraction_1__iter_value_0 = NULL;

                goto outline_result_1;
                // Exception handler code:
                try_except_handler_2:;
                exception_keeper_type_1 = exception_type;
                exception_keeper_value_1 = exception_value;
                exception_keeper_tb_1 = exception_tb;
                exception_keeper_lineno_1 = exception_lineno;
                exception_type = NULL;
                exception_value = NULL;
                exception_tb = NULL;
                exception_lineno = 0;

                Py_XDECREF(tmp_list_contraction_1__$0);
                tmp_list_contraction_1__$0 = NULL;

                Py_XDECREF(tmp_list_contraction_1__contraction_result);
                tmp_list_contraction_1__contraction_result = NULL;

                Py_XDECREF(tmp_list_contraction_1__iter_value_0);
                tmp_list_contraction_1__iter_value_0 = NULL;

                // Re-raise.
                exception_type = exception_keeper_type_1;
                exception_value = exception_keeper_value_1;
                exception_tb = exception_keeper_tb_1;
                exception_lineno = exception_keeper_lineno_1;

                goto frame_exception_exit_1;
                // End of try:
                // Return statement must have exited already.
                NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_105_set_reason);
                return NULL;
                outline_result_1:;
                CHECK_OBJECT(par_reason);
                tmp_args_element_name_1 = par_reason;
                frame_69ba33aac22465dc3e11fe94f2672358->m_frame.f_lineno = 2048;
                {
                    PyObject *call_args[] = {tmp_args_element_name_1};
                    tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_4, const_str_plain_index, call_args);
                }

                Py_DECREF(tmp_called_instance_4);
                if (tmp_assign_source_2 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2048;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                assert(var_reason_code == NULL);
                var_reason_code = tmp_assign_source_2;
            }
            {
                PyObject *tmp_assign_source_7;
                PyObject *tmp_called_instance_6;
                PyObject *tmp_mvar_value_1;
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

                if (unlikely(tmp_mvar_value_1 == NULL)) {
                    tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
                }

                if (tmp_mvar_value_1 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 2050;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_instance_6 = tmp_mvar_value_1;
                frame_69ba33aac22465dc3e11fe94f2672358->m_frame.f_lineno = 2050;
                tmp_assign_source_7 = CALL_METHOD_NO_ARGS(tmp_called_instance_6, const_str_plain_ASN1_ENUMERATED_new);
                if (tmp_assign_source_7 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2050;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                assert(var_new_reason_ext == NULL);
                var_new_reason_ext = tmp_assign_source_7;
            }
            {
                PyObject *tmp_called_name_1;
                PyObject *tmp_mvar_value_2;
                PyObject *tmp_call_result_2;
                PyObject *tmp_args_element_name_2;
                PyObject *tmp_compexpr_left_2;
                PyObject *tmp_compexpr_right_2;
                PyObject *tmp_source_name_2;
                PyObject *tmp_mvar_value_3;
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

                if (unlikely(tmp_mvar_value_2 == NULL)) {
                    tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
                }

                if (tmp_mvar_value_2 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
                    exception_tb = NULL;

                    exception_lineno = 2051;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_name_1 = tmp_mvar_value_2;
                CHECK_OBJECT(var_new_reason_ext);
                tmp_compexpr_left_2 = var_new_reason_ext;
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

                if (unlikely(tmp_mvar_value_3 == NULL)) {
                    tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
                }

                if (tmp_mvar_value_3 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 2051;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_2 = tmp_mvar_value_3;
                tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_NULL);
                if (tmp_compexpr_right_2 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2051;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                tmp_args_element_name_2 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
                Py_DECREF(tmp_compexpr_right_2);
                if (tmp_args_element_name_2 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2051;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                frame_69ba33aac22465dc3e11fe94f2672358->m_frame.f_lineno = 2051;
                tmp_call_result_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_2);
                Py_DECREF(tmp_args_element_name_2);
                if (tmp_call_result_2 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2051;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                Py_DECREF(tmp_call_result_2);
            }
            {
                PyObject *tmp_assign_source_8;
                PyObject *tmp_called_name_2;
                PyObject *tmp_source_name_3;
                PyObject *tmp_mvar_value_4;
                PyObject *tmp_args_element_name_3;
                PyObject *tmp_args_element_name_4;
                PyObject *tmp_source_name_4;
                PyObject *tmp_mvar_value_5;
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

                if (unlikely(tmp_mvar_value_4 == NULL)) {
                    tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
                }

                if (tmp_mvar_value_4 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 2052;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_3 = tmp_mvar_value_4;
                tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_gc);
                if (tmp_called_name_2 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2052;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT(var_new_reason_ext);
                tmp_args_element_name_3 = var_new_reason_ext;
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

                if (unlikely(tmp_mvar_value_5 == NULL)) {
                    tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
                }

                if (tmp_mvar_value_5 == NULL) {
                    Py_DECREF(tmp_called_name_2);
                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 2052;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_4 = tmp_mvar_value_5;
                tmp_args_element_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_ASN1_ENUMERATED_free);
                if (tmp_args_element_name_4 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    Py_DECREF(tmp_called_name_2);

                    exception_lineno = 2052;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                frame_69ba33aac22465dc3e11fe94f2672358->m_frame.f_lineno = 2052;
                {
                    PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4};
                    tmp_assign_source_8 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
                }

                Py_DECREF(tmp_called_name_2);
                Py_DECREF(tmp_args_element_name_4);
                if (tmp_assign_source_8 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2052;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                {
                    PyObject *old = var_new_reason_ext;
                    assert(old != NULL);
                    var_new_reason_ext = tmp_assign_source_8;
                    Py_DECREF(old);
                }

            }
            {
                PyObject *tmp_assign_source_9;
                PyObject *tmp_called_instance_7;
                PyObject *tmp_mvar_value_6;
                PyObject *tmp_args_element_name_5;
                PyObject *tmp_args_element_name_6;
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

                if (unlikely(tmp_mvar_value_6 == NULL)) {
                    tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
                }

                if (tmp_mvar_value_6 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 2054;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_instance_7 = tmp_mvar_value_6;
                CHECK_OBJECT(var_new_reason_ext);
                tmp_args_element_name_5 = var_new_reason_ext;
                CHECK_OBJECT(var_reason_code);
                tmp_args_element_name_6 = var_reason_code;
                frame_69ba33aac22465dc3e11fe94f2672358->m_frame.f_lineno = 2054;
                {
                    PyObject *call_args[] = {tmp_args_element_name_5, tmp_args_element_name_6};
                    tmp_assign_source_9 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_7, const_str_plain_ASN1_ENUMERATED_set, call_args);
                }

                if (tmp_assign_source_9 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2054;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                assert(var_set_result == NULL);
                var_set_result = tmp_assign_source_9;
            }
            {
                PyObject *tmp_called_name_3;
                PyObject *tmp_mvar_value_7;
                PyObject *tmp_call_result_3;
                PyObject *tmp_args_element_name_7;
                PyObject *tmp_compexpr_left_3;
                PyObject *tmp_compexpr_right_3;
                PyObject *tmp_source_name_5;
                PyObject *tmp_mvar_value_8;
                tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

                if (unlikely(tmp_mvar_value_7 == NULL)) {
                    tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
                }

                if (tmp_mvar_value_7 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
                    exception_tb = NULL;

                    exception_lineno = 2055;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_name_3 = tmp_mvar_value_7;
                CHECK_OBJECT(var_set_result);
                tmp_compexpr_left_3 = var_set_result;
                tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

                if (unlikely(tmp_mvar_value_8 == NULL)) {
                    tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
                }

                if (tmp_mvar_value_8 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 2055;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_5 = tmp_mvar_value_8;
                tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_NULL);
                if (tmp_compexpr_right_3 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2055;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                tmp_args_element_name_7 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_3, tmp_compexpr_right_3);
                Py_DECREF(tmp_compexpr_right_3);
                if (tmp_args_element_name_7 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2055;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                frame_69ba33aac22465dc3e11fe94f2672358->m_frame.f_lineno = 2055;
                tmp_call_result_3 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_3, tmp_args_element_name_7);
                Py_DECREF(tmp_args_element_name_7);
                if (tmp_call_result_3 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2055;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                Py_DECREF(tmp_call_result_3);
            }
            {
                PyObject *tmp_called_instance_8;
                PyObject *tmp_call_result_4;
                CHECK_OBJECT(par_self);
                tmp_called_instance_8 = par_self;
                frame_69ba33aac22465dc3e11fe94f2672358->m_frame.f_lineno = 2057;
                tmp_call_result_4 = CALL_METHOD_NO_ARGS(tmp_called_instance_8, const_str_plain__delete_reason);
                if (tmp_call_result_4 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2057;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                Py_DECREF(tmp_call_result_4);
            }
            {
                PyObject *tmp_assign_source_10;
                PyObject *tmp_called_name_4;
                PyObject *tmp_source_name_6;
                PyObject *tmp_mvar_value_9;
                PyObject *tmp_args_element_name_8;
                PyObject *tmp_source_name_7;
                PyObject *tmp_args_element_name_9;
                PyObject *tmp_source_name_8;
                PyObject *tmp_mvar_value_10;
                PyObject *tmp_args_element_name_10;
                PyObject *tmp_args_element_name_11;
                PyObject *tmp_args_element_name_12;
                tmp_mvar_value_9 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

                if (unlikely(tmp_mvar_value_9 == NULL)) {
                    tmp_mvar_value_9 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
                }

                if (tmp_mvar_value_9 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 2058;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_6 = tmp_mvar_value_9;
                tmp_called_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_X509_REVOKED_add1_ext_i2d);
                if (tmp_called_name_4 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2058;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT(par_self);
                tmp_source_name_7 = par_self;
                tmp_args_element_name_8 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain__revoked);
                if (tmp_args_element_name_8 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    Py_DECREF(tmp_called_name_4);

                    exception_lineno = 2059;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                tmp_mvar_value_10 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

                if (unlikely(tmp_mvar_value_10 == NULL)) {
                    tmp_mvar_value_10 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
                }

                if (tmp_mvar_value_10 == NULL) {
                    Py_DECREF(tmp_called_name_4);
                    Py_DECREF(tmp_args_element_name_8);
                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 2059;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_8 = tmp_mvar_value_10;
                tmp_args_element_name_9 = LOOKUP_ATTRIBUTE(tmp_source_name_8, const_str_plain_NID_crl_reason);
                if (tmp_args_element_name_9 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    Py_DECREF(tmp_called_name_4);
                    Py_DECREF(tmp_args_element_name_8);

                    exception_lineno = 2059;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT(var_new_reason_ext);
                tmp_args_element_name_10 = var_new_reason_ext;
                tmp_args_element_name_11 = const_int_0;
                tmp_args_element_name_12 = const_int_0;
                frame_69ba33aac22465dc3e11fe94f2672358->m_frame.f_lineno = 2058;
                {
                    PyObject *call_args[] = {tmp_args_element_name_8, tmp_args_element_name_9, tmp_args_element_name_10, tmp_args_element_name_11, tmp_args_element_name_12};
                    tmp_assign_source_10 = CALL_FUNCTION_WITH_ARGS5(tmp_called_name_4, call_args);
                }

                Py_DECREF(tmp_called_name_4);
                Py_DECREF(tmp_args_element_name_8);
                Py_DECREF(tmp_args_element_name_9);
                if (tmp_assign_source_10 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2058;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                assert(var_add_result == NULL);
                var_add_result = tmp_assign_source_10;
            }
            {
                PyObject *tmp_called_name_5;
                PyObject *tmp_mvar_value_11;
                PyObject *tmp_call_result_5;
                PyObject *tmp_args_element_name_13;
                PyObject *tmp_compexpr_left_4;
                PyObject *tmp_compexpr_right_4;
                tmp_mvar_value_11 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

                if (unlikely(tmp_mvar_value_11 == NULL)) {
                    tmp_mvar_value_11 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
                }

                if (tmp_mvar_value_11 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
                    exception_tb = NULL;

                    exception_lineno = 2060;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_name_5 = tmp_mvar_value_11;
                CHECK_OBJECT(var_add_result);
                tmp_compexpr_left_4 = var_add_result;
                tmp_compexpr_right_4 = const_int_pos_1;
                tmp_args_element_name_13 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_4, tmp_compexpr_right_4);
                if (tmp_args_element_name_13 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2060;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                frame_69ba33aac22465dc3e11fe94f2672358->m_frame.f_lineno = 2060;
                tmp_call_result_5 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_5, tmp_args_element_name_13);
                Py_DECREF(tmp_args_element_name_13);
                if (tmp_call_result_5 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2060;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                Py_DECREF(tmp_call_result_5);
            }
            branch_end_2:;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_69ba33aac22465dc3e11fe94f2672358);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_69ba33aac22465dc3e11fe94f2672358);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_69ba33aac22465dc3e11fe94f2672358, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_69ba33aac22465dc3e11fe94f2672358->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_69ba33aac22465dc3e11fe94f2672358, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_69ba33aac22465dc3e11fe94f2672358,
        type_description_1,
        par_self,
        par_reason,
        var_reason_code,
        var_set_result,
        var_r,
        var_add_result,
        var_new_reason_ext
    );


    // Release cached frame.
    if (frame_69ba33aac22465dc3e11fe94f2672358 == cache_frame_69ba33aac22465dc3e11fe94f2672358) {
        Py_DECREF(frame_69ba33aac22465dc3e11fe94f2672358);
    }
    cache_frame_69ba33aac22465dc3e11fe94f2672358 = NULL;

    assertFrameObject(frame_69ba33aac22465dc3e11fe94f2672358);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_105_set_reason);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_reason_code);
    var_reason_code = NULL;

    Py_XDECREF(var_set_result);
    var_set_result = NULL;

    Py_XDECREF(par_reason);
    par_reason = NULL;

    Py_XDECREF(var_r);
    var_r = NULL;

    Py_XDECREF(var_add_result);
    var_add_result = NULL;

    Py_XDECREF(var_new_reason_ext);
    var_new_reason_ext = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_reason_code);
    var_reason_code = NULL;

    Py_XDECREF(var_set_result);
    var_set_result = NULL;

    CHECK_OBJECT((PyObject *)par_reason);
    Py_DECREF(par_reason);
    par_reason = NULL;

    Py_XDECREF(var_r);
    var_r = NULL;

    Py_XDECREF(var_add_result);
    var_add_result = NULL;

    Py_XDECREF(var_new_reason_ext);
    var_new_reason_ext = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_105_set_reason);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_106_get_reason(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_bio = NULL;
    PyObject *var_obj = NULL;
    PyObject *var_print_result = NULL;
    PyObject *var_i = NULL;
    PyObject *var_ext = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_ab078d627a4f8a1ea8d9fa8ec2ab7620;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_ab078d627a4f8a1ea8d9fa8ec2ab7620 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_ab078d627a4f8a1ea8d9fa8ec2ab7620, codeobj_ab078d627a4f8a1ea8d9fa8ec2ab7620, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_ab078d627a4f8a1ea8d9fa8ec2ab7620 = cache_frame_ab078d627a4f8a1ea8d9fa8ec2ab7620;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_ab078d627a4f8a1ea8d9fa8ec2ab7620);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_ab078d627a4f8a1ea8d9fa8ec2ab7620) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_range_arg_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2074;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_X509_REVOKED_get_ext_count);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2074;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__revoked);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2074;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_ab078d627a4f8a1ea8d9fa8ec2ab7620->m_frame.f_lineno = 2074;
        tmp_range_arg_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_range_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2074;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_iter_arg_1 = BUILTIN_RANGE(tmp_range_arg_1);
        Py_DECREF(tmp_range_arg_1);
        if (tmp_iter_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2074;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_1 = MAKE_ITERATOR(tmp_iter_arg_1);
        Py_DECREF(tmp_iter_arg_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2074;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert(tmp_for_loop_1__for_iterator == NULL);
        tmp_for_loop_1__for_iterator = tmp_assign_source_1;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT(tmp_for_loop_1__for_iterator);
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_2 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_2 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "oooooo";
                exception_lineno = 2074;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_2;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_3;
        CHECK_OBJECT(tmp_for_loop_1__iter_value);
        tmp_assign_source_3 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_i;
            var_i = tmp_assign_source_3;
            Py_INCREF(var_i);
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2075;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_X509_REVOKED_get_ext);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2075;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_4 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain__revoked);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 2075;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT(var_i);
        tmp_args_element_name_3 = var_i;
        frame_ab078d627a4f8a1ea8d9fa8ec2ab7620->m_frame.f_lineno = 2075;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assign_source_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2075;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_ext;
            var_ext = tmp_assign_source_4;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2076;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_1 = tmp_mvar_value_3;
        CHECK_OBJECT(var_ext);
        tmp_args_element_name_4 = var_ext;
        frame_ab078d627a4f8a1ea8d9fa8ec2ab7620->m_frame.f_lineno = 2076;
        {
            PyObject *call_args[] = {tmp_args_element_name_4};
            tmp_assign_source_5 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_X509_EXTENSION_get_object, call_args);
        }

        if (tmp_assign_source_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2076;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_obj;
            var_obj = tmp_assign_source_5;
            Py_XDECREF(old);
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_5;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2077;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_2 = tmp_mvar_value_4;
        CHECK_OBJECT(var_obj);
        tmp_args_element_name_5 = var_obj;
        frame_ab078d627a4f8a1ea8d9fa8ec2ab7620->m_frame.f_lineno = 2077;
        {
            PyObject *call_args[] = {tmp_args_element_name_5};
            tmp_compexpr_left_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_OBJ_obj2nid, call_args);
        }

        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2077;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_5 == NULL) {
            Py_DECREF(tmp_compexpr_left_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2077;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }

        tmp_source_name_5 = tmp_mvar_value_5;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_NID_crl_reason);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_1);

            exception_lineno = 2077;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2077;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_6;
            PyObject *tmp_called_name_3;
            PyObject *tmp_mvar_value_6;
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf);

            if (unlikely(tmp_mvar_value_6 == NULL)) {
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf);
            }

            if (tmp_mvar_value_6 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 3591 ], 41, 0);
                exception_tb = NULL;

                exception_lineno = 2078;
                type_description_1 = "oooooo";
                goto try_except_handler_2;
            }

            tmp_called_name_3 = tmp_mvar_value_6;
            frame_ab078d627a4f8a1ea8d9fa8ec2ab7620->m_frame.f_lineno = 2078;
            tmp_assign_source_6 = CALL_FUNCTION_NO_ARGS(tmp_called_name_3);
            if (tmp_assign_source_6 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2078;
                type_description_1 = "oooooo";
                goto try_except_handler_2;
            }
            assert(var_bio == NULL);
            var_bio = tmp_assign_source_6;
        }
        {
            PyObject *tmp_assign_source_7;
            PyObject *tmp_called_instance_3;
            PyObject *tmp_mvar_value_7;
            PyObject *tmp_args_element_name_6;
            PyObject *tmp_args_element_name_7;
            PyObject *tmp_args_element_name_8;
            PyObject *tmp_args_element_name_9;
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_7 == NULL)) {
                tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_7 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 2080;
                type_description_1 = "oooooo";
                goto try_except_handler_2;
            }

            tmp_called_instance_3 = tmp_mvar_value_7;
            CHECK_OBJECT(var_bio);
            tmp_args_element_name_6 = var_bio;
            CHECK_OBJECT(var_ext);
            tmp_args_element_name_7 = var_ext;
            tmp_args_element_name_8 = const_int_0;
            tmp_args_element_name_9 = const_int_0;
            frame_ab078d627a4f8a1ea8d9fa8ec2ab7620->m_frame.f_lineno = 2080;
            {
                PyObject *call_args[] = {tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8, tmp_args_element_name_9};
                tmp_assign_source_7 = CALL_METHOD_WITH_ARGS4(tmp_called_instance_3, const_str_plain_X509V3_EXT_print, call_args);
            }

            if (tmp_assign_source_7 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2080;
                type_description_1 = "oooooo";
                goto try_except_handler_2;
            }
            assert(var_print_result == NULL);
            var_print_result = tmp_assign_source_7;
        }
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_operand_name_1;
            CHECK_OBJECT(var_print_result);
            tmp_operand_name_1 = var_print_result;
            tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2081;
                type_description_1 = "oooooo";
                goto try_except_handler_2;
            }
            tmp_condition_result_2 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
                goto branch_yes_2;
            } else {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_assign_source_8;
                PyObject *tmp_called_name_4;
                PyObject *tmp_source_name_6;
                PyObject *tmp_mvar_value_8;
                PyObject *tmp_args_element_name_10;
                PyObject *tmp_args_element_name_11;
                PyObject *tmp_called_instance_4;
                PyObject *tmp_mvar_value_9;
                PyObject *tmp_args_element_name_12;
                tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

                if (unlikely(tmp_mvar_value_8 == NULL)) {
                    tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
                }

                if (tmp_mvar_value_8 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 2082;
                    type_description_1 = "oooooo";
                    goto try_except_handler_2;
                }

                tmp_source_name_6 = tmp_mvar_value_8;
                tmp_called_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_M_ASN1_OCTET_STRING_print);
                if (tmp_called_name_4 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2082;
                    type_description_1 = "oooooo";
                    goto try_except_handler_2;
                }
                CHECK_OBJECT(var_bio);
                tmp_args_element_name_10 = var_bio;
                tmp_mvar_value_9 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

                if (unlikely(tmp_mvar_value_9 == NULL)) {
                    tmp_mvar_value_9 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
                }

                if (tmp_mvar_value_9 == NULL) {
                    Py_DECREF(tmp_called_name_4);
                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 2083;
                    type_description_1 = "oooooo";
                    goto try_except_handler_2;
                }

                tmp_called_instance_4 = tmp_mvar_value_9;
                CHECK_OBJECT(var_ext);
                tmp_args_element_name_12 = var_ext;
                frame_ab078d627a4f8a1ea8d9fa8ec2ab7620->m_frame.f_lineno = 2083;
                {
                    PyObject *call_args[] = {tmp_args_element_name_12};
                    tmp_args_element_name_11 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_4, const_str_plain_X509_EXTENSION_get_data, call_args);
                }

                if (tmp_args_element_name_11 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    Py_DECREF(tmp_called_name_4);

                    exception_lineno = 2083;
                    type_description_1 = "oooooo";
                    goto try_except_handler_2;
                }
                frame_ab078d627a4f8a1ea8d9fa8ec2ab7620->m_frame.f_lineno = 2082;
                {
                    PyObject *call_args[] = {tmp_args_element_name_10, tmp_args_element_name_11};
                    tmp_assign_source_8 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_4, call_args);
                }

                Py_DECREF(tmp_called_name_4);
                Py_DECREF(tmp_args_element_name_11);
                if (tmp_assign_source_8 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2082;
                    type_description_1 = "oooooo";
                    goto try_except_handler_2;
                }
                {
                    PyObject *old = var_print_result;
                    assert(old != NULL);
                    var_print_result = tmp_assign_source_8;
                    Py_DECREF(old);
                }

            }
            {
                PyObject *tmp_called_name_5;
                PyObject *tmp_mvar_value_10;
                PyObject *tmp_call_result_1;
                PyObject *tmp_args_element_name_13;
                PyObject *tmp_compexpr_left_2;
                PyObject *tmp_compexpr_right_2;
                tmp_mvar_value_10 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

                if (unlikely(tmp_mvar_value_10 == NULL)) {
                    tmp_mvar_value_10 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
                }

                if (tmp_mvar_value_10 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
                    exception_tb = NULL;

                    exception_lineno = 2085;
                    type_description_1 = "oooooo";
                    goto try_except_handler_2;
                }

                tmp_called_name_5 = tmp_mvar_value_10;
                CHECK_OBJECT(var_print_result);
                tmp_compexpr_left_2 = var_print_result;
                tmp_compexpr_right_2 = const_int_0;
                tmp_args_element_name_13 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
                if (tmp_args_element_name_13 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2085;
                    type_description_1 = "oooooo";
                    goto try_except_handler_2;
                }
                frame_ab078d627a4f8a1ea8d9fa8ec2ab7620->m_frame.f_lineno = 2085;
                tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_5, tmp_args_element_name_13);
                Py_DECREF(tmp_args_element_name_13);
                if (tmp_call_result_1 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2085;
                    type_description_1 = "oooooo";
                    goto try_except_handler_2;
                }
                Py_DECREF(tmp_call_result_1);
            }
            branch_no_2:;
        }
        {
            PyObject *tmp_called_name_6;
            PyObject *tmp_mvar_value_11;
            PyObject *tmp_args_element_name_14;
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__bio_to_string);

            if (unlikely(tmp_mvar_value_11 == NULL)) {
                tmp_mvar_value_11 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__bio_to_string);
            }

            if (tmp_mvar_value_11 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 3632 ], 43, 0);
                exception_tb = NULL;

                exception_lineno = 2087;
                type_description_1 = "oooooo";
                goto try_except_handler_2;
            }

            tmp_called_name_6 = tmp_mvar_value_11;
            CHECK_OBJECT(var_bio);
            tmp_args_element_name_14 = var_bio;
            frame_ab078d627a4f8a1ea8d9fa8ec2ab7620->m_frame.f_lineno = 2087;
            tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_6, tmp_args_element_name_14);
            if (tmp_return_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2087;
                type_description_1 = "oooooo";
                goto try_except_handler_2;
            }
            goto try_return_handler_2;
        }
        branch_no_1:;
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


        exception_lineno = 2074;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT((PyObject *)tmp_for_loop_1__iter_value);
    Py_DECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    goto frame_return_exit_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ab078d627a4f8a1ea8d9fa8ec2ab7620);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_ab078d627a4f8a1ea8d9fa8ec2ab7620);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ab078d627a4f8a1ea8d9fa8ec2ab7620);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_ab078d627a4f8a1ea8d9fa8ec2ab7620, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_ab078d627a4f8a1ea8d9fa8ec2ab7620->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_ab078d627a4f8a1ea8d9fa8ec2ab7620, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ab078d627a4f8a1ea8d9fa8ec2ab7620,
        type_description_1,
        par_self,
        var_bio,
        var_obj,
        var_print_result,
        var_i,
        var_ext
    );


    // Release cached frame.
    if (frame_ab078d627a4f8a1ea8d9fa8ec2ab7620 == cache_frame_ab078d627a4f8a1ea8d9fa8ec2ab7620) {
        Py_DECREF(frame_ab078d627a4f8a1ea8d9fa8ec2ab7620);
    }
    cache_frame_ab078d627a4f8a1ea8d9fa8ec2ab7620 = NULL;

    assertFrameObject(frame_ab078d627a4f8a1ea8d9fa8ec2ab7620);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_106_get_reason);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_bio);
    var_bio = NULL;

    Py_XDECREF(var_obj);
    var_obj = NULL;

    Py_XDECREF(var_print_result);
    var_print_result = NULL;

    Py_XDECREF(var_i);
    var_i = NULL;

    Py_XDECREF(var_ext);
    var_ext = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_bio);
    var_bio = NULL;

    Py_XDECREF(var_obj);
    var_obj = NULL;

    Py_XDECREF(var_print_result);
    var_print_result = NULL;

    Py_XDECREF(var_i);
    var_i = NULL;

    Py_XDECREF(var_ext);
    var_ext = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_106_get_reason);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_107_all_reasons(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_fa5b81e573b15ecdf6f1dca4e70b2a76;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_fa5b81e573b15ecdf6f1dca4e70b2a76 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_fa5b81e573b15ecdf6f1dca4e70b2a76, codeobj_fa5b81e573b15ecdf6f1dca4e70b2a76, module_OpenSSL$crypto, sizeof(void *));
    frame_fa5b81e573b15ecdf6f1dca4e70b2a76 = cache_frame_fa5b81e573b15ecdf6f1dca4e70b2a76;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_fa5b81e573b15ecdf6f1dca4e70b2a76);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_fa5b81e573b15ecdf6f1dca4e70b2a76) == 2); // Frame stack

    // Framed code:
    {
        Py_ssize_t tmp_sliceslicedel_index_lower_1;
        Py_ssize_t tmp_slice_index_upper_1;
        PyObject *tmp_slice_source_1;
        PyObject *tmp_source_name_1;
        tmp_sliceslicedel_index_lower_1 = 0;
        tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_slice_source_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__crl_reasons);
        if (tmp_slice_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2099;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = LOOKUP_INDEX_SLICE(tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1);
        Py_DECREF(tmp_slice_source_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2099;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_fa5b81e573b15ecdf6f1dca4e70b2a76);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_fa5b81e573b15ecdf6f1dca4e70b2a76);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_fa5b81e573b15ecdf6f1dca4e70b2a76);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_fa5b81e573b15ecdf6f1dca4e70b2a76, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_fa5b81e573b15ecdf6f1dca4e70b2a76->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_fa5b81e573b15ecdf6f1dca4e70b2a76, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_fa5b81e573b15ecdf6f1dca4e70b2a76,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_fa5b81e573b15ecdf6f1dca4e70b2a76 == cache_frame_fa5b81e573b15ecdf6f1dca4e70b2a76) {
        Py_DECREF(frame_fa5b81e573b15ecdf6f1dca4e70b2a76);
    }
    cache_frame_fa5b81e573b15ecdf6f1dca4e70b2a76 = NULL;

    assertFrameObject(frame_fa5b81e573b15ecdf6f1dca4e70b2a76);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_107_all_reasons);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_108_set_rev_date(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_when = python_pars[1];
    PyObject *var_dt = NULL;
    struct Nuitka_FrameObject *frame_151b1f6515b68f745ad19e8b1fbe6905;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_151b1f6515b68f745ad19e8b1fbe6905 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_151b1f6515b68f745ad19e8b1fbe6905, codeobj_151b1f6515b68f745ad19e8b1fbe6905, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_151b1f6515b68f745ad19e8b1fbe6905 = cache_frame_151b1f6515b68f745ad19e8b1fbe6905;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_151b1f6515b68f745ad19e8b1fbe6905);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_151b1f6515b68f745ad19e8b1fbe6905) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2109;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_X509_REVOKED_get0_revocationDate);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2109;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__revoked);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2109;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_151b1f6515b68f745ad19e8b1fbe6905->m_frame.f_lineno = 2109;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2109;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_dt == NULL);
        var_dt = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__set_asn1_time);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__set_asn1_time);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3960 ], 43, 0);
            exception_tb = NULL;

            exception_lineno = 2110;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT(var_dt);
        tmp_args_element_name_2 = var_dt;
        CHECK_OBJECT(par_when);
        tmp_args_element_name_3 = par_when;
        frame_151b1f6515b68f745ad19e8b1fbe6905->m_frame.f_lineno = 2110;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2110;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_151b1f6515b68f745ad19e8b1fbe6905);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_151b1f6515b68f745ad19e8b1fbe6905);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_151b1f6515b68f745ad19e8b1fbe6905);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_151b1f6515b68f745ad19e8b1fbe6905, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_151b1f6515b68f745ad19e8b1fbe6905->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_151b1f6515b68f745ad19e8b1fbe6905, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_151b1f6515b68f745ad19e8b1fbe6905,
        type_description_1,
        par_self,
        par_when,
        var_dt
    );


    // Release cached frame.
    if (frame_151b1f6515b68f745ad19e8b1fbe6905 == cache_frame_151b1f6515b68f745ad19e8b1fbe6905) {
        Py_DECREF(frame_151b1f6515b68f745ad19e8b1fbe6905);
    }
    cache_frame_151b1f6515b68f745ad19e8b1fbe6905 = NULL;

    assertFrameObject(frame_151b1f6515b68f745ad19e8b1fbe6905);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_108_set_rev_date);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_dt);
    Py_DECREF(var_dt);
    var_dt = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_dt);
    var_dt = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_108_set_rev_date);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_when);
    Py_DECREF(par_when);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_when);
    Py_DECREF(par_when);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_109_get_rev_date(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_dt = NULL;
    struct Nuitka_FrameObject *frame_2f75f854001e71ff4003dca12987865c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_2f75f854001e71ff4003dca12987865c = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_2f75f854001e71ff4003dca12987865c, codeobj_2f75f854001e71ff4003dca12987865c, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *));
    frame_2f75f854001e71ff4003dca12987865c = cache_frame_2f75f854001e71ff4003dca12987865c;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_2f75f854001e71ff4003dca12987865c);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_2f75f854001e71ff4003dca12987865c) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2119;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_X509_REVOKED_get0_revocationDate);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2119;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__revoked);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2119;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_2f75f854001e71ff4003dca12987865c->m_frame.f_lineno = 2119;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2119;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert(var_dt == NULL);
        var_dt = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__get_asn1_time);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__get_asn1_time);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3917 ], 43, 0);
            exception_tb = NULL;

            exception_lineno = 2120;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT(var_dt);
        tmp_args_element_name_2 = var_dt;
        frame_2f75f854001e71ff4003dca12987865c->m_frame.f_lineno = 2120;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_2);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2120;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2f75f854001e71ff4003dca12987865c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_2f75f854001e71ff4003dca12987865c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2f75f854001e71ff4003dca12987865c);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_2f75f854001e71ff4003dca12987865c, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_2f75f854001e71ff4003dca12987865c->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_2f75f854001e71ff4003dca12987865c, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2f75f854001e71ff4003dca12987865c,
        type_description_1,
        par_self,
        var_dt
    );


    // Release cached frame.
    if (frame_2f75f854001e71ff4003dca12987865c == cache_frame_2f75f854001e71ff4003dca12987865c) {
        Py_DECREF(frame_2f75f854001e71ff4003dca12987865c);
    }
    cache_frame_2f75f854001e71ff4003dca12987865c = NULL;

    assertFrameObject(frame_2f75f854001e71ff4003dca12987865c);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_109_get_rev_date);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_dt);
    Py_DECREF(var_dt);
    var_dt = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_dt);
    var_dt = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_109_get_rev_date);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_110___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_crl = NULL;
    struct Nuitka_FrameObject *frame_4f7957c52b7d5aeb30baabbb3d3cb7ab;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_4f7957c52b7d5aeb30baabbb3d3cb7ab = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_4f7957c52b7d5aeb30baabbb3d3cb7ab, codeobj_4f7957c52b7d5aeb30baabbb3d3cb7ab, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *));
    frame_4f7957c52b7d5aeb30baabbb3d3cb7ab = cache_frame_4f7957c52b7d5aeb30baabbb3d3cb7ab;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_4f7957c52b7d5aeb30baabbb3d3cb7ab);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_4f7957c52b7d5aeb30baabbb3d3cb7ab) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2129;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_4f7957c52b7d5aeb30baabbb3d3cb7ab->m_frame.f_lineno = 2129;
        tmp_assign_source_1 = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_X509_CRL_new);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2129;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert(var_crl == NULL);
        var_crl = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2130;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_gc);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2130;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_crl);
        tmp_args_element_name_1 = var_crl;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2130;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_X509_CRL_free);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2130;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_4f7957c52b7d5aeb30baabbb3d3cb7ab->m_frame.f_lineno = 2130;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2130;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__crl, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2130;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_4f7957c52b7d5aeb30baabbb3d3cb7ab);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_4f7957c52b7d5aeb30baabbb3d3cb7ab);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_4f7957c52b7d5aeb30baabbb3d3cb7ab, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_4f7957c52b7d5aeb30baabbb3d3cb7ab->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_4f7957c52b7d5aeb30baabbb3d3cb7ab, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4f7957c52b7d5aeb30baabbb3d3cb7ab,
        type_description_1,
        par_self,
        var_crl
    );


    // Release cached frame.
    if (frame_4f7957c52b7d5aeb30baabbb3d3cb7ab == cache_frame_4f7957c52b7d5aeb30baabbb3d3cb7ab) {
        Py_DECREF(frame_4f7957c52b7d5aeb30baabbb3d3cb7ab);
    }
    cache_frame_4f7957c52b7d5aeb30baabbb3d3cb7ab = NULL;

    assertFrameObject(frame_4f7957c52b7d5aeb30baabbb3d3cb7ab);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_110___init__);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_crl);
    Py_DECREF(var_crl);
    var_crl = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_crl);
    var_crl = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_110___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_111_to_cryptography(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var__CertificateRevocationList = NULL;
    PyObject *var_backend = NULL;
    struct Nuitka_FrameObject *frame_c813942487f91c1997585eb0b387e327;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_c813942487f91c1997585eb0b387e327 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_c813942487f91c1997585eb0b387e327, codeobj_c813942487f91c1997585eb0b387e327, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_c813942487f91c1997585eb0b387e327 = cache_frame_c813942487f91c1997585eb0b387e327;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_c813942487f91c1997585eb0b387e327);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_c813942487f91c1997585eb0b387e327) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_import_name_from_1;
        PyObject *tmp_name_name_1;
        PyObject *tmp_globals_name_1;
        PyObject *tmp_locals_name_1;
        PyObject *tmp_fromlist_name_1;
        tmp_name_name_1 = const_str_digest_2b6a6c0099f1f1dd77d2725acd0722df;
        tmp_globals_name_1 = (PyObject *)moduledict_OpenSSL$crypto;
        tmp_locals_name_1 = Py_None;
        tmp_fromlist_name_1 = const_tuple_str_plain__CertificateRevocationList_tuple;
        frame_c813942487f91c1997585eb0b387e327->m_frame.f_lineno = 2140;
        tmp_import_name_from_1 = IMPORT_MODULE4(tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1);
        if (tmp_import_name_from_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2140;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_1 = IMPORT_NAME(tmp_import_name_from_1, const_str_plain__CertificateRevocationList);
        Py_DECREF(tmp_import_name_from_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2140;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var__CertificateRevocationList == NULL);
        var__CertificateRevocationList = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__get_backend);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__get_backend);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3241 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 2143;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        frame_c813942487f91c1997585eb0b387e327->m_frame.f_lineno = 2143;
        tmp_assign_source_2 = CALL_FUNCTION_NO_ARGS(tmp_called_name_1);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2143;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_backend == NULL);
        var_backend = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(var__CertificateRevocationList);
        tmp_called_name_2 = var__CertificateRevocationList;
        CHECK_OBJECT(var_backend);
        tmp_args_element_name_1 = var_backend;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__crl);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2144;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_c813942487f91c1997585eb0b387e327->m_frame.f_lineno = 2144;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_args_element_name_2);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2144;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c813942487f91c1997585eb0b387e327);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_c813942487f91c1997585eb0b387e327);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c813942487f91c1997585eb0b387e327);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_c813942487f91c1997585eb0b387e327, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_c813942487f91c1997585eb0b387e327->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_c813942487f91c1997585eb0b387e327, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c813942487f91c1997585eb0b387e327,
        type_description_1,
        par_self,
        var__CertificateRevocationList,
        var_backend
    );


    // Release cached frame.
    if (frame_c813942487f91c1997585eb0b387e327 == cache_frame_c813942487f91c1997585eb0b387e327) {
        Py_DECREF(frame_c813942487f91c1997585eb0b387e327);
    }
    cache_frame_c813942487f91c1997585eb0b387e327 = NULL;

    assertFrameObject(frame_c813942487f91c1997585eb0b387e327);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_111_to_cryptography);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var__CertificateRevocationList);
    Py_DECREF(var__CertificateRevocationList);
    var__CertificateRevocationList = NULL;

    CHECK_OBJECT((PyObject *)var_backend);
    Py_DECREF(var_backend);
    var_backend = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var__CertificateRevocationList);
    var__CertificateRevocationList = NULL;

    Py_XDECREF(var_backend);
    var_backend = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_111_to_cryptography);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_112_from_cryptography(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_crypto_crl = python_pars[1];
    PyObject *var_crl = NULL;
    struct Nuitka_FrameObject *frame_6ac5e01a4091f7c0a9e36a34af31a1a9;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_6ac5e01a4091f7c0a9e36a34af31a1a9 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_6ac5e01a4091f7c0a9e36a34af31a1a9, codeobj_6ac5e01a4091f7c0a9e36a34af31a1a9, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_6ac5e01a4091f7c0a9e36a34af31a1a9 = cache_frame_6ac5e01a4091f7c0a9e36a34af31a1a9;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_6ac5e01a4091f7c0a9e36a34af31a1a9);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_6ac5e01a4091f7c0a9e36a34af31a1a9) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_crypto_crl);
        tmp_isinstance_inst_1 = par_crypto_crl;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_x509);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_x509);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3675 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2158;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_isinstance_cls_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_CertificateRevocationList);
        if (tmp_isinstance_cls_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2158;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        Py_DECREF(tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2158;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2158;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_35f6b1c1261cd55e34a5b00d6cb8d5ea;
            frame_6ac5e01a4091f7c0a9e36a34af31a1a9->m_frame.f_lineno = 2159;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 2159;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        CHECK_OBJECT(par_cls);
        tmp_called_name_1 = par_cls;
        frame_6ac5e01a4091f7c0a9e36a34af31a1a9->m_frame.f_lineno = 2161;
        tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS(tmp_called_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2161;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_crl == NULL);
        var_crl = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_crypto_crl);
        tmp_source_name_2 = par_crypto_crl;
        tmp_assattr_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__x509_crl);
        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2162;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_crl);
        tmp_assattr_target_1 = var_crl;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__crl, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2162;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_6ac5e01a4091f7c0a9e36a34af31a1a9);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_6ac5e01a4091f7c0a9e36a34af31a1a9);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_6ac5e01a4091f7c0a9e36a34af31a1a9, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_6ac5e01a4091f7c0a9e36a34af31a1a9->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_6ac5e01a4091f7c0a9e36a34af31a1a9, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6ac5e01a4091f7c0a9e36a34af31a1a9,
        type_description_1,
        par_cls,
        par_crypto_crl,
        var_crl
    );


    // Release cached frame.
    if (frame_6ac5e01a4091f7c0a9e36a34af31a1a9 == cache_frame_6ac5e01a4091f7c0a9e36a34af31a1a9) {
        Py_DECREF(frame_6ac5e01a4091f7c0a9e36a34af31a1a9);
    }
    cache_frame_6ac5e01a4091f7c0a9e36a34af31a1a9 = NULL;

    assertFrameObject(frame_6ac5e01a4091f7c0a9e36a34af31a1a9);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT(var_crl);
    tmp_return_value = var_crl;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_112_from_cryptography);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_crl);
    Py_DECREF(var_crl);
    var_crl = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_crl);
    var_crl = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_112_from_cryptography);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_crypto_crl);
    Py_DECREF(par_crypto_crl);
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_crypto_crl);
    Py_DECREF(par_crypto_crl);
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_113_get_revoked(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_revoked = NULL;
    PyObject *var_i = NULL;
    PyObject *var_pyrev = NULL;
    PyObject *var_results = NULL;
    PyObject *var_revoked_stack = NULL;
    PyObject *var_revoked_copy = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_e4f22ea9413d3c0f22c2aa13efebb1d8;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_e4f22ea9413d3c0f22c2aa13efebb1d8 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = PyList_New(0);
        assert(var_results == NULL);
        var_results = tmp_assign_source_1;
    }
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_e4f22ea9413d3c0f22c2aa13efebb1d8, codeobj_e4f22ea9413d3c0f22c2aa13efebb1d8, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_e4f22ea9413d3c0f22c2aa13efebb1d8 = cache_frame_e4f22ea9413d3c0f22c2aa13efebb1d8;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_e4f22ea9413d3c0f22c2aa13efebb1d8);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_e4f22ea9413d3c0f22c2aa13efebb1d8) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2176;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_X509_CRL_get_REVOKED);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2176;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__crl);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2176;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        frame_e4f22ea9413d3c0f22c2aa13efebb1d8->m_frame.f_lineno = 2176;
        tmp_assign_source_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2176;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_revoked_stack == NULL);
        var_revoked_stack = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_range_arg_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2177;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_2;
        CHECK_OBJECT(var_revoked_stack);
        tmp_args_element_name_2 = var_revoked_stack;
        frame_e4f22ea9413d3c0f22c2aa13efebb1d8->m_frame.f_lineno = 2177;
        {
            PyObject *call_args[] = {tmp_args_element_name_2};
            tmp_range_arg_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_sk_X509_REVOKED_num, call_args);
        }

        if (tmp_range_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2177;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_iter_arg_1 = BUILTIN_RANGE(tmp_range_arg_1);
        Py_DECREF(tmp_range_arg_1);
        if (tmp_iter_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2177;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_3 = MAKE_ITERATOR(tmp_iter_arg_1);
        Py_DECREF(tmp_iter_arg_1);
        if (tmp_assign_source_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2177;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        assert(tmp_for_loop_1__for_iterator == NULL);
        tmp_for_loop_1__for_iterator = tmp_assign_source_3;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_4;
        CHECK_OBJECT(tmp_for_loop_1__for_iterator);
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_4 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_4 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "ooooooo";
                exception_lineno = 2177;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_4;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_5;
        CHECK_OBJECT(tmp_for_loop_1__iter_value);
        tmp_assign_source_5 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_i;
            var_i = tmp_assign_source_5;
            Py_INCREF(var_i);
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2178;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_2 = tmp_mvar_value_3;
        CHECK_OBJECT(var_revoked_stack);
        tmp_args_element_name_3 = var_revoked_stack;
        CHECK_OBJECT(var_i);
        tmp_args_element_name_4 = var_i;
        frame_e4f22ea9413d3c0f22c2aa13efebb1d8->m_frame.f_lineno = 2178;
        {
            PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4};
            tmp_assign_source_6 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_2, const_str_plain_sk_X509_REVOKED_value, call_args);
        }

        if (tmp_assign_source_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2178;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_revoked;
            var_revoked = tmp_assign_source_6;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_5;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2179;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_3 = tmp_mvar_value_4;
        CHECK_OBJECT(var_revoked);
        tmp_args_element_name_5 = var_revoked;
        frame_e4f22ea9413d3c0f22c2aa13efebb1d8->m_frame.f_lineno = 2179;
        {
            PyObject *call_args[] = {tmp_args_element_name_5};
            tmp_assign_source_7 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_3, const_str_plain_Cryptography_X509_REVOKED_dup, call_args);
        }

        if (tmp_assign_source_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2179;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_revoked_copy;
            var_revoked_copy = tmp_assign_source_7;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_8;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_mvar_value_6;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_Revoked);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_Revoked);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 4137 ], 36, 0);
            exception_tb = NULL;

            exception_lineno = 2180;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }

        tmp_source_name_3 = tmp_mvar_value_5;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain___new__);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2180;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_Revoked);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_Revoked);
        }

        if (tmp_mvar_value_6 == NULL) {
            Py_DECREF(tmp_called_name_2);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 4137 ], 36, 0);
            exception_tb = NULL;

            exception_lineno = 2180;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }

        tmp_args_element_name_6 = tmp_mvar_value_6;
        frame_e4f22ea9413d3c0f22c2aa13efebb1d8->m_frame.f_lineno = 2180;
        tmp_assign_source_8 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_6);
        Py_DECREF(tmp_called_name_2);
        if (tmp_assign_source_8 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2180;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_pyrev;
            var_pyrev = tmp_assign_source_8;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_7 == NULL)) {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_7 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2181;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }

        tmp_source_name_4 = tmp_mvar_value_7;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_gc);
        if (tmp_called_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2181;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT(var_revoked_copy);
        tmp_args_element_name_7 = var_revoked_copy;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_8 == NULL)) {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_8 == NULL) {
            Py_DECREF(tmp_called_name_3);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2181;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }

        tmp_source_name_5 = tmp_mvar_value_8;
        tmp_args_element_name_8 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_X509_REVOKED_free);
        if (tmp_args_element_name_8 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);

            exception_lineno = 2181;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
        frame_e4f22ea9413d3c0f22c2aa13efebb1d8->m_frame.f_lineno = 2181;
        {
            PyObject *call_args[] = {tmp_args_element_name_7, tmp_args_element_name_8};
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_3, call_args);
        }

        Py_DECREF(tmp_called_name_3);
        Py_DECREF(tmp_args_element_name_8);
        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2181;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT(var_pyrev);
        tmp_assattr_target_1 = var_pyrev;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__revoked, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2181;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
    }
    {
        PyObject *tmp_called_instance_4;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_9;
        CHECK_OBJECT(var_results);
        tmp_called_instance_4 = var_results;
        CHECK_OBJECT(var_pyrev);
        tmp_args_element_name_9 = var_pyrev;
        frame_e4f22ea9413d3c0f22c2aa13efebb1d8->m_frame.f_lineno = 2182;
        {
            PyObject *call_args[] = {tmp_args_element_name_9};
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_4, const_str_plain_append, call_args);
        }

        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2182;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
        Py_DECREF(tmp_call_result_1);
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


        exception_lineno = 2177;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    {
        nuitka_bool tmp_condition_result_1;
        int tmp_truth_name_1;
        CHECK_OBJECT(var_results);
        tmp_truth_name_1 = CHECK_IF_TRUE(var_results);
        assert(!(tmp_truth_name_1 == -1));
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_tuple_arg_1;
            CHECK_OBJECT(var_results);
            tmp_tuple_arg_1 = var_results;
            tmp_return_value = PySequence_Tuple(tmp_tuple_arg_1);
            if (tmp_return_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2184;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e4f22ea9413d3c0f22c2aa13efebb1d8);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_e4f22ea9413d3c0f22c2aa13efebb1d8);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e4f22ea9413d3c0f22c2aa13efebb1d8);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_e4f22ea9413d3c0f22c2aa13efebb1d8, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_e4f22ea9413d3c0f22c2aa13efebb1d8->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_e4f22ea9413d3c0f22c2aa13efebb1d8, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e4f22ea9413d3c0f22c2aa13efebb1d8,
        type_description_1,
        par_self,
        var_revoked,
        var_i,
        var_pyrev,
        var_results,
        var_revoked_stack,
        var_revoked_copy
    );


    // Release cached frame.
    if (frame_e4f22ea9413d3c0f22c2aa13efebb1d8 == cache_frame_e4f22ea9413d3c0f22c2aa13efebb1d8) {
        Py_DECREF(frame_e4f22ea9413d3c0f22c2aa13efebb1d8);
    }
    cache_frame_e4f22ea9413d3c0f22c2aa13efebb1d8 = NULL;

    assertFrameObject(frame_e4f22ea9413d3c0f22c2aa13efebb1d8);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_113_get_revoked);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_revoked);
    var_revoked = NULL;

    Py_XDECREF(var_i);
    var_i = NULL;

    Py_XDECREF(var_pyrev);
    var_pyrev = NULL;

    CHECK_OBJECT((PyObject *)var_results);
    Py_DECREF(var_results);
    var_results = NULL;

    CHECK_OBJECT((PyObject *)var_revoked_stack);
    Py_DECREF(var_revoked_stack);
    var_revoked_stack = NULL;

    Py_XDECREF(var_revoked_copy);
    var_revoked_copy = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_revoked);
    var_revoked = NULL;

    Py_XDECREF(var_i);
    var_i = NULL;

    Py_XDECREF(var_pyrev);
    var_pyrev = NULL;

    CHECK_OBJECT((PyObject *)var_results);
    Py_DECREF(var_results);
    var_results = NULL;

    Py_XDECREF(var_revoked_stack);
    var_revoked_stack = NULL;

    Py_XDECREF(var_revoked_copy);
    var_revoked_copy = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_113_get_revoked);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_114_add_revoked(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_revoked = python_pars[1];
    PyObject *var_copy = NULL;
    PyObject *var_add_result = NULL;
    struct Nuitka_FrameObject *frame_68a1e3325fbb1f364eb9342008f9697e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_68a1e3325fbb1f364eb9342008f9697e = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_68a1e3325fbb1f364eb9342008f9697e, codeobj_68a1e3325fbb1f364eb9342008f9697e, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_68a1e3325fbb1f364eb9342008f9697e = cache_frame_68a1e3325fbb1f364eb9342008f9697e;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_68a1e3325fbb1f364eb9342008f9697e);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_68a1e3325fbb1f364eb9342008f9697e) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2197;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_Cryptography_X509_REVOKED_dup);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2197;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_revoked);
        tmp_source_name_2 = par_revoked;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__revoked);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2197;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_68a1e3325fbb1f364eb9342008f9697e->m_frame.f_lineno = 2197;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2197;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_copy == NULL);
        var_copy = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 2198;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT(var_copy);
        tmp_compexpr_left_1 = var_copy;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2198;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_3;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_NULL);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2198;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_2 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2198;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_68a1e3325fbb1f364eb9342008f9697e->m_frame.f_lineno = 2198;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_2);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2198;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_5;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2200;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_4;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_X509_CRL_add0_revoked);
        if (tmp_called_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2200;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_5 = par_self;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain__crl);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);

            exception_lineno = 2200;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_copy);
        tmp_args_element_name_4 = var_copy;
        frame_68a1e3325fbb1f364eb9342008f9697e->m_frame.f_lineno = 2200;
        {
            PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4};
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_3, call_args);
        }

        Py_DECREF(tmp_called_name_3);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2200;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_add_result == NULL);
        var_add_result = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_name_4;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 2201;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_4 = tmp_mvar_value_5;
        CHECK_OBJECT(var_add_result);
        tmp_compexpr_left_2 = var_add_result;
        tmp_compexpr_right_2 = const_int_0;
        tmp_args_element_name_5 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
        if (tmp_args_element_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2201;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_68a1e3325fbb1f364eb9342008f9697e->m_frame.f_lineno = 2201;
        tmp_call_result_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_4, tmp_args_element_name_5);
        Py_DECREF(tmp_args_element_name_5);
        if (tmp_call_result_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2201;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_2);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_68a1e3325fbb1f364eb9342008f9697e);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_68a1e3325fbb1f364eb9342008f9697e);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_68a1e3325fbb1f364eb9342008f9697e, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_68a1e3325fbb1f364eb9342008f9697e->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_68a1e3325fbb1f364eb9342008f9697e, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_68a1e3325fbb1f364eb9342008f9697e,
        type_description_1,
        par_self,
        par_revoked,
        var_copy,
        var_add_result
    );


    // Release cached frame.
    if (frame_68a1e3325fbb1f364eb9342008f9697e == cache_frame_68a1e3325fbb1f364eb9342008f9697e) {
        Py_DECREF(frame_68a1e3325fbb1f364eb9342008f9697e);
    }
    cache_frame_68a1e3325fbb1f364eb9342008f9697e = NULL;

    assertFrameObject(frame_68a1e3325fbb1f364eb9342008f9697e);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_114_add_revoked);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_copy);
    Py_DECREF(var_copy);
    var_copy = NULL;

    CHECK_OBJECT((PyObject *)var_add_result);
    Py_DECREF(var_add_result);
    var_add_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_copy);
    var_copy = NULL;

    Py_XDECREF(var_add_result);
    var_add_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_114_add_revoked);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_revoked);
    Py_DECREF(par_revoked);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_revoked);
    Py_DECREF(par_revoked);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_115_get_issuer(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var__issuer = NULL;
    PyObject *var_issuer = NULL;
    struct Nuitka_FrameObject *frame_83dbeb702a8014baa25622a5026507ba;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_83dbeb702a8014baa25622a5026507ba = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_83dbeb702a8014baa25622a5026507ba, codeobj_83dbeb702a8014baa25622a5026507ba, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_83dbeb702a8014baa25622a5026507ba = cache_frame_83dbeb702a8014baa25622a5026507ba;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_83dbeb702a8014baa25622a5026507ba);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_83dbeb702a8014baa25622a5026507ba) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2211;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_X509_NAME_dup);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2211;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2211;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_X509_CRL_get_issuer);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2211;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__crl);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 2211;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_83dbeb702a8014baa25622a5026507ba->m_frame.f_lineno = 2211;
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_2);
        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2211;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_83dbeb702a8014baa25622a5026507ba->m_frame.f_lineno = 2211;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2211;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var__issuer == NULL);
        var__issuer = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 2212;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_3;
        CHECK_OBJECT(var__issuer);
        tmp_compexpr_left_1 = var__issuer;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2212;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_4;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_NULL);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2212;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2212;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_83dbeb702a8014baa25622a5026507ba->m_frame.f_lineno = 2212;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_3, tmp_args_element_name_3);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2212;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_6;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2213;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_5;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_gc);
        if (tmp_called_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2213;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var__issuer);
        tmp_args_element_name_4 = var__issuer;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_6 == NULL) {
            Py_DECREF(tmp_called_name_4);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2213;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_6;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_X509_NAME_free);
        if (tmp_args_element_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_4);

            exception_lineno = 2213;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_83dbeb702a8014baa25622a5026507ba->m_frame.f_lineno = 2213;
        {
            PyObject *call_args[] = {tmp_args_element_name_4, tmp_args_element_name_5};
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_4, call_args);
        }

        Py_DECREF(tmp_called_name_4);
        Py_DECREF(tmp_args_element_name_5);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2213;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var__issuer;
            assert(old != NULL);
            var__issuer = tmp_assign_source_2;
            Py_DECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_name_5;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_mvar_value_8;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Name);

        if (unlikely(tmp_mvar_value_7 == NULL)) {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Name);
        }

        if (tmp_mvar_value_7 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1105 ], 37, 0);
            exception_tb = NULL;

            exception_lineno = 2214;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = tmp_mvar_value_7;
        tmp_called_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain___new__);
        if (tmp_called_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2214;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Name);

        if (unlikely(tmp_mvar_value_8 == NULL)) {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Name);
        }

        if (tmp_mvar_value_8 == NULL) {
            Py_DECREF(tmp_called_name_5);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1105 ], 37, 0);
            exception_tb = NULL;

            exception_lineno = 2214;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_6 = tmp_mvar_value_8;
        frame_83dbeb702a8014baa25622a5026507ba->m_frame.f_lineno = 2214;
        tmp_assign_source_3 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_5, tmp_args_element_name_6);
        Py_DECREF(tmp_called_name_5);
        if (tmp_assign_source_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2214;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_issuer == NULL);
        var_issuer = tmp_assign_source_3;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(var__issuer);
        tmp_assattr_name_1 = var__issuer;
        CHECK_OBJECT(var_issuer);
        tmp_assattr_target_1 = var_issuer;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__name, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2215;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_83dbeb702a8014baa25622a5026507ba);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_83dbeb702a8014baa25622a5026507ba);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_83dbeb702a8014baa25622a5026507ba, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_83dbeb702a8014baa25622a5026507ba->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_83dbeb702a8014baa25622a5026507ba, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_83dbeb702a8014baa25622a5026507ba,
        type_description_1,
        par_self,
        var__issuer,
        var_issuer
    );


    // Release cached frame.
    if (frame_83dbeb702a8014baa25622a5026507ba == cache_frame_83dbeb702a8014baa25622a5026507ba) {
        Py_DECREF(frame_83dbeb702a8014baa25622a5026507ba);
    }
    cache_frame_83dbeb702a8014baa25622a5026507ba = NULL;

    assertFrameObject(frame_83dbeb702a8014baa25622a5026507ba);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT(var_issuer);
    tmp_return_value = var_issuer;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_115_get_issuer);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var__issuer);
    Py_DECREF(var__issuer);
    var__issuer = NULL;

    CHECK_OBJECT((PyObject *)var_issuer);
    Py_DECREF(var_issuer);
    var_issuer = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var__issuer);
    var__issuer = NULL;

    Py_XDECREF(var_issuer);
    var_issuer = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_115_get_issuer);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_116_set_version(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_version = python_pars[1];
    struct Nuitka_FrameObject *frame_1ea23726b81bbec2d72c3f055e13f1f3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_1ea23726b81bbec2d72c3f055e13f1f3 = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_1ea23726b81bbec2d72c3f055e13f1f3, codeobj_1ea23726b81bbec2d72c3f055e13f1f3, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *));
    frame_1ea23726b81bbec2d72c3f055e13f1f3 = cache_frame_1ea23726b81bbec2d72c3f055e13f1f3;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_1ea23726b81bbec2d72c3f055e13f1f3);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_1ea23726b81bbec2d72c3f055e13f1f3) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 2227;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2227;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_X509_CRL_set_version);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2227;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__crl);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 2227;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_version);
        tmp_args_element_name_3 = par_version;
        frame_1ea23726b81bbec2d72c3f055e13f1f3->m_frame.f_lineno = 2227;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_compexpr_left_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2227;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = const_int_0;
        tmp_args_element_name_1 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2227;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_1ea23726b81bbec2d72c3f055e13f1f3->m_frame.f_lineno = 2227;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2227;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_1ea23726b81bbec2d72c3f055e13f1f3);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_1ea23726b81bbec2d72c3f055e13f1f3);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_1ea23726b81bbec2d72c3f055e13f1f3, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_1ea23726b81bbec2d72c3f055e13f1f3->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_1ea23726b81bbec2d72c3f055e13f1f3, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1ea23726b81bbec2d72c3f055e13f1f3,
        type_description_1,
        par_self,
        par_version
    );


    // Release cached frame.
    if (frame_1ea23726b81bbec2d72c3f055e13f1f3 == cache_frame_1ea23726b81bbec2d72c3f055e13f1f3) {
        Py_DECREF(frame_1ea23726b81bbec2d72c3f055e13f1f3);
    }
    cache_frame_1ea23726b81bbec2d72c3f055e13f1f3 = NULL;

    assertFrameObject(frame_1ea23726b81bbec2d72c3f055e13f1f3);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_116_set_version);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_version);
    Py_DECREF(par_version);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_version);
    Py_DECREF(par_version);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_117__set_boundary_time(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_which = python_pars[1];
    PyObject *par_when = python_pars[2];
    struct Nuitka_FrameObject *frame_c7126baf39e9c42b3efde559aa07f143;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_c7126baf39e9c42b3efde559aa07f143 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_c7126baf39e9c42b3efde559aa07f143, codeobj_c7126baf39e9c42b3efde559aa07f143, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_c7126baf39e9c42b3efde559aa07f143 = cache_frame_c7126baf39e9c42b3efde559aa07f143;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_c7126baf39e9c42b3efde559aa07f143);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_c7126baf39e9c42b3efde559aa07f143) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__set_asn1_time);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__set_asn1_time);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3960 ], 43, 0);
            exception_tb = NULL;

            exception_lineno = 2230;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT(par_which);
        tmp_called_name_2 = par_which;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__crl);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2230;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_c7126baf39e9c42b3efde559aa07f143->m_frame.f_lineno = 2230;
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_2);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2230;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_when);
        tmp_args_element_name_3 = par_when;
        frame_c7126baf39e9c42b3efde559aa07f143->m_frame.f_lineno = 2230;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_3};
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2230;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c7126baf39e9c42b3efde559aa07f143);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_c7126baf39e9c42b3efde559aa07f143);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c7126baf39e9c42b3efde559aa07f143);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_c7126baf39e9c42b3efde559aa07f143, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_c7126baf39e9c42b3efde559aa07f143->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_c7126baf39e9c42b3efde559aa07f143, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c7126baf39e9c42b3efde559aa07f143,
        type_description_1,
        par_self,
        par_which,
        par_when
    );


    // Release cached frame.
    if (frame_c7126baf39e9c42b3efde559aa07f143 == cache_frame_c7126baf39e9c42b3efde559aa07f143) {
        Py_DECREF(frame_c7126baf39e9c42b3efde559aa07f143);
    }
    cache_frame_c7126baf39e9c42b3efde559aa07f143 = NULL;

    assertFrameObject(frame_c7126baf39e9c42b3efde559aa07f143);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_117__set_boundary_time);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_when);
    Py_DECREF(par_when);
    CHECK_OBJECT(par_which);
    Py_DECREF(par_which);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_when);
    Py_DECREF(par_when);
    CHECK_OBJECT(par_which);
    Py_DECREF(par_which);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_118_set_lastUpdate(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_when = python_pars[1];
    struct Nuitka_FrameObject *frame_6adba4da8c74bf815c0210e671b10c64;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_6adba4da8c74bf815c0210e671b10c64 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_6adba4da8c74bf815c0210e671b10c64, codeobj_6adba4da8c74bf815c0210e671b10c64, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *));
    frame_6adba4da8c74bf815c0210e671b10c64 = cache_frame_6adba4da8c74bf815c0210e671b10c64;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_6adba4da8c74bf815c0210e671b10c64);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_6adba4da8c74bf815c0210e671b10c64) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__set_boundary_time);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2245;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2245;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_1;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_X509_CRL_get_lastUpdate);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2245;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_when);
        tmp_args_element_name_2 = par_when;
        frame_6adba4da8c74bf815c0210e671b10c64->m_frame.f_lineno = 2245;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2245;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_6adba4da8c74bf815c0210e671b10c64);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_6adba4da8c74bf815c0210e671b10c64);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_6adba4da8c74bf815c0210e671b10c64);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_6adba4da8c74bf815c0210e671b10c64, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_6adba4da8c74bf815c0210e671b10c64->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_6adba4da8c74bf815c0210e671b10c64, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6adba4da8c74bf815c0210e671b10c64,
        type_description_1,
        par_self,
        par_when
    );


    // Release cached frame.
    if (frame_6adba4da8c74bf815c0210e671b10c64 == cache_frame_6adba4da8c74bf815c0210e671b10c64) {
        Py_DECREF(frame_6adba4da8c74bf815c0210e671b10c64);
    }
    cache_frame_6adba4da8c74bf815c0210e671b10c64 = NULL;

    assertFrameObject(frame_6adba4da8c74bf815c0210e671b10c64);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_118_set_lastUpdate);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_when);
    Py_DECREF(par_when);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_when);
    Py_DECREF(par_when);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_119_set_nextUpdate(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_when = python_pars[1];
    struct Nuitka_FrameObject *frame_09ba91e9bcc11b447039b645c382509f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_09ba91e9bcc11b447039b645c382509f = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_09ba91e9bcc11b447039b645c382509f, codeobj_09ba91e9bcc11b447039b645c382509f, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *));
    frame_09ba91e9bcc11b447039b645c382509f = cache_frame_09ba91e9bcc11b447039b645c382509f;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_09ba91e9bcc11b447039b645c382509f);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_09ba91e9bcc11b447039b645c382509f) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__set_boundary_time);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2260;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2260;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_1;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_X509_CRL_get_nextUpdate);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2260;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_when);
        tmp_args_element_name_2 = par_when;
        frame_09ba91e9bcc11b447039b645c382509f->m_frame.f_lineno = 2260;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2260;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_09ba91e9bcc11b447039b645c382509f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_09ba91e9bcc11b447039b645c382509f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_09ba91e9bcc11b447039b645c382509f);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_09ba91e9bcc11b447039b645c382509f, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_09ba91e9bcc11b447039b645c382509f->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_09ba91e9bcc11b447039b645c382509f, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_09ba91e9bcc11b447039b645c382509f,
        type_description_1,
        par_self,
        par_when
    );


    // Release cached frame.
    if (frame_09ba91e9bcc11b447039b645c382509f == cache_frame_09ba91e9bcc11b447039b645c382509f) {
        Py_DECREF(frame_09ba91e9bcc11b447039b645c382509f);
    }
    cache_frame_09ba91e9bcc11b447039b645c382509f = NULL;

    assertFrameObject(frame_09ba91e9bcc11b447039b645c382509f);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_119_set_nextUpdate);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_when);
    Py_DECREF(par_when);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_when);
    Py_DECREF(par_when);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_120_sign(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_issuer_cert = python_pars[1];
    PyObject *par_issuer_key = python_pars[2];
    PyObject *par_digest = python_pars[3];
    PyObject *var_digest_obj = NULL;
    PyObject *var_result = NULL;
    struct Nuitka_FrameObject *frame_a5dfabf8fb4be3653adb4ee5e3a9d1ee;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_a5dfabf8fb4be3653adb4ee5e3a9d1ee = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_a5dfabf8fb4be3653adb4ee5e3a9d1ee, codeobj_a5dfabf8fb4be3653adb4ee5e3a9d1ee, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_a5dfabf8fb4be3653adb4ee5e3a9d1ee = cache_frame_a5dfabf8fb4be3653adb4ee5e3a9d1ee;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_a5dfabf8fb4be3653adb4ee5e3a9d1ee);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_a5dfabf8fb4be3653adb4ee5e3a9d1ee) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2279;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT(par_digest);
        tmp_args_element_name_1 = par_digest;
        frame_a5dfabf8fb4be3653adb4ee5e3a9d1ee->m_frame.f_lineno = 2279;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_EVP_get_digestbyname, call_args);
        }

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2279;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert(var_digest_obj == NULL);
        var_digest_obj = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 2280;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_2;
        CHECK_OBJECT(var_digest_obj);
        tmp_compexpr_left_1 = var_digest_obj;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2280;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_3;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_NULL);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2280;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_2 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2280;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_a5dfabf8fb4be3653adb4ee5e3a9d1ee->m_frame.f_lineno = 2280;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_2);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2280;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_5;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2281;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_4;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_X509_CRL_set_issuer_name);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2281;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__crl);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 2282;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_5 == NULL) {
            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_3);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2282;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_5;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_X509_get_subject_name);
        if (tmp_called_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_3);

            exception_lineno = 2282;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_issuer_cert);
        tmp_source_name_5 = par_issuer_cert;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain__x509);
        if (tmp_args_element_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_3);
            Py_DECREF(tmp_called_name_3);

            exception_lineno = 2282;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_a5dfabf8fb4be3653adb4ee5e3a9d1ee->m_frame.f_lineno = 2282;
        tmp_args_element_name_4 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_3, tmp_args_element_name_5);
        Py_DECREF(tmp_called_name_3);
        Py_DECREF(tmp_args_element_name_5);
        if (tmp_args_element_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_3);

            exception_lineno = 2282;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_a5dfabf8fb4be3653adb4ee5e3a9d1ee->m_frame.f_lineno = 2281;
        {
            PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4};
            tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_3);
        Py_DECREF(tmp_args_element_name_4);
        if (tmp_call_result_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2281;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_2);
    }
    {
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_call_result_3;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_source_name_7;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_6 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2283;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_6;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_X509_CRL_sort);
        if (tmp_called_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2283;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_7 = par_self;
        tmp_args_element_name_6 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain__crl);
        if (tmp_args_element_name_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_4);

            exception_lineno = 2283;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_a5dfabf8fb4be3653adb4ee5e3a9d1ee->m_frame.f_lineno = 2283;
        tmp_call_result_3 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_4, tmp_args_element_name_6);
        Py_DECREF(tmp_called_name_4);
        Py_DECREF(tmp_args_element_name_6);
        if (tmp_call_result_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2283;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_3);
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_5;
        PyObject *tmp_source_name_8;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_source_name_9;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_source_name_10;
        PyObject *tmp_args_element_name_9;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_7 == NULL)) {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_7 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2284;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_8 = tmp_mvar_value_7;
        tmp_called_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_8, const_str_plain_X509_CRL_sign);
        if (tmp_called_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2284;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_9 = par_self;
        tmp_args_element_name_7 = LOOKUP_ATTRIBUTE(tmp_source_name_9, const_str_plain__crl);
        if (tmp_args_element_name_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_5);

            exception_lineno = 2284;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_issuer_key);
        tmp_source_name_10 = par_issuer_key;
        tmp_args_element_name_8 = LOOKUP_ATTRIBUTE(tmp_source_name_10, const_str_plain__pkey);
        if (tmp_args_element_name_8 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_5);
            Py_DECREF(tmp_args_element_name_7);

            exception_lineno = 2284;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_digest_obj);
        tmp_args_element_name_9 = var_digest_obj;
        frame_a5dfabf8fb4be3653adb4ee5e3a9d1ee->m_frame.f_lineno = 2284;
        {
            PyObject *call_args[] = {tmp_args_element_name_7, tmp_args_element_name_8, tmp_args_element_name_9};
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_5, call_args);
        }

        Py_DECREF(tmp_called_name_5);
        Py_DECREF(tmp_args_element_name_7);
        Py_DECREF(tmp_args_element_name_8);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2284;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert(var_result == NULL);
        var_result = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_name_6;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_call_result_4;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_8 == NULL)) {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_8 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 2285;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_6 = tmp_mvar_value_8;
        CHECK_OBJECT(var_result);
        tmp_compexpr_left_2 = var_result;
        tmp_compexpr_right_2 = const_int_0;
        tmp_args_element_name_10 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
        if (tmp_args_element_name_10 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2285;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_a5dfabf8fb4be3653adb4ee5e3a9d1ee->m_frame.f_lineno = 2285;
        tmp_call_result_4 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_6, tmp_args_element_name_10);
        Py_DECREF(tmp_args_element_name_10);
        if (tmp_call_result_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2285;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_4);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a5dfabf8fb4be3653adb4ee5e3a9d1ee);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a5dfabf8fb4be3653adb4ee5e3a9d1ee);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_a5dfabf8fb4be3653adb4ee5e3a9d1ee, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_a5dfabf8fb4be3653adb4ee5e3a9d1ee->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_a5dfabf8fb4be3653adb4ee5e3a9d1ee, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a5dfabf8fb4be3653adb4ee5e3a9d1ee,
        type_description_1,
        par_self,
        par_issuer_cert,
        par_issuer_key,
        par_digest,
        var_digest_obj,
        var_result
    );


    // Release cached frame.
    if (frame_a5dfabf8fb4be3653adb4ee5e3a9d1ee == cache_frame_a5dfabf8fb4be3653adb4ee5e3a9d1ee) {
        Py_DECREF(frame_a5dfabf8fb4be3653adb4ee5e3a9d1ee);
    }
    cache_frame_a5dfabf8fb4be3653adb4ee5e3a9d1ee = NULL;

    assertFrameObject(frame_a5dfabf8fb4be3653adb4ee5e3a9d1ee);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_120_sign);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_digest_obj);
    Py_DECREF(var_digest_obj);
    var_digest_obj = NULL;

    CHECK_OBJECT((PyObject *)var_result);
    Py_DECREF(var_result);
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_digest_obj);
    var_digest_obj = NULL;

    Py_XDECREF(var_result);
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_120_sign);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_issuer_cert);
    Py_DECREF(par_issuer_cert);
    CHECK_OBJECT(par_issuer_key);
    Py_DECREF(par_issuer_key);
    CHECK_OBJECT(par_digest);
    Py_DECREF(par_digest);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_issuer_cert);
    Py_DECREF(par_issuer_cert);
    CHECK_OBJECT(par_issuer_key);
    Py_DECREF(par_issuer_key);
    CHECK_OBJECT(par_digest);
    Py_DECREF(par_digest);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_121_export(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_cert = python_pars[1];
    PyObject *par_key = python_pars[2];
    PyObject *par_type = python_pars[3];
    PyObject *par_days = python_pars[4];
    PyObject *par_digest = python_pars[5];
    PyObject *var_bio = NULL;
    PyObject *var_sometime = NULL;
    PyObject *var_digest_obj = NULL;
    PyObject *var_sign_result = NULL;
    struct Nuitka_FrameObject *frame_63d5d54775413644d68413130bf8b01c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_63d5d54775413644d68413130bf8b01c = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_63d5d54775413644d68413130bf8b01c, codeobj_63d5d54775413644d68413130bf8b01c, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_63d5d54775413644d68413130bf8b01c = cache_frame_63d5d54775413644d68413130bf8b01c;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_63d5d54775413644d68413130bf8b01c);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_63d5d54775413644d68413130bf8b01c) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_cert);
        tmp_isinstance_inst_1 = par_cert;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 236 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2302;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2302;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2302;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_c804b213c384a15865e18bf31cfff70e;
            frame_63d5d54775413644d68413130bf8b01c->m_frame.f_lineno = 2303;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 2303;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_2;
        PyObject *tmp_isinstance_inst_2;
        PyObject *tmp_isinstance_cls_2;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT(par_key);
        tmp_isinstance_inst_2 = par_key;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 978 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2304;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_2 = tmp_mvar_value_2;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_2, tmp_isinstance_cls_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2304;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_2 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2304;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            tmp_make_exception_arg_2 = const_str_digest_0226e12d6e09b849c37787a1a7ec35a4;
            frame_63d5d54775413644d68413130bf8b01c->m_frame.f_lineno = 2305;
            tmp_raise_type_2 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_2);
            assert(!(tmp_raise_type_2 == NULL));
            exception_type = tmp_raise_type_2;
            exception_lineno = 2305;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_operand_name_3;
        PyObject *tmp_isinstance_inst_3;
        PyObject *tmp_isinstance_cls_3;
        CHECK_OBJECT(par_type);
        tmp_isinstance_inst_3 = par_type;
        tmp_isinstance_cls_3 = (PyObject *)&PyInt_Type;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_3, tmp_isinstance_cls_3);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2306;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_3 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_3);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2306;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
            goto branch_yes_3;
        } else {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_raise_type_3;
            PyObject *tmp_make_exception_arg_3;
            tmp_make_exception_arg_3 = const_str_digest_50f07d7dbc7dc060eb5685744b92c007;
            frame_63d5d54775413644d68413130bf8b01c->m_frame.f_lineno = 2307;
            tmp_raise_type_3 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_3);
            assert(!(tmp_raise_type_3 == NULL));
            exception_type = tmp_raise_type_3;
            exception_lineno = 2307;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_3:;
    }
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_3;
        CHECK_OBJECT(par_digest);
        tmp_compexpr_left_1 = par_digest;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__UNSPECIFIED);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__UNSPECIFIED);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 937 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 2309;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_3;
        tmp_condition_result_4 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_4 == NUITKA_BOOL_TRUE) {
            goto branch_yes_4;
        } else {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_raise_type_4;
            PyObject *tmp_make_exception_arg_4;
            tmp_make_exception_arg_4 = const_str_digest_e19f4eaf61167e65441aca909fe75b36;
            frame_63d5d54775413644d68413130bf8b01c->m_frame.f_lineno = 2310;
            tmp_raise_type_4 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_4);
            assert(!(tmp_raise_type_4 == NULL));
            exception_type = tmp_raise_type_4;
            exception_lineno = 2310;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_4:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2312;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_4;
        CHECK_OBJECT(par_digest);
        tmp_args_element_name_1 = par_digest;
        frame_63d5d54775413644d68413130bf8b01c->m_frame.f_lineno = 2312;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_EVP_get_digestbyname, call_args);
        }

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2312;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_digest_obj == NULL);
        var_digest_obj = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_5;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_5;
        CHECK_OBJECT(var_digest_obj);
        tmp_compexpr_left_2 = var_digest_obj;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2313;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_5;
        tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_NULL);
        if (tmp_compexpr_right_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2313;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
        Py_DECREF(tmp_compexpr_right_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2313;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_5 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_5 == NUITKA_BOOL_TRUE) {
            goto branch_yes_5;
        } else {
            goto branch_no_5;
        }
        branch_yes_5:;
        {
            PyObject *tmp_raise_type_5;
            PyObject *tmp_make_exception_arg_5;
            tmp_make_exception_arg_5 = const_str_digest_500f278b67471fc0f770fccc80d65d95;
            frame_63d5d54775413644d68413130bf8b01c->m_frame.f_lineno = 2314;
            tmp_raise_type_5 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_5);
            assert(!(tmp_raise_type_5 == NULL));
            exception_type = tmp_raise_type_5;
            exception_lineno = 2314;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_5:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_7;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_6 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2316;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_6;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_BIO_new);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2316;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_7 == NULL)) {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_7 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2316;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_7;
        frame_63d5d54775413644d68413130bf8b01c->m_frame.f_lineno = 2316;
        tmp_args_element_name_2 = CALL_METHOD_NO_ARGS(tmp_called_instance_2, const_str_plain_BIO_s_mem);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2316;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        frame_63d5d54775413644d68413130bf8b01c->m_frame.f_lineno = 2316;
        tmp_assign_source_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_2);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2316;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_bio == NULL);
        var_bio = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_9;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_8 == NULL)) {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_8 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 2317;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_8;
        CHECK_OBJECT(var_bio);
        tmp_compexpr_left_3 = var_bio;
        tmp_mvar_value_9 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_9 == NULL)) {
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_9 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2317;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_9;
        tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_NULL);
        if (tmp_compexpr_right_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2317;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_3, tmp_compexpr_right_3);
        Py_DECREF(tmp_compexpr_right_3);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2317;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        frame_63d5d54775413644d68413130bf8b01c->m_frame.f_lineno = 2317;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_3);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2317;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_10;
        tmp_mvar_value_10 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_10 == NULL)) {
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_10 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2321;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_3 = tmp_mvar_value_10;
        frame_63d5d54775413644d68413130bf8b01c->m_frame.f_lineno = 2321;
        tmp_assign_source_3 = CALL_METHOD_NO_ARGS(tmp_called_instance_3, const_str_plain_ASN1_TIME_new);
        if (tmp_assign_source_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2321;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_sometime == NULL);
        var_sometime = tmp_assign_source_3;
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_11;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_12;
        tmp_mvar_value_11 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_11 == NULL)) {
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_11 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 2322;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_11;
        CHECK_OBJECT(var_sometime);
        tmp_compexpr_left_4 = var_sometime;
        tmp_mvar_value_12 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_12 == NULL)) {
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_12 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2322;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_12;
        tmp_compexpr_right_4 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_NULL);
        if (tmp_compexpr_right_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2322;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_4 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_4, tmp_compexpr_right_4);
        Py_DECREF(tmp_compexpr_right_4);
        if (tmp_args_element_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2322;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        frame_63d5d54775413644d68413130bf8b01c->m_frame.f_lineno = 2322;
        tmp_call_result_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_3, tmp_args_element_name_4);
        Py_DECREF(tmp_args_element_name_4);
        if (tmp_call_result_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2322;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_2);
    }
    {
        PyObject *tmp_called_instance_4;
        PyObject *tmp_mvar_value_13;
        PyObject *tmp_call_result_3;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_args_element_name_6;
        tmp_mvar_value_13 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_13 == NULL)) {
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_13 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2324;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_4 = tmp_mvar_value_13;
        CHECK_OBJECT(var_sometime);
        tmp_args_element_name_5 = var_sometime;
        tmp_args_element_name_6 = const_int_0;
        frame_63d5d54775413644d68413130bf8b01c->m_frame.f_lineno = 2324;
        {
            PyObject *call_args[] = {tmp_args_element_name_5, tmp_args_element_name_6};
            tmp_call_result_3 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_4, const_str_plain_X509_gmtime_adj, call_args);
        }

        if (tmp_call_result_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2324;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_3);
    }
    {
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_14;
        PyObject *tmp_call_result_4;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_source_name_6;
        PyObject *tmp_args_element_name_8;
        tmp_mvar_value_14 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_14 == NULL)) {
            tmp_mvar_value_14 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_14 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2325;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_14;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_X509_CRL_set_lastUpdate);
        if (tmp_called_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2325;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_6 = par_self;
        tmp_args_element_name_7 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain__crl);
        if (tmp_args_element_name_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_4);

            exception_lineno = 2325;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_sometime);
        tmp_args_element_name_8 = var_sometime;
        frame_63d5d54775413644d68413130bf8b01c->m_frame.f_lineno = 2325;
        {
            PyObject *call_args[] = {tmp_args_element_name_7, tmp_args_element_name_8};
            tmp_call_result_4 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_4, call_args);
        }

        Py_DECREF(tmp_called_name_4);
        Py_DECREF(tmp_args_element_name_7);
        if (tmp_call_result_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2325;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_4);
    }
    {
        PyObject *tmp_called_name_5;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_15;
        PyObject *tmp_call_result_5;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_left_name_3;
        PyObject *tmp_right_name_1;
        PyObject *tmp_right_name_2;
        PyObject *tmp_right_name_3;
        tmp_mvar_value_15 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_15 == NULL)) {
            tmp_mvar_value_15 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_15 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2327;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = tmp_mvar_value_15;
        tmp_called_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain_X509_gmtime_adj);
        if (tmp_called_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2327;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_sometime);
        tmp_args_element_name_9 = var_sometime;
        CHECK_OBJECT(par_days);
        tmp_left_name_3 = par_days;
        tmp_right_name_1 = const_int_pos_24;
        tmp_left_name_2 = BINARY_OPERATION_MUL_OBJECT_INT(tmp_left_name_3, tmp_right_name_1);
        if (tmp_left_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_5);

            exception_lineno = 2327;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_right_name_2 = const_int_pos_60;
        tmp_left_name_1 = BINARY_OPERATION_MUL_OBJECT_INT(tmp_left_name_2, tmp_right_name_2);
        Py_DECREF(tmp_left_name_2);
        if (tmp_left_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_5);

            exception_lineno = 2327;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_right_name_3 = const_int_pos_60;
        tmp_args_element_name_10 = BINARY_OPERATION_MUL_OBJECT_INT(tmp_left_name_1, tmp_right_name_3);
        Py_DECREF(tmp_left_name_1);
        if (tmp_args_element_name_10 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_5);

            exception_lineno = 2327;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        frame_63d5d54775413644d68413130bf8b01c->m_frame.f_lineno = 2327;
        {
            PyObject *call_args[] = {tmp_args_element_name_9, tmp_args_element_name_10};
            tmp_call_result_5 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_5, call_args);
        }

        Py_DECREF(tmp_called_name_5);
        Py_DECREF(tmp_args_element_name_10);
        if (tmp_call_result_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2327;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_5);
    }
    {
        PyObject *tmp_called_name_6;
        PyObject *tmp_source_name_8;
        PyObject *tmp_mvar_value_16;
        PyObject *tmp_call_result_6;
        PyObject *tmp_args_element_name_11;
        PyObject *tmp_source_name_9;
        PyObject *tmp_args_element_name_12;
        tmp_mvar_value_16 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_16 == NULL)) {
            tmp_mvar_value_16 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_16 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2328;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_8 = tmp_mvar_value_16;
        tmp_called_name_6 = LOOKUP_ATTRIBUTE(tmp_source_name_8, const_str_plain_X509_CRL_set_nextUpdate);
        if (tmp_called_name_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2328;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_9 = par_self;
        tmp_args_element_name_11 = LOOKUP_ATTRIBUTE(tmp_source_name_9, const_str_plain__crl);
        if (tmp_args_element_name_11 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_6);

            exception_lineno = 2328;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_sometime);
        tmp_args_element_name_12 = var_sometime;
        frame_63d5d54775413644d68413130bf8b01c->m_frame.f_lineno = 2328;
        {
            PyObject *call_args[] = {tmp_args_element_name_11, tmp_args_element_name_12};
            tmp_call_result_6 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_6, call_args);
        }

        Py_DECREF(tmp_called_name_6);
        Py_DECREF(tmp_args_element_name_11);
        if (tmp_call_result_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2328;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_6);
    }
    {
        PyObject *tmp_called_name_7;
        PyObject *tmp_source_name_10;
        PyObject *tmp_mvar_value_17;
        PyObject *tmp_call_result_7;
        PyObject *tmp_args_element_name_13;
        PyObject *tmp_source_name_11;
        PyObject *tmp_args_element_name_14;
        PyObject *tmp_called_name_8;
        PyObject *tmp_source_name_12;
        PyObject *tmp_mvar_value_18;
        PyObject *tmp_args_element_name_15;
        PyObject *tmp_source_name_13;
        tmp_mvar_value_17 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_17 == NULL)) {
            tmp_mvar_value_17 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_17 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2330;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_10 = tmp_mvar_value_17;
        tmp_called_name_7 = LOOKUP_ATTRIBUTE(tmp_source_name_10, const_str_plain_X509_CRL_set_issuer_name);
        if (tmp_called_name_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2330;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_11 = par_self;
        tmp_args_element_name_13 = LOOKUP_ATTRIBUTE(tmp_source_name_11, const_str_plain__crl);
        if (tmp_args_element_name_13 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_7);

            exception_lineno = 2331;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_18 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_18 == NULL)) {
            tmp_mvar_value_18 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_18 == NULL) {
            Py_DECREF(tmp_called_name_7);
            Py_DECREF(tmp_args_element_name_13);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2331;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_12 = tmp_mvar_value_18;
        tmp_called_name_8 = LOOKUP_ATTRIBUTE(tmp_source_name_12, const_str_plain_X509_get_subject_name);
        if (tmp_called_name_8 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_7);
            Py_DECREF(tmp_args_element_name_13);

            exception_lineno = 2331;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_cert);
        tmp_source_name_13 = par_cert;
        tmp_args_element_name_15 = LOOKUP_ATTRIBUTE(tmp_source_name_13, const_str_plain__x509);
        if (tmp_args_element_name_15 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_7);
            Py_DECREF(tmp_args_element_name_13);
            Py_DECREF(tmp_called_name_8);

            exception_lineno = 2331;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        frame_63d5d54775413644d68413130bf8b01c->m_frame.f_lineno = 2331;
        tmp_args_element_name_14 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_8, tmp_args_element_name_15);
        Py_DECREF(tmp_called_name_8);
        Py_DECREF(tmp_args_element_name_15);
        if (tmp_args_element_name_14 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_7);
            Py_DECREF(tmp_args_element_name_13);

            exception_lineno = 2331;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        frame_63d5d54775413644d68413130bf8b01c->m_frame.f_lineno = 2330;
        {
            PyObject *call_args[] = {tmp_args_element_name_13, tmp_args_element_name_14};
            tmp_call_result_7 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_7, call_args);
        }

        Py_DECREF(tmp_called_name_7);
        Py_DECREF(tmp_args_element_name_13);
        Py_DECREF(tmp_args_element_name_14);
        if (tmp_call_result_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2330;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_7);
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_name_9;
        PyObject *tmp_source_name_14;
        PyObject *tmp_mvar_value_19;
        PyObject *tmp_args_element_name_16;
        PyObject *tmp_source_name_15;
        PyObject *tmp_args_element_name_17;
        PyObject *tmp_source_name_16;
        PyObject *tmp_args_element_name_18;
        tmp_mvar_value_19 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_19 == NULL)) {
            tmp_mvar_value_19 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_19 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2334;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_14 = tmp_mvar_value_19;
        tmp_called_name_9 = LOOKUP_ATTRIBUTE(tmp_source_name_14, const_str_plain_X509_CRL_sign);
        if (tmp_called_name_9 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2334;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_15 = par_self;
        tmp_args_element_name_16 = LOOKUP_ATTRIBUTE(tmp_source_name_15, const_str_plain__crl);
        if (tmp_args_element_name_16 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_9);

            exception_lineno = 2334;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_key);
        tmp_source_name_16 = par_key;
        tmp_args_element_name_17 = LOOKUP_ATTRIBUTE(tmp_source_name_16, const_str_plain__pkey);
        if (tmp_args_element_name_17 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_9);
            Py_DECREF(tmp_args_element_name_16);

            exception_lineno = 2334;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_digest_obj);
        tmp_args_element_name_18 = var_digest_obj;
        frame_63d5d54775413644d68413130bf8b01c->m_frame.f_lineno = 2334;
        {
            PyObject *call_args[] = {tmp_args_element_name_16, tmp_args_element_name_17, tmp_args_element_name_18};
            tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_9, call_args);
        }

        Py_DECREF(tmp_called_name_9);
        Py_DECREF(tmp_args_element_name_16);
        Py_DECREF(tmp_args_element_name_17);
        if (tmp_assign_source_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2334;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_sign_result == NULL);
        var_sign_result = tmp_assign_source_4;
    }
    {
        nuitka_bool tmp_condition_result_6;
        PyObject *tmp_operand_name_4;
        CHECK_OBJECT(var_sign_result);
        tmp_operand_name_4 = var_sign_result;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_4);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2335;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_6 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_6 == NUITKA_BOOL_TRUE) {
            goto branch_yes_6;
        } else {
            goto branch_no_6;
        }
        branch_yes_6:;
        {
            PyObject *tmp_called_name_10;
            PyObject *tmp_mvar_value_20;
            PyObject *tmp_call_result_8;
            tmp_mvar_value_20 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error);

            if (unlikely(tmp_mvar_value_20 == NULL)) {
                tmp_mvar_value_20 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error);
            }

            if (tmp_mvar_value_20 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 0 ], 49, 0);
                exception_tb = NULL;

                exception_lineno = 2336;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_10 = tmp_mvar_value_20;
            frame_63d5d54775413644d68413130bf8b01c->m_frame.f_lineno = 2336;
            tmp_call_result_8 = CALL_FUNCTION_NO_ARGS(tmp_called_name_10);
            if (tmp_call_result_8 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2336;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_8);
        }
        branch_no_6:;
    }
    {
        PyObject *tmp_called_name_11;
        PyObject *tmp_mvar_value_21;
        PyObject *tmp_args_element_name_19;
        PyObject *tmp_args_element_name_20;
        tmp_mvar_value_21 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_dump_crl);

        if (unlikely(tmp_mvar_value_21 == NULL)) {
            tmp_mvar_value_21 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_dump_crl);
        }

        if (tmp_mvar_value_21 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 4173 ], 37, 0);
            exception_tb = NULL;

            exception_lineno = 2338;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_11 = tmp_mvar_value_21;
        CHECK_OBJECT(par_type);
        tmp_args_element_name_19 = par_type;
        CHECK_OBJECT(par_self);
        tmp_args_element_name_20 = par_self;
        frame_63d5d54775413644d68413130bf8b01c->m_frame.f_lineno = 2338;
        {
            PyObject *call_args[] = {tmp_args_element_name_19, tmp_args_element_name_20};
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_11, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2338;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_63d5d54775413644d68413130bf8b01c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_63d5d54775413644d68413130bf8b01c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_63d5d54775413644d68413130bf8b01c);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_63d5d54775413644d68413130bf8b01c, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_63d5d54775413644d68413130bf8b01c->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_63d5d54775413644d68413130bf8b01c, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_63d5d54775413644d68413130bf8b01c,
        type_description_1,
        par_self,
        par_cert,
        par_key,
        par_type,
        par_days,
        par_digest,
        var_bio,
        var_sometime,
        var_digest_obj,
        var_sign_result
    );


    // Release cached frame.
    if (frame_63d5d54775413644d68413130bf8b01c == cache_frame_63d5d54775413644d68413130bf8b01c) {
        Py_DECREF(frame_63d5d54775413644d68413130bf8b01c);
    }
    cache_frame_63d5d54775413644d68413130bf8b01c = NULL;

    assertFrameObject(frame_63d5d54775413644d68413130bf8b01c);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_121_export);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_bio);
    Py_DECREF(var_bio);
    var_bio = NULL;

    CHECK_OBJECT((PyObject *)var_sometime);
    Py_DECREF(var_sometime);
    var_sometime = NULL;

    CHECK_OBJECT((PyObject *)var_digest_obj);
    Py_DECREF(var_digest_obj);
    var_digest_obj = NULL;

    CHECK_OBJECT((PyObject *)var_sign_result);
    Py_DECREF(var_sign_result);
    var_sign_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_bio);
    var_bio = NULL;

    Py_XDECREF(var_sometime);
    var_sometime = NULL;

    Py_XDECREF(var_digest_obj);
    var_digest_obj = NULL;

    Py_XDECREF(var_sign_result);
    var_sign_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_121_export);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_days);
    Py_DECREF(par_days);
    CHECK_OBJECT(par_cert);
    Py_DECREF(par_cert);
    CHECK_OBJECT(par_key);
    Py_DECREF(par_key);
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);
    CHECK_OBJECT(par_digest);
    Py_DECREF(par_digest);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_days);
    Py_DECREF(par_days);
    CHECK_OBJECT(par_cert);
    Py_DECREF(par_cert);
    CHECK_OBJECT(par_key);
    Py_DECREF(par_key);
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);
    CHECK_OBJECT(par_digest);
    Py_DECREF(par_digest);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_122_type_is_signed(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_3675b56e8a472299e465a6cac7a20233;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_3675b56e8a472299e465a6cac7a20233 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_3675b56e8a472299e465a6cac7a20233, codeobj_3675b56e8a472299e465a6cac7a20233, module_OpenSSL$crypto, sizeof(void *));
    frame_3675b56e8a472299e465a6cac7a20233 = cache_frame_3675b56e8a472299e465a6cac7a20233;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_3675b56e8a472299e465a6cac7a20233);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_3675b56e8a472299e465a6cac7a20233) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_value_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2355;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_PKCS7_type_is_signed);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2355;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__pkcs7);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2355;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_3675b56e8a472299e465a6cac7a20233->m_frame.f_lineno = 2355;
        tmp_value_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_value_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2355;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_value_name_1);
        Py_DECREF(tmp_value_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2355;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = (tmp_res != 0) ? Py_True : Py_False;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3675b56e8a472299e465a6cac7a20233);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_3675b56e8a472299e465a6cac7a20233);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3675b56e8a472299e465a6cac7a20233);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_3675b56e8a472299e465a6cac7a20233, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_3675b56e8a472299e465a6cac7a20233->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_3675b56e8a472299e465a6cac7a20233, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3675b56e8a472299e465a6cac7a20233,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_3675b56e8a472299e465a6cac7a20233 == cache_frame_3675b56e8a472299e465a6cac7a20233) {
        Py_DECREF(frame_3675b56e8a472299e465a6cac7a20233);
    }
    cache_frame_3675b56e8a472299e465a6cac7a20233 = NULL;

    assertFrameObject(frame_3675b56e8a472299e465a6cac7a20233);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_122_type_is_signed);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_123_type_is_enveloped(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_404049e2a875869f38e29055c42cb643;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_404049e2a875869f38e29055c42cb643 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_404049e2a875869f38e29055c42cb643, codeobj_404049e2a875869f38e29055c42cb643, module_OpenSSL$crypto, sizeof(void *));
    frame_404049e2a875869f38e29055c42cb643 = cache_frame_404049e2a875869f38e29055c42cb643;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_404049e2a875869f38e29055c42cb643);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_404049e2a875869f38e29055c42cb643) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_value_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2363;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_PKCS7_type_is_enveloped);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2363;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__pkcs7);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2363;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_404049e2a875869f38e29055c42cb643->m_frame.f_lineno = 2363;
        tmp_value_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_value_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2363;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_value_name_1);
        Py_DECREF(tmp_value_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2363;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = (tmp_res != 0) ? Py_True : Py_False;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_404049e2a875869f38e29055c42cb643);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_404049e2a875869f38e29055c42cb643);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_404049e2a875869f38e29055c42cb643);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_404049e2a875869f38e29055c42cb643, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_404049e2a875869f38e29055c42cb643->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_404049e2a875869f38e29055c42cb643, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_404049e2a875869f38e29055c42cb643,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_404049e2a875869f38e29055c42cb643 == cache_frame_404049e2a875869f38e29055c42cb643) {
        Py_DECREF(frame_404049e2a875869f38e29055c42cb643);
    }
    cache_frame_404049e2a875869f38e29055c42cb643 = NULL;

    assertFrameObject(frame_404049e2a875869f38e29055c42cb643);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_123_type_is_enveloped);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_124_type_is_signedAndEnveloped(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_03c4cee92a073dc3714d696db7ba0ad3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_03c4cee92a073dc3714d696db7ba0ad3 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_03c4cee92a073dc3714d696db7ba0ad3, codeobj_03c4cee92a073dc3714d696db7ba0ad3, module_OpenSSL$crypto, sizeof(void *));
    frame_03c4cee92a073dc3714d696db7ba0ad3 = cache_frame_03c4cee92a073dc3714d696db7ba0ad3;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_03c4cee92a073dc3714d696db7ba0ad3);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_03c4cee92a073dc3714d696db7ba0ad3) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_value_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2371;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_PKCS7_type_is_signedAndEnveloped);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2371;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__pkcs7);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2371;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_03c4cee92a073dc3714d696db7ba0ad3->m_frame.f_lineno = 2371;
        tmp_value_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_value_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2371;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_value_name_1);
        Py_DECREF(tmp_value_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2371;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = (tmp_res != 0) ? Py_True : Py_False;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_03c4cee92a073dc3714d696db7ba0ad3);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_03c4cee92a073dc3714d696db7ba0ad3);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_03c4cee92a073dc3714d696db7ba0ad3);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_03c4cee92a073dc3714d696db7ba0ad3, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_03c4cee92a073dc3714d696db7ba0ad3->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_03c4cee92a073dc3714d696db7ba0ad3, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_03c4cee92a073dc3714d696db7ba0ad3,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_03c4cee92a073dc3714d696db7ba0ad3 == cache_frame_03c4cee92a073dc3714d696db7ba0ad3) {
        Py_DECREF(frame_03c4cee92a073dc3714d696db7ba0ad3);
    }
    cache_frame_03c4cee92a073dc3714d696db7ba0ad3 = NULL;

    assertFrameObject(frame_03c4cee92a073dc3714d696db7ba0ad3);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_124_type_is_signedAndEnveloped);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_125_type_is_data(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_9bf9cf1b8da4c938f3ae767506473565;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_9bf9cf1b8da4c938f3ae767506473565 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_9bf9cf1b8da4c938f3ae767506473565, codeobj_9bf9cf1b8da4c938f3ae767506473565, module_OpenSSL$crypto, sizeof(void *));
    frame_9bf9cf1b8da4c938f3ae767506473565 = cache_frame_9bf9cf1b8da4c938f3ae767506473565;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_9bf9cf1b8da4c938f3ae767506473565);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_9bf9cf1b8da4c938f3ae767506473565) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_value_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2379;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_PKCS7_type_is_data);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2379;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__pkcs7);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2379;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_9bf9cf1b8da4c938f3ae767506473565->m_frame.f_lineno = 2379;
        tmp_value_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_value_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2379;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_value_name_1);
        Py_DECREF(tmp_value_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2379;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = (tmp_res != 0) ? Py_True : Py_False;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9bf9cf1b8da4c938f3ae767506473565);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_9bf9cf1b8da4c938f3ae767506473565);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9bf9cf1b8da4c938f3ae767506473565);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_9bf9cf1b8da4c938f3ae767506473565, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_9bf9cf1b8da4c938f3ae767506473565->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_9bf9cf1b8da4c938f3ae767506473565, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9bf9cf1b8da4c938f3ae767506473565,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_9bf9cf1b8da4c938f3ae767506473565 == cache_frame_9bf9cf1b8da4c938f3ae767506473565) {
        Py_DECREF(frame_9bf9cf1b8da4c938f3ae767506473565);
    }
    cache_frame_9bf9cf1b8da4c938f3ae767506473565 = NULL;

    assertFrameObject(frame_9bf9cf1b8da4c938f3ae767506473565);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_125_type_is_data);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_126_get_type_name(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_string_type = NULL;
    PyObject *var_nid = NULL;
    struct Nuitka_FrameObject *frame_c084b3860bf0d3247773b3ddb209b309;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_c084b3860bf0d3247773b3ddb209b309 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_c084b3860bf0d3247773b3ddb209b309, codeobj_c084b3860bf0d3247773b3ddb209b309, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_c084b3860bf0d3247773b3ddb209b309 = cache_frame_c084b3860bf0d3247773b3ddb209b309;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_c084b3860bf0d3247773b3ddb209b309);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_c084b3860bf0d3247773b3ddb209b309) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_source_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2387;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_OBJ_obj2nid);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2387;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_source_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__pkcs7);
        if (tmp_source_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2387;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_type);
        Py_DECREF(tmp_source_name_2);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2387;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_c084b3860bf0d3247773b3ddb209b309->m_frame.f_lineno = 2387;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2387;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_nid == NULL);
        var_nid = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2388;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_2;
        CHECK_OBJECT(var_nid);
        tmp_args_element_name_2 = var_nid;
        frame_c084b3860bf0d3247773b3ddb209b309->m_frame.f_lineno = 2388;
        {
            PyObject *call_args[] = {tmp_args_element_name_2};
            tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_OBJ_nid2sn, call_args);
        }

        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2388;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_string_type == NULL);
        var_string_type = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2389;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_3;
        CHECK_OBJECT(var_string_type);
        tmp_args_element_name_3 = var_string_type;
        frame_c084b3860bf0d3247773b3ddb209b309->m_frame.f_lineno = 2389;
        {
            PyObject *call_args[] = {tmp_args_element_name_3};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_string, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2389;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c084b3860bf0d3247773b3ddb209b309);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_c084b3860bf0d3247773b3ddb209b309);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c084b3860bf0d3247773b3ddb209b309);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_c084b3860bf0d3247773b3ddb209b309, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_c084b3860bf0d3247773b3ddb209b309->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_c084b3860bf0d3247773b3ddb209b309, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c084b3860bf0d3247773b3ddb209b309,
        type_description_1,
        par_self,
        var_string_type,
        var_nid
    );


    // Release cached frame.
    if (frame_c084b3860bf0d3247773b3ddb209b309 == cache_frame_c084b3860bf0d3247773b3ddb209b309) {
        Py_DECREF(frame_c084b3860bf0d3247773b3ddb209b309);
    }
    cache_frame_c084b3860bf0d3247773b3ddb209b309 = NULL;

    assertFrameObject(frame_c084b3860bf0d3247773b3ddb209b309);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_126_get_type_name);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_string_type);
    Py_DECREF(var_string_type);
    var_string_type = NULL;

    CHECK_OBJECT((PyObject *)var_nid);
    Py_DECREF(var_nid);
    var_nid = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_string_type);
    var_string_type = NULL;

    Py_XDECREF(var_nid);
    var_nid = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_126_get_type_name);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_127___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_c90140b7a0c346bc70320cca292002db;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_c90140b7a0c346bc70320cca292002db = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_c90140b7a0c346bc70320cca292002db, codeobj_c90140b7a0c346bc70320cca292002db, module_OpenSSL$crypto, sizeof(void *));
    frame_c90140b7a0c346bc70320cca292002db = cache_frame_c90140b7a0c346bc70320cca292002db;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_c90140b7a0c346bc70320cca292002db);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_c90140b7a0c346bc70320cca292002db) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        tmp_assattr_name_1 = Py_None;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__pkey, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2405;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        tmp_assattr_name_2 = Py_None;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain__cert, tmp_assattr_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2406;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_assattr_target_3;
        tmp_assattr_name_3 = Py_None;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_3 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_3, const_str_plain__cacerts, tmp_assattr_name_3);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2407;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_4;
        PyObject *tmp_assattr_target_4;
        tmp_assattr_name_4 = Py_None;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_4 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_4, const_str_plain__friendlyname, tmp_assattr_name_4);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2408;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c90140b7a0c346bc70320cca292002db);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c90140b7a0c346bc70320cca292002db);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_c90140b7a0c346bc70320cca292002db, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_c90140b7a0c346bc70320cca292002db->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_c90140b7a0c346bc70320cca292002db, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c90140b7a0c346bc70320cca292002db,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_c90140b7a0c346bc70320cca292002db == cache_frame_c90140b7a0c346bc70320cca292002db) {
        Py_DECREF(frame_c90140b7a0c346bc70320cca292002db);
    }
    cache_frame_c90140b7a0c346bc70320cca292002db = NULL;

    assertFrameObject(frame_c90140b7a0c346bc70320cca292002db);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_127___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_128_get_certificate(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_b9f83c00bb65fd2c7bce3d5bc80d9004;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_b9f83c00bb65fd2c7bce3d5bc80d9004 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_b9f83c00bb65fd2c7bce3d5bc80d9004, codeobj_b9f83c00bb65fd2c7bce3d5bc80d9004, module_OpenSSL$crypto, sizeof(void *));
    frame_b9f83c00bb65fd2c7bce3d5bc80d9004 = cache_frame_b9f83c00bb65fd2c7bce3d5bc80d9004;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_b9f83c00bb65fd2c7bce3d5bc80d9004);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_b9f83c00bb65fd2c7bce3d5bc80d9004) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_return_value = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__cert);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2417;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b9f83c00bb65fd2c7bce3d5bc80d9004);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_b9f83c00bb65fd2c7bce3d5bc80d9004);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b9f83c00bb65fd2c7bce3d5bc80d9004);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_b9f83c00bb65fd2c7bce3d5bc80d9004, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_b9f83c00bb65fd2c7bce3d5bc80d9004->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_b9f83c00bb65fd2c7bce3d5bc80d9004, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b9f83c00bb65fd2c7bce3d5bc80d9004,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_b9f83c00bb65fd2c7bce3d5bc80d9004 == cache_frame_b9f83c00bb65fd2c7bce3d5bc80d9004) {
        Py_DECREF(frame_b9f83c00bb65fd2c7bce3d5bc80d9004);
    }
    cache_frame_b9f83c00bb65fd2c7bce3d5bc80d9004 = NULL;

    assertFrameObject(frame_b9f83c00bb65fd2c7bce3d5bc80d9004);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_128_get_certificate);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_129_set_certificate(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_cert = python_pars[1];
    struct Nuitka_FrameObject *frame_999486723fe5c8277b4a8914c9586c78;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_999486723fe5c8277b4a8914c9586c78 = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_999486723fe5c8277b4a8914c9586c78, codeobj_999486723fe5c8277b4a8914c9586c78, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *));
    frame_999486723fe5c8277b4a8914c9586c78 = cache_frame_999486723fe5c8277b4a8914c9586c78;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_999486723fe5c8277b4a8914c9586c78);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_999486723fe5c8277b4a8914c9586c78) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_cert);
        tmp_isinstance_inst_1 = par_cert;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 236 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2428;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2428;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2428;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_c804b213c384a15865e18bf31cfff70e;
            frame_999486723fe5c8277b4a8914c9586c78->m_frame.f_lineno = 2429;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 2429;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_cert);
        tmp_assattr_name_1 = par_cert;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__cert, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2430;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_999486723fe5c8277b4a8914c9586c78);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_999486723fe5c8277b4a8914c9586c78);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_999486723fe5c8277b4a8914c9586c78, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_999486723fe5c8277b4a8914c9586c78->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_999486723fe5c8277b4a8914c9586c78, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_999486723fe5c8277b4a8914c9586c78,
        type_description_1,
        par_self,
        par_cert
    );


    // Release cached frame.
    if (frame_999486723fe5c8277b4a8914c9586c78 == cache_frame_999486723fe5c8277b4a8914c9586c78) {
        Py_DECREF(frame_999486723fe5c8277b4a8914c9586c78);
    }
    cache_frame_999486723fe5c8277b4a8914c9586c78 = NULL;

    assertFrameObject(frame_999486723fe5c8277b4a8914c9586c78);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_129_set_certificate);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_cert);
    Py_DECREF(par_cert);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_cert);
    Py_DECREF(par_cert);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_130_get_privatekey(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_426fef8004659e269aa693019fc0f0fd;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_426fef8004659e269aa693019fc0f0fd = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_426fef8004659e269aa693019fc0f0fd, codeobj_426fef8004659e269aa693019fc0f0fd, module_OpenSSL$crypto, sizeof(void *));
    frame_426fef8004659e269aa693019fc0f0fd = cache_frame_426fef8004659e269aa693019fc0f0fd;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_426fef8004659e269aa693019fc0f0fd);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_426fef8004659e269aa693019fc0f0fd) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_return_value = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__pkey);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2439;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_426fef8004659e269aa693019fc0f0fd);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_426fef8004659e269aa693019fc0f0fd);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_426fef8004659e269aa693019fc0f0fd);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_426fef8004659e269aa693019fc0f0fd, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_426fef8004659e269aa693019fc0f0fd->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_426fef8004659e269aa693019fc0f0fd, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_426fef8004659e269aa693019fc0f0fd,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_426fef8004659e269aa693019fc0f0fd == cache_frame_426fef8004659e269aa693019fc0f0fd) {
        Py_DECREF(frame_426fef8004659e269aa693019fc0f0fd);
    }
    cache_frame_426fef8004659e269aa693019fc0f0fd = NULL;

    assertFrameObject(frame_426fef8004659e269aa693019fc0f0fd);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_130_get_privatekey);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_131_set_privatekey(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_pkey = python_pars[1];
    struct Nuitka_FrameObject *frame_f40f51dde7e8f7585957d7400a166b67;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_f40f51dde7e8f7585957d7400a166b67 = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_f40f51dde7e8f7585957d7400a166b67, codeobj_f40f51dde7e8f7585957d7400a166b67, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *));
    frame_f40f51dde7e8f7585957d7400a166b67 = cache_frame_f40f51dde7e8f7585957d7400a166b67;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_f40f51dde7e8f7585957d7400a166b67);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_f40f51dde7e8f7585957d7400a166b67) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_pkey);
        tmp_isinstance_inst_1 = par_pkey;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 978 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2450;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2450;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2450;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_499043b9b2da602637f07b1aa101ddfb;
            frame_f40f51dde7e8f7585957d7400a166b67->m_frame.f_lineno = 2451;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 2451;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_pkey);
        tmp_assattr_name_1 = par_pkey;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__pkey, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2452;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_f40f51dde7e8f7585957d7400a166b67);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_f40f51dde7e8f7585957d7400a166b67);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_f40f51dde7e8f7585957d7400a166b67, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_f40f51dde7e8f7585957d7400a166b67->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_f40f51dde7e8f7585957d7400a166b67, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f40f51dde7e8f7585957d7400a166b67,
        type_description_1,
        par_self,
        par_pkey
    );


    // Release cached frame.
    if (frame_f40f51dde7e8f7585957d7400a166b67 == cache_frame_f40f51dde7e8f7585957d7400a166b67) {
        Py_DECREF(frame_f40f51dde7e8f7585957d7400a166b67);
    }
    cache_frame_f40f51dde7e8f7585957d7400a166b67 = NULL;

    assertFrameObject(frame_f40f51dde7e8f7585957d7400a166b67);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_131_set_privatekey);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_pkey);
    Py_DECREF(par_pkey);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_pkey);
    Py_DECREF(par_pkey);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_132_get_ca_certificates(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_cdc04db7a74dd11ea6b2177a19c32798;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_cdc04db7a74dd11ea6b2177a19c32798 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_cdc04db7a74dd11ea6b2177a19c32798, codeobj_cdc04db7a74dd11ea6b2177a19c32798, module_OpenSSL$crypto, sizeof(void *));
    frame_cdc04db7a74dd11ea6b2177a19c32798 = cache_frame_cdc04db7a74dd11ea6b2177a19c32798;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_cdc04db7a74dd11ea6b2177a19c32798);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_cdc04db7a74dd11ea6b2177a19c32798) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__cacerts);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2462;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 != tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_compexpr_left_1);
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_tuple_arg_1;
            PyObject *tmp_source_name_2;
            CHECK_OBJECT(par_self);
            tmp_source_name_2 = par_self;
            tmp_tuple_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__cacerts);
            if (tmp_tuple_arg_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2463;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            tmp_return_value = PySequence_Tuple(tmp_tuple_arg_1);
            Py_DECREF(tmp_tuple_arg_1);
            if (tmp_return_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2463;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_cdc04db7a74dd11ea6b2177a19c32798);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_cdc04db7a74dd11ea6b2177a19c32798);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_cdc04db7a74dd11ea6b2177a19c32798);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_cdc04db7a74dd11ea6b2177a19c32798, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_cdc04db7a74dd11ea6b2177a19c32798->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_cdc04db7a74dd11ea6b2177a19c32798, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_cdc04db7a74dd11ea6b2177a19c32798,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_cdc04db7a74dd11ea6b2177a19c32798 == cache_frame_cdc04db7a74dd11ea6b2177a19c32798) {
        Py_DECREF(frame_cdc04db7a74dd11ea6b2177a19c32798);
    }
    cache_frame_cdc04db7a74dd11ea6b2177a19c32798 = NULL;

    assertFrameObject(frame_cdc04db7a74dd11ea6b2177a19c32798);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_132_get_ca_certificates);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_133_set_ca_certificates(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_cacerts = python_pars[1];
    PyObject *var_cert = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_75232e283be8a43fe94949460ca59119;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_75232e283be8a43fe94949460ca59119 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_75232e283be8a43fe94949460ca59119, codeobj_75232e283be8a43fe94949460ca59119, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_75232e283be8a43fe94949460ca59119 = cache_frame_75232e283be8a43fe94949460ca59119;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_75232e283be8a43fe94949460ca59119);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_75232e283be8a43fe94949460ca59119) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_cacerts);
        tmp_compexpr_left_1 = par_cacerts;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assattr_name_1;
            PyObject *tmp_assattr_target_1;
            tmp_assattr_name_1 = Py_None;
            CHECK_OBJECT(par_self);
            tmp_assattr_target_1 = par_self;
            tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__cacerts, tmp_assattr_name_1);
            if (tmp_result == false) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2476;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_list_arg_1;
            CHECK_OBJECT(par_cacerts);
            tmp_list_arg_1 = par_cacerts;
            tmp_assign_source_1 = PySequence_List(tmp_list_arg_1);
            if (tmp_assign_source_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2478;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_cacerts;
                assert(old != NULL);
                par_cacerts = tmp_assign_source_1;
                Py_DECREF(old);
            }

        }
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT(par_cacerts);
            tmp_iter_arg_1 = par_cacerts;
            tmp_assign_source_2 = MAKE_ITERATOR(tmp_iter_arg_1);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2479;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            assert(tmp_for_loop_1__for_iterator == NULL);
            tmp_for_loop_1__for_iterator = tmp_assign_source_2;
        }
        // Tried code:
        loop_start_1:;
        {
            PyObject *tmp_next_source_1;
            PyObject *tmp_assign_source_3;
            CHECK_OBJECT(tmp_for_loop_1__for_iterator);
            tmp_next_source_1 = tmp_for_loop_1__for_iterator;
            tmp_assign_source_3 = ITERATOR_NEXT(tmp_next_source_1);
            if (tmp_assign_source_3 == NULL) {
                if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                    goto loop_end_1;
                } else {

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    type_description_1 = "ooo";
                    exception_lineno = 2479;
                    goto try_except_handler_2;
                }
            }

            {
                PyObject *old = tmp_for_loop_1__iter_value;
                tmp_for_loop_1__iter_value = tmp_assign_source_3;
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_assign_source_4;
            CHECK_OBJECT(tmp_for_loop_1__iter_value);
            tmp_assign_source_4 = tmp_for_loop_1__iter_value;
            {
                PyObject *old = var_cert;
                var_cert = tmp_assign_source_4;
                Py_INCREF(var_cert);
                Py_XDECREF(old);
            }

        }
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_operand_name_1;
            PyObject *tmp_isinstance_inst_1;
            PyObject *tmp_isinstance_cls_1;
            PyObject *tmp_mvar_value_1;
            CHECK_OBJECT(var_cert);
            tmp_isinstance_inst_1 = var_cert;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509);

            if (unlikely(tmp_mvar_value_1 == NULL)) {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509);
            }

            if (tmp_mvar_value_1 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 236 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 2480;
                type_description_1 = "ooo";
                goto try_except_handler_2;
            }

            tmp_isinstance_cls_1 = tmp_mvar_value_1;
            tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2480;
                type_description_1 = "ooo";
                goto try_except_handler_2;
            }
            tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2480;
                type_description_1 = "ooo";
                goto try_except_handler_2;
            }
            tmp_condition_result_2 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
                goto branch_yes_2;
            } else {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_raise_type_1;
                PyObject *tmp_make_exception_arg_1;
                tmp_make_exception_arg_1 = const_str_digest_1691c1bfd96a22cfc48aca410da45814;
                frame_75232e283be8a43fe94949460ca59119->m_frame.f_lineno = 2481;
                tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
                assert(!(tmp_raise_type_1 == NULL));
                exception_type = tmp_raise_type_1;
                exception_lineno = 2481;
                RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "ooo";
                goto try_except_handler_2;
            }
            branch_no_2:;
        }
        if (CONSIDER_THREADING() == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2479;
            type_description_1 = "ooo";
            goto try_except_handler_2;
        }
        goto loop_start_1;
        loop_end_1:;
        goto try_end_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF(tmp_for_loop_1__iter_value);
        tmp_for_loop_1__iter_value = NULL;

        CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
        Py_DECREF(tmp_for_loop_1__for_iterator);
        tmp_for_loop_1__for_iterator = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto frame_exception_exit_1;
        // End of try:
        try_end_1:;
        Py_XDECREF(tmp_for_loop_1__iter_value);
        tmp_for_loop_1__iter_value = NULL;

        CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
        Py_DECREF(tmp_for_loop_1__for_iterator);
        tmp_for_loop_1__for_iterator = NULL;

        {
            PyObject *tmp_assattr_name_2;
            PyObject *tmp_assattr_target_2;
            CHECK_OBJECT(par_cacerts);
            tmp_assattr_name_2 = par_cacerts;
            CHECK_OBJECT(par_self);
            tmp_assattr_target_2 = par_self;
            tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain__cacerts, tmp_assattr_name_2);
            if (tmp_result == false) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2484;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_75232e283be8a43fe94949460ca59119);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_75232e283be8a43fe94949460ca59119);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_75232e283be8a43fe94949460ca59119, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_75232e283be8a43fe94949460ca59119->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_75232e283be8a43fe94949460ca59119, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_75232e283be8a43fe94949460ca59119,
        type_description_1,
        par_self,
        par_cacerts,
        var_cert
    );


    // Release cached frame.
    if (frame_75232e283be8a43fe94949460ca59119 == cache_frame_75232e283be8a43fe94949460ca59119) {
        Py_DECREF(frame_75232e283be8a43fe94949460ca59119);
    }
    cache_frame_75232e283be8a43fe94949460ca59119 = NULL;

    assertFrameObject(frame_75232e283be8a43fe94949460ca59119);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_133_set_ca_certificates);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_cert);
    var_cert = NULL;

    CHECK_OBJECT((PyObject *)par_cacerts);
    Py_DECREF(par_cacerts);
    par_cacerts = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_cert);
    var_cert = NULL;

    CHECK_OBJECT((PyObject *)par_cacerts);
    Py_DECREF(par_cacerts);
    par_cacerts = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_133_set_ca_certificates);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_134_set_friendlyname(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_name = python_pars[1];
    struct Nuitka_FrameObject *frame_60a54c7eb9de93d0fd2fe53bbdafcf10;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_60a54c7eb9de93d0fd2fe53bbdafcf10 = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_60a54c7eb9de93d0fd2fe53bbdafcf10, codeobj_60a54c7eb9de93d0fd2fe53bbdafcf10, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *));
    frame_60a54c7eb9de93d0fd2fe53bbdafcf10 = cache_frame_60a54c7eb9de93d0fd2fe53bbdafcf10;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_60a54c7eb9de93d0fd2fe53bbdafcf10);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_60a54c7eb9de93d0fd2fe53bbdafcf10) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_name);
        tmp_compexpr_left_1 = par_name;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assattr_name_1;
            PyObject *tmp_assattr_target_1;
            tmp_assattr_name_1 = Py_None;
            CHECK_OBJECT(par_self);
            tmp_assattr_target_1 = par_self;
            tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__friendlyname, tmp_assattr_name_1);
            if (tmp_result == false) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2496;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
        }
        goto branch_end_1;
        branch_no_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_operand_name_1;
            PyObject *tmp_isinstance_inst_1;
            PyObject *tmp_isinstance_cls_1;
            CHECK_OBJECT(par_name);
            tmp_isinstance_inst_1 = par_name;
            tmp_isinstance_cls_1 = (PyObject *)&PyString_Type;
            tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2497;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2497;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
                goto branch_yes_2;
            } else {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_raise_type_1;
                PyObject *tmp_make_exception_arg_1;
                PyObject *tmp_left_name_1;
                PyObject *tmp_right_name_1;
                PyObject *tmp_tuple_element_1;
                tmp_left_name_1 = const_str_digest_d7980f3a0e05fb43bc9ed0fa0707a2f9;
                CHECK_OBJECT(par_name);
                tmp_tuple_element_1 = par_name;
                tmp_right_name_1 = PyTuple_New(1);
                Py_INCREF(tmp_tuple_element_1);
                PyTuple_SET_ITEM(tmp_right_name_1, 0, tmp_tuple_element_1);
                tmp_make_exception_arg_1 = BINARY_OPERATION_MOD_STR_TUPLE(tmp_left_name_1, tmp_right_name_1);
                Py_DECREF(tmp_right_name_1);
                if (tmp_make_exception_arg_1 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2499;
                    type_description_1 = "oo";
                    goto frame_exception_exit_1;
                }
                frame_60a54c7eb9de93d0fd2fe53bbdafcf10->m_frame.f_lineno = 2498;
                tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
                Py_DECREF(tmp_make_exception_arg_1);
                assert(!(tmp_raise_type_1 == NULL));
                exception_type = tmp_raise_type_1;
                exception_lineno = 2498;
                RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            branch_no_2:;
        }
        branch_end_1:;
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT(par_name);
        tmp_assattr_name_2 = par_name;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain__friendlyname, tmp_assattr_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2501;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_60a54c7eb9de93d0fd2fe53bbdafcf10);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_60a54c7eb9de93d0fd2fe53bbdafcf10);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_60a54c7eb9de93d0fd2fe53bbdafcf10, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_60a54c7eb9de93d0fd2fe53bbdafcf10->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_60a54c7eb9de93d0fd2fe53bbdafcf10, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_60a54c7eb9de93d0fd2fe53bbdafcf10,
        type_description_1,
        par_self,
        par_name
    );


    // Release cached frame.
    if (frame_60a54c7eb9de93d0fd2fe53bbdafcf10 == cache_frame_60a54c7eb9de93d0fd2fe53bbdafcf10) {
        Py_DECREF(frame_60a54c7eb9de93d0fd2fe53bbdafcf10);
    }
    cache_frame_60a54c7eb9de93d0fd2fe53bbdafcf10 = NULL;

    assertFrameObject(frame_60a54c7eb9de93d0fd2fe53bbdafcf10);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_134_set_friendlyname);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_name);
    Py_DECREF(par_name);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_name);
    Py_DECREF(par_name);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_135_get_friendlyname(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_295f1119c769c014813a47d7534945e3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_295f1119c769c014813a47d7534945e3 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_295f1119c769c014813a47d7534945e3, codeobj_295f1119c769c014813a47d7534945e3, module_OpenSSL$crypto, sizeof(void *));
    frame_295f1119c769c014813a47d7534945e3 = cache_frame_295f1119c769c014813a47d7534945e3;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_295f1119c769c014813a47d7534945e3);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_295f1119c769c014813a47d7534945e3) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_return_value = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__friendlyname);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2510;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_295f1119c769c014813a47d7534945e3);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_295f1119c769c014813a47d7534945e3);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_295f1119c769c014813a47d7534945e3);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_295f1119c769c014813a47d7534945e3, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_295f1119c769c014813a47d7534945e3->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_295f1119c769c014813a47d7534945e3, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_295f1119c769c014813a47d7534945e3,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_295f1119c769c014813a47d7534945e3 == cache_frame_295f1119c769c014813a47d7534945e3) {
        Py_DECREF(frame_295f1119c769c014813a47d7534945e3);
    }
    cache_frame_295f1119c769c014813a47d7534945e3 = NULL;

    assertFrameObject(frame_295f1119c769c014813a47d7534945e3);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_135_get_friendlyname);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_136_export(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_passphrase = python_pars[1];
    PyObject *par_iter = python_pars[2];
    PyObject *par_maciter = python_pars[3];
    PyObject *var_pkey = NULL;
    PyObject *var_bio = NULL;
    PyObject *var_cacerts = NULL;
    PyObject *var_cert = NULL;
    PyObject *var_friendlyname = NULL;
    PyObject *var_pkcs12 = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_e7cef9cdd61becb04e1edcd19e659b06;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_e7cef9cdd61becb04e1edcd19e659b06 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_e7cef9cdd61becb04e1edcd19e659b06, codeobj_e7cef9cdd61becb04e1edcd19e659b06, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_e7cef9cdd61becb04e1edcd19e659b06 = cache_frame_e7cef9cdd61becb04e1edcd19e659b06;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_e7cef9cdd61becb04e1edcd19e659b06);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_e7cef9cdd61becb04e1edcd19e659b06) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1011 ], 52, 0);
            exception_tb = NULL;

            exception_lineno = 2532;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        tmp_args_element_name_1 = const_str_plain_passphrase;
        CHECK_OBJECT(par_passphrase);
        tmp_args_element_name_2 = par_passphrase;
        frame_e7cef9cdd61becb04e1edcd19e659b06->m_frame.f_lineno = 2532;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2532;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = par_passphrase;
            assert(old != NULL);
            par_passphrase = tmp_assign_source_1;
            Py_DECREF(old);
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__cacerts);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2534;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_compexpr_left_1);
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_source_name_2;
            PyObject *tmp_mvar_value_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 2535;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_2 = tmp_mvar_value_2;
            tmp_assign_source_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_NULL);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2535;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }
            assert(var_cacerts == NULL);
            var_cacerts = tmp_assign_source_2;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_mvar_value_3;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_3 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 2537;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_1 = tmp_mvar_value_3;
            frame_e7cef9cdd61becb04e1edcd19e659b06->m_frame.f_lineno = 2537;
            tmp_assign_source_3 = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_sk_X509_new_null);
            if (tmp_assign_source_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2537;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }
            assert(var_cacerts == NULL);
            var_cacerts = tmp_assign_source_3;
        }
        {
            PyObject *tmp_assign_source_4;
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_3;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_source_name_4;
            PyObject *tmp_mvar_value_5;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_4 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 2538;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_3 = tmp_mvar_value_4;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_gc);
            if (tmp_called_name_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2538;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_cacerts);
            tmp_args_element_name_3 = var_cacerts;
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_5 == NULL)) {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_5 == NULL) {
                Py_DECREF(tmp_called_name_2);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 2538;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_4 = tmp_mvar_value_5;
            tmp_args_element_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_sk_X509_free);
            if (tmp_args_element_name_4 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_2);

                exception_lineno = 2538;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }
            frame_e7cef9cdd61becb04e1edcd19e659b06->m_frame.f_lineno = 2538;
            {
                PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4};
                tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
            }

            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_4);
            if (tmp_assign_source_4 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2538;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = var_cacerts;
                assert(old != NULL);
                var_cacerts = tmp_assign_source_4;
                Py_DECREF(old);
            }

        }
        {
            PyObject *tmp_assign_source_5;
            PyObject *tmp_iter_arg_1;
            PyObject *tmp_source_name_5;
            CHECK_OBJECT(par_self);
            tmp_source_name_5 = par_self;
            tmp_iter_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain__cacerts);
            if (tmp_iter_arg_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2539;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_assign_source_5 = MAKE_ITERATOR(tmp_iter_arg_1);
            Py_DECREF(tmp_iter_arg_1);
            if (tmp_assign_source_5 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2539;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }
            assert(tmp_for_loop_1__for_iterator == NULL);
            tmp_for_loop_1__for_iterator = tmp_assign_source_5;
        }
        // Tried code:
        loop_start_1:;
        {
            PyObject *tmp_next_source_1;
            PyObject *tmp_assign_source_6;
            CHECK_OBJECT(tmp_for_loop_1__for_iterator);
            tmp_next_source_1 = tmp_for_loop_1__for_iterator;
            tmp_assign_source_6 = ITERATOR_NEXT(tmp_next_source_1);
            if (tmp_assign_source_6 == NULL) {
                if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                    goto loop_end_1;
                } else {

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    type_description_1 = "oooooooooo";
                    exception_lineno = 2539;
                    goto try_except_handler_2;
                }
            }

            {
                PyObject *old = tmp_for_loop_1__iter_value;
                tmp_for_loop_1__iter_value = tmp_assign_source_6;
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_assign_source_7;
            CHECK_OBJECT(tmp_for_loop_1__iter_value);
            tmp_assign_source_7 = tmp_for_loop_1__iter_value;
            {
                PyObject *old = var_cert;
                var_cert = tmp_assign_source_7;
                Py_INCREF(var_cert);
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_called_name_3;
            PyObject *tmp_source_name_6;
            PyObject *tmp_mvar_value_6;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_5;
            PyObject *tmp_args_element_name_6;
            PyObject *tmp_source_name_7;
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_6 == NULL)) {
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_6 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 2540;
                type_description_1 = "oooooooooo";
                goto try_except_handler_2;
            }

            tmp_source_name_6 = tmp_mvar_value_6;
            tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_sk_X509_push);
            if (tmp_called_name_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2540;
                type_description_1 = "oooooooooo";
                goto try_except_handler_2;
            }
            CHECK_OBJECT(var_cacerts);
            tmp_args_element_name_5 = var_cacerts;
            CHECK_OBJECT(var_cert);
            tmp_source_name_7 = var_cert;
            tmp_args_element_name_6 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain__x509);
            if (tmp_args_element_name_6 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_3);

                exception_lineno = 2540;
                type_description_1 = "oooooooooo";
                goto try_except_handler_2;
            }
            frame_e7cef9cdd61becb04e1edcd19e659b06->m_frame.f_lineno = 2540;
            {
                PyObject *call_args[] = {tmp_args_element_name_5, tmp_args_element_name_6};
                tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_3, call_args);
            }

            Py_DECREF(tmp_called_name_3);
            Py_DECREF(tmp_args_element_name_6);
            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2540;
                type_description_1 = "oooooooooo";
                goto try_except_handler_2;
            }
            Py_DECREF(tmp_call_result_1);
        }
        if (CONSIDER_THREADING() == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2539;
            type_description_1 = "oooooooooo";
            goto try_except_handler_2;
        }
        goto loop_start_1;
        loop_end_1:;
        goto try_end_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF(tmp_for_loop_1__iter_value);
        tmp_for_loop_1__iter_value = NULL;

        CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
        Py_DECREF(tmp_for_loop_1__for_iterator);
        tmp_for_loop_1__for_iterator = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto frame_exception_exit_1;
        // End of try:
        try_end_1:;
        Py_XDECREF(tmp_for_loop_1__iter_value);
        tmp_for_loop_1__iter_value = NULL;

        CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
        Py_DECREF(tmp_for_loop_1__for_iterator);
        tmp_for_loop_1__for_iterator = NULL;

        branch_end_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        CHECK_OBJECT(par_passphrase);
        tmp_compexpr_left_2 = par_passphrase;
        tmp_compexpr_right_2 = Py_None;
        tmp_condition_result_2 = (tmp_compexpr_left_2 == tmp_compexpr_right_2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_8;
            PyObject *tmp_source_name_8;
            PyObject *tmp_mvar_value_7;
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_7 == NULL)) {
                tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_7 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 2543;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_8 = tmp_mvar_value_7;
            tmp_assign_source_8 = LOOKUP_ATTRIBUTE(tmp_source_name_8, const_str_plain_NULL);
            if (tmp_assign_source_8 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2543;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_passphrase;
                assert(old != NULL);
                par_passphrase = tmp_assign_source_8;
                Py_DECREF(old);
            }

        }
        branch_no_2:;
    }
    {
        PyObject *tmp_assign_source_9;
        PyObject *tmp_source_name_9;
        CHECK_OBJECT(par_self);
        tmp_source_name_9 = par_self;
        tmp_assign_source_9 = LOOKUP_ATTRIBUTE(tmp_source_name_9, const_str_plain__friendlyname);
        if (tmp_assign_source_9 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2545;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_friendlyname == NULL);
        var_friendlyname = tmp_assign_source_9;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        CHECK_OBJECT(var_friendlyname);
        tmp_compexpr_left_3 = var_friendlyname;
        tmp_compexpr_right_3 = Py_None;
        tmp_condition_result_3 = (tmp_compexpr_left_3 == tmp_compexpr_right_3) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
            goto branch_yes_3;
        } else {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_assign_source_10;
            PyObject *tmp_source_name_10;
            PyObject *tmp_mvar_value_8;
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_8 == NULL)) {
                tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_8 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 2547;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_10 = tmp_mvar_value_8;
            tmp_assign_source_10 = LOOKUP_ATTRIBUTE(tmp_source_name_10, const_str_plain_NULL);
            if (tmp_assign_source_10 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2547;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = var_friendlyname;
                assert(old != NULL);
                var_friendlyname = tmp_assign_source_10;
                Py_DECREF(old);
            }

        }
        branch_no_3:;
    }
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        PyObject *tmp_source_name_11;
        CHECK_OBJECT(par_self);
        tmp_source_name_11 = par_self;
        tmp_compexpr_left_4 = LOOKUP_ATTRIBUTE(tmp_source_name_11, const_str_plain__pkey);
        if (tmp_compexpr_left_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2549;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_4 = Py_None;
        tmp_condition_result_4 = (tmp_compexpr_left_4 == tmp_compexpr_right_4) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_compexpr_left_4);
        if (tmp_condition_result_4 == NUITKA_BOOL_TRUE) {
            goto branch_yes_4;
        } else {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_assign_source_11;
            PyObject *tmp_source_name_12;
            PyObject *tmp_mvar_value_9;
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_9 == NULL)) {
                tmp_mvar_value_9 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_9 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 2550;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_12 = tmp_mvar_value_9;
            tmp_assign_source_11 = LOOKUP_ATTRIBUTE(tmp_source_name_12, const_str_plain_NULL);
            if (tmp_assign_source_11 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2550;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }
            assert(var_pkey == NULL);
            var_pkey = tmp_assign_source_11;
        }
        goto branch_end_4;
        branch_no_4:;
        {
            PyObject *tmp_assign_source_12;
            PyObject *tmp_source_name_13;
            PyObject *tmp_source_name_14;
            CHECK_OBJECT(par_self);
            tmp_source_name_14 = par_self;
            tmp_source_name_13 = LOOKUP_ATTRIBUTE(tmp_source_name_14, const_str_plain__pkey);
            if (tmp_source_name_13 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2552;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_assign_source_12 = LOOKUP_ATTRIBUTE(tmp_source_name_13, const_str_plain__pkey);
            Py_DECREF(tmp_source_name_13);
            if (tmp_assign_source_12 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2552;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }
            assert(var_pkey == NULL);
            var_pkey = tmp_assign_source_12;
        }
        branch_end_4:;
    }
    {
        nuitka_bool tmp_condition_result_5;
        PyObject *tmp_compexpr_left_5;
        PyObject *tmp_compexpr_right_5;
        PyObject *tmp_source_name_15;
        CHECK_OBJECT(par_self);
        tmp_source_name_15 = par_self;
        tmp_compexpr_left_5 = LOOKUP_ATTRIBUTE(tmp_source_name_15, const_str_plain__cert);
        if (tmp_compexpr_left_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2554;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_5 = Py_None;
        tmp_condition_result_5 = (tmp_compexpr_left_5 == tmp_compexpr_right_5) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_compexpr_left_5);
        if (tmp_condition_result_5 == NUITKA_BOOL_TRUE) {
            goto branch_yes_5;
        } else {
            goto branch_no_5;
        }
        branch_yes_5:;
        {
            PyObject *tmp_assign_source_13;
            PyObject *tmp_source_name_16;
            PyObject *tmp_mvar_value_10;
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_10 == NULL)) {
                tmp_mvar_value_10 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_10 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 2555;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_16 = tmp_mvar_value_10;
            tmp_assign_source_13 = LOOKUP_ATTRIBUTE(tmp_source_name_16, const_str_plain_NULL);
            if (tmp_assign_source_13 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2555;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = var_cert;
                var_cert = tmp_assign_source_13;
                Py_XDECREF(old);
            }

        }
        goto branch_end_5;
        branch_no_5:;
        {
            PyObject *tmp_assign_source_14;
            PyObject *tmp_source_name_17;
            PyObject *tmp_source_name_18;
            CHECK_OBJECT(par_self);
            tmp_source_name_18 = par_self;
            tmp_source_name_17 = LOOKUP_ATTRIBUTE(tmp_source_name_18, const_str_plain__cert);
            if (tmp_source_name_17 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2557;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_assign_source_14 = LOOKUP_ATTRIBUTE(tmp_source_name_17, const_str_plain__x509);
            Py_DECREF(tmp_source_name_17);
            if (tmp_assign_source_14 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2557;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = var_cert;
                var_cert = tmp_assign_source_14;
                Py_XDECREF(old);
            }

        }
        branch_end_5:;
    }
    {
        PyObject *tmp_assign_source_15;
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_19;
        PyObject *tmp_mvar_value_11;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_args_element_name_11;
        PyObject *tmp_args_element_name_12;
        PyObject *tmp_source_name_20;
        PyObject *tmp_mvar_value_12;
        PyObject *tmp_args_element_name_13;
        PyObject *tmp_source_name_21;
        PyObject *tmp_mvar_value_13;
        PyObject *tmp_args_element_name_14;
        PyObject *tmp_args_element_name_15;
        PyObject *tmp_args_element_name_16;
        tmp_mvar_value_11 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_11 == NULL)) {
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_11 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2559;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_19 = tmp_mvar_value_11;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_19, const_str_plain_PKCS12_create);
        if (tmp_called_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2559;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_passphrase);
        tmp_args_element_name_7 = par_passphrase;
        CHECK_OBJECT(var_friendlyname);
        tmp_args_element_name_8 = var_friendlyname;
        CHECK_OBJECT(var_pkey);
        tmp_args_element_name_9 = var_pkey;
        CHECK_OBJECT(var_cert);
        tmp_args_element_name_10 = var_cert;
        CHECK_OBJECT(var_cacerts);
        tmp_args_element_name_11 = var_cacerts;
        tmp_mvar_value_12 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_12 == NULL)) {
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_12 == NULL) {
            Py_DECREF(tmp_called_name_4);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2561;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_20 = tmp_mvar_value_12;
        tmp_args_element_name_12 = LOOKUP_ATTRIBUTE(tmp_source_name_20, const_str_plain_NID_pbe_WithSHA1And3_Key_TripleDES_CBC);
        if (tmp_args_element_name_12 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_4);

            exception_lineno = 2561;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_13 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_13 == NULL)) {
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_13 == NULL) {
            Py_DECREF(tmp_called_name_4);
            Py_DECREF(tmp_args_element_name_12);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2562;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_21 = tmp_mvar_value_13;
        tmp_args_element_name_13 = LOOKUP_ATTRIBUTE(tmp_source_name_21, const_str_plain_NID_pbe_WithSHA1And3_Key_TripleDES_CBC);
        if (tmp_args_element_name_13 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_4);
            Py_DECREF(tmp_args_element_name_12);

            exception_lineno = 2562;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_iter);
        tmp_args_element_name_14 = par_iter;
        CHECK_OBJECT(par_maciter);
        tmp_args_element_name_15 = par_maciter;
        tmp_args_element_name_16 = const_int_0;
        frame_e7cef9cdd61becb04e1edcd19e659b06->m_frame.f_lineno = 2559;
        {
            PyObject *call_args[] = {tmp_args_element_name_7, tmp_args_element_name_8, tmp_args_element_name_9, tmp_args_element_name_10, tmp_args_element_name_11, tmp_args_element_name_12, tmp_args_element_name_13, tmp_args_element_name_14, tmp_args_element_name_15, tmp_args_element_name_16};
            tmp_assign_source_15 = CALL_FUNCTION_WITH_ARGS10(tmp_called_name_4, call_args);
        }

        Py_DECREF(tmp_called_name_4);
        Py_DECREF(tmp_args_element_name_12);
        Py_DECREF(tmp_args_element_name_13);
        if (tmp_assign_source_15 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2559;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_pkcs12 == NULL);
        var_pkcs12 = tmp_assign_source_15;
    }
    {
        nuitka_bool tmp_condition_result_6;
        PyObject *tmp_compexpr_left_6;
        PyObject *tmp_compexpr_right_6;
        PyObject *tmp_source_name_22;
        PyObject *tmp_mvar_value_14;
        CHECK_OBJECT(var_pkcs12);
        tmp_compexpr_left_6 = var_pkcs12;
        tmp_mvar_value_14 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_14 == NULL)) {
            tmp_mvar_value_14 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_14 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2564;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_22 = tmp_mvar_value_14;
        tmp_compexpr_right_6 = LOOKUP_ATTRIBUTE(tmp_source_name_22, const_str_plain_NULL);
        if (tmp_compexpr_right_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2564;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_6, tmp_compexpr_right_6);
        Py_DECREF(tmp_compexpr_right_6);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2564;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_6 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_6 == NUITKA_BOOL_TRUE) {
            goto branch_yes_6;
        } else {
            goto branch_no_6;
        }
        branch_yes_6:;
        {
            PyObject *tmp_called_name_5;
            PyObject *tmp_mvar_value_15;
            PyObject *tmp_call_result_2;
            tmp_mvar_value_15 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error);

            if (unlikely(tmp_mvar_value_15 == NULL)) {
                tmp_mvar_value_15 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error);
            }

            if (tmp_mvar_value_15 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 0 ], 49, 0);
                exception_tb = NULL;

                exception_lineno = 2565;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_5 = tmp_mvar_value_15;
            frame_e7cef9cdd61becb04e1edcd19e659b06->m_frame.f_lineno = 2565;
            tmp_call_result_2 = CALL_FUNCTION_NO_ARGS(tmp_called_name_5);
            if (tmp_call_result_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2565;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_2);
        }
        branch_no_6:;
    }
    {
        PyObject *tmp_assign_source_16;
        PyObject *tmp_called_name_6;
        PyObject *tmp_source_name_23;
        PyObject *tmp_mvar_value_16;
        PyObject *tmp_args_element_name_17;
        PyObject *tmp_args_element_name_18;
        PyObject *tmp_source_name_24;
        PyObject *tmp_mvar_value_17;
        tmp_mvar_value_16 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_16 == NULL)) {
            tmp_mvar_value_16 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_16 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2566;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_23 = tmp_mvar_value_16;
        tmp_called_name_6 = LOOKUP_ATTRIBUTE(tmp_source_name_23, const_str_plain_gc);
        if (tmp_called_name_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2566;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_pkcs12);
        tmp_args_element_name_17 = var_pkcs12;
        tmp_mvar_value_17 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_17 == NULL)) {
            tmp_mvar_value_17 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_17 == NULL) {
            Py_DECREF(tmp_called_name_6);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2566;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_24 = tmp_mvar_value_17;
        tmp_args_element_name_18 = LOOKUP_ATTRIBUTE(tmp_source_name_24, const_str_plain_PKCS12_free);
        if (tmp_args_element_name_18 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_6);

            exception_lineno = 2566;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        frame_e7cef9cdd61becb04e1edcd19e659b06->m_frame.f_lineno = 2566;
        {
            PyObject *call_args[] = {tmp_args_element_name_17, tmp_args_element_name_18};
            tmp_assign_source_16 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_6, call_args);
        }

        Py_DECREF(tmp_called_name_6);
        Py_DECREF(tmp_args_element_name_18);
        if (tmp_assign_source_16 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2566;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var_pkcs12;
            assert(old != NULL);
            var_pkcs12 = tmp_assign_source_16;
            Py_DECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_17;
        PyObject *tmp_called_name_7;
        PyObject *tmp_mvar_value_18;
        tmp_mvar_value_18 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf);

        if (unlikely(tmp_mvar_value_18 == NULL)) {
            tmp_mvar_value_18 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf);
        }

        if (tmp_mvar_value_18 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3591 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 2568;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_7 = tmp_mvar_value_18;
        frame_e7cef9cdd61becb04e1edcd19e659b06->m_frame.f_lineno = 2568;
        tmp_assign_source_17 = CALL_FUNCTION_NO_ARGS(tmp_called_name_7);
        if (tmp_assign_source_17 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2568;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_bio == NULL);
        var_bio = tmp_assign_source_17;
    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_19;
        PyObject *tmp_call_result_3;
        PyObject *tmp_args_element_name_19;
        PyObject *tmp_args_element_name_20;
        tmp_mvar_value_19 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_19 == NULL)) {
            tmp_mvar_value_19 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_19 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2569;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_19;
        CHECK_OBJECT(var_bio);
        tmp_args_element_name_19 = var_bio;
        CHECK_OBJECT(var_pkcs12);
        tmp_args_element_name_20 = var_pkcs12;
        frame_e7cef9cdd61becb04e1edcd19e659b06->m_frame.f_lineno = 2569;
        {
            PyObject *call_args[] = {tmp_args_element_name_19, tmp_args_element_name_20};
            tmp_call_result_3 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_2, const_str_plain_i2d_PKCS12_bio, call_args);
        }

        if (tmp_call_result_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2569;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_3);
    }
    {
        PyObject *tmp_called_name_8;
        PyObject *tmp_mvar_value_20;
        PyObject *tmp_args_element_name_21;
        tmp_mvar_value_20 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__bio_to_string);

        if (unlikely(tmp_mvar_value_20 == NULL)) {
            tmp_mvar_value_20 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__bio_to_string);
        }

        if (tmp_mvar_value_20 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3632 ], 43, 0);
            exception_tb = NULL;

            exception_lineno = 2570;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_8 = tmp_mvar_value_20;
        CHECK_OBJECT(var_bio);
        tmp_args_element_name_21 = var_bio;
        frame_e7cef9cdd61becb04e1edcd19e659b06->m_frame.f_lineno = 2570;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_8, tmp_args_element_name_21);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2570;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e7cef9cdd61becb04e1edcd19e659b06);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_e7cef9cdd61becb04e1edcd19e659b06);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e7cef9cdd61becb04e1edcd19e659b06);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_e7cef9cdd61becb04e1edcd19e659b06, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_e7cef9cdd61becb04e1edcd19e659b06->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_e7cef9cdd61becb04e1edcd19e659b06, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e7cef9cdd61becb04e1edcd19e659b06,
        type_description_1,
        par_self,
        par_passphrase,
        par_iter,
        par_maciter,
        var_pkey,
        var_bio,
        var_cacerts,
        var_cert,
        var_friendlyname,
        var_pkcs12
    );


    // Release cached frame.
    if (frame_e7cef9cdd61becb04e1edcd19e659b06 == cache_frame_e7cef9cdd61becb04e1edcd19e659b06) {
        Py_DECREF(frame_e7cef9cdd61becb04e1edcd19e659b06);
    }
    cache_frame_e7cef9cdd61becb04e1edcd19e659b06 = NULL;

    assertFrameObject(frame_e7cef9cdd61becb04e1edcd19e659b06);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_136_export);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_pkey);
    Py_DECREF(var_pkey);
    var_pkey = NULL;

    CHECK_OBJECT((PyObject *)var_bio);
    Py_DECREF(var_bio);
    var_bio = NULL;

    CHECK_OBJECT((PyObject *)var_cacerts);
    Py_DECREF(var_cacerts);
    var_cacerts = NULL;

    CHECK_OBJECT((PyObject *)var_cert);
    Py_DECREF(var_cert);
    var_cert = NULL;

    CHECK_OBJECT((PyObject *)par_passphrase);
    Py_DECREF(par_passphrase);
    par_passphrase = NULL;

    CHECK_OBJECT((PyObject *)var_friendlyname);
    Py_DECREF(var_friendlyname);
    var_friendlyname = NULL;

    CHECK_OBJECT((PyObject *)var_pkcs12);
    Py_DECREF(var_pkcs12);
    var_pkcs12 = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_pkey);
    var_pkey = NULL;

    Py_XDECREF(var_bio);
    var_bio = NULL;

    Py_XDECREF(var_cacerts);
    var_cacerts = NULL;

    Py_XDECREF(var_cert);
    var_cert = NULL;

    Py_XDECREF(par_passphrase);
    par_passphrase = NULL;

    Py_XDECREF(var_friendlyname);
    var_friendlyname = NULL;

    Py_XDECREF(var_pkcs12);
    var_pkcs12 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_136_export);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_maciter);
    Py_DECREF(par_maciter);
    CHECK_OBJECT(par_iter);
    Py_DECREF(par_iter);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_maciter);
    Py_DECREF(par_maciter);
    CHECK_OBJECT(par_iter);
    Py_DECREF(par_iter);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_137___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_spki = NULL;
    struct Nuitka_FrameObject *frame_3823949e19d48b686be78204ad33eba9;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_3823949e19d48b686be78204ad33eba9 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_3823949e19d48b686be78204ad33eba9, codeobj_3823949e19d48b686be78204ad33eba9, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *));
    frame_3823949e19d48b686be78204ad33eba9 = cache_frame_3823949e19d48b686be78204ad33eba9;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_3823949e19d48b686be78204ad33eba9);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_3823949e19d48b686be78204ad33eba9) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2586;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_3823949e19d48b686be78204ad33eba9->m_frame.f_lineno = 2586;
        tmp_assign_source_1 = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_NETSCAPE_SPKI_new);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2586;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert(var_spki == NULL);
        var_spki = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2587;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_gc);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2587;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_spki);
        tmp_args_element_name_1 = var_spki;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2587;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_NETSCAPE_SPKI_free);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2587;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_3823949e19d48b686be78204ad33eba9->m_frame.f_lineno = 2587;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2587;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__spki, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2587;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3823949e19d48b686be78204ad33eba9);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3823949e19d48b686be78204ad33eba9);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_3823949e19d48b686be78204ad33eba9, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_3823949e19d48b686be78204ad33eba9->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_3823949e19d48b686be78204ad33eba9, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3823949e19d48b686be78204ad33eba9,
        type_description_1,
        par_self,
        var_spki
    );


    // Release cached frame.
    if (frame_3823949e19d48b686be78204ad33eba9 == cache_frame_3823949e19d48b686be78204ad33eba9) {
        Py_DECREF(frame_3823949e19d48b686be78204ad33eba9);
    }
    cache_frame_3823949e19d48b686be78204ad33eba9 = NULL;

    assertFrameObject(frame_3823949e19d48b686be78204ad33eba9);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_137___init__);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_spki);
    Py_DECREF(var_spki);
    var_spki = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_spki);
    var_spki = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_137___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_138_sign(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_pkey = python_pars[1];
    PyObject *par_digest = python_pars[2];
    PyObject *var_digest_obj = NULL;
    PyObject *var_sign_result = NULL;
    struct Nuitka_FrameObject *frame_603b25455c6bfd7b211c177899c083b0;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_603b25455c6bfd7b211c177899c083b0 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_603b25455c6bfd7b211c177899c083b0, codeobj_603b25455c6bfd7b211c177899c083b0, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_603b25455c6bfd7b211c177899c083b0 = cache_frame_603b25455c6bfd7b211c177899c083b0;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_603b25455c6bfd7b211c177899c083b0);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_603b25455c6bfd7b211c177899c083b0) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_attribute_value_1;
        int tmp_truth_name_1;
        CHECK_OBJECT(par_pkey);
        tmp_source_name_1 = par_pkey;
        tmp_attribute_value_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__only_public);
        if (tmp_attribute_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2601;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE(tmp_attribute_value_1);
        if (tmp_truth_name_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_attribute_value_1);

            exception_lineno = 2601;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_attribute_value_1);
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_8aae826f04ca2a5df2a0de1a103a1f13;
            frame_603b25455c6bfd7b211c177899c083b0->m_frame.f_lineno = 2602;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 2602;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_pkey);
        tmp_source_name_2 = par_pkey;
        tmp_operand_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__initialized);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2604;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2604;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            tmp_make_exception_arg_2 = const_str_digest_d84b19202bfdec9cc8e6f9577d4fac5e;
            frame_603b25455c6bfd7b211c177899c083b0->m_frame.f_lineno = 2605;
            tmp_raise_type_2 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_2);
            assert(!(tmp_raise_type_2 == NULL));
            exception_type = tmp_raise_type_2;
            exception_lineno = 2605;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2607;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_EVP_get_digestbyname);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2607;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__byte_string);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__byte_string);
        }

        if (tmp_mvar_value_2 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3511 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 2607;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT(par_digest);
        tmp_args_element_name_2 = par_digest;
        frame_603b25455c6bfd7b211c177899c083b0->m_frame.f_lineno = 2607;
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_2);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2607;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_603b25455c6bfd7b211c177899c083b0->m_frame.f_lineno = 2607;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2607;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(var_digest_obj == NULL);
        var_digest_obj = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_3;
        CHECK_OBJECT(var_digest_obj);
        tmp_compexpr_left_1 = var_digest_obj;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2608;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_3;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_NULL);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2608;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2608;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
            goto branch_yes_3;
        } else {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_raise_type_3;
            PyObject *tmp_make_exception_arg_3;
            tmp_make_exception_arg_3 = const_str_digest_500f278b67471fc0f770fccc80d65d95;
            frame_603b25455c6bfd7b211c177899c083b0->m_frame.f_lineno = 2609;
            tmp_raise_type_3 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_3);
            assert(!(tmp_raise_type_3 == NULL));
            exception_type = tmp_raise_type_3;
            exception_lineno = 2609;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        branch_no_3:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_6;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_source_name_7;
        PyObject *tmp_args_element_name_5;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2611;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_4;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_NETSCAPE_SPKI_sign);
        if (tmp_called_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2611;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_6 = par_self;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain__spki);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);

            exception_lineno = 2612;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_pkey);
        tmp_source_name_7 = par_pkey;
        tmp_args_element_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain__pkey);
        if (tmp_args_element_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);
            Py_DECREF(tmp_args_element_name_3);

            exception_lineno = 2612;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_digest_obj);
        tmp_args_element_name_5 = var_digest_obj;
        frame_603b25455c6bfd7b211c177899c083b0->m_frame.f_lineno = 2611;
        {
            PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5};
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_3, call_args);
        }

        Py_DECREF(tmp_called_name_3);
        Py_DECREF(tmp_args_element_name_3);
        Py_DECREF(tmp_args_element_name_4);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2611;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(var_sign_result == NULL);
        var_sign_result = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_name_4;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 2614;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_4 = tmp_mvar_value_5;
        CHECK_OBJECT(var_sign_result);
        tmp_compexpr_left_2 = var_sign_result;
        tmp_compexpr_right_2 = const_int_0;
        tmp_args_element_name_6 = RICH_COMPARE_GT_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
        if (tmp_args_element_name_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2614;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_603b25455c6bfd7b211c177899c083b0->m_frame.f_lineno = 2614;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_4, tmp_args_element_name_6);
        Py_DECREF(tmp_args_element_name_6);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2614;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_603b25455c6bfd7b211c177899c083b0);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_603b25455c6bfd7b211c177899c083b0);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_603b25455c6bfd7b211c177899c083b0, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_603b25455c6bfd7b211c177899c083b0->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_603b25455c6bfd7b211c177899c083b0, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_603b25455c6bfd7b211c177899c083b0,
        type_description_1,
        par_self,
        par_pkey,
        par_digest,
        var_digest_obj,
        var_sign_result
    );


    // Release cached frame.
    if (frame_603b25455c6bfd7b211c177899c083b0 == cache_frame_603b25455c6bfd7b211c177899c083b0) {
        Py_DECREF(frame_603b25455c6bfd7b211c177899c083b0);
    }
    cache_frame_603b25455c6bfd7b211c177899c083b0 = NULL;

    assertFrameObject(frame_603b25455c6bfd7b211c177899c083b0);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_138_sign);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_digest_obj);
    Py_DECREF(var_digest_obj);
    var_digest_obj = NULL;

    CHECK_OBJECT((PyObject *)var_sign_result);
    Py_DECREF(var_sign_result);
    var_sign_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_digest_obj);
    var_digest_obj = NULL;

    Py_XDECREF(var_sign_result);
    var_sign_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_138_sign);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_pkey);
    Py_DECREF(par_pkey);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_digest);
    Py_DECREF(par_digest);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_pkey);
    Py_DECREF(par_pkey);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_digest);
    Py_DECREF(par_digest);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_139_verify(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_key = python_pars[1];
    PyObject *var_answer = NULL;
    struct Nuitka_FrameObject *frame_6580b2147d66eb9876d3eb667c120ce7;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_6580b2147d66eb9876d3eb667c120ce7 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_6580b2147d66eb9876d3eb667c120ce7, codeobj_6580b2147d66eb9876d3eb667c120ce7, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_6580b2147d66eb9876d3eb667c120ce7 = cache_frame_6580b2147d66eb9876d3eb667c120ce7;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_6580b2147d66eb9876d3eb667c120ce7);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_6580b2147d66eb9876d3eb667c120ce7) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2628;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_NETSCAPE_SPKI_verify);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2628;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__spki);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2628;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_key);
        tmp_source_name_3 = par_key;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__pkey);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_element_name_1);

            exception_lineno = 2628;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_6580b2147d66eb9876d3eb667c120ce7->m_frame.f_lineno = 2628;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2628;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_answer == NULL);
        var_answer = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(var_answer);
        tmp_compexpr_left_1 = var_answer;
        tmp_compexpr_right_1 = const_int_0;
        tmp_res = RICH_COMPARE_BOOL_LTE_OBJECT_INT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2629;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_name_2;
            PyObject *tmp_mvar_value_2;
            PyObject *tmp_call_result_1;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 0 ], 49, 0);
                exception_tb = NULL;

                exception_lineno = 2630;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_2 = tmp_mvar_value_2;
            frame_6580b2147d66eb9876d3eb667c120ce7->m_frame.f_lineno = 2630;
            tmp_call_result_1 = CALL_FUNCTION_NO_ARGS(tmp_called_name_2);
            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2630;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_1);
        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_6580b2147d66eb9876d3eb667c120ce7);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_6580b2147d66eb9876d3eb667c120ce7);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_6580b2147d66eb9876d3eb667c120ce7, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_6580b2147d66eb9876d3eb667c120ce7->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_6580b2147d66eb9876d3eb667c120ce7, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6580b2147d66eb9876d3eb667c120ce7,
        type_description_1,
        par_self,
        par_key,
        var_answer
    );


    // Release cached frame.
    if (frame_6580b2147d66eb9876d3eb667c120ce7 == cache_frame_6580b2147d66eb9876d3eb667c120ce7) {
        Py_DECREF(frame_6580b2147d66eb9876d3eb667c120ce7);
    }
    cache_frame_6580b2147d66eb9876d3eb667c120ce7 = NULL;

    assertFrameObject(frame_6580b2147d66eb9876d3eb667c120ce7);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_True;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_139_verify);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_answer);
    Py_DECREF(var_answer);
    var_answer = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_answer);
    var_answer = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_139_verify);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_key);
    Py_DECREF(par_key);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_key);
    Py_DECREF(par_key);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_140_b64_encode(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_encoded = NULL;
    PyObject *var_result = NULL;
    struct Nuitka_FrameObject *frame_46e833f2a78ffcfd023683533321764a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_46e833f2a78ffcfd023683533321764a = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_46e833f2a78ffcfd023683533321764a, codeobj_46e833f2a78ffcfd023683533321764a, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_46e833f2a78ffcfd023683533321764a = cache_frame_46e833f2a78ffcfd023683533321764a;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_46e833f2a78ffcfd023683533321764a);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_46e833f2a78ffcfd023683533321764a) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2640;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_NETSCAPE_SPKI_b64_encode);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2640;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__spki);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2640;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_46e833f2a78ffcfd023683533321764a->m_frame.f_lineno = 2640;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2640;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_encoded == NULL);
        var_encoded = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2641;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_2;
        CHECK_OBJECT(var_encoded);
        tmp_args_element_name_2 = var_encoded;
        frame_46e833f2a78ffcfd023683533321764a->m_frame.f_lineno = 2641;
        {
            PyObject *call_args[] = {tmp_args_element_name_2};
            tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_string, call_args);
        }

        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2641;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_result == NULL);
        var_result = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2642;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_3;
        CHECK_OBJECT(var_encoded);
        tmp_args_element_name_3 = var_encoded;
        frame_46e833f2a78ffcfd023683533321764a->m_frame.f_lineno = 2642;
        {
            PyObject *call_args[] = {tmp_args_element_name_3};
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_OPENSSL_free, call_args);
        }

        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2642;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_46e833f2a78ffcfd023683533321764a);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_46e833f2a78ffcfd023683533321764a);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_46e833f2a78ffcfd023683533321764a, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_46e833f2a78ffcfd023683533321764a->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_46e833f2a78ffcfd023683533321764a, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_46e833f2a78ffcfd023683533321764a,
        type_description_1,
        par_self,
        var_encoded,
        var_result
    );


    // Release cached frame.
    if (frame_46e833f2a78ffcfd023683533321764a == cache_frame_46e833f2a78ffcfd023683533321764a) {
        Py_DECREF(frame_46e833f2a78ffcfd023683533321764a);
    }
    cache_frame_46e833f2a78ffcfd023683533321764a = NULL;

    assertFrameObject(frame_46e833f2a78ffcfd023683533321764a);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT(var_result);
    tmp_return_value = var_result;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_140_b64_encode);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_encoded);
    Py_DECREF(var_encoded);
    var_encoded = NULL;

    CHECK_OBJECT((PyObject *)var_result);
    Py_DECREF(var_result);
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_encoded);
    var_encoded = NULL;

    Py_XDECREF(var_result);
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_140_b64_encode);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_141_get_pubkey(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_pkey = NULL;
    struct Nuitka_FrameObject *frame_12a92438471858197cd72f0dfaa82ede;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_12a92438471858197cd72f0dfaa82ede = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_12a92438471858197cd72f0dfaa82ede, codeobj_12a92438471858197cd72f0dfaa82ede, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *));
    frame_12a92438471858197cd72f0dfaa82ede = cache_frame_12a92438471858197cd72f0dfaa82ede;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_12a92438471858197cd72f0dfaa82ede);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_12a92438471858197cd72f0dfaa82ede) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 978 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2652;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain___new__);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2652;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey);
        }

        if (tmp_mvar_value_2 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 978 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2652;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = tmp_mvar_value_2;
        frame_12a92438471858197cd72f0dfaa82ede->m_frame.f_lineno = 2652;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2652;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert(var_pkey == NULL);
        var_pkey = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2653;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_NETSCAPE_SPKI_get_pubkey);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2653;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__spki);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 2653;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_12a92438471858197cd72f0dfaa82ede->m_frame.f_lineno = 2653;
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_2);
        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2653;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_pkey);
        tmp_assattr_target_1 = var_pkey;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__pkey, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2653;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_4;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_5;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 2654;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_4;
        CHECK_OBJECT(var_pkey);
        tmp_source_name_4 = var_pkey;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain__pkey);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2654;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_5 == NULL) {
            Py_DECREF(tmp_compexpr_left_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2654;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_5;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_NULL);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_1);

            exception_lineno = 2654;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2654;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_12a92438471858197cd72f0dfaa82ede->m_frame.f_lineno = 2654;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_3, tmp_args_element_name_3);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2654;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_source_name_7;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_8;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_assattr_target_2;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_6 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2655;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_6;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_gc);
        if (tmp_called_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2655;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_pkey);
        tmp_source_name_7 = var_pkey;
        tmp_args_element_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain__pkey);
        if (tmp_args_element_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_4);

            exception_lineno = 2655;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_7 == NULL)) {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_7 == NULL) {
            Py_DECREF(tmp_called_name_4);
            Py_DECREF(tmp_args_element_name_4);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2655;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_8 = tmp_mvar_value_7;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_8, const_str_plain_EVP_PKEY_free);
        if (tmp_args_element_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_4);
            Py_DECREF(tmp_args_element_name_4);

            exception_lineno = 2655;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_12a92438471858197cd72f0dfaa82ede->m_frame.f_lineno = 2655;
        {
            PyObject *call_args[] = {tmp_args_element_name_4, tmp_args_element_name_5};
            tmp_assattr_name_2 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_4, call_args);
        }

        Py_DECREF(tmp_called_name_4);
        Py_DECREF(tmp_args_element_name_4);
        Py_DECREF(tmp_args_element_name_5);
        if (tmp_assattr_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2655;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_pkey);
        tmp_assattr_target_2 = var_pkey;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain__pkey, tmp_assattr_name_2);
        Py_DECREF(tmp_assattr_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2655;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_assattr_target_3;
        tmp_assattr_name_3 = Py_True;
        CHECK_OBJECT(var_pkey);
        tmp_assattr_target_3 = var_pkey;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_3, const_str_plain__only_public, tmp_assattr_name_3);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2656;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_12a92438471858197cd72f0dfaa82ede);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_12a92438471858197cd72f0dfaa82ede);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_12a92438471858197cd72f0dfaa82ede, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_12a92438471858197cd72f0dfaa82ede->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_12a92438471858197cd72f0dfaa82ede, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_12a92438471858197cd72f0dfaa82ede,
        type_description_1,
        par_self,
        var_pkey
    );


    // Release cached frame.
    if (frame_12a92438471858197cd72f0dfaa82ede == cache_frame_12a92438471858197cd72f0dfaa82ede) {
        Py_DECREF(frame_12a92438471858197cd72f0dfaa82ede);
    }
    cache_frame_12a92438471858197cd72f0dfaa82ede = NULL;

    assertFrameObject(frame_12a92438471858197cd72f0dfaa82ede);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT(var_pkey);
    tmp_return_value = var_pkey;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_141_get_pubkey);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_pkey);
    Py_DECREF(var_pkey);
    var_pkey = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_pkey);
    var_pkey = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_141_get_pubkey);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_142_set_pubkey(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_pkey = python_pars[1];
    PyObject *var_set_result = NULL;
    struct Nuitka_FrameObject *frame_cfb453c9877c1441541c8778d573d561;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_cfb453c9877c1441541c8778d573d561 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_cfb453c9877c1441541c8778d573d561, codeobj_cfb453c9877c1441541c8778d573d561, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_cfb453c9877c1441541c8778d573d561 = cache_frame_cfb453c9877c1441541c8778d573d561;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_cfb453c9877c1441541c8778d573d561);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_cfb453c9877c1441541c8778d573d561) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2666;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_NETSCAPE_SPKI_set_pubkey);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2666;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__spki);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2666;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_pkey);
        tmp_source_name_3 = par_pkey;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__pkey);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_element_name_1);

            exception_lineno = 2666;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_cfb453c9877c1441541c8778d573d561->m_frame.f_lineno = 2666;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2666;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_set_result == NULL);
        var_set_result = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 2667;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT(var_set_result);
        tmp_compexpr_left_1 = var_set_result;
        tmp_compexpr_right_1 = const_int_pos_1;
        tmp_args_element_name_3 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2667;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_cfb453c9877c1441541c8778d573d561->m_frame.f_lineno = 2667;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_3);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2667;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_cfb453c9877c1441541c8778d573d561);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_cfb453c9877c1441541c8778d573d561);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_cfb453c9877c1441541c8778d573d561, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_cfb453c9877c1441541c8778d573d561->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_cfb453c9877c1441541c8778d573d561, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_cfb453c9877c1441541c8778d573d561,
        type_description_1,
        par_self,
        par_pkey,
        var_set_result
    );


    // Release cached frame.
    if (frame_cfb453c9877c1441541c8778d573d561 == cache_frame_cfb453c9877c1441541c8778d573d561) {
        Py_DECREF(frame_cfb453c9877c1441541c8778d573d561);
    }
    cache_frame_cfb453c9877c1441541c8778d573d561 = NULL;

    assertFrameObject(frame_cfb453c9877c1441541c8778d573d561);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_142_set_pubkey);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_set_result);
    Py_DECREF(var_set_result);
    var_set_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_set_result);
    var_set_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_142_set_pubkey);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_pkey);
    Py_DECREF(par_pkey);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_pkey);
    Py_DECREF(par_pkey);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_143___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_type = python_pars[1];
    PyObject *par_passphrase = python_pars[2];
    PyObject *par_more_args = python_pars[3];
    PyObject *par_truncate = python_pars[4];
    struct Nuitka_FrameObject *frame_91db092762599116cb72df14f7165542;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_91db092762599116cb72df14f7165542 = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_91db092762599116cb72df14f7165542, codeobj_91db092762599116cb72df14f7165542, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_91db092762599116cb72df14f7165542 = cache_frame_91db092762599116cb72df14f7165542;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_91db092762599116cb72df14f7165542);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_91db092762599116cb72df14f7165542) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_and_left_truth_1;
        nuitka_bool tmp_and_left_value_1;
        nuitka_bool tmp_and_right_value_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        CHECK_OBJECT(par_type);
        tmp_compexpr_left_1 = par_type;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 632 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 2679;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2679;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if (tmp_and_left_truth_1 == 1) {
            goto and_right_1;
        } else {
            goto and_left_1;
        }
        and_right_1:;
        CHECK_OBJECT(par_passphrase);
        tmp_compexpr_left_2 = par_passphrase;
        tmp_compexpr_right_2 = Py_None;
        tmp_and_right_value_1 = (tmp_compexpr_left_2 != tmp_compexpr_right_2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_condition_result_1 = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_condition_result_1 = tmp_and_left_value_1;
        and_end_1:;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_d546905f9a7fd3b3fc24a90a7432aa72;
            frame_91db092762599116cb72df14f7165542->m_frame.f_lineno = 2680;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 2680;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_passphrase);
        tmp_assattr_name_1 = par_passphrase;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__passphrase, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2683;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT(par_more_args);
        tmp_assattr_name_2 = par_more_args;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain__more_args, tmp_assattr_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2684;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_assattr_target_3;
        CHECK_OBJECT(par_truncate);
        tmp_assattr_name_3 = par_truncate;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_3 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_3, const_str_plain__truncate, tmp_assattr_name_3);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2685;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_4;
        PyObject *tmp_assattr_target_4;
        tmp_assattr_name_4 = PyList_New(0);
        CHECK_OBJECT(par_self);
        tmp_assattr_target_4 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_4, const_str_plain__problems, tmp_assattr_name_4);
        Py_DECREF(tmp_assattr_name_4);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2686;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_91db092762599116cb72df14f7165542);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_91db092762599116cb72df14f7165542);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_91db092762599116cb72df14f7165542, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_91db092762599116cb72df14f7165542->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_91db092762599116cb72df14f7165542, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_91db092762599116cb72df14f7165542,
        type_description_1,
        par_self,
        par_type,
        par_passphrase,
        par_more_args,
        par_truncate
    );


    // Release cached frame.
    if (frame_91db092762599116cb72df14f7165542 == cache_frame_91db092762599116cb72df14f7165542) {
        Py_DECREF(frame_91db092762599116cb72df14f7165542);
    }
    cache_frame_91db092762599116cb72df14f7165542 = NULL;

    assertFrameObject(frame_91db092762599116cb72df14f7165542);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_143___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_more_args);
    Py_DECREF(par_more_args);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);
    CHECK_OBJECT(par_truncate);
    Py_DECREF(par_truncate);
    CHECK_OBJECT(par_passphrase);
    Py_DECREF(par_passphrase);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_more_args);
    Py_DECREF(par_more_args);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);
    CHECK_OBJECT(par_truncate);
    Py_DECREF(par_truncate);
    CHECK_OBJECT(par_passphrase);
    Py_DECREF(par_passphrase);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_144_callback(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_3afae2cb1616023deaf9f3e5ada83ddc;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_3afae2cb1616023deaf9f3e5ada83ddc = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_3afae2cb1616023deaf9f3e5ada83ddc, codeobj_3afae2cb1616023deaf9f3e5ada83ddc, module_OpenSSL$crypto, sizeof(void *));
    frame_3afae2cb1616023deaf9f3e5ada83ddc = cache_frame_3afae2cb1616023deaf9f3e5ada83ddc;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_3afae2cb1616023deaf9f3e5ada83ddc);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_3afae2cb1616023deaf9f3e5ada83ddc) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__passphrase);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2690;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_compexpr_left_1);
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_source_name_2;
            PyObject *tmp_mvar_value_1;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_1 == NULL)) {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_1 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 2691;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }

            tmp_source_name_2 = tmp_mvar_value_1;
            tmp_return_value = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_NULL);
            if (tmp_return_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2691;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_isinstance_inst_1;
            PyObject *tmp_isinstance_cls_1;
            PyObject *tmp_source_name_3;
            CHECK_OBJECT(par_self);
            tmp_source_name_3 = par_self;
            tmp_isinstance_inst_1 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__passphrase);
            if (tmp_isinstance_inst_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2692;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            tmp_isinstance_cls_1 = (PyObject *)&PyString_Type;
            tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
            Py_DECREF(tmp_isinstance_inst_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2692;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
                goto branch_yes_2;
            } else {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_source_name_4;
                PyObject *tmp_mvar_value_2;
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

                if (unlikely(tmp_mvar_value_2 == NULL)) {
                    tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
                }

                if (tmp_mvar_value_2 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 2693;
                    type_description_1 = "o";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_4 = tmp_mvar_value_2;
                tmp_return_value = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_NULL);
                if (tmp_return_value == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2693;
                    type_description_1 = "o";
                    goto frame_exception_exit_1;
                }
                goto frame_return_exit_1;
            }
            goto branch_end_2;
            branch_no_2:;
            {
                nuitka_bool tmp_condition_result_3;
                PyObject *tmp_called_name_1;
                PyObject *tmp_call_result_1;
                PyObject *tmp_args_element_name_1;
                PyObject *tmp_source_name_5;
                int tmp_truth_name_1;
                tmp_called_name_1 = LOOKUP_BUILTIN(const_str_plain_callable);
                assert(tmp_called_name_1 != NULL);
                CHECK_OBJECT(par_self);
                tmp_source_name_5 = par_self;
                tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain__passphrase);
                if (tmp_args_element_name_1 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2694;
                    type_description_1 = "o";
                    goto frame_exception_exit_1;
                }
                frame_3afae2cb1616023deaf9f3e5ada83ddc->m_frame.f_lineno = 2694;
                tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
                Py_DECREF(tmp_args_element_name_1);
                if (tmp_call_result_1 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2694;
                    type_description_1 = "o";
                    goto frame_exception_exit_1;
                }
                tmp_truth_name_1 = CHECK_IF_TRUE(tmp_call_result_1);
                if (tmp_truth_name_1 == -1) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    Py_DECREF(tmp_call_result_1);

                    exception_lineno = 2694;
                    type_description_1 = "o";
                    goto frame_exception_exit_1;
                }
                tmp_condition_result_3 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                Py_DECREF(tmp_call_result_1);
                if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
                    goto branch_yes_3;
                } else {
                    goto branch_no_3;
                }
                branch_yes_3:;
                {
                    PyObject *tmp_called_name_2;
                    PyObject *tmp_source_name_6;
                    PyObject *tmp_mvar_value_3;
                    PyObject *tmp_args_element_name_2;
                    PyObject *tmp_args_element_name_3;
                    PyObject *tmp_source_name_7;
                    tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

                    if (unlikely(tmp_mvar_value_3 == NULL)) {
                        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
                    }

                    if (tmp_mvar_value_3 == NULL) {

                        exception_type = PyExc_NameError;
                        Py_INCREF(exception_type);
                        exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                        exception_tb = NULL;

                        exception_lineno = 2695;
                        type_description_1 = "o";
                        goto frame_exception_exit_1;
                    }

                    tmp_source_name_6 = tmp_mvar_value_3;
                    tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_callback);
                    if (tmp_called_name_2 == NULL) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                        exception_lineno = 2695;
                        type_description_1 = "o";
                        goto frame_exception_exit_1;
                    }
                    tmp_args_element_name_2 = const_str_plain_pem_password_cb;
                    CHECK_OBJECT(par_self);
                    tmp_source_name_7 = par_self;
                    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain__read_passphrase);
                    if (tmp_args_element_name_3 == NULL) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                        Py_DECREF(tmp_called_name_2);

                        exception_lineno = 2695;
                        type_description_1 = "o";
                        goto frame_exception_exit_1;
                    }
                    frame_3afae2cb1616023deaf9f3e5ada83ddc->m_frame.f_lineno = 2695;
                    {
                        PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
                        tmp_return_value = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
                    }

                    Py_DECREF(tmp_called_name_2);
                    Py_DECREF(tmp_args_element_name_3);
                    if (tmp_return_value == NULL) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                        exception_lineno = 2695;
                        type_description_1 = "o";
                        goto frame_exception_exit_1;
                    }
                    goto frame_return_exit_1;
                }
                goto branch_end_3;
                branch_no_3:;
                {
                    PyObject *tmp_raise_type_1;
                    PyObject *tmp_make_exception_arg_1;
                    tmp_make_exception_arg_1 = const_str_digest_7db2dd03172a07cae912434bb4ced82e;
                    frame_3afae2cb1616023deaf9f3e5ada83ddc->m_frame.f_lineno = 2697;
                    tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
                    assert(!(tmp_raise_type_1 == NULL));
                    exception_type = tmp_raise_type_1;
                    exception_lineno = 2697;
                    RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                    type_description_1 = "o";
                    goto frame_exception_exit_1;
                }
                branch_end_3:;
            }
            branch_end_2:;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3afae2cb1616023deaf9f3e5ada83ddc);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_3afae2cb1616023deaf9f3e5ada83ddc);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3afae2cb1616023deaf9f3e5ada83ddc);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_3afae2cb1616023deaf9f3e5ada83ddc, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_3afae2cb1616023deaf9f3e5ada83ddc->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_3afae2cb1616023deaf9f3e5ada83ddc, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3afae2cb1616023deaf9f3e5ada83ddc,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_3afae2cb1616023deaf9f3e5ada83ddc == cache_frame_3afae2cb1616023deaf9f3e5ada83ddc) {
        Py_DECREF(frame_3afae2cb1616023deaf9f3e5ada83ddc);
    }
    cache_frame_3afae2cb1616023deaf9f3e5ada83ddc = NULL;

    assertFrameObject(frame_3afae2cb1616023deaf9f3e5ada83ddc);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_144_callback);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_145_callback_args(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_dae642fc1d00d46dc97a94e0671a6f94;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_dae642fc1d00d46dc97a94e0671a6f94 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_dae642fc1d00d46dc97a94e0671a6f94, codeobj_dae642fc1d00d46dc97a94e0671a6f94, module_OpenSSL$crypto, sizeof(void *));
    frame_dae642fc1d00d46dc97a94e0671a6f94 = cache_frame_dae642fc1d00d46dc97a94e0671a6f94;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_dae642fc1d00d46dc97a94e0671a6f94);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_dae642fc1d00d46dc97a94e0671a6f94) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__passphrase);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2703;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_compexpr_left_1);
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_source_name_2;
            PyObject *tmp_mvar_value_1;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_1 == NULL)) {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_1 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 2704;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }

            tmp_source_name_2 = tmp_mvar_value_1;
            tmp_return_value = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_NULL);
            if (tmp_return_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2704;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_isinstance_inst_1;
            PyObject *tmp_isinstance_cls_1;
            PyObject *tmp_source_name_3;
            CHECK_OBJECT(par_self);
            tmp_source_name_3 = par_self;
            tmp_isinstance_inst_1 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__passphrase);
            if (tmp_isinstance_inst_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2705;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            tmp_isinstance_cls_1 = (PyObject *)&PyString_Type;
            tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
            Py_DECREF(tmp_isinstance_inst_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2705;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
                goto branch_yes_2;
            } else {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_source_name_4;
                CHECK_OBJECT(par_self);
                tmp_source_name_4 = par_self;
                tmp_return_value = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain__passphrase);
                if (tmp_return_value == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2706;
                    type_description_1 = "o";
                    goto frame_exception_exit_1;
                }
                goto frame_return_exit_1;
            }
            goto branch_end_2;
            branch_no_2:;
            {
                nuitka_bool tmp_condition_result_3;
                PyObject *tmp_called_name_1;
                PyObject *tmp_call_result_1;
                PyObject *tmp_args_element_name_1;
                PyObject *tmp_source_name_5;
                int tmp_truth_name_1;
                tmp_called_name_1 = LOOKUP_BUILTIN(const_str_plain_callable);
                assert(tmp_called_name_1 != NULL);
                CHECK_OBJECT(par_self);
                tmp_source_name_5 = par_self;
                tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain__passphrase);
                if (tmp_args_element_name_1 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2707;
                    type_description_1 = "o";
                    goto frame_exception_exit_1;
                }
                frame_dae642fc1d00d46dc97a94e0671a6f94->m_frame.f_lineno = 2707;
                tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
                Py_DECREF(tmp_args_element_name_1);
                if (tmp_call_result_1 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2707;
                    type_description_1 = "o";
                    goto frame_exception_exit_1;
                }
                tmp_truth_name_1 = CHECK_IF_TRUE(tmp_call_result_1);
                if (tmp_truth_name_1 == -1) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    Py_DECREF(tmp_call_result_1);

                    exception_lineno = 2707;
                    type_description_1 = "o";
                    goto frame_exception_exit_1;
                }
                tmp_condition_result_3 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                Py_DECREF(tmp_call_result_1);
                if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
                    goto branch_yes_3;
                } else {
                    goto branch_no_3;
                }
                branch_yes_3:;
                {
                    PyObject *tmp_source_name_6;
                    PyObject *tmp_mvar_value_2;
                    tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

                    if (unlikely(tmp_mvar_value_2 == NULL)) {
                        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
                    }

                    if (tmp_mvar_value_2 == NULL) {

                        exception_type = PyExc_NameError;
                        Py_INCREF(exception_type);
                        exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                        exception_tb = NULL;

                        exception_lineno = 2708;
                        type_description_1 = "o";
                        goto frame_exception_exit_1;
                    }

                    tmp_source_name_6 = tmp_mvar_value_2;
                    tmp_return_value = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_NULL);
                    if (tmp_return_value == NULL) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                        exception_lineno = 2708;
                        type_description_1 = "o";
                        goto frame_exception_exit_1;
                    }
                    goto frame_return_exit_1;
                }
                goto branch_end_3;
                branch_no_3:;
                {
                    PyObject *tmp_raise_type_1;
                    PyObject *tmp_make_exception_arg_1;
                    tmp_make_exception_arg_1 = const_str_digest_7db2dd03172a07cae912434bb4ced82e;
                    frame_dae642fc1d00d46dc97a94e0671a6f94->m_frame.f_lineno = 2710;
                    tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
                    assert(!(tmp_raise_type_1 == NULL));
                    exception_type = tmp_raise_type_1;
                    exception_lineno = 2710;
                    RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                    type_description_1 = "o";
                    goto frame_exception_exit_1;
                }
                branch_end_3:;
            }
            branch_end_2:;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_dae642fc1d00d46dc97a94e0671a6f94);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_dae642fc1d00d46dc97a94e0671a6f94);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_dae642fc1d00d46dc97a94e0671a6f94);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_dae642fc1d00d46dc97a94e0671a6f94, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_dae642fc1d00d46dc97a94e0671a6f94->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_dae642fc1d00d46dc97a94e0671a6f94, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_dae642fc1d00d46dc97a94e0671a6f94,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_dae642fc1d00d46dc97a94e0671a6f94 == cache_frame_dae642fc1d00d46dc97a94e0671a6f94) {
        Py_DECREF(frame_dae642fc1d00d46dc97a94e0671a6f94);
    }
    cache_frame_dae642fc1d00d46dc97a94e0671a6f94 = NULL;

    assertFrameObject(frame_dae642fc1d00d46dc97a94e0671a6f94);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_145_callback_args);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_146_raise_if_problem(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_exceptionType = python_pars[1];
    struct Nuitka_FrameObject *frame_0d63d1af7f4ff3d26e5354dc78437737;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_0d63d1af7f4ff3d26e5354dc78437737 = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_0d63d1af7f4ff3d26e5354dc78437737, codeobj_0d63d1af7f4ff3d26e5354dc78437737, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *));
    frame_0d63d1af7f4ff3d26e5354dc78437737 = cache_frame_0d63d1af7f4ff3d26e5354dc78437737;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_0d63d1af7f4ff3d26e5354dc78437737);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_0d63d1af7f4ff3d26e5354dc78437737) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_attribute_value_1;
        int tmp_truth_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_attribute_value_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__problems);
        if (tmp_attribute_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2715;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE(tmp_attribute_value_1);
        if (tmp_truth_name_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_attribute_value_1);

            exception_lineno = 2715;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_attribute_value_1);
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        // Tried code:
        {
            PyObject *tmp_called_name_1;
            PyObject *tmp_mvar_value_1;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_1;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__exception_from_error_queue);

            if (unlikely(tmp_mvar_value_1 == NULL)) {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__exception_from_error_queue);
            }

            if (tmp_mvar_value_1 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 4210 ], 56, 0);
                exception_tb = NULL;

                exception_lineno = 2719;
                type_description_1 = "oo";
                goto try_except_handler_1;
            }

            tmp_called_name_1 = tmp_mvar_value_1;
            CHECK_OBJECT(par_exceptionType);
            tmp_args_element_name_1 = par_exceptionType;
            frame_0d63d1af7f4ff3d26e5354dc78437737->m_frame.f_lineno = 2719;
            tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2719;
                type_description_1 = "oo";
                goto try_except_handler_1;
            }
            Py_DECREF(tmp_call_result_1);
        }
        goto try_end_1;
        // Exception handler code:
        try_except_handler_1:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Preserve existing published exception.
        PRESERVE_FRAME_EXCEPTION(frame_0d63d1af7f4ff3d26e5354dc78437737);
        if (exception_keeper_tb_1 == NULL) {
            exception_keeper_tb_1 = MAKE_TRACEBACK(frame_0d63d1af7f4ff3d26e5354dc78437737, exception_keeper_lineno_1);
        } else if (exception_keeper_lineno_1 != 0) {
            exception_keeper_tb_1 = ADD_TRACEBACK(exception_keeper_tb_1, frame_0d63d1af7f4ff3d26e5354dc78437737, exception_keeper_lineno_1);
        }

        NORMALIZE_EXCEPTION(&exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1);
        PUBLISH_EXCEPTION(&exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1);
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_operand_name_1;
            PyObject *tmp_compexpr_left_1;
            PyObject *tmp_compexpr_right_1;
            tmp_compexpr_left_1 = EXC_TYPE(PyThreadState_GET());
            CHECK_OBJECT(par_exceptionType);
            tmp_compexpr_right_1 = par_exceptionType;
            tmp_res = EXCEPTION_MATCH_BOOL(tmp_compexpr_left_1, tmp_compexpr_right_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2720;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2720;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
                goto branch_yes_2;
            } else {
                goto branch_no_2;
            }
            branch_yes_2:;
            tmp_result = RERAISE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            if (unlikely(tmp_result == false)) {
                exception_lineno = 2718;
            }

            if (exception_tb && exception_tb->tb_frame == &frame_0d63d1af7f4ff3d26e5354dc78437737->m_frame) frame_0d63d1af7f4ff3d26e5354dc78437737->m_frame.f_lineno = exception_tb->tb_lineno;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
            branch_no_2:;
        }
        goto try_end_1;
        // exception handler codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_146_raise_if_problem);
        return NULL;
        // End of try:
        try_end_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_source_name_2;
            CHECK_OBJECT(par_self);
            tmp_source_name_2 = par_self;
            tmp_called_instance_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__problems);
            if (tmp_called_instance_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2723;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            frame_0d63d1af7f4ff3d26e5354dc78437737->m_frame.f_lineno = 2723;
            tmp_raise_type_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_pop, &PyTuple_GET_ITEM(const_tuple_int_0_tuple, 0));

            Py_DECREF(tmp_called_instance_1);
            if (tmp_raise_type_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2723;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            exception_type = tmp_raise_type_1;
            exception_lineno = 2723;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }

#if 1
    RESTORE_FRAME_EXCEPTION(frame_0d63d1af7f4ff3d26e5354dc78437737);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION(frame_0d63d1af7f4ff3d26e5354dc78437737);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_0d63d1af7f4ff3d26e5354dc78437737, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_0d63d1af7f4ff3d26e5354dc78437737->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_0d63d1af7f4ff3d26e5354dc78437737, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0d63d1af7f4ff3d26e5354dc78437737,
        type_description_1,
        par_self,
        par_exceptionType
    );


    // Release cached frame.
    if (frame_0d63d1af7f4ff3d26e5354dc78437737 == cache_frame_0d63d1af7f4ff3d26e5354dc78437737) {
        Py_DECREF(frame_0d63d1af7f4ff3d26e5354dc78437737);
    }
    cache_frame_0d63d1af7f4ff3d26e5354dc78437737 = NULL;

    assertFrameObject(frame_0d63d1af7f4ff3d26e5354dc78437737);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_146_raise_if_problem);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_exceptionType);
    Py_DECREF(par_exceptionType);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_exceptionType);
    Py_DECREF(par_exceptionType);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_147__read_passphrase(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_buf = python_pars[1];
    PyObject *par_size = python_pars[2];
    PyObject *par_rwflag = python_pars[3];
    PyObject *par_userdata = python_pars[4];
    PyObject *var_e = NULL;
    PyObject *var_i = NULL;
    PyObject *var_result = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_4beb331670662238f060a150b02707c9;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    static struct Nuitka_FrameObject *cache_frame_4beb331670662238f060a150b02707c9 = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_4beb331670662238f060a150b02707c9, codeobj_4beb331670662238f060a150b02707c9, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_4beb331670662238f060a150b02707c9 = cache_frame_4beb331670662238f060a150b02707c9;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_4beb331670662238f060a150b02707c9);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_4beb331670662238f060a150b02707c9) == 2); // Frame stack

    // Framed code:
    // Tried code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_attribute_value_1;
        int tmp_truth_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_attribute_value_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__more_args);
        if (tmp_attribute_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2727;
            type_description_1 = "oooooooo";
            goto try_except_handler_2;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE(tmp_attribute_value_1);
        if (tmp_truth_name_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_attribute_value_1);

            exception_lineno = 2727;
            type_description_1 = "oooooooo";
            goto try_except_handler_2;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_attribute_value_1);
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_args_element_name_3;
            CHECK_OBJECT(par_self);
            tmp_called_instance_1 = par_self;
            CHECK_OBJECT(par_size);
            tmp_args_element_name_1 = par_size;
            CHECK_OBJECT(par_rwflag);
            tmp_args_element_name_2 = par_rwflag;
            CHECK_OBJECT(par_userdata);
            tmp_args_element_name_3 = par_userdata;
            frame_4beb331670662238f060a150b02707c9->m_frame.f_lineno = 2728;
            {
                PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3};
                tmp_assign_source_1 = CALL_METHOD_WITH_ARGS3(tmp_called_instance_1, const_str_plain__passphrase, call_args);
            }

            if (tmp_assign_source_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2728;
                type_description_1 = "oooooooo";
                goto try_except_handler_2;
            }
            assert(var_result == NULL);
            var_result = tmp_assign_source_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_called_instance_2;
            PyObject *tmp_args_element_name_4;
            CHECK_OBJECT(par_self);
            tmp_called_instance_2 = par_self;
            CHECK_OBJECT(par_rwflag);
            tmp_args_element_name_4 = par_rwflag;
            frame_4beb331670662238f060a150b02707c9->m_frame.f_lineno = 2730;
            {
                PyObject *call_args[] = {tmp_args_element_name_4};
                tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain__passphrase, call_args);
            }

            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2730;
                type_description_1 = "oooooooo";
                goto try_except_handler_2;
            }
            assert(var_result == NULL);
            var_result = tmp_assign_source_2;
        }
        branch_end_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        CHECK_OBJECT(var_result);
        tmp_isinstance_inst_1 = var_result;
        tmp_isinstance_cls_1 = (PyObject *)&PyString_Type;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2731;
            type_description_1 = "oooooooo";
            goto try_except_handler_2;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2731;
            type_description_1 = "oooooooo";
            goto try_except_handler_2;
        }
        tmp_condition_result_2 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_7338acfc5a3b91c07965b6befadc8c7a;
            frame_4beb331670662238f060a150b02707c9->m_frame.f_lineno = 2732;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 2732;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oooooooo";
            goto try_except_handler_2;
        }
        branch_no_2:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_len_arg_1;
        CHECK_OBJECT(var_result);
        tmp_len_arg_1 = var_result;
        tmp_compexpr_left_1 = BUILTIN_LEN(tmp_len_arg_1);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2733;
            type_description_1 = "oooooooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT(par_size);
        tmp_compexpr_right_1 = par_size;
        tmp_res = RICH_COMPARE_BOOL_GT_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2733;
            type_description_1 = "oooooooo";
            goto try_except_handler_2;
        }
        tmp_condition_result_3 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
            goto branch_yes_3;
        } else {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            nuitka_bool tmp_condition_result_4;
            PyObject *tmp_source_name_2;
            PyObject *tmp_attribute_value_2;
            int tmp_truth_name_2;
            CHECK_OBJECT(par_self);
            tmp_source_name_2 = par_self;
            tmp_attribute_value_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__truncate);
            if (tmp_attribute_value_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2734;
                type_description_1 = "oooooooo";
                goto try_except_handler_2;
            }
            tmp_truth_name_2 = CHECK_IF_TRUE(tmp_attribute_value_2);
            if (tmp_truth_name_2 == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_attribute_value_2);

                exception_lineno = 2734;
                type_description_1 = "oooooooo";
                goto try_except_handler_2;
            }
            tmp_condition_result_4 = tmp_truth_name_2 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            Py_DECREF(tmp_attribute_value_2);
            if (tmp_condition_result_4 == NUITKA_BOOL_TRUE) {
                goto branch_yes_4;
            } else {
                goto branch_no_4;
            }
            branch_yes_4:;
            {
                PyObject *tmp_assign_source_3;
                PyObject *tmp_slice_source_1;
                PyObject *tmp_slice_upper_1;
                CHECK_OBJECT(var_result);
                tmp_slice_source_1 = var_result;
                CHECK_OBJECT(par_size);
                tmp_slice_upper_1 = par_size;
                tmp_assign_source_3 = LOOKUP_SLICE(tmp_slice_source_1, Py_None, tmp_slice_upper_1);
                if (tmp_assign_source_3 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2735;
                    type_description_1 = "oooooooo";
                    goto try_except_handler_2;
                }
                {
                    PyObject *old = var_result;
                    assert(old != NULL);
                    var_result = tmp_assign_source_3;
                    Py_DECREF(old);
                }

            }
            goto branch_end_4;
            branch_no_4:;
            {
                PyObject *tmp_raise_type_2;
                PyObject *tmp_make_exception_arg_2;
                tmp_make_exception_arg_2 = const_str_digest_9cb57ebafd0926d1746d2e66a6198efe;
                frame_4beb331670662238f060a150b02707c9->m_frame.f_lineno = 2737;
                tmp_raise_type_2 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_2);
                assert(!(tmp_raise_type_2 == NULL));
                exception_type = tmp_raise_type_2;
                exception_lineno = 2737;
                RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "oooooooo";
                goto try_except_handler_2;
            }
            branch_end_4:;
        }
        branch_no_3:;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_range_arg_1;
        PyObject *tmp_len_arg_2;
        if (var_result == NULL) {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("local variable '%s' referenced before assignment", "result");
            exception_tb = NULL;

            exception_lineno = 2740;
            type_description_1 = "oooooooo";
            goto try_except_handler_2;
        }

        tmp_len_arg_2 = var_result;
        tmp_range_arg_1 = BUILTIN_LEN(tmp_len_arg_2);
        if (tmp_range_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2740;
            type_description_1 = "oooooooo";
            goto try_except_handler_2;
        }
        tmp_iter_arg_1 = BUILTIN_RANGE(tmp_range_arg_1);
        Py_DECREF(tmp_range_arg_1);
        if (tmp_iter_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2740;
            type_description_1 = "oooooooo";
            goto try_except_handler_2;
        }
        tmp_assign_source_4 = MAKE_ITERATOR(tmp_iter_arg_1);
        Py_DECREF(tmp_iter_arg_1);
        if (tmp_assign_source_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2740;
            type_description_1 = "oooooooo";
            goto try_except_handler_2;
        }
        assert(tmp_for_loop_1__for_iterator == NULL);
        tmp_for_loop_1__for_iterator = tmp_assign_source_4;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_5;
        CHECK_OBJECT(tmp_for_loop_1__for_iterator);
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_5 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_5 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "oooooooo";
                exception_lineno = 2740;
                goto try_except_handler_3;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_5;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_6;
        CHECK_OBJECT(tmp_for_loop_1__iter_value);
        tmp_assign_source_6 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_i;
            var_i = tmp_assign_source_6;
            Py_INCREF(var_i);
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_ass_subvalue_1;
        PyObject *tmp_slice_source_2;
        PyObject *tmp_slice_lower_1;
        PyObject *tmp_slice_upper_2;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_ass_subscribed_1;
        PyObject *tmp_ass_subscript_1;
        if (var_result == NULL) {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("local variable '%s' referenced before assignment", "result");
            exception_tb = NULL;

            exception_lineno = 2741;
            type_description_1 = "oooooooo";
            goto try_except_handler_3;
        }

        tmp_slice_source_2 = var_result;
        CHECK_OBJECT(var_i);
        tmp_slice_lower_1 = var_i;
        CHECK_OBJECT(var_i);
        tmp_left_name_1 = var_i;
        tmp_right_name_1 = const_int_pos_1;
        tmp_slice_upper_2 = BINARY_OPERATION_ADD_OBJECT_INT(tmp_left_name_1, tmp_right_name_1);
        if (tmp_slice_upper_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2741;
            type_description_1 = "oooooooo";
            goto try_except_handler_3;
        }
        tmp_ass_subvalue_1 = LOOKUP_SLICE(tmp_slice_source_2, tmp_slice_lower_1, tmp_slice_upper_2);
        Py_DECREF(tmp_slice_upper_2);
        if (tmp_ass_subvalue_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2741;
            type_description_1 = "oooooooo";
            goto try_except_handler_3;
        }
        CHECK_OBJECT(par_buf);
        tmp_ass_subscribed_1 = par_buf;
        CHECK_OBJECT(var_i);
        tmp_ass_subscript_1 = var_i;
        tmp_result = SET_SUBSCRIPT(tmp_ass_subscribed_1, tmp_ass_subscript_1, tmp_ass_subvalue_1);
        Py_DECREF(tmp_ass_subvalue_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2741;
            type_description_1 = "oooooooo";
            goto try_except_handler_3;
        }
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


        exception_lineno = 2740;
        type_description_1 = "oooooooo";
        goto try_except_handler_3;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    // End of try:
    try_end_1:;
    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    {
        PyObject *tmp_len_arg_3;
        if (var_result == NULL) {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("local variable '%s' referenced before assignment", "result");
            exception_tb = NULL;

            exception_lineno = 2742;
            type_description_1 = "oooooooo";
            goto try_except_handler_2;
        }

        tmp_len_arg_3 = var_result;
        tmp_return_value = BUILTIN_LEN(tmp_len_arg_3);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2742;
            type_description_1 = "oooooooo";
            goto try_except_handler_2;
        }
        goto frame_return_exit_1;
    }
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_147__read_passphrase);
    return NULL;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION(frame_4beb331670662238f060a150b02707c9);
    if (exception_keeper_tb_2 == NULL) {
        exception_keeper_tb_2 = MAKE_TRACEBACK(frame_4beb331670662238f060a150b02707c9, exception_keeper_lineno_2);
    } else if (exception_keeper_lineno_2 != 0) {
        exception_keeper_tb_2 = ADD_TRACEBACK(exception_keeper_tb_2, frame_4beb331670662238f060a150b02707c9, exception_keeper_lineno_2);
    }

    NORMALIZE_EXCEPTION(&exception_keeper_type_2, &exception_keeper_value_2, &exception_keeper_tb_2);
    PUBLISH_EXCEPTION(&exception_keeper_type_2, &exception_keeper_value_2, &exception_keeper_tb_2);
    {
        nuitka_bool tmp_condition_result_5;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        tmp_compexpr_left_2 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_2 = PyExc_Exception;
        tmp_res = EXCEPTION_MATCH_BOOL(tmp_compexpr_left_2, tmp_compexpr_right_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2743;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_5 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_5 == NUITKA_BOOL_TRUE) {
            goto branch_yes_5;
        } else {
            goto branch_no_5;
        }
        branch_yes_5:;
        {
            PyObject *tmp_assign_source_7;
            tmp_assign_source_7 = EXC_VALUE(PyThreadState_GET());
            assert(var_e == NULL);
            Py_INCREF(tmp_assign_source_7);
            var_e = tmp_assign_source_7;
        }
        {
            PyObject *tmp_called_instance_3;
            PyObject *tmp_source_name_3;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_5;
            CHECK_OBJECT(par_self);
            tmp_source_name_3 = par_self;
            tmp_called_instance_3 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__problems);
            if (tmp_called_instance_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2744;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_e);
            tmp_args_element_name_5 = var_e;
            frame_4beb331670662238f060a150b02707c9->m_frame.f_lineno = 2744;
            {
                PyObject *call_args[] = {tmp_args_element_name_5};
                tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_3, const_str_plain_append, call_args);
            }

            Py_DECREF(tmp_called_instance_3);
            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2744;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_1);
        }
        tmp_return_value = const_int_0;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        goto branch_end_5;
        branch_no_5:;
        tmp_result = RERAISE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
        if (unlikely(tmp_result == false)) {
            exception_lineno = 2726;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_4beb331670662238f060a150b02707c9->m_frame) frame_4beb331670662238f060a150b02707c9->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
        branch_end_5:;
    }
    // End of try:

#if 1
    RESTORE_FRAME_EXCEPTION(frame_4beb331670662238f060a150b02707c9);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION(frame_4beb331670662238f060a150b02707c9);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION(frame_4beb331670662238f060a150b02707c9);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_4beb331670662238f060a150b02707c9, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_4beb331670662238f060a150b02707c9->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_4beb331670662238f060a150b02707c9, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4beb331670662238f060a150b02707c9,
        type_description_1,
        par_self,
        par_buf,
        par_size,
        par_rwflag,
        par_userdata,
        var_e,
        var_i,
        var_result
    );


    // Release cached frame.
    if (frame_4beb331670662238f060a150b02707c9 == cache_frame_4beb331670662238f060a150b02707c9) {
        Py_DECREF(frame_4beb331670662238f060a150b02707c9);
    }
    cache_frame_4beb331670662238f060a150b02707c9 = NULL;

    assertFrameObject(frame_4beb331670662238f060a150b02707c9);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_147__read_passphrase);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_e);
    var_e = NULL;

    Py_XDECREF(var_i);
    var_i = NULL;

    Py_XDECREF(var_result);
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_e);
    var_e = NULL;

    Py_XDECREF(var_i);
    var_i = NULL;

    Py_XDECREF(var_result);
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_147__read_passphrase);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_userdata);
    Py_DECREF(par_userdata);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_rwflag);
    Py_DECREF(par_rwflag);
    CHECK_OBJECT(par_buf);
    Py_DECREF(par_buf);
    CHECK_OBJECT(par_size);
    Py_DECREF(par_size);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_userdata);
    Py_DECREF(par_userdata);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_rwflag);
    Py_DECREF(par_rwflag);
    CHECK_OBJECT(par_buf);
    Py_DECREF(par_buf);
    CHECK_OBJECT(par_size);
    Py_DECREF(par_size);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_148_load_publickey(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_type = python_pars[0];
    PyObject *par_buffer = python_pars[1];
    PyObject *var_bio = NULL;
    PyObject *var_pkey = NULL;
    PyObject *var_evp_pkey = NULL;
    struct Nuitka_FrameObject *frame_84543461673eee61a7305bb77fc49b09;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_84543461673eee61a7305bb77fc49b09 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_84543461673eee61a7305bb77fc49b09, codeobj_84543461673eee61a7305bb77fc49b09, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_84543461673eee61a7305bb77fc49b09 = cache_frame_84543461673eee61a7305bb77fc49b09;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_84543461673eee61a7305bb77fc49b09);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_84543461673eee61a7305bb77fc49b09) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_buffer);
        tmp_isinstance_inst_1 = par_buffer;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__text_type);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__text_type);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3552 ], 39, 0);
            exception_tb = NULL;

            exception_lineno = 2759;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2759;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_called_instance_1;
            CHECK_OBJECT(par_buffer);
            tmp_called_instance_1 = par_buffer;
            frame_84543461673eee61a7305bb77fc49b09->m_frame.f_lineno = 2760;
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_encode, &PyTuple_GET_ITEM(const_tuple_str_plain_ascii_tuple, 0));

            if (tmp_assign_source_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2760;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_buffer;
                assert(old != NULL);
                par_buffer = tmp_assign_source_1;
                Py_DECREF(old);
            }

        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3591 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 2762;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_2;
        CHECK_OBJECT(par_buffer);
        tmp_args_element_name_1 = par_buffer;
        frame_84543461673eee61a7305bb77fc49b09->m_frame.f_lineno = 2762;
        tmp_assign_source_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2762;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(var_bio == NULL);
        var_bio = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_3;
        CHECK_OBJECT(par_type);
        tmp_compexpr_left_1 = par_type;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 632 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 2764;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_3;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2764;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_1;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_source_name_2;
            PyObject *tmp_mvar_value_5;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_source_name_3;
            PyObject *tmp_mvar_value_6;
            PyObject *tmp_args_element_name_5;
            PyObject *tmp_source_name_4;
            PyObject *tmp_mvar_value_7;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_4 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 2765;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_1 = tmp_mvar_value_4;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_PEM_read_bio_PUBKEY);
            if (tmp_called_name_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2765;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_bio);
            tmp_args_element_name_2 = var_bio;
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_5 == NULL)) {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_5 == NULL) {
                Py_DECREF(tmp_called_name_2);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 2766;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_2 = tmp_mvar_value_5;
            tmp_args_element_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_NULL);
            if (tmp_args_element_name_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_2);

                exception_lineno = 2766;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_6 == NULL)) {
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_6 == NULL) {
                Py_DECREF(tmp_called_name_2);
                Py_DECREF(tmp_args_element_name_3);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 2766;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_3 = tmp_mvar_value_6;
            tmp_args_element_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_NULL);
            if (tmp_args_element_name_4 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_2);
                Py_DECREF(tmp_args_element_name_3);

                exception_lineno = 2766;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_7 == NULL)) {
                tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_7 == NULL) {
                Py_DECREF(tmp_called_name_2);
                Py_DECREF(tmp_args_element_name_3);
                Py_DECREF(tmp_args_element_name_4);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 2766;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_4 = tmp_mvar_value_7;
            tmp_args_element_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_NULL);
            if (tmp_args_element_name_5 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_2);
                Py_DECREF(tmp_args_element_name_3);
                Py_DECREF(tmp_args_element_name_4);

                exception_lineno = 2766;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            frame_84543461673eee61a7305bb77fc49b09->m_frame.f_lineno = 2765;
            {
                PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5};
                tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS4(tmp_called_name_2, call_args);
            }

            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_3);
            Py_DECREF(tmp_args_element_name_4);
            Py_DECREF(tmp_args_element_name_5);
            if (tmp_assign_source_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2765;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            assert(var_evp_pkey == NULL);
            var_evp_pkey = tmp_assign_source_3;
        }
        goto branch_end_2;
        branch_no_2:;
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_mvar_value_8;
            CHECK_OBJECT(par_type);
            tmp_compexpr_left_2 = par_type;
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1);

            if (unlikely(tmp_mvar_value_8 == NULL)) {
                tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1);
            }

            if (tmp_mvar_value_8 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 4053 ], 42, 0);
                exception_tb = NULL;

                exception_lineno = 2767;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_2 = tmp_mvar_value_8;
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2767;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_3 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
                goto branch_yes_3;
            } else {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_assign_source_4;
                PyObject *tmp_called_name_3;
                PyObject *tmp_source_name_5;
                PyObject *tmp_mvar_value_9;
                PyObject *tmp_args_element_name_6;
                PyObject *tmp_args_element_name_7;
                PyObject *tmp_source_name_6;
                PyObject *tmp_mvar_value_10;
                tmp_mvar_value_9 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

                if (unlikely(tmp_mvar_value_9 == NULL)) {
                    tmp_mvar_value_9 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
                }

                if (tmp_mvar_value_9 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 2768;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_5 = tmp_mvar_value_9;
                tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_d2i_PUBKEY_bio);
                if (tmp_called_name_3 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2768;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT(var_bio);
                tmp_args_element_name_6 = var_bio;
                tmp_mvar_value_10 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

                if (unlikely(tmp_mvar_value_10 == NULL)) {
                    tmp_mvar_value_10 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
                }

                if (tmp_mvar_value_10 == NULL) {
                    Py_DECREF(tmp_called_name_3);
                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 2768;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_6 = tmp_mvar_value_10;
                tmp_args_element_name_7 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_NULL);
                if (tmp_args_element_name_7 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    Py_DECREF(tmp_called_name_3);

                    exception_lineno = 2768;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                frame_84543461673eee61a7305bb77fc49b09->m_frame.f_lineno = 2768;
                {
                    PyObject *call_args[] = {tmp_args_element_name_6, tmp_args_element_name_7};
                    tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_3, call_args);
                }

                Py_DECREF(tmp_called_name_3);
                Py_DECREF(tmp_args_element_name_7);
                if (tmp_assign_source_4 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2768;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                assert(var_evp_pkey == NULL);
                var_evp_pkey = tmp_assign_source_4;
            }
            goto branch_end_3;
            branch_no_3:;
            {
                PyObject *tmp_raise_type_1;
                PyObject *tmp_make_exception_arg_1;
                tmp_make_exception_arg_1 = const_str_digest_f019d8c1ebbf58631ace92b4423b3aad;
                frame_84543461673eee61a7305bb77fc49b09->m_frame.f_lineno = 2770;
                tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_1);
                assert(!(tmp_raise_type_1 == NULL));
                exception_type = tmp_raise_type_1;
                exception_lineno = 2770;
                RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            branch_end_3:;
        }
        branch_end_2:;
    }
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_11;
        if (var_evp_pkey == NULL) {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("local variable '%s' referenced before assignment", "evp_pkey");
            exception_tb = NULL;

            exception_lineno = 2772;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_left_3 = var_evp_pkey;
        tmp_mvar_value_11 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_11 == NULL)) {
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_11 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2772;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = tmp_mvar_value_11;
        tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain_NULL);
        if (tmp_compexpr_right_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2772;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_3, tmp_compexpr_right_3);
        Py_DECREF(tmp_compexpr_right_3);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2772;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_4 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_4 == NUITKA_BOOL_TRUE) {
            goto branch_yes_4;
        } else {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_called_name_4;
            PyObject *tmp_mvar_value_12;
            PyObject *tmp_call_result_1;
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error);

            if (unlikely(tmp_mvar_value_12 == NULL)) {
                tmp_mvar_value_12 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error);
            }

            if (tmp_mvar_value_12 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 0 ], 49, 0);
                exception_tb = NULL;

                exception_lineno = 2773;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_4 = tmp_mvar_value_12;
            frame_84543461673eee61a7305bb77fc49b09->m_frame.f_lineno = 2773;
            tmp_call_result_1 = CALL_FUNCTION_NO_ARGS(tmp_called_name_4);
            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2773;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_1);
        }
        branch_no_4:;
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_called_name_5;
        PyObject *tmp_source_name_8;
        PyObject *tmp_mvar_value_13;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_mvar_value_14;
        tmp_mvar_value_13 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey);

        if (unlikely(tmp_mvar_value_13 == NULL)) {
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey);
        }

        if (tmp_mvar_value_13 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 978 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2775;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_8 = tmp_mvar_value_13;
        tmp_called_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_8, const_str_plain___new__);
        if (tmp_called_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2775;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_14 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey);

        if (unlikely(tmp_mvar_value_14 == NULL)) {
            tmp_mvar_value_14 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey);
        }

        if (tmp_mvar_value_14 == NULL) {
            Py_DECREF(tmp_called_name_5);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 978 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2775;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_8 = tmp_mvar_value_14;
        frame_84543461673eee61a7305bb77fc49b09->m_frame.f_lineno = 2775;
        tmp_assign_source_5 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_5, tmp_args_element_name_8);
        Py_DECREF(tmp_called_name_5);
        if (tmp_assign_source_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2775;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(var_pkey == NULL);
        var_pkey = tmp_assign_source_5;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_6;
        PyObject *tmp_source_name_9;
        PyObject *tmp_mvar_value_15;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_source_name_10;
        PyObject *tmp_mvar_value_16;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_15 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_15 == NULL)) {
            tmp_mvar_value_15 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_15 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2776;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_9 = tmp_mvar_value_15;
        tmp_called_name_6 = LOOKUP_ATTRIBUTE(tmp_source_name_9, const_str_plain_gc);
        if (tmp_called_name_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2776;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        if (var_evp_pkey == NULL) {
            Py_DECREF(tmp_called_name_6);
            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("local variable '%s' referenced before assignment", "evp_pkey");
            exception_tb = NULL;

            exception_lineno = 2776;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_9 = var_evp_pkey;
        tmp_mvar_value_16 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_16 == NULL)) {
            tmp_mvar_value_16 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_16 == NULL) {
            Py_DECREF(tmp_called_name_6);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2776;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_10 = tmp_mvar_value_16;
        tmp_args_element_name_10 = LOOKUP_ATTRIBUTE(tmp_source_name_10, const_str_plain_EVP_PKEY_free);
        if (tmp_args_element_name_10 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_6);

            exception_lineno = 2776;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_84543461673eee61a7305bb77fc49b09->m_frame.f_lineno = 2776;
        {
            PyObject *call_args[] = {tmp_args_element_name_9, tmp_args_element_name_10};
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_6, call_args);
        }

        Py_DECREF(tmp_called_name_6);
        Py_DECREF(tmp_args_element_name_10);
        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2776;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_pkey);
        tmp_assattr_target_1 = var_pkey;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__pkey, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2776;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        tmp_assattr_name_2 = Py_True;
        CHECK_OBJECT(var_pkey);
        tmp_assattr_target_2 = var_pkey;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain__only_public, tmp_assattr_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2777;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_84543461673eee61a7305bb77fc49b09);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_84543461673eee61a7305bb77fc49b09);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_84543461673eee61a7305bb77fc49b09, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_84543461673eee61a7305bb77fc49b09->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_84543461673eee61a7305bb77fc49b09, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_84543461673eee61a7305bb77fc49b09,
        type_description_1,
        par_type,
        par_buffer,
        var_bio,
        var_pkey,
        var_evp_pkey
    );


    // Release cached frame.
    if (frame_84543461673eee61a7305bb77fc49b09 == cache_frame_84543461673eee61a7305bb77fc49b09) {
        Py_DECREF(frame_84543461673eee61a7305bb77fc49b09);
    }
    cache_frame_84543461673eee61a7305bb77fc49b09 = NULL;

    assertFrameObject(frame_84543461673eee61a7305bb77fc49b09);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT(var_pkey);
    tmp_return_value = var_pkey;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_148_load_publickey);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)par_buffer);
    Py_DECREF(par_buffer);
    par_buffer = NULL;

    CHECK_OBJECT((PyObject *)var_bio);
    Py_DECREF(var_bio);
    var_bio = NULL;

    CHECK_OBJECT((PyObject *)var_pkey);
    Py_DECREF(var_pkey);
    var_pkey = NULL;

    Py_XDECREF(var_evp_pkey);
    var_evp_pkey = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(par_buffer);
    par_buffer = NULL;

    Py_XDECREF(var_bio);
    var_bio = NULL;

    Py_XDECREF(var_pkey);
    var_pkey = NULL;

    Py_XDECREF(var_evp_pkey);
    var_evp_pkey = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_148_load_publickey);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_149_load_privatekey(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_type = python_pars[0];
    PyObject *par_buffer = python_pars[1];
    PyObject *par_passphrase = python_pars[2];
    PyObject *var_bio = NULL;
    PyObject *var_helper = NULL;
    PyObject *var_pkey = NULL;
    PyObject *var_evp_pkey = NULL;
    struct Nuitka_FrameObject *frame_b7fff7ac811f5c1447b68a592d106780;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_b7fff7ac811f5c1447b68a592d106780 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_b7fff7ac811f5c1447b68a592d106780, codeobj_b7fff7ac811f5c1447b68a592d106780, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_b7fff7ac811f5c1447b68a592d106780 = cache_frame_b7fff7ac811f5c1447b68a592d106780;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_b7fff7ac811f5c1447b68a592d106780);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_b7fff7ac811f5c1447b68a592d106780) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_buffer);
        tmp_isinstance_inst_1 = par_buffer;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__text_type);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__text_type);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3552 ], 39, 0);
            exception_tb = NULL;

            exception_lineno = 2794;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2794;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_called_instance_1;
            CHECK_OBJECT(par_buffer);
            tmp_called_instance_1 = par_buffer;
            frame_b7fff7ac811f5c1447b68a592d106780->m_frame.f_lineno = 2795;
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_encode, &PyTuple_GET_ITEM(const_tuple_str_plain_ascii_tuple, 0));

            if (tmp_assign_source_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2795;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_buffer;
                assert(old != NULL);
                par_buffer = tmp_assign_source_1;
                Py_DECREF(old);
            }

        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3591 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 2797;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_2;
        CHECK_OBJECT(par_buffer);
        tmp_args_element_name_1 = par_buffer;
        frame_b7fff7ac811f5c1447b68a592d106780->m_frame.f_lineno = 2797;
        tmp_assign_source_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2797;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_bio == NULL);
        var_bio = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__PassphraseHelper);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__PassphraseHelper);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 586 ], 46, 0);
            exception_tb = NULL;

            exception_lineno = 2799;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_3;
        CHECK_OBJECT(par_type);
        tmp_args_element_name_2 = par_type;
        CHECK_OBJECT(par_passphrase);
        tmp_args_element_name_3 = par_passphrase;
        frame_b7fff7ac811f5c1447b68a592d106780->m_frame.f_lineno = 2799;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        if (tmp_assign_source_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2799;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_helper == NULL);
        var_helper = tmp_assign_source_3;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_4;
        CHECK_OBJECT(par_type);
        tmp_compexpr_left_1 = par_type;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 632 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 2800;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_4;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2800;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_4;
            PyObject *tmp_called_name_3;
            PyObject *tmp_source_name_1;
            PyObject *tmp_mvar_value_5;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_args_element_name_5;
            PyObject *tmp_source_name_2;
            PyObject *tmp_mvar_value_6;
            PyObject *tmp_args_element_name_6;
            PyObject *tmp_source_name_3;
            PyObject *tmp_args_element_name_7;
            PyObject *tmp_source_name_4;
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_5 == NULL)) {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_5 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 2801;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_1 = tmp_mvar_value_5;
            tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_PEM_read_bio_PrivateKey);
            if (tmp_called_name_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2801;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_bio);
            tmp_args_element_name_4 = var_bio;
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_6 == NULL)) {
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_6 == NULL) {
                Py_DECREF(tmp_called_name_3);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 2802;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_2 = tmp_mvar_value_6;
            tmp_args_element_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_NULL);
            if (tmp_args_element_name_5 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_3);

                exception_lineno = 2802;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_helper);
            tmp_source_name_3 = var_helper;
            tmp_args_element_name_6 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_callback);
            if (tmp_args_element_name_6 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_3);
                Py_DECREF(tmp_args_element_name_5);

                exception_lineno = 2802;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_helper);
            tmp_source_name_4 = var_helper;
            tmp_args_element_name_7 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_callback_args);
            if (tmp_args_element_name_7 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_3);
                Py_DECREF(tmp_args_element_name_5);
                Py_DECREF(tmp_args_element_name_6);

                exception_lineno = 2802;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            frame_b7fff7ac811f5c1447b68a592d106780->m_frame.f_lineno = 2801;
            {
                PyObject *call_args[] = {tmp_args_element_name_4, tmp_args_element_name_5, tmp_args_element_name_6, tmp_args_element_name_7};
                tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS4(tmp_called_name_3, call_args);
            }

            Py_DECREF(tmp_called_name_3);
            Py_DECREF(tmp_args_element_name_5);
            Py_DECREF(tmp_args_element_name_6);
            Py_DECREF(tmp_args_element_name_7);
            if (tmp_assign_source_4 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2801;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            assert(var_evp_pkey == NULL);
            var_evp_pkey = tmp_assign_source_4;
        }
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_call_result_1;
            CHECK_OBJECT(var_helper);
            tmp_called_instance_2 = var_helper;
            frame_b7fff7ac811f5c1447b68a592d106780->m_frame.f_lineno = 2803;
            tmp_call_result_1 = CALL_METHOD_NO_ARGS(tmp_called_instance_2, const_str_plain_raise_if_problem);
            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2803;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_1);
        }
        goto branch_end_2;
        branch_no_2:;
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_mvar_value_7;
            CHECK_OBJECT(par_type);
            tmp_compexpr_left_2 = par_type;
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1);

            if (unlikely(tmp_mvar_value_7 == NULL)) {
                tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1);
            }

            if (tmp_mvar_value_7 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 4053 ], 42, 0);
                exception_tb = NULL;

                exception_lineno = 2804;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_2 = tmp_mvar_value_7;
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2804;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_3 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
                goto branch_yes_3;
            } else {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_assign_source_5;
                PyObject *tmp_called_name_4;
                PyObject *tmp_source_name_5;
                PyObject *tmp_mvar_value_8;
                PyObject *tmp_args_element_name_8;
                PyObject *tmp_args_element_name_9;
                PyObject *tmp_source_name_6;
                PyObject *tmp_mvar_value_9;
                tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

                if (unlikely(tmp_mvar_value_8 == NULL)) {
                    tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
                }

                if (tmp_mvar_value_8 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 2805;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_5 = tmp_mvar_value_8;
                tmp_called_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_d2i_PrivateKey_bio);
                if (tmp_called_name_4 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2805;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT(var_bio);
                tmp_args_element_name_8 = var_bio;
                tmp_mvar_value_9 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

                if (unlikely(tmp_mvar_value_9 == NULL)) {
                    tmp_mvar_value_9 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
                }

                if (tmp_mvar_value_9 == NULL) {
                    Py_DECREF(tmp_called_name_4);
                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 2805;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_6 = tmp_mvar_value_9;
                tmp_args_element_name_9 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_NULL);
                if (tmp_args_element_name_9 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    Py_DECREF(tmp_called_name_4);

                    exception_lineno = 2805;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                frame_b7fff7ac811f5c1447b68a592d106780->m_frame.f_lineno = 2805;
                {
                    PyObject *call_args[] = {tmp_args_element_name_8, tmp_args_element_name_9};
                    tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_4, call_args);
                }

                Py_DECREF(tmp_called_name_4);
                Py_DECREF(tmp_args_element_name_9);
                if (tmp_assign_source_5 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2805;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                assert(var_evp_pkey == NULL);
                var_evp_pkey = tmp_assign_source_5;
            }
            goto branch_end_3;
            branch_no_3:;
            {
                PyObject *tmp_raise_type_1;
                PyObject *tmp_make_exception_arg_1;
                tmp_make_exception_arg_1 = const_str_digest_f019d8c1ebbf58631ace92b4423b3aad;
                frame_b7fff7ac811f5c1447b68a592d106780->m_frame.f_lineno = 2807;
                tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_1);
                assert(!(tmp_raise_type_1 == NULL));
                exception_type = tmp_raise_type_1;
                exception_lineno = 2807;
                RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            branch_end_3:;
        }
        branch_end_2:;
    }
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_10;
        if (var_evp_pkey == NULL) {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("local variable '%s' referenced before assignment", "evp_pkey");
            exception_tb = NULL;

            exception_lineno = 2809;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_left_3 = var_evp_pkey;
        tmp_mvar_value_10 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_10 == NULL)) {
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_10 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2809;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = tmp_mvar_value_10;
        tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain_NULL);
        if (tmp_compexpr_right_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2809;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_3, tmp_compexpr_right_3);
        Py_DECREF(tmp_compexpr_right_3);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2809;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_4 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_4 == NUITKA_BOOL_TRUE) {
            goto branch_yes_4;
        } else {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_called_name_5;
            PyObject *tmp_mvar_value_11;
            PyObject *tmp_call_result_2;
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error);

            if (unlikely(tmp_mvar_value_11 == NULL)) {
                tmp_mvar_value_11 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error);
            }

            if (tmp_mvar_value_11 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 0 ], 49, 0);
                exception_tb = NULL;

                exception_lineno = 2810;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_5 = tmp_mvar_value_11;
            frame_b7fff7ac811f5c1447b68a592d106780->m_frame.f_lineno = 2810;
            tmp_call_result_2 = CALL_FUNCTION_NO_ARGS(tmp_called_name_5);
            if (tmp_call_result_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2810;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_2);
        }
        branch_no_4:;
    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_called_name_6;
        PyObject *tmp_source_name_8;
        PyObject *tmp_mvar_value_12;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_mvar_value_13;
        tmp_mvar_value_12 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey);

        if (unlikely(tmp_mvar_value_12 == NULL)) {
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey);
        }

        if (tmp_mvar_value_12 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 978 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2812;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_8 = tmp_mvar_value_12;
        tmp_called_name_6 = LOOKUP_ATTRIBUTE(tmp_source_name_8, const_str_plain___new__);
        if (tmp_called_name_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2812;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_13 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey);

        if (unlikely(tmp_mvar_value_13 == NULL)) {
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey);
        }

        if (tmp_mvar_value_13 == NULL) {
            Py_DECREF(tmp_called_name_6);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 978 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2812;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_10 = tmp_mvar_value_13;
        frame_b7fff7ac811f5c1447b68a592d106780->m_frame.f_lineno = 2812;
        tmp_assign_source_6 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_6, tmp_args_element_name_10);
        Py_DECREF(tmp_called_name_6);
        if (tmp_assign_source_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2812;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_pkey == NULL);
        var_pkey = tmp_assign_source_6;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_7;
        PyObject *tmp_source_name_9;
        PyObject *tmp_mvar_value_14;
        PyObject *tmp_args_element_name_11;
        PyObject *tmp_args_element_name_12;
        PyObject *tmp_source_name_10;
        PyObject *tmp_mvar_value_15;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_14 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_14 == NULL)) {
            tmp_mvar_value_14 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_14 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2813;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_9 = tmp_mvar_value_14;
        tmp_called_name_7 = LOOKUP_ATTRIBUTE(tmp_source_name_9, const_str_plain_gc);
        if (tmp_called_name_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2813;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        if (var_evp_pkey == NULL) {
            Py_DECREF(tmp_called_name_7);
            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("local variable '%s' referenced before assignment", "evp_pkey");
            exception_tb = NULL;

            exception_lineno = 2813;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_11 = var_evp_pkey;
        tmp_mvar_value_15 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_15 == NULL)) {
            tmp_mvar_value_15 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_15 == NULL) {
            Py_DECREF(tmp_called_name_7);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2813;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_10 = tmp_mvar_value_15;
        tmp_args_element_name_12 = LOOKUP_ATTRIBUTE(tmp_source_name_10, const_str_plain_EVP_PKEY_free);
        if (tmp_args_element_name_12 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_7);

            exception_lineno = 2813;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        frame_b7fff7ac811f5c1447b68a592d106780->m_frame.f_lineno = 2813;
        {
            PyObject *call_args[] = {tmp_args_element_name_11, tmp_args_element_name_12};
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_7, call_args);
        }

        Py_DECREF(tmp_called_name_7);
        Py_DECREF(tmp_args_element_name_12);
        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2813;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_pkey);
        tmp_assattr_target_1 = var_pkey;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__pkey, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2813;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b7fff7ac811f5c1447b68a592d106780);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b7fff7ac811f5c1447b68a592d106780);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_b7fff7ac811f5c1447b68a592d106780, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_b7fff7ac811f5c1447b68a592d106780->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_b7fff7ac811f5c1447b68a592d106780, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b7fff7ac811f5c1447b68a592d106780,
        type_description_1,
        par_type,
        par_buffer,
        par_passphrase,
        var_bio,
        var_helper,
        var_pkey,
        var_evp_pkey
    );


    // Release cached frame.
    if (frame_b7fff7ac811f5c1447b68a592d106780 == cache_frame_b7fff7ac811f5c1447b68a592d106780) {
        Py_DECREF(frame_b7fff7ac811f5c1447b68a592d106780);
    }
    cache_frame_b7fff7ac811f5c1447b68a592d106780 = NULL;

    assertFrameObject(frame_b7fff7ac811f5c1447b68a592d106780);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT(var_pkey);
    tmp_return_value = var_pkey;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_149_load_privatekey);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_bio);
    Py_DECREF(var_bio);
    var_bio = NULL;

    CHECK_OBJECT((PyObject *)var_helper);
    Py_DECREF(var_helper);
    var_helper = NULL;

    CHECK_OBJECT((PyObject *)var_pkey);
    Py_DECREF(var_pkey);
    var_pkey = NULL;

    CHECK_OBJECT((PyObject *)par_buffer);
    Py_DECREF(par_buffer);
    par_buffer = NULL;

    Py_XDECREF(var_evp_pkey);
    var_evp_pkey = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_bio);
    var_bio = NULL;

    Py_XDECREF(var_helper);
    var_helper = NULL;

    Py_XDECREF(var_pkey);
    var_pkey = NULL;

    Py_XDECREF(par_buffer);
    par_buffer = NULL;

    Py_XDECREF(var_evp_pkey);
    var_evp_pkey = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_149_load_privatekey);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_passphrase);
    Py_DECREF(par_passphrase);
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_passphrase);
    Py_DECREF(par_passphrase);
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_150_dump_certificate_request(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_type = python_pars[0];
    PyObject *par_req = python_pars[1];
    PyObject *var_bio = NULL;
    PyObject *var_result_code = NULL;
    struct Nuitka_FrameObject *frame_37ee45b6be0afd221cf7a538d742d0bf;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_37ee45b6be0afd221cf7a538d742d0bf = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_37ee45b6be0afd221cf7a538d742d0bf, codeobj_37ee45b6be0afd221cf7a538d742d0bf, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_37ee45b6be0afd221cf7a538d742d0bf = cache_frame_37ee45b6be0afd221cf7a538d742d0bf;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_37ee45b6be0afd221cf7a538d742d0bf);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_37ee45b6be0afd221cf7a538d742d0bf) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3591 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 2826;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        frame_37ee45b6be0afd221cf7a538d742d0bf->m_frame.f_lineno = 2826;
        tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS(tmp_called_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2826;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_bio == NULL);
        var_bio = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT(par_type);
        tmp_compexpr_left_1 = par_type;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 632 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 2828;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_2;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2828;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_1;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_source_name_2;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_3 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 2829;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_1 = tmp_mvar_value_3;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_PEM_write_bio_X509_REQ);
            if (tmp_called_name_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2829;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_bio);
            tmp_args_element_name_1 = var_bio;
            CHECK_OBJECT(par_req);
            tmp_source_name_2 = par_req;
            tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__req);
            if (tmp_args_element_name_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_2);

                exception_lineno = 2829;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            frame_37ee45b6be0afd221cf7a538d742d0bf->m_frame.f_lineno = 2829;
            {
                PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
                tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
            }

            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_2);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2829;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            assert(var_result_code == NULL);
            var_result_code = tmp_assign_source_2;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_mvar_value_4;
            CHECK_OBJECT(par_type);
            tmp_compexpr_left_2 = par_type;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1);
            }

            if (tmp_mvar_value_4 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 4053 ], 42, 0);
                exception_tb = NULL;

                exception_lineno = 2830;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_2 = tmp_mvar_value_4;
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2830;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
                goto branch_yes_2;
            } else {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_assign_source_3;
                PyObject *tmp_called_name_3;
                PyObject *tmp_source_name_3;
                PyObject *tmp_mvar_value_5;
                PyObject *tmp_args_element_name_3;
                PyObject *tmp_args_element_name_4;
                PyObject *tmp_source_name_4;
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

                if (unlikely(tmp_mvar_value_5 == NULL)) {
                    tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
                }

                if (tmp_mvar_value_5 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 2831;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_3 = tmp_mvar_value_5;
                tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_i2d_X509_REQ_bio);
                if (tmp_called_name_3 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2831;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT(var_bio);
                tmp_args_element_name_3 = var_bio;
                CHECK_OBJECT(par_req);
                tmp_source_name_4 = par_req;
                tmp_args_element_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain__req);
                if (tmp_args_element_name_4 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    Py_DECREF(tmp_called_name_3);

                    exception_lineno = 2831;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                frame_37ee45b6be0afd221cf7a538d742d0bf->m_frame.f_lineno = 2831;
                {
                    PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4};
                    tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_3, call_args);
                }

                Py_DECREF(tmp_called_name_3);
                Py_DECREF(tmp_args_element_name_4);
                if (tmp_assign_source_3 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2831;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                assert(var_result_code == NULL);
                var_result_code = tmp_assign_source_3;
            }
            goto branch_end_2;
            branch_no_2:;
            {
                nuitka_bool tmp_condition_result_3;
                PyObject *tmp_compexpr_left_3;
                PyObject *tmp_compexpr_right_3;
                PyObject *tmp_mvar_value_6;
                CHECK_OBJECT(par_type);
                tmp_compexpr_left_3 = par_type;
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_TEXT);

                if (unlikely(tmp_mvar_value_6 == NULL)) {
                    tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_TEXT);
                }

                if (tmp_mvar_value_6 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 4095 ], 42, 0);
                    exception_tb = NULL;

                    exception_lineno = 2832;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }

                tmp_compexpr_right_3 = tmp_mvar_value_6;
                tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_3, tmp_compexpr_right_3);
                if (tmp_res == -1) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2832;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                tmp_condition_result_3 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
                    goto branch_yes_3;
                } else {
                    goto branch_no_3;
                }
                branch_yes_3:;
                {
                    PyObject *tmp_assign_source_4;
                    PyObject *tmp_called_name_4;
                    PyObject *tmp_source_name_5;
                    PyObject *tmp_mvar_value_7;
                    PyObject *tmp_args_element_name_5;
                    PyObject *tmp_args_element_name_6;
                    PyObject *tmp_source_name_6;
                    PyObject *tmp_args_element_name_7;
                    PyObject *tmp_args_element_name_8;
                    tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

                    if (unlikely(tmp_mvar_value_7 == NULL)) {
                        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
                    }

                    if (tmp_mvar_value_7 == NULL) {

                        exception_type = PyExc_NameError;
                        Py_INCREF(exception_type);
                        exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                        exception_tb = NULL;

                        exception_lineno = 2833;
                        type_description_1 = "oooo";
                        goto frame_exception_exit_1;
                    }

                    tmp_source_name_5 = tmp_mvar_value_7;
                    tmp_called_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_X509_REQ_print_ex);
                    if (tmp_called_name_4 == NULL) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                        exception_lineno = 2833;
                        type_description_1 = "oooo";
                        goto frame_exception_exit_1;
                    }
                    CHECK_OBJECT(var_bio);
                    tmp_args_element_name_5 = var_bio;
                    CHECK_OBJECT(par_req);
                    tmp_source_name_6 = par_req;
                    tmp_args_element_name_6 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain__req);
                    if (tmp_args_element_name_6 == NULL) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                        Py_DECREF(tmp_called_name_4);

                        exception_lineno = 2833;
                        type_description_1 = "oooo";
                        goto frame_exception_exit_1;
                    }
                    tmp_args_element_name_7 = const_int_0;
                    tmp_args_element_name_8 = const_int_0;
                    frame_37ee45b6be0afd221cf7a538d742d0bf->m_frame.f_lineno = 2833;
                    {
                        PyObject *call_args[] = {tmp_args_element_name_5, tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8};
                        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS4(tmp_called_name_4, call_args);
                    }

                    Py_DECREF(tmp_called_name_4);
                    Py_DECREF(tmp_args_element_name_6);
                    if (tmp_assign_source_4 == NULL) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                        exception_lineno = 2833;
                        type_description_1 = "oooo";
                        goto frame_exception_exit_1;
                    }
                    assert(var_result_code == NULL);
                    var_result_code = tmp_assign_source_4;
                }
                goto branch_end_3;
                branch_no_3:;
                {
                    PyObject *tmp_raise_type_1;
                    PyObject *tmp_make_exception_arg_1;
                    tmp_make_exception_arg_1 = const_str_digest_11c225ccbab9acffc38107dee9691702;
                    frame_37ee45b6be0afd221cf7a538d742d0bf->m_frame.f_lineno = 2835;
                    tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_1);
                    assert(!(tmp_raise_type_1 == NULL));
                    exception_type = tmp_raise_type_1;
                    exception_lineno = 2835;
                    RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                branch_end_3:;
            }
            branch_end_2:;
        }
        branch_end_1:;
    }
    {
        PyObject *tmp_called_name_5;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_8 == NULL)) {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_8 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 2840;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_5 = tmp_mvar_value_8;
        if (var_result_code == NULL) {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("local variable '%s' referenced before assignment", "result_code");
            exception_tb = NULL;

            exception_lineno = 2840;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_left_4 = var_result_code;
        tmp_compexpr_right_4 = const_int_0;
        tmp_args_element_name_9 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_4, tmp_compexpr_right_4);
        if (tmp_args_element_name_9 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2840;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_37ee45b6be0afd221cf7a538d742d0bf->m_frame.f_lineno = 2840;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_5, tmp_args_element_name_9);
        Py_DECREF(tmp_args_element_name_9);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2840;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_called_name_6;
        PyObject *tmp_mvar_value_9;
        PyObject *tmp_args_element_name_10;
        tmp_mvar_value_9 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__bio_to_string);

        if (unlikely(tmp_mvar_value_9 == NULL)) {
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__bio_to_string);
        }

        if (tmp_mvar_value_9 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3632 ], 43, 0);
            exception_tb = NULL;

            exception_lineno = 2842;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_6 = tmp_mvar_value_9;
        CHECK_OBJECT(var_bio);
        tmp_args_element_name_10 = var_bio;
        frame_37ee45b6be0afd221cf7a538d742d0bf->m_frame.f_lineno = 2842;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_6, tmp_args_element_name_10);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2842;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_37ee45b6be0afd221cf7a538d742d0bf);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_37ee45b6be0afd221cf7a538d742d0bf);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_37ee45b6be0afd221cf7a538d742d0bf);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_37ee45b6be0afd221cf7a538d742d0bf, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_37ee45b6be0afd221cf7a538d742d0bf->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_37ee45b6be0afd221cf7a538d742d0bf, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_37ee45b6be0afd221cf7a538d742d0bf,
        type_description_1,
        par_type,
        par_req,
        var_bio,
        var_result_code
    );


    // Release cached frame.
    if (frame_37ee45b6be0afd221cf7a538d742d0bf == cache_frame_37ee45b6be0afd221cf7a538d742d0bf) {
        Py_DECREF(frame_37ee45b6be0afd221cf7a538d742d0bf);
    }
    cache_frame_37ee45b6be0afd221cf7a538d742d0bf = NULL;

    assertFrameObject(frame_37ee45b6be0afd221cf7a538d742d0bf);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_150_dump_certificate_request);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_bio);
    Py_DECREF(var_bio);
    var_bio = NULL;

    Py_XDECREF(var_result_code);
    var_result_code = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_bio);
    var_bio = NULL;

    Py_XDECREF(var_result_code);
    var_result_code = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_150_dump_certificate_request);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_req);
    Py_DECREF(par_req);
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_req);
    Py_DECREF(par_req);
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_151_load_certificate_request(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_type = python_pars[0];
    PyObject *par_buffer = python_pars[1];
    PyObject *var_bio = NULL;
    PyObject *var_req = NULL;
    PyObject *var_x509req = NULL;
    struct Nuitka_FrameObject *frame_dd9bf8ebdf933d2516db3e82c61898d8;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_dd9bf8ebdf933d2516db3e82c61898d8 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_dd9bf8ebdf933d2516db3e82c61898d8, codeobj_dd9bf8ebdf933d2516db3e82c61898d8, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_dd9bf8ebdf933d2516db3e82c61898d8 = cache_frame_dd9bf8ebdf933d2516db3e82c61898d8;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_dd9bf8ebdf933d2516db3e82c61898d8);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_dd9bf8ebdf933d2516db3e82c61898d8) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_buffer);
        tmp_isinstance_inst_1 = par_buffer;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__text_type);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__text_type);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3552 ], 39, 0);
            exception_tb = NULL;

            exception_lineno = 2854;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2854;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_called_instance_1;
            CHECK_OBJECT(par_buffer);
            tmp_called_instance_1 = par_buffer;
            frame_dd9bf8ebdf933d2516db3e82c61898d8->m_frame.f_lineno = 2855;
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_encode, &PyTuple_GET_ITEM(const_tuple_str_plain_ascii_tuple, 0));

            if (tmp_assign_source_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2855;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_buffer;
                assert(old != NULL);
                par_buffer = tmp_assign_source_1;
                Py_DECREF(old);
            }

        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3591 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 2857;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_2;
        CHECK_OBJECT(par_buffer);
        tmp_args_element_name_1 = par_buffer;
        frame_dd9bf8ebdf933d2516db3e82c61898d8->m_frame.f_lineno = 2857;
        tmp_assign_source_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2857;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(var_bio == NULL);
        var_bio = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_3;
        CHECK_OBJECT(par_type);
        tmp_compexpr_left_1 = par_type;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 632 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 2859;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_3;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2859;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_1;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_source_name_2;
            PyObject *tmp_mvar_value_5;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_source_name_3;
            PyObject *tmp_mvar_value_6;
            PyObject *tmp_args_element_name_5;
            PyObject *tmp_source_name_4;
            PyObject *tmp_mvar_value_7;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_4 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 2860;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_1 = tmp_mvar_value_4;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_PEM_read_bio_X509_REQ);
            if (tmp_called_name_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2860;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_bio);
            tmp_args_element_name_2 = var_bio;
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_5 == NULL)) {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_5 == NULL) {
                Py_DECREF(tmp_called_name_2);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 2860;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_2 = tmp_mvar_value_5;
            tmp_args_element_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_NULL);
            if (tmp_args_element_name_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_2);

                exception_lineno = 2860;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_6 == NULL)) {
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_6 == NULL) {
                Py_DECREF(tmp_called_name_2);
                Py_DECREF(tmp_args_element_name_3);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 2860;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_3 = tmp_mvar_value_6;
            tmp_args_element_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_NULL);
            if (tmp_args_element_name_4 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_2);
                Py_DECREF(tmp_args_element_name_3);

                exception_lineno = 2860;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_7 == NULL)) {
                tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_7 == NULL) {
                Py_DECREF(tmp_called_name_2);
                Py_DECREF(tmp_args_element_name_3);
                Py_DECREF(tmp_args_element_name_4);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 2860;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_4 = tmp_mvar_value_7;
            tmp_args_element_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_NULL);
            if (tmp_args_element_name_5 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_2);
                Py_DECREF(tmp_args_element_name_3);
                Py_DECREF(tmp_args_element_name_4);

                exception_lineno = 2860;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            frame_dd9bf8ebdf933d2516db3e82c61898d8->m_frame.f_lineno = 2860;
            {
                PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5};
                tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS4(tmp_called_name_2, call_args);
            }

            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_3);
            Py_DECREF(tmp_args_element_name_4);
            Py_DECREF(tmp_args_element_name_5);
            if (tmp_assign_source_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2860;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            assert(var_req == NULL);
            var_req = tmp_assign_source_3;
        }
        goto branch_end_2;
        branch_no_2:;
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_mvar_value_8;
            CHECK_OBJECT(par_type);
            tmp_compexpr_left_2 = par_type;
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1);

            if (unlikely(tmp_mvar_value_8 == NULL)) {
                tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1);
            }

            if (tmp_mvar_value_8 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 4053 ], 42, 0);
                exception_tb = NULL;

                exception_lineno = 2861;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_2 = tmp_mvar_value_8;
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2861;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_3 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
                goto branch_yes_3;
            } else {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_assign_source_4;
                PyObject *tmp_called_name_3;
                PyObject *tmp_source_name_5;
                PyObject *tmp_mvar_value_9;
                PyObject *tmp_args_element_name_6;
                PyObject *tmp_args_element_name_7;
                PyObject *tmp_source_name_6;
                PyObject *tmp_mvar_value_10;
                tmp_mvar_value_9 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

                if (unlikely(tmp_mvar_value_9 == NULL)) {
                    tmp_mvar_value_9 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
                }

                if (tmp_mvar_value_9 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 2862;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_5 = tmp_mvar_value_9;
                tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_d2i_X509_REQ_bio);
                if (tmp_called_name_3 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2862;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT(var_bio);
                tmp_args_element_name_6 = var_bio;
                tmp_mvar_value_10 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

                if (unlikely(tmp_mvar_value_10 == NULL)) {
                    tmp_mvar_value_10 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
                }

                if (tmp_mvar_value_10 == NULL) {
                    Py_DECREF(tmp_called_name_3);
                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 2862;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_6 = tmp_mvar_value_10;
                tmp_args_element_name_7 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_NULL);
                if (tmp_args_element_name_7 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    Py_DECREF(tmp_called_name_3);

                    exception_lineno = 2862;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                frame_dd9bf8ebdf933d2516db3e82c61898d8->m_frame.f_lineno = 2862;
                {
                    PyObject *call_args[] = {tmp_args_element_name_6, tmp_args_element_name_7};
                    tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_3, call_args);
                }

                Py_DECREF(tmp_called_name_3);
                Py_DECREF(tmp_args_element_name_7);
                if (tmp_assign_source_4 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2862;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                assert(var_req == NULL);
                var_req = tmp_assign_source_4;
            }
            goto branch_end_3;
            branch_no_3:;
            {
                PyObject *tmp_raise_type_1;
                PyObject *tmp_make_exception_arg_1;
                tmp_make_exception_arg_1 = const_str_digest_f019d8c1ebbf58631ace92b4423b3aad;
                frame_dd9bf8ebdf933d2516db3e82c61898d8->m_frame.f_lineno = 2864;
                tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_1);
                assert(!(tmp_raise_type_1 == NULL));
                exception_type = tmp_raise_type_1;
                exception_lineno = 2864;
                RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            branch_end_3:;
        }
        branch_end_2:;
    }
    {
        PyObject *tmp_called_name_4;
        PyObject *tmp_mvar_value_11;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_12;
        tmp_mvar_value_11 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_11 == NULL)) {
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_11 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 2866;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_4 = tmp_mvar_value_11;
        if (var_req == NULL) {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("local variable '%s' referenced before assignment", "req");
            exception_tb = NULL;

            exception_lineno = 2866;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_left_3 = var_req;
        tmp_mvar_value_12 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_12 == NULL)) {
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_12 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2866;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = tmp_mvar_value_12;
        tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain_NULL);
        if (tmp_compexpr_right_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2866;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_8 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_3, tmp_compexpr_right_3);
        Py_DECREF(tmp_compexpr_right_3);
        if (tmp_args_element_name_8 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2866;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_dd9bf8ebdf933d2516db3e82c61898d8->m_frame.f_lineno = 2866;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_4, tmp_args_element_name_8);
        Py_DECREF(tmp_args_element_name_8);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2866;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_called_name_5;
        PyObject *tmp_source_name_8;
        PyObject *tmp_mvar_value_13;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_mvar_value_14;
        tmp_mvar_value_13 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Req);

        if (unlikely(tmp_mvar_value_13 == NULL)) {
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Req);
        }

        if (tmp_mvar_value_13 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 4266 ], 36, 0);
            exception_tb = NULL;

            exception_lineno = 2868;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_8 = tmp_mvar_value_13;
        tmp_called_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_8, const_str_plain___new__);
        if (tmp_called_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2868;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_14 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Req);

        if (unlikely(tmp_mvar_value_14 == NULL)) {
            tmp_mvar_value_14 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Req);
        }

        if (tmp_mvar_value_14 == NULL) {
            Py_DECREF(tmp_called_name_5);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 4266 ], 36, 0);
            exception_tb = NULL;

            exception_lineno = 2868;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_9 = tmp_mvar_value_14;
        frame_dd9bf8ebdf933d2516db3e82c61898d8->m_frame.f_lineno = 2868;
        tmp_assign_source_5 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_5, tmp_args_element_name_9);
        Py_DECREF(tmp_called_name_5);
        if (tmp_assign_source_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2868;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(var_x509req == NULL);
        var_x509req = tmp_assign_source_5;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_6;
        PyObject *tmp_source_name_9;
        PyObject *tmp_mvar_value_15;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_args_element_name_11;
        PyObject *tmp_source_name_10;
        PyObject *tmp_mvar_value_16;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_15 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_15 == NULL)) {
            tmp_mvar_value_15 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_15 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2869;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_9 = tmp_mvar_value_15;
        tmp_called_name_6 = LOOKUP_ATTRIBUTE(tmp_source_name_9, const_str_plain_gc);
        if (tmp_called_name_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2869;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        if (var_req == NULL) {
            Py_DECREF(tmp_called_name_6);
            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("local variable '%s' referenced before assignment", "req");
            exception_tb = NULL;

            exception_lineno = 2869;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_10 = var_req;
        tmp_mvar_value_16 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_16 == NULL)) {
            tmp_mvar_value_16 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_16 == NULL) {
            Py_DECREF(tmp_called_name_6);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2869;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_10 = tmp_mvar_value_16;
        tmp_args_element_name_11 = LOOKUP_ATTRIBUTE(tmp_source_name_10, const_str_plain_X509_REQ_free);
        if (tmp_args_element_name_11 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_6);

            exception_lineno = 2869;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_dd9bf8ebdf933d2516db3e82c61898d8->m_frame.f_lineno = 2869;
        {
            PyObject *call_args[] = {tmp_args_element_name_10, tmp_args_element_name_11};
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_6, call_args);
        }

        Py_DECREF(tmp_called_name_6);
        Py_DECREF(tmp_args_element_name_11);
        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2869;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_x509req);
        tmp_assattr_target_1 = var_x509req;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__req, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2869;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_dd9bf8ebdf933d2516db3e82c61898d8);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_dd9bf8ebdf933d2516db3e82c61898d8);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_dd9bf8ebdf933d2516db3e82c61898d8, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_dd9bf8ebdf933d2516db3e82c61898d8->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_dd9bf8ebdf933d2516db3e82c61898d8, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_dd9bf8ebdf933d2516db3e82c61898d8,
        type_description_1,
        par_type,
        par_buffer,
        var_bio,
        var_req,
        var_x509req
    );


    // Release cached frame.
    if (frame_dd9bf8ebdf933d2516db3e82c61898d8 == cache_frame_dd9bf8ebdf933d2516db3e82c61898d8) {
        Py_DECREF(frame_dd9bf8ebdf933d2516db3e82c61898d8);
    }
    cache_frame_dd9bf8ebdf933d2516db3e82c61898d8 = NULL;

    assertFrameObject(frame_dd9bf8ebdf933d2516db3e82c61898d8);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT(var_x509req);
    tmp_return_value = var_x509req;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_151_load_certificate_request);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)par_buffer);
    Py_DECREF(par_buffer);
    par_buffer = NULL;

    CHECK_OBJECT((PyObject *)var_bio);
    Py_DECREF(var_bio);
    var_bio = NULL;

    Py_XDECREF(var_req);
    var_req = NULL;

    CHECK_OBJECT((PyObject *)var_x509req);
    Py_DECREF(var_x509req);
    var_x509req = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(par_buffer);
    par_buffer = NULL;

    Py_XDECREF(var_bio);
    var_bio = NULL;

    Py_XDECREF(var_req);
    var_req = NULL;

    Py_XDECREF(var_x509req);
    var_x509req = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_151_load_certificate_request);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_152_sign(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_pkey = python_pars[0];
    PyObject *par_data = python_pars[1];
    PyObject *par_digest = python_pars[2];
    PyObject *var_final_result = NULL;
    PyObject *var_signature_length = NULL;
    PyObject *var_length = NULL;
    PyObject *var_digest_obj = NULL;
    PyObject *var_signature_buffer = NULL;
    PyObject *var_md_ctx = NULL;
    struct Nuitka_FrameObject *frame_8c86ab161458de9d92d55080e4948b8b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_8c86ab161458de9d92d55080e4948b8b = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_8c86ab161458de9d92d55080e4948b8b, codeobj_8c86ab161458de9d92d55080e4948b8b, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_8c86ab161458de9d92d55080e4948b8b = cache_frame_8c86ab161458de9d92d55080e4948b8b;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_8c86ab161458de9d92d55080e4948b8b);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_8c86ab161458de9d92d55080e4948b8b) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1011 ], 52, 0);
            exception_tb = NULL;

            exception_lineno = 2884;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        tmp_args_element_name_1 = const_str_plain_data;
        CHECK_OBJECT(par_data);
        tmp_args_element_name_2 = par_data;
        frame_8c86ab161458de9d92d55080e4948b8b->m_frame.f_lineno = 2884;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2884;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = par_data;
            assert(old != NULL);
            par_data = tmp_assign_source_1;
            Py_DECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2886;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_EVP_get_digestbyname);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2886;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__byte_string);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__byte_string);
        }

        if (tmp_mvar_value_3 == NULL) {
            Py_DECREF(tmp_called_name_2);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3511 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 2886;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_3;
        CHECK_OBJECT(par_digest);
        tmp_args_element_name_4 = par_digest;
        frame_8c86ab161458de9d92d55080e4948b8b->m_frame.f_lineno = 2886;
        tmp_args_element_name_3 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_3, tmp_args_element_name_4);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 2886;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        frame_8c86ab161458de9d92d55080e4948b8b->m_frame.f_lineno = 2886;
        tmp_assign_source_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_3);
        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2886;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_digest_obj == NULL);
        var_digest_obj = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_4;
        CHECK_OBJECT(var_digest_obj);
        tmp_compexpr_left_1 = var_digest_obj;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2887;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_4;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_NULL);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2887;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2887;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_500f278b67471fc0f770fccc80d65d95;
            frame_8c86ab161458de9d92d55080e4948b8b->m_frame.f_lineno = 2888;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 2888;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_5;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2890;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_5;
        frame_8c86ab161458de9d92d55080e4948b8b->m_frame.f_lineno = 2890;
        tmp_assign_source_3 = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_Cryptography_EVP_MD_CTX_new);
        if (tmp_assign_source_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2890;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_md_ctx == NULL);
        var_md_ctx = tmp_assign_source_3;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_7;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_6 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2891;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_6;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_gc);
        if (tmp_called_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2891;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_md_ctx);
        tmp_args_element_name_5 = var_md_ctx;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_7 == NULL)) {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_7 == NULL) {
            Py_DECREF(tmp_called_name_4);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2891;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_7;
        tmp_args_element_name_6 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_Cryptography_EVP_MD_CTX_free);
        if (tmp_args_element_name_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_4);

            exception_lineno = 2891;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        frame_8c86ab161458de9d92d55080e4948b8b->m_frame.f_lineno = 2891;
        {
            PyObject *call_args[] = {tmp_args_element_name_5, tmp_args_element_name_6};
            tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_4, call_args);
        }

        Py_DECREF(tmp_called_name_4);
        Py_DECREF(tmp_args_element_name_6);
        if (tmp_assign_source_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2891;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var_md_ctx;
            assert(old != NULL);
            var_md_ctx = tmp_assign_source_4;
            Py_DECREF(old);
        }

    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_args_element_name_8;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_8 == NULL)) {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_8 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2893;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_8;
        CHECK_OBJECT(var_md_ctx);
        tmp_args_element_name_7 = var_md_ctx;
        CHECK_OBJECT(var_digest_obj);
        tmp_args_element_name_8 = var_digest_obj;
        frame_8c86ab161458de9d92d55080e4948b8b->m_frame.f_lineno = 2893;
        {
            PyObject *call_args[] = {tmp_args_element_name_7, tmp_args_element_name_8};
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_2, const_str_plain_EVP_SignInit, call_args);
        }

        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2893;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_called_name_5;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_9;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_args_element_name_11;
        PyObject *tmp_len_arg_1;
        tmp_mvar_value_9 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_9 == NULL)) {
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_9 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2894;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_9;
        tmp_called_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_EVP_SignUpdate);
        if (tmp_called_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2894;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_md_ctx);
        tmp_args_element_name_9 = var_md_ctx;
        CHECK_OBJECT(par_data);
        tmp_args_element_name_10 = par_data;
        CHECK_OBJECT(par_data);
        tmp_len_arg_1 = par_data;
        tmp_args_element_name_11 = BUILTIN_LEN(tmp_len_arg_1);
        if (tmp_args_element_name_11 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_5);

            exception_lineno = 2894;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        frame_8c86ab161458de9d92d55080e4948b8b->m_frame.f_lineno = 2894;
        {
            PyObject *call_args[] = {tmp_args_element_name_9, tmp_args_element_name_10, tmp_args_element_name_11};
            tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_5, call_args);
        }

        Py_DECREF(tmp_called_name_5);
        Py_DECREF(tmp_args_element_name_11);
        if (tmp_call_result_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2894;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_2);
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_called_name_6;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_10;
        PyObject *tmp_args_element_name_12;
        PyObject *tmp_source_name_7;
        tmp_mvar_value_10 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_10 == NULL)) {
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_10 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2896;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_10;
        tmp_called_name_6 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_EVP_PKEY_size);
        if (tmp_called_name_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2896;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_pkey);
        tmp_source_name_7 = par_pkey;
        tmp_args_element_name_12 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain__pkey);
        if (tmp_args_element_name_12 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_6);

            exception_lineno = 2896;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        frame_8c86ab161458de9d92d55080e4948b8b->m_frame.f_lineno = 2896;
        tmp_assign_source_5 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_6, tmp_args_element_name_12);
        Py_DECREF(tmp_called_name_6);
        Py_DECREF(tmp_args_element_name_12);
        if (tmp_assign_source_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2896;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_length == NULL);
        var_length = tmp_assign_source_5;
    }
    {
        PyObject *tmp_called_name_7;
        PyObject *tmp_mvar_value_11;
        PyObject *tmp_call_result_3;
        PyObject *tmp_args_element_name_13;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        tmp_mvar_value_11 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_11 == NULL)) {
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_11 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 2897;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_7 = tmp_mvar_value_11;
        CHECK_OBJECT(var_length);
        tmp_compexpr_left_2 = var_length;
        tmp_compexpr_right_2 = const_int_0;
        tmp_args_element_name_13 = RICH_COMPARE_GT_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
        if (tmp_args_element_name_13 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2897;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        frame_8c86ab161458de9d92d55080e4948b8b->m_frame.f_lineno = 2897;
        tmp_call_result_3 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_7, tmp_args_element_name_13);
        Py_DECREF(tmp_args_element_name_13);
        if (tmp_call_result_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2897;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_3);
    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_12;
        PyObject *tmp_args_element_name_14;
        PyObject *tmp_args_element_name_15;
        tmp_mvar_value_12 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_12 == NULL)) {
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_12 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2898;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_3 = tmp_mvar_value_12;
        tmp_args_element_name_14 = const_str_digest_81f1b0dfcc7a862e6940580ec4cc42d3;
        CHECK_OBJECT(var_length);
        tmp_args_element_name_15 = var_length;
        frame_8c86ab161458de9d92d55080e4948b8b->m_frame.f_lineno = 2898;
        {
            PyObject *call_args[] = {tmp_args_element_name_14, tmp_args_element_name_15};
            tmp_assign_source_6 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_3, const_str_plain_new, call_args);
        }

        if (tmp_assign_source_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2898;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_signature_buffer == NULL);
        var_signature_buffer = tmp_assign_source_6;
    }
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_called_instance_4;
        PyObject *tmp_mvar_value_13;
        tmp_mvar_value_13 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_13 == NULL)) {
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_13 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2899;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_4 = tmp_mvar_value_13;
        frame_8c86ab161458de9d92d55080e4948b8b->m_frame.f_lineno = 2899;
        tmp_assign_source_7 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_4, const_str_plain_new, &PyTuple_GET_ITEM(const_tuple_str_digest_e33a7f733650e687efe98e5491512b82_tuple, 0));

        if (tmp_assign_source_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2899;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_signature_length == NULL);
        var_signature_length = tmp_assign_source_7;
    }
    {
        PyObject *tmp_assign_source_8;
        PyObject *tmp_called_name_8;
        PyObject *tmp_source_name_8;
        PyObject *tmp_mvar_value_14;
        PyObject *tmp_args_element_name_16;
        PyObject *tmp_args_element_name_17;
        PyObject *tmp_args_element_name_18;
        PyObject *tmp_args_element_name_19;
        PyObject *tmp_source_name_9;
        tmp_mvar_value_14 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_14 == NULL)) {
            tmp_mvar_value_14 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_14 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2900;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_8 = tmp_mvar_value_14;
        tmp_called_name_8 = LOOKUP_ATTRIBUTE(tmp_source_name_8, const_str_plain_EVP_SignFinal);
        if (tmp_called_name_8 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2900;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_md_ctx);
        tmp_args_element_name_16 = var_md_ctx;
        CHECK_OBJECT(var_signature_buffer);
        tmp_args_element_name_17 = var_signature_buffer;
        CHECK_OBJECT(var_signature_length);
        tmp_args_element_name_18 = var_signature_length;
        CHECK_OBJECT(par_pkey);
        tmp_source_name_9 = par_pkey;
        tmp_args_element_name_19 = LOOKUP_ATTRIBUTE(tmp_source_name_9, const_str_plain__pkey);
        if (tmp_args_element_name_19 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_8);

            exception_lineno = 2901;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        frame_8c86ab161458de9d92d55080e4948b8b->m_frame.f_lineno = 2900;
        {
            PyObject *call_args[] = {tmp_args_element_name_16, tmp_args_element_name_17, tmp_args_element_name_18, tmp_args_element_name_19};
            tmp_assign_source_8 = CALL_FUNCTION_WITH_ARGS4(tmp_called_name_8, call_args);
        }

        Py_DECREF(tmp_called_name_8);
        Py_DECREF(tmp_args_element_name_19);
        if (tmp_assign_source_8 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2900;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_final_result == NULL);
        var_final_result = tmp_assign_source_8;
    }
    {
        PyObject *tmp_called_name_9;
        PyObject *tmp_mvar_value_15;
        PyObject *tmp_call_result_4;
        PyObject *tmp_args_element_name_20;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        tmp_mvar_value_15 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_15 == NULL)) {
            tmp_mvar_value_15 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_15 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 2902;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_9 = tmp_mvar_value_15;
        CHECK_OBJECT(var_final_result);
        tmp_compexpr_left_3 = var_final_result;
        tmp_compexpr_right_3 = const_int_pos_1;
        tmp_args_element_name_20 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_3, tmp_compexpr_right_3);
        if (tmp_args_element_name_20 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2902;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        frame_8c86ab161458de9d92d55080e4948b8b->m_frame.f_lineno = 2902;
        tmp_call_result_4 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_9, tmp_args_element_name_20);
        Py_DECREF(tmp_args_element_name_20);
        if (tmp_call_result_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2902;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_4);
    }
    {
        Py_ssize_t tmp_sliceslicedel_index_lower_1;
        Py_ssize_t tmp_slice_index_upper_1;
        PyObject *tmp_slice_source_1;
        PyObject *tmp_called_name_10;
        PyObject *tmp_source_name_10;
        PyObject *tmp_mvar_value_16;
        PyObject *tmp_args_element_name_21;
        PyObject *tmp_args_element_name_22;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_subscript_name_1;
        tmp_sliceslicedel_index_lower_1 = 0;
        tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
        tmp_mvar_value_16 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_16 == NULL)) {
            tmp_mvar_value_16 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_16 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2904;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_10 = tmp_mvar_value_16;
        tmp_called_name_10 = LOOKUP_ATTRIBUTE(tmp_source_name_10, const_str_plain_buffer);
        if (tmp_called_name_10 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2904;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_signature_buffer);
        tmp_args_element_name_21 = var_signature_buffer;
        CHECK_OBJECT(var_signature_length);
        tmp_subscribed_name_1 = var_signature_length;
        tmp_subscript_name_1 = const_int_0;
        tmp_args_element_name_22 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_1, tmp_subscript_name_1, 0);
        if (tmp_args_element_name_22 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_10);

            exception_lineno = 2904;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        frame_8c86ab161458de9d92d55080e4948b8b->m_frame.f_lineno = 2904;
        {
            PyObject *call_args[] = {tmp_args_element_name_21, tmp_args_element_name_22};
            tmp_slice_source_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_10, call_args);
        }

        Py_DECREF(tmp_called_name_10);
        Py_DECREF(tmp_args_element_name_22);
        if (tmp_slice_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2904;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = LOOKUP_INDEX_SLICE(tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1);
        Py_DECREF(tmp_slice_source_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2904;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8c86ab161458de9d92d55080e4948b8b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_8c86ab161458de9d92d55080e4948b8b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8c86ab161458de9d92d55080e4948b8b);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_8c86ab161458de9d92d55080e4948b8b, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_8c86ab161458de9d92d55080e4948b8b->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_8c86ab161458de9d92d55080e4948b8b, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8c86ab161458de9d92d55080e4948b8b,
        type_description_1,
        par_pkey,
        par_data,
        par_digest,
        var_final_result,
        var_signature_length,
        var_length,
        var_digest_obj,
        var_signature_buffer,
        var_md_ctx
    );


    // Release cached frame.
    if (frame_8c86ab161458de9d92d55080e4948b8b == cache_frame_8c86ab161458de9d92d55080e4948b8b) {
        Py_DECREF(frame_8c86ab161458de9d92d55080e4948b8b);
    }
    cache_frame_8c86ab161458de9d92d55080e4948b8b = NULL;

    assertFrameObject(frame_8c86ab161458de9d92d55080e4948b8b);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_152_sign);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_final_result);
    Py_DECREF(var_final_result);
    var_final_result = NULL;

    CHECK_OBJECT((PyObject *)var_signature_length);
    Py_DECREF(var_signature_length);
    var_signature_length = NULL;

    CHECK_OBJECT((PyObject *)var_length);
    Py_DECREF(var_length);
    var_length = NULL;

    CHECK_OBJECT((PyObject *)var_digest_obj);
    Py_DECREF(var_digest_obj);
    var_digest_obj = NULL;

    CHECK_OBJECT((PyObject *)var_signature_buffer);
    Py_DECREF(var_signature_buffer);
    var_signature_buffer = NULL;

    CHECK_OBJECT((PyObject *)var_md_ctx);
    Py_DECREF(var_md_ctx);
    var_md_ctx = NULL;

    CHECK_OBJECT((PyObject *)par_data);
    Py_DECREF(par_data);
    par_data = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_final_result);
    var_final_result = NULL;

    Py_XDECREF(var_signature_length);
    var_signature_length = NULL;

    Py_XDECREF(var_length);
    var_length = NULL;

    Py_XDECREF(var_digest_obj);
    var_digest_obj = NULL;

    Py_XDECREF(var_signature_buffer);
    var_signature_buffer = NULL;

    Py_XDECREF(var_md_ctx);
    var_md_ctx = NULL;

    CHECK_OBJECT((PyObject *)par_data);
    Py_DECREF(par_data);
    par_data = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_152_sign);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_pkey);
    Py_DECREF(par_pkey);
    CHECK_OBJECT(par_digest);
    Py_DECREF(par_digest);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_pkey);
    Py_DECREF(par_pkey);
    CHECK_OBJECT(par_digest);
    Py_DECREF(par_digest);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_153_verify(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cert = python_pars[0];
    PyObject *par_signature = python_pars[1];
    PyObject *par_data = python_pars[2];
    PyObject *par_digest = python_pars[3];
    PyObject *var_pkey = NULL;
    PyObject *var_digest_obj = NULL;
    PyObject *var_verify_result = NULL;
    PyObject *var_md_ctx = NULL;
    struct Nuitka_FrameObject *frame_7d7f67b2a9e1de973b6a168bc3652501;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_7d7f67b2a9e1de973b6a168bc3652501 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_7d7f67b2a9e1de973b6a168bc3652501, codeobj_7d7f67b2a9e1de973b6a168bc3652501, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_7d7f67b2a9e1de973b6a168bc3652501 = cache_frame_7d7f67b2a9e1de973b6a168bc3652501;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_7d7f67b2a9e1de973b6a168bc3652501);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_7d7f67b2a9e1de973b6a168bc3652501) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1011 ], 52, 0);
            exception_tb = NULL;

            exception_lineno = 2920;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        tmp_args_element_name_1 = const_str_plain_data;
        CHECK_OBJECT(par_data);
        tmp_args_element_name_2 = par_data;
        frame_7d7f67b2a9e1de973b6a168bc3652501->m_frame.f_lineno = 2920;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2920;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = par_data;
            assert(old != NULL);
            par_data = tmp_assign_source_1;
            Py_DECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2922;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_EVP_get_digestbyname);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2922;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__byte_string);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__byte_string);
        }

        if (tmp_mvar_value_3 == NULL) {
            Py_DECREF(tmp_called_name_2);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3511 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 2922;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_3;
        CHECK_OBJECT(par_digest);
        tmp_args_element_name_4 = par_digest;
        frame_7d7f67b2a9e1de973b6a168bc3652501->m_frame.f_lineno = 2922;
        tmp_args_element_name_3 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_3, tmp_args_element_name_4);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 2922;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        frame_7d7f67b2a9e1de973b6a168bc3652501->m_frame.f_lineno = 2922;
        tmp_assign_source_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_3);
        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2922;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_digest_obj == NULL);
        var_digest_obj = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_4;
        CHECK_OBJECT(var_digest_obj);
        tmp_compexpr_left_1 = var_digest_obj;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2923;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_4;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_NULL);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2923;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2923;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_500f278b67471fc0f770fccc80d65d95;
            frame_7d7f67b2a9e1de973b6a168bc3652501->m_frame.f_lineno = 2924;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 2924;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_4;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2926;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_5;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_X509_get_pubkey);
        if (tmp_called_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2926;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_cert);
        tmp_source_name_4 = par_cert;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain__x509);
        if (tmp_args_element_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_4);

            exception_lineno = 2926;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        frame_7d7f67b2a9e1de973b6a168bc3652501->m_frame.f_lineno = 2926;
        tmp_assign_source_3 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_4, tmp_args_element_name_5);
        Py_DECREF(tmp_called_name_4);
        Py_DECREF(tmp_args_element_name_5);
        if (tmp_assign_source_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2926;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_pkey == NULL);
        var_pkey = tmp_assign_source_3;
    }
    {
        PyObject *tmp_called_name_5;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_7;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_6 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 2927;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_5 = tmp_mvar_value_6;
        CHECK_OBJECT(var_pkey);
        tmp_compexpr_left_2 = var_pkey;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_7 == NULL)) {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_7 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2927;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_7;
        tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_NULL);
        if (tmp_compexpr_right_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2927;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_6 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
        Py_DECREF(tmp_compexpr_right_2);
        if (tmp_args_element_name_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2927;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        frame_7d7f67b2a9e1de973b6a168bc3652501->m_frame.f_lineno = 2927;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_5, tmp_args_element_name_6);
        Py_DECREF(tmp_args_element_name_6);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2927;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_name_6;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_9;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_8 == NULL)) {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_8 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2928;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_8;
        tmp_called_name_6 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_gc);
        if (tmp_called_name_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2928;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_pkey);
        tmp_args_element_name_7 = var_pkey;
        tmp_mvar_value_9 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_9 == NULL)) {
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_9 == NULL) {
            Py_DECREF(tmp_called_name_6);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2928;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = tmp_mvar_value_9;
        tmp_args_element_name_8 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain_EVP_PKEY_free);
        if (tmp_args_element_name_8 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_6);

            exception_lineno = 2928;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        frame_7d7f67b2a9e1de973b6a168bc3652501->m_frame.f_lineno = 2928;
        {
            PyObject *call_args[] = {tmp_args_element_name_7, tmp_args_element_name_8};
            tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_6, call_args);
        }

        Py_DECREF(tmp_called_name_6);
        Py_DECREF(tmp_args_element_name_8);
        if (tmp_assign_source_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2928;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var_pkey;
            assert(old != NULL);
            var_pkey = tmp_assign_source_4;
            Py_DECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_10;
        tmp_mvar_value_10 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_10 == NULL)) {
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_10 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2930;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_10;
        frame_7d7f67b2a9e1de973b6a168bc3652501->m_frame.f_lineno = 2930;
        tmp_assign_source_5 = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_Cryptography_EVP_MD_CTX_new);
        if (tmp_assign_source_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2930;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_md_ctx == NULL);
        var_md_ctx = tmp_assign_source_5;
    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_called_name_7;
        PyObject *tmp_source_name_8;
        PyObject *tmp_mvar_value_11;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_source_name_9;
        PyObject *tmp_mvar_value_12;
        tmp_mvar_value_11 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_11 == NULL)) {
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_11 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2931;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_8 = tmp_mvar_value_11;
        tmp_called_name_7 = LOOKUP_ATTRIBUTE(tmp_source_name_8, const_str_plain_gc);
        if (tmp_called_name_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2931;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_md_ctx);
        tmp_args_element_name_9 = var_md_ctx;
        tmp_mvar_value_12 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_12 == NULL)) {
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_12 == NULL) {
            Py_DECREF(tmp_called_name_7);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2931;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_9 = tmp_mvar_value_12;
        tmp_args_element_name_10 = LOOKUP_ATTRIBUTE(tmp_source_name_9, const_str_plain_Cryptography_EVP_MD_CTX_free);
        if (tmp_args_element_name_10 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_7);

            exception_lineno = 2931;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        frame_7d7f67b2a9e1de973b6a168bc3652501->m_frame.f_lineno = 2931;
        {
            PyObject *call_args[] = {tmp_args_element_name_9, tmp_args_element_name_10};
            tmp_assign_source_6 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_7, call_args);
        }

        Py_DECREF(tmp_called_name_7);
        Py_DECREF(tmp_args_element_name_10);
        if (tmp_assign_source_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2931;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var_md_ctx;
            assert(old != NULL);
            var_md_ctx = tmp_assign_source_6;
            Py_DECREF(old);
        }

    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_13;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_11;
        PyObject *tmp_args_element_name_12;
        tmp_mvar_value_13 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_13 == NULL)) {
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_13 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2933;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_13;
        CHECK_OBJECT(var_md_ctx);
        tmp_args_element_name_11 = var_md_ctx;
        CHECK_OBJECT(var_digest_obj);
        tmp_args_element_name_12 = var_digest_obj;
        frame_7d7f67b2a9e1de973b6a168bc3652501->m_frame.f_lineno = 2933;
        {
            PyObject *call_args[] = {tmp_args_element_name_11, tmp_args_element_name_12};
            tmp_call_result_2 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_2, const_str_plain_EVP_VerifyInit, call_args);
        }

        if (tmp_call_result_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2933;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_2);
    }
    {
        PyObject *tmp_called_name_8;
        PyObject *tmp_source_name_10;
        PyObject *tmp_mvar_value_14;
        PyObject *tmp_call_result_3;
        PyObject *tmp_args_element_name_13;
        PyObject *tmp_args_element_name_14;
        PyObject *tmp_args_element_name_15;
        PyObject *tmp_len_arg_1;
        tmp_mvar_value_14 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_14 == NULL)) {
            tmp_mvar_value_14 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_14 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2934;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_10 = tmp_mvar_value_14;
        tmp_called_name_8 = LOOKUP_ATTRIBUTE(tmp_source_name_10, const_str_plain_EVP_VerifyUpdate);
        if (tmp_called_name_8 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2934;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_md_ctx);
        tmp_args_element_name_13 = var_md_ctx;
        CHECK_OBJECT(par_data);
        tmp_args_element_name_14 = par_data;
        CHECK_OBJECT(par_data);
        tmp_len_arg_1 = par_data;
        tmp_args_element_name_15 = BUILTIN_LEN(tmp_len_arg_1);
        if (tmp_args_element_name_15 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_8);

            exception_lineno = 2934;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        frame_7d7f67b2a9e1de973b6a168bc3652501->m_frame.f_lineno = 2934;
        {
            PyObject *call_args[] = {tmp_args_element_name_13, tmp_args_element_name_14, tmp_args_element_name_15};
            tmp_call_result_3 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_8, call_args);
        }

        Py_DECREF(tmp_called_name_8);
        Py_DECREF(tmp_args_element_name_15);
        if (tmp_call_result_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2934;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_3);
    }
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_called_name_9;
        PyObject *tmp_source_name_11;
        PyObject *tmp_mvar_value_15;
        PyObject *tmp_args_element_name_16;
        PyObject *tmp_args_element_name_17;
        PyObject *tmp_args_element_name_18;
        PyObject *tmp_len_arg_2;
        PyObject *tmp_args_element_name_19;
        tmp_mvar_value_15 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_15 == NULL)) {
            tmp_mvar_value_15 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_15 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2935;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_11 = tmp_mvar_value_15;
        tmp_called_name_9 = LOOKUP_ATTRIBUTE(tmp_source_name_11, const_str_plain_EVP_VerifyFinal);
        if (tmp_called_name_9 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2935;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_md_ctx);
        tmp_args_element_name_16 = var_md_ctx;
        CHECK_OBJECT(par_signature);
        tmp_args_element_name_17 = par_signature;
        CHECK_OBJECT(par_signature);
        tmp_len_arg_2 = par_signature;
        tmp_args_element_name_18 = BUILTIN_LEN(tmp_len_arg_2);
        if (tmp_args_element_name_18 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_9);

            exception_lineno = 2936;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_pkey);
        tmp_args_element_name_19 = var_pkey;
        frame_7d7f67b2a9e1de973b6a168bc3652501->m_frame.f_lineno = 2935;
        {
            PyObject *call_args[] = {tmp_args_element_name_16, tmp_args_element_name_17, tmp_args_element_name_18, tmp_args_element_name_19};
            tmp_assign_source_7 = CALL_FUNCTION_WITH_ARGS4(tmp_called_name_9, call_args);
        }

        Py_DECREF(tmp_called_name_9);
        Py_DECREF(tmp_args_element_name_18);
        if (tmp_assign_source_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2935;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_verify_result == NULL);
        var_verify_result = tmp_assign_source_7;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        CHECK_OBJECT(var_verify_result);
        tmp_compexpr_left_3 = var_verify_result;
        tmp_compexpr_right_3 = const_int_pos_1;
        tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_INT(tmp_compexpr_left_3, tmp_compexpr_right_3);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2939;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_called_name_10;
            PyObject *tmp_mvar_value_16;
            PyObject *tmp_call_result_4;
            tmp_mvar_value_16 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error);

            if (unlikely(tmp_mvar_value_16 == NULL)) {
                tmp_mvar_value_16 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error);
            }

            if (tmp_mvar_value_16 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 0 ], 49, 0);
                exception_tb = NULL;

                exception_lineno = 2940;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_10 = tmp_mvar_value_16;
            frame_7d7f67b2a9e1de973b6a168bc3652501->m_frame.f_lineno = 2940;
            tmp_call_result_4 = CALL_FUNCTION_NO_ARGS(tmp_called_name_10);
            if (tmp_call_result_4 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2940;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_4);
        }
        branch_no_2:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_7d7f67b2a9e1de973b6a168bc3652501);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_7d7f67b2a9e1de973b6a168bc3652501);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_7d7f67b2a9e1de973b6a168bc3652501, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_7d7f67b2a9e1de973b6a168bc3652501->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_7d7f67b2a9e1de973b6a168bc3652501, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7d7f67b2a9e1de973b6a168bc3652501,
        type_description_1,
        par_cert,
        par_signature,
        par_data,
        par_digest,
        var_pkey,
        var_digest_obj,
        var_verify_result,
        var_md_ctx
    );


    // Release cached frame.
    if (frame_7d7f67b2a9e1de973b6a168bc3652501 == cache_frame_7d7f67b2a9e1de973b6a168bc3652501) {
        Py_DECREF(frame_7d7f67b2a9e1de973b6a168bc3652501);
    }
    cache_frame_7d7f67b2a9e1de973b6a168bc3652501 = NULL;

    assertFrameObject(frame_7d7f67b2a9e1de973b6a168bc3652501);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_153_verify);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_pkey);
    Py_DECREF(var_pkey);
    var_pkey = NULL;

    CHECK_OBJECT((PyObject *)var_digest_obj);
    Py_DECREF(var_digest_obj);
    var_digest_obj = NULL;

    CHECK_OBJECT((PyObject *)var_verify_result);
    Py_DECREF(var_verify_result);
    var_verify_result = NULL;

    CHECK_OBJECT((PyObject *)var_md_ctx);
    Py_DECREF(var_md_ctx);
    var_md_ctx = NULL;

    CHECK_OBJECT((PyObject *)par_data);
    Py_DECREF(par_data);
    par_data = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_pkey);
    var_pkey = NULL;

    Py_XDECREF(var_digest_obj);
    var_digest_obj = NULL;

    Py_XDECREF(var_verify_result);
    var_verify_result = NULL;

    Py_XDECREF(var_md_ctx);
    var_md_ctx = NULL;

    CHECK_OBJECT((PyObject *)par_data);
    Py_DECREF(par_data);
    par_data = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_153_verify);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_cert);
    Py_DECREF(par_cert);
    CHECK_OBJECT(par_signature);
    Py_DECREF(par_signature);
    CHECK_OBJECT(par_digest);
    Py_DECREF(par_digest);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_cert);
    Py_DECREF(par_cert);
    CHECK_OBJECT(par_signature);
    Py_DECREF(par_signature);
    CHECK_OBJECT(par_digest);
    Py_DECREF(par_digest);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_154_dump_crl(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_type = python_pars[0];
    PyObject *par_crl = python_pars[1];
    PyObject *var_bio = NULL;
    PyObject *var_ret = NULL;
    struct Nuitka_FrameObject *frame_937719077c95baa6246e33cb27a31dc5;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_937719077c95baa6246e33cb27a31dc5 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_937719077c95baa6246e33cb27a31dc5, codeobj_937719077c95baa6246e33cb27a31dc5, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_937719077c95baa6246e33cb27a31dc5 = cache_frame_937719077c95baa6246e33cb27a31dc5;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_937719077c95baa6246e33cb27a31dc5);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_937719077c95baa6246e33cb27a31dc5) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3591 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 2954;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        frame_937719077c95baa6246e33cb27a31dc5->m_frame.f_lineno = 2954;
        tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS(tmp_called_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2954;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_bio == NULL);
        var_bio = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT(par_type);
        tmp_compexpr_left_1 = par_type;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 632 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 2956;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_2;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2956;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_1;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_source_name_2;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_3 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 2957;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_1 = tmp_mvar_value_3;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_PEM_write_bio_X509_CRL);
            if (tmp_called_name_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2957;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_bio);
            tmp_args_element_name_1 = var_bio;
            CHECK_OBJECT(par_crl);
            tmp_source_name_2 = par_crl;
            tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__crl);
            if (tmp_args_element_name_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_2);

                exception_lineno = 2957;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            frame_937719077c95baa6246e33cb27a31dc5->m_frame.f_lineno = 2957;
            {
                PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
                tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
            }

            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_2);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2957;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            assert(var_ret == NULL);
            var_ret = tmp_assign_source_2;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_mvar_value_4;
            CHECK_OBJECT(par_type);
            tmp_compexpr_left_2 = par_type;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1);
            }

            if (tmp_mvar_value_4 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 4053 ], 42, 0);
                exception_tb = NULL;

                exception_lineno = 2958;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_2 = tmp_mvar_value_4;
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2958;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
                goto branch_yes_2;
            } else {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_assign_source_3;
                PyObject *tmp_called_name_3;
                PyObject *tmp_source_name_3;
                PyObject *tmp_mvar_value_5;
                PyObject *tmp_args_element_name_3;
                PyObject *tmp_args_element_name_4;
                PyObject *tmp_source_name_4;
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

                if (unlikely(tmp_mvar_value_5 == NULL)) {
                    tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
                }

                if (tmp_mvar_value_5 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 2959;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_3 = tmp_mvar_value_5;
                tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_i2d_X509_CRL_bio);
                if (tmp_called_name_3 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2959;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT(var_bio);
                tmp_args_element_name_3 = var_bio;
                CHECK_OBJECT(par_crl);
                tmp_source_name_4 = par_crl;
                tmp_args_element_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain__crl);
                if (tmp_args_element_name_4 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    Py_DECREF(tmp_called_name_3);

                    exception_lineno = 2959;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                frame_937719077c95baa6246e33cb27a31dc5->m_frame.f_lineno = 2959;
                {
                    PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4};
                    tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_3, call_args);
                }

                Py_DECREF(tmp_called_name_3);
                Py_DECREF(tmp_args_element_name_4);
                if (tmp_assign_source_3 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2959;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                assert(var_ret == NULL);
                var_ret = tmp_assign_source_3;
            }
            goto branch_end_2;
            branch_no_2:;
            {
                nuitka_bool tmp_condition_result_3;
                PyObject *tmp_compexpr_left_3;
                PyObject *tmp_compexpr_right_3;
                PyObject *tmp_mvar_value_6;
                CHECK_OBJECT(par_type);
                tmp_compexpr_left_3 = par_type;
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_TEXT);

                if (unlikely(tmp_mvar_value_6 == NULL)) {
                    tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_TEXT);
                }

                if (tmp_mvar_value_6 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 4095 ], 42, 0);
                    exception_tb = NULL;

                    exception_lineno = 2960;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }

                tmp_compexpr_right_3 = tmp_mvar_value_6;
                tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_3, tmp_compexpr_right_3);
                if (tmp_res == -1) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2960;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                tmp_condition_result_3 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
                    goto branch_yes_3;
                } else {
                    goto branch_no_3;
                }
                branch_yes_3:;
                {
                    PyObject *tmp_assign_source_4;
                    PyObject *tmp_called_name_4;
                    PyObject *tmp_source_name_5;
                    PyObject *tmp_mvar_value_7;
                    PyObject *tmp_args_element_name_5;
                    PyObject *tmp_args_element_name_6;
                    PyObject *tmp_source_name_6;
                    tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

                    if (unlikely(tmp_mvar_value_7 == NULL)) {
                        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
                    }

                    if (tmp_mvar_value_7 == NULL) {

                        exception_type = PyExc_NameError;
                        Py_INCREF(exception_type);
                        exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                        exception_tb = NULL;

                        exception_lineno = 2961;
                        type_description_1 = "oooo";
                        goto frame_exception_exit_1;
                    }

                    tmp_source_name_5 = tmp_mvar_value_7;
                    tmp_called_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_X509_CRL_print);
                    if (tmp_called_name_4 == NULL) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                        exception_lineno = 2961;
                        type_description_1 = "oooo";
                        goto frame_exception_exit_1;
                    }
                    CHECK_OBJECT(var_bio);
                    tmp_args_element_name_5 = var_bio;
                    CHECK_OBJECT(par_crl);
                    tmp_source_name_6 = par_crl;
                    tmp_args_element_name_6 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain__crl);
                    if (tmp_args_element_name_6 == NULL) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                        Py_DECREF(tmp_called_name_4);

                        exception_lineno = 2961;
                        type_description_1 = "oooo";
                        goto frame_exception_exit_1;
                    }
                    frame_937719077c95baa6246e33cb27a31dc5->m_frame.f_lineno = 2961;
                    {
                        PyObject *call_args[] = {tmp_args_element_name_5, tmp_args_element_name_6};
                        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_4, call_args);
                    }

                    Py_DECREF(tmp_called_name_4);
                    Py_DECREF(tmp_args_element_name_6);
                    if (tmp_assign_source_4 == NULL) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                        exception_lineno = 2961;
                        type_description_1 = "oooo";
                        goto frame_exception_exit_1;
                    }
                    assert(var_ret == NULL);
                    var_ret = tmp_assign_source_4;
                }
                goto branch_end_3;
                branch_no_3:;
                {
                    PyObject *tmp_raise_type_1;
                    PyObject *tmp_make_exception_arg_1;
                    tmp_make_exception_arg_1 = const_str_digest_11c225ccbab9acffc38107dee9691702;
                    frame_937719077c95baa6246e33cb27a31dc5->m_frame.f_lineno = 2963;
                    tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_1);
                    assert(!(tmp_raise_type_1 == NULL));
                    exception_type = tmp_raise_type_1;
                    exception_lineno = 2963;
                    RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                branch_end_3:;
            }
            branch_end_2:;
        }
        branch_end_1:;
    }
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        if (var_ret == NULL) {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("local variable '%s' referenced before assignment", "ret");
            exception_tb = NULL;

            exception_lineno = 2967;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_left_4 = var_ret;
        tmp_compexpr_right_4 = const_int_pos_1;
        tmp_operand_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_4, tmp_compexpr_right_4);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2967;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2967;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_4 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_4 == NUITKA_BOOL_TRUE) {
            goto branch_yes_4;
        } else {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_raise_type_2;
            tmp_raise_type_2 = PyExc_AssertionError;
            exception_type = tmp_raise_type_2;
            Py_INCREF(tmp_raise_type_2);
            exception_lineno = 2967;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        branch_no_4:;
    }
    {
        PyObject *tmp_called_name_5;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_args_element_name_7;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__bio_to_string);

        if (unlikely(tmp_mvar_value_8 == NULL)) {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__bio_to_string);
        }

        if (tmp_mvar_value_8 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3632 ], 43, 0);
            exception_tb = NULL;

            exception_lineno = 2968;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_5 = tmp_mvar_value_8;
        CHECK_OBJECT(var_bio);
        tmp_args_element_name_7 = var_bio;
        frame_937719077c95baa6246e33cb27a31dc5->m_frame.f_lineno = 2968;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_5, tmp_args_element_name_7);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2968;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_937719077c95baa6246e33cb27a31dc5);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_937719077c95baa6246e33cb27a31dc5);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_937719077c95baa6246e33cb27a31dc5);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_937719077c95baa6246e33cb27a31dc5, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_937719077c95baa6246e33cb27a31dc5->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_937719077c95baa6246e33cb27a31dc5, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_937719077c95baa6246e33cb27a31dc5,
        type_description_1,
        par_type,
        par_crl,
        var_bio,
        var_ret
    );


    // Release cached frame.
    if (frame_937719077c95baa6246e33cb27a31dc5 == cache_frame_937719077c95baa6246e33cb27a31dc5) {
        Py_DECREF(frame_937719077c95baa6246e33cb27a31dc5);
    }
    cache_frame_937719077c95baa6246e33cb27a31dc5 = NULL;

    assertFrameObject(frame_937719077c95baa6246e33cb27a31dc5);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_154_dump_crl);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_bio);
    Py_DECREF(var_bio);
    var_bio = NULL;

    Py_XDECREF(var_ret);
    var_ret = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_bio);
    var_bio = NULL;

    Py_XDECREF(var_ret);
    var_ret = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_154_dump_crl);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);
    CHECK_OBJECT(par_crl);
    Py_DECREF(par_crl);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);
    CHECK_OBJECT(par_crl);
    Py_DECREF(par_crl);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_155_load_crl(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_type = python_pars[0];
    PyObject *par_buffer = python_pars[1];
    PyObject *var_bio = NULL;
    PyObject *var_result = NULL;
    PyObject *var_crl = NULL;
    struct Nuitka_FrameObject *frame_6e98a073ab05ca431e08e0cd283b2282;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_6e98a073ab05ca431e08e0cd283b2282 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_6e98a073ab05ca431e08e0cd283b2282, codeobj_6e98a073ab05ca431e08e0cd283b2282, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_6e98a073ab05ca431e08e0cd283b2282 = cache_frame_6e98a073ab05ca431e08e0cd283b2282;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_6e98a073ab05ca431e08e0cd283b2282);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_6e98a073ab05ca431e08e0cd283b2282) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_buffer);
        tmp_isinstance_inst_1 = par_buffer;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__text_type);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__text_type);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3552 ], 39, 0);
            exception_tb = NULL;

            exception_lineno = 2981;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2981;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_called_instance_1;
            CHECK_OBJECT(par_buffer);
            tmp_called_instance_1 = par_buffer;
            frame_6e98a073ab05ca431e08e0cd283b2282->m_frame.f_lineno = 2982;
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_encode, &PyTuple_GET_ITEM(const_tuple_str_plain_ascii_tuple, 0));

            if (tmp_assign_source_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2982;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_buffer;
                assert(old != NULL);
                par_buffer = tmp_assign_source_1;
                Py_DECREF(old);
            }

        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3591 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 2984;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_2;
        CHECK_OBJECT(par_buffer);
        tmp_args_element_name_1 = par_buffer;
        frame_6e98a073ab05ca431e08e0cd283b2282->m_frame.f_lineno = 2984;
        tmp_assign_source_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2984;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(var_bio == NULL);
        var_bio = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_3;
        CHECK_OBJECT(par_type);
        tmp_compexpr_left_1 = par_type;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 632 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 2986;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_3;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2986;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_1;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_source_name_2;
            PyObject *tmp_mvar_value_5;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_source_name_3;
            PyObject *tmp_mvar_value_6;
            PyObject *tmp_args_element_name_5;
            PyObject *tmp_source_name_4;
            PyObject *tmp_mvar_value_7;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_4 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 2987;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_1 = tmp_mvar_value_4;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_PEM_read_bio_X509_CRL);
            if (tmp_called_name_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2987;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_bio);
            tmp_args_element_name_2 = var_bio;
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_5 == NULL)) {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_5 == NULL) {
                Py_DECREF(tmp_called_name_2);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 2987;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_2 = tmp_mvar_value_5;
            tmp_args_element_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_NULL);
            if (tmp_args_element_name_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_2);

                exception_lineno = 2987;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_6 == NULL)) {
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_6 == NULL) {
                Py_DECREF(tmp_called_name_2);
                Py_DECREF(tmp_args_element_name_3);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 2987;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_3 = tmp_mvar_value_6;
            tmp_args_element_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_NULL);
            if (tmp_args_element_name_4 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_2);
                Py_DECREF(tmp_args_element_name_3);

                exception_lineno = 2987;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_7 == NULL)) {
                tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_7 == NULL) {
                Py_DECREF(tmp_called_name_2);
                Py_DECREF(tmp_args_element_name_3);
                Py_DECREF(tmp_args_element_name_4);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 2987;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_4 = tmp_mvar_value_7;
            tmp_args_element_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_NULL);
            if (tmp_args_element_name_5 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_2);
                Py_DECREF(tmp_args_element_name_3);
                Py_DECREF(tmp_args_element_name_4);

                exception_lineno = 2987;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            frame_6e98a073ab05ca431e08e0cd283b2282->m_frame.f_lineno = 2987;
            {
                PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5};
                tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS4(tmp_called_name_2, call_args);
            }

            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_3);
            Py_DECREF(tmp_args_element_name_4);
            Py_DECREF(tmp_args_element_name_5);
            if (tmp_assign_source_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2987;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            assert(var_crl == NULL);
            var_crl = tmp_assign_source_3;
        }
        goto branch_end_2;
        branch_no_2:;
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_mvar_value_8;
            CHECK_OBJECT(par_type);
            tmp_compexpr_left_2 = par_type;
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1);

            if (unlikely(tmp_mvar_value_8 == NULL)) {
                tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1);
            }

            if (tmp_mvar_value_8 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 4053 ], 42, 0);
                exception_tb = NULL;

                exception_lineno = 2988;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_2 = tmp_mvar_value_8;
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2988;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_3 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
                goto branch_yes_3;
            } else {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_assign_source_4;
                PyObject *tmp_called_name_3;
                PyObject *tmp_source_name_5;
                PyObject *tmp_mvar_value_9;
                PyObject *tmp_args_element_name_6;
                PyObject *tmp_args_element_name_7;
                PyObject *tmp_source_name_6;
                PyObject *tmp_mvar_value_10;
                tmp_mvar_value_9 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

                if (unlikely(tmp_mvar_value_9 == NULL)) {
                    tmp_mvar_value_9 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
                }

                if (tmp_mvar_value_9 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 2989;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_5 = tmp_mvar_value_9;
                tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_d2i_X509_CRL_bio);
                if (tmp_called_name_3 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2989;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT(var_bio);
                tmp_args_element_name_6 = var_bio;
                tmp_mvar_value_10 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

                if (unlikely(tmp_mvar_value_10 == NULL)) {
                    tmp_mvar_value_10 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
                }

                if (tmp_mvar_value_10 == NULL) {
                    Py_DECREF(tmp_called_name_3);
                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 2989;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_6 = tmp_mvar_value_10;
                tmp_args_element_name_7 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_NULL);
                if (tmp_args_element_name_7 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    Py_DECREF(tmp_called_name_3);

                    exception_lineno = 2989;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                frame_6e98a073ab05ca431e08e0cd283b2282->m_frame.f_lineno = 2989;
                {
                    PyObject *call_args[] = {tmp_args_element_name_6, tmp_args_element_name_7};
                    tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_3, call_args);
                }

                Py_DECREF(tmp_called_name_3);
                Py_DECREF(tmp_args_element_name_7);
                if (tmp_assign_source_4 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 2989;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                assert(var_crl == NULL);
                var_crl = tmp_assign_source_4;
            }
            goto branch_end_3;
            branch_no_3:;
            {
                PyObject *tmp_raise_type_1;
                PyObject *tmp_make_exception_arg_1;
                tmp_make_exception_arg_1 = const_str_digest_f019d8c1ebbf58631ace92b4423b3aad;
                frame_6e98a073ab05ca431e08e0cd283b2282->m_frame.f_lineno = 2991;
                tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_1);
                assert(!(tmp_raise_type_1 == NULL));
                exception_type = tmp_raise_type_1;
                exception_lineno = 2991;
                RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            branch_end_3:;
        }
        branch_end_2:;
    }
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_11;
        if (var_crl == NULL) {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("local variable '%s' referenced before assignment", "crl");
            exception_tb = NULL;

            exception_lineno = 2993;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_left_3 = var_crl;
        tmp_mvar_value_11 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_11 == NULL)) {
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_11 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2993;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = tmp_mvar_value_11;
        tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain_NULL);
        if (tmp_compexpr_right_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2993;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_3, tmp_compexpr_right_3);
        Py_DECREF(tmp_compexpr_right_3);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2993;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_4 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_4 == NUITKA_BOOL_TRUE) {
            goto branch_yes_4;
        } else {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_called_name_4;
            PyObject *tmp_mvar_value_12;
            PyObject *tmp_call_result_1;
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error);

            if (unlikely(tmp_mvar_value_12 == NULL)) {
                tmp_mvar_value_12 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error);
            }

            if (tmp_mvar_value_12 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 0 ], 49, 0);
                exception_tb = NULL;

                exception_lineno = 2994;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_4 = tmp_mvar_value_12;
            frame_6e98a073ab05ca431e08e0cd283b2282->m_frame.f_lineno = 2994;
            tmp_call_result_1 = CALL_FUNCTION_NO_ARGS(tmp_called_name_4);
            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2994;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_1);
        }
        branch_no_4:;
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_called_name_5;
        PyObject *tmp_source_name_8;
        PyObject *tmp_mvar_value_13;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_mvar_value_14;
        tmp_mvar_value_13 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_CRL);

        if (unlikely(tmp_mvar_value_13 == NULL)) {
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_CRL);
        }

        if (tmp_mvar_value_13 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 4302 ], 32, 0);
            exception_tb = NULL;

            exception_lineno = 2996;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_8 = tmp_mvar_value_13;
        tmp_called_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_8, const_str_plain___new__);
        if (tmp_called_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2996;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_14 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_CRL);

        if (unlikely(tmp_mvar_value_14 == NULL)) {
            tmp_mvar_value_14 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_CRL);
        }

        if (tmp_mvar_value_14 == NULL) {
            Py_DECREF(tmp_called_name_5);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 4302 ], 32, 0);
            exception_tb = NULL;

            exception_lineno = 2996;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_8 = tmp_mvar_value_14;
        frame_6e98a073ab05ca431e08e0cd283b2282->m_frame.f_lineno = 2996;
        tmp_assign_source_5 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_5, tmp_args_element_name_8);
        Py_DECREF(tmp_called_name_5);
        if (tmp_assign_source_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2996;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(var_result == NULL);
        var_result = tmp_assign_source_5;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_6;
        PyObject *tmp_source_name_9;
        PyObject *tmp_mvar_value_15;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_source_name_10;
        PyObject *tmp_mvar_value_16;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_15 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_15 == NULL)) {
            tmp_mvar_value_15 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_15 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2997;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_9 = tmp_mvar_value_15;
        tmp_called_name_6 = LOOKUP_ATTRIBUTE(tmp_source_name_9, const_str_plain_gc);
        if (tmp_called_name_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2997;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        if (var_crl == NULL) {
            Py_DECREF(tmp_called_name_6);
            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("local variable '%s' referenced before assignment", "crl");
            exception_tb = NULL;

            exception_lineno = 2997;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_9 = var_crl;
        tmp_mvar_value_16 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_16 == NULL)) {
            tmp_mvar_value_16 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_16 == NULL) {
            Py_DECREF(tmp_called_name_6);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2997;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_10 = tmp_mvar_value_16;
        tmp_args_element_name_10 = LOOKUP_ATTRIBUTE(tmp_source_name_10, const_str_plain_X509_CRL_free);
        if (tmp_args_element_name_10 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_6);

            exception_lineno = 2997;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_6e98a073ab05ca431e08e0cd283b2282->m_frame.f_lineno = 2997;
        {
            PyObject *call_args[] = {tmp_args_element_name_9, tmp_args_element_name_10};
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_6, call_args);
        }

        Py_DECREF(tmp_called_name_6);
        Py_DECREF(tmp_args_element_name_10);
        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2997;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_result);
        tmp_assattr_target_1 = var_result;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__crl, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2997;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_6e98a073ab05ca431e08e0cd283b2282);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_6e98a073ab05ca431e08e0cd283b2282);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_6e98a073ab05ca431e08e0cd283b2282, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_6e98a073ab05ca431e08e0cd283b2282->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_6e98a073ab05ca431e08e0cd283b2282, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6e98a073ab05ca431e08e0cd283b2282,
        type_description_1,
        par_type,
        par_buffer,
        var_bio,
        var_result,
        var_crl
    );


    // Release cached frame.
    if (frame_6e98a073ab05ca431e08e0cd283b2282 == cache_frame_6e98a073ab05ca431e08e0cd283b2282) {
        Py_DECREF(frame_6e98a073ab05ca431e08e0cd283b2282);
    }
    cache_frame_6e98a073ab05ca431e08e0cd283b2282 = NULL;

    assertFrameObject(frame_6e98a073ab05ca431e08e0cd283b2282);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT(var_result);
    tmp_return_value = var_result;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_155_load_crl);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)par_buffer);
    Py_DECREF(par_buffer);
    par_buffer = NULL;

    CHECK_OBJECT((PyObject *)var_bio);
    Py_DECREF(var_bio);
    var_bio = NULL;

    CHECK_OBJECT((PyObject *)var_result);
    Py_DECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_crl);
    var_crl = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(par_buffer);
    par_buffer = NULL;

    Py_XDECREF(var_bio);
    var_bio = NULL;

    Py_XDECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_crl);
    var_crl = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_155_load_crl);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_156_load_pkcs7_data(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_type = python_pars[0];
    PyObject *par_buffer = python_pars[1];
    PyObject *var_bio = NULL;
    PyObject *var_pypkcs7 = NULL;
    PyObject *var_pkcs7 = NULL;
    struct Nuitka_FrameObject *frame_bd97d2185c62e99374c1533c90a95f19;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_bd97d2185c62e99374c1533c90a95f19 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_bd97d2185c62e99374c1533c90a95f19, codeobj_bd97d2185c62e99374c1533c90a95f19, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_bd97d2185c62e99374c1533c90a95f19 = cache_frame_bd97d2185c62e99374c1533c90a95f19;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_bd97d2185c62e99374c1533c90a95f19);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_bd97d2185c62e99374c1533c90a95f19) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_buffer);
        tmp_isinstance_inst_1 = par_buffer;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__text_type);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__text_type);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3552 ], 39, 0);
            exception_tb = NULL;

            exception_lineno = 3010;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3010;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_called_instance_1;
            CHECK_OBJECT(par_buffer);
            tmp_called_instance_1 = par_buffer;
            frame_bd97d2185c62e99374c1533c90a95f19->m_frame.f_lineno = 3011;
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_encode, &PyTuple_GET_ITEM(const_tuple_str_plain_ascii_tuple, 0));

            if (tmp_assign_source_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 3011;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_buffer;
                assert(old != NULL);
                par_buffer = tmp_assign_source_1;
                Py_DECREF(old);
            }

        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3591 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 3013;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_2;
        CHECK_OBJECT(par_buffer);
        tmp_args_element_name_1 = par_buffer;
        frame_bd97d2185c62e99374c1533c90a95f19->m_frame.f_lineno = 3013;
        tmp_assign_source_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3013;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(var_bio == NULL);
        var_bio = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_3;
        CHECK_OBJECT(par_type);
        tmp_compexpr_left_1 = par_type;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 632 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 3015;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_3;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3015;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_1;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_source_name_2;
            PyObject *tmp_mvar_value_5;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_source_name_3;
            PyObject *tmp_mvar_value_6;
            PyObject *tmp_args_element_name_5;
            PyObject *tmp_source_name_4;
            PyObject *tmp_mvar_value_7;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_4 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 3016;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_1 = tmp_mvar_value_4;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_PEM_read_bio_PKCS7);
            if (tmp_called_name_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 3016;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_bio);
            tmp_args_element_name_2 = var_bio;
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_5 == NULL)) {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_5 == NULL) {
                Py_DECREF(tmp_called_name_2);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 3016;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_2 = tmp_mvar_value_5;
            tmp_args_element_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_NULL);
            if (tmp_args_element_name_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_2);

                exception_lineno = 3016;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_6 == NULL)) {
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_6 == NULL) {
                Py_DECREF(tmp_called_name_2);
                Py_DECREF(tmp_args_element_name_3);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 3016;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_3 = tmp_mvar_value_6;
            tmp_args_element_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_NULL);
            if (tmp_args_element_name_4 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_2);
                Py_DECREF(tmp_args_element_name_3);

                exception_lineno = 3016;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_7 == NULL)) {
                tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_7 == NULL) {
                Py_DECREF(tmp_called_name_2);
                Py_DECREF(tmp_args_element_name_3);
                Py_DECREF(tmp_args_element_name_4);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 3016;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_4 = tmp_mvar_value_7;
            tmp_args_element_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_NULL);
            if (tmp_args_element_name_5 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_2);
                Py_DECREF(tmp_args_element_name_3);
                Py_DECREF(tmp_args_element_name_4);

                exception_lineno = 3016;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            frame_bd97d2185c62e99374c1533c90a95f19->m_frame.f_lineno = 3016;
            {
                PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5};
                tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS4(tmp_called_name_2, call_args);
            }

            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_3);
            Py_DECREF(tmp_args_element_name_4);
            Py_DECREF(tmp_args_element_name_5);
            if (tmp_assign_source_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 3016;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            assert(var_pkcs7 == NULL);
            var_pkcs7 = tmp_assign_source_3;
        }
        goto branch_end_2;
        branch_no_2:;
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_mvar_value_8;
            CHECK_OBJECT(par_type);
            tmp_compexpr_left_2 = par_type;
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1);

            if (unlikely(tmp_mvar_value_8 == NULL)) {
                tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1);
            }

            if (tmp_mvar_value_8 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 4053 ], 42, 0);
                exception_tb = NULL;

                exception_lineno = 3017;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_2 = tmp_mvar_value_8;
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 3017;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_3 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
                goto branch_yes_3;
            } else {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_assign_source_4;
                PyObject *tmp_called_name_3;
                PyObject *tmp_source_name_5;
                PyObject *tmp_mvar_value_9;
                PyObject *tmp_args_element_name_6;
                PyObject *tmp_args_element_name_7;
                PyObject *tmp_source_name_6;
                PyObject *tmp_mvar_value_10;
                tmp_mvar_value_9 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

                if (unlikely(tmp_mvar_value_9 == NULL)) {
                    tmp_mvar_value_9 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
                }

                if (tmp_mvar_value_9 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 3018;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_5 = tmp_mvar_value_9;
                tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_d2i_PKCS7_bio);
                if (tmp_called_name_3 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 3018;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT(var_bio);
                tmp_args_element_name_6 = var_bio;
                tmp_mvar_value_10 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

                if (unlikely(tmp_mvar_value_10 == NULL)) {
                    tmp_mvar_value_10 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
                }

                if (tmp_mvar_value_10 == NULL) {
                    Py_DECREF(tmp_called_name_3);
                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 3018;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_6 = tmp_mvar_value_10;
                tmp_args_element_name_7 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_NULL);
                if (tmp_args_element_name_7 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    Py_DECREF(tmp_called_name_3);

                    exception_lineno = 3018;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                frame_bd97d2185c62e99374c1533c90a95f19->m_frame.f_lineno = 3018;
                {
                    PyObject *call_args[] = {tmp_args_element_name_6, tmp_args_element_name_7};
                    tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_3, call_args);
                }

                Py_DECREF(tmp_called_name_3);
                Py_DECREF(tmp_args_element_name_7);
                if (tmp_assign_source_4 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 3018;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                assert(var_pkcs7 == NULL);
                var_pkcs7 = tmp_assign_source_4;
            }
            goto branch_end_3;
            branch_no_3:;
            {
                PyObject *tmp_raise_type_1;
                PyObject *tmp_make_exception_arg_1;
                tmp_make_exception_arg_1 = const_str_digest_f019d8c1ebbf58631ace92b4423b3aad;
                frame_bd97d2185c62e99374c1533c90a95f19->m_frame.f_lineno = 3020;
                tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_1);
                assert(!(tmp_raise_type_1 == NULL));
                exception_type = tmp_raise_type_1;
                exception_lineno = 3020;
                RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            branch_end_3:;
        }
        branch_end_2:;
    }
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_11;
        if (var_pkcs7 == NULL) {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("local variable '%s' referenced before assignment", "pkcs7");
            exception_tb = NULL;

            exception_lineno = 3022;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_left_3 = var_pkcs7;
        tmp_mvar_value_11 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_11 == NULL)) {
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_11 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 3022;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = tmp_mvar_value_11;
        tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain_NULL);
        if (tmp_compexpr_right_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3022;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_3, tmp_compexpr_right_3);
        Py_DECREF(tmp_compexpr_right_3);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3022;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_4 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_4 == NUITKA_BOOL_TRUE) {
            goto branch_yes_4;
        } else {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_called_name_4;
            PyObject *tmp_mvar_value_12;
            PyObject *tmp_call_result_1;
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error);

            if (unlikely(tmp_mvar_value_12 == NULL)) {
                tmp_mvar_value_12 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error);
            }

            if (tmp_mvar_value_12 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 0 ], 49, 0);
                exception_tb = NULL;

                exception_lineno = 3023;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_4 = tmp_mvar_value_12;
            frame_bd97d2185c62e99374c1533c90a95f19->m_frame.f_lineno = 3023;
            tmp_call_result_1 = CALL_FUNCTION_NO_ARGS(tmp_called_name_4);
            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 3023;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_1);
        }
        branch_no_4:;
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_called_name_5;
        PyObject *tmp_source_name_8;
        PyObject *tmp_mvar_value_13;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_mvar_value_14;
        tmp_mvar_value_13 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKCS7);

        if (unlikely(tmp_mvar_value_13 == NULL)) {
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_PKCS7);
        }

        if (tmp_mvar_value_13 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 4334 ], 34, 0);
            exception_tb = NULL;

            exception_lineno = 3025;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_8 = tmp_mvar_value_13;
        tmp_called_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_8, const_str_plain___new__);
        if (tmp_called_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3025;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_14 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKCS7);

        if (unlikely(tmp_mvar_value_14 == NULL)) {
            tmp_mvar_value_14 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_PKCS7);
        }

        if (tmp_mvar_value_14 == NULL) {
            Py_DECREF(tmp_called_name_5);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 4334 ], 34, 0);
            exception_tb = NULL;

            exception_lineno = 3025;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_8 = tmp_mvar_value_14;
        frame_bd97d2185c62e99374c1533c90a95f19->m_frame.f_lineno = 3025;
        tmp_assign_source_5 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_5, tmp_args_element_name_8);
        Py_DECREF(tmp_called_name_5);
        if (tmp_assign_source_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3025;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(var_pypkcs7 == NULL);
        var_pypkcs7 = tmp_assign_source_5;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_6;
        PyObject *tmp_source_name_9;
        PyObject *tmp_mvar_value_15;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_source_name_10;
        PyObject *tmp_mvar_value_16;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_15 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_15 == NULL)) {
            tmp_mvar_value_15 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_15 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 3026;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_9 = tmp_mvar_value_15;
        tmp_called_name_6 = LOOKUP_ATTRIBUTE(tmp_source_name_9, const_str_plain_gc);
        if (tmp_called_name_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3026;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        if (var_pkcs7 == NULL) {
            Py_DECREF(tmp_called_name_6);
            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("local variable '%s' referenced before assignment", "pkcs7");
            exception_tb = NULL;

            exception_lineno = 3026;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_9 = var_pkcs7;
        tmp_mvar_value_16 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_16 == NULL)) {
            tmp_mvar_value_16 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_16 == NULL) {
            Py_DECREF(tmp_called_name_6);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 3026;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_10 = tmp_mvar_value_16;
        tmp_args_element_name_10 = LOOKUP_ATTRIBUTE(tmp_source_name_10, const_str_plain_PKCS7_free);
        if (tmp_args_element_name_10 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_6);

            exception_lineno = 3026;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_bd97d2185c62e99374c1533c90a95f19->m_frame.f_lineno = 3026;
        {
            PyObject *call_args[] = {tmp_args_element_name_9, tmp_args_element_name_10};
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_6, call_args);
        }

        Py_DECREF(tmp_called_name_6);
        Py_DECREF(tmp_args_element_name_10);
        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3026;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_pypkcs7);
        tmp_assattr_target_1 = var_pypkcs7;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__pkcs7, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3026;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_bd97d2185c62e99374c1533c90a95f19);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_bd97d2185c62e99374c1533c90a95f19);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_bd97d2185c62e99374c1533c90a95f19, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_bd97d2185c62e99374c1533c90a95f19->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_bd97d2185c62e99374c1533c90a95f19, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_bd97d2185c62e99374c1533c90a95f19,
        type_description_1,
        par_type,
        par_buffer,
        var_bio,
        var_pypkcs7,
        var_pkcs7
    );


    // Release cached frame.
    if (frame_bd97d2185c62e99374c1533c90a95f19 == cache_frame_bd97d2185c62e99374c1533c90a95f19) {
        Py_DECREF(frame_bd97d2185c62e99374c1533c90a95f19);
    }
    cache_frame_bd97d2185c62e99374c1533c90a95f19 = NULL;

    assertFrameObject(frame_bd97d2185c62e99374c1533c90a95f19);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT(var_pypkcs7);
    tmp_return_value = var_pypkcs7;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_156_load_pkcs7_data);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)par_buffer);
    Py_DECREF(par_buffer);
    par_buffer = NULL;

    CHECK_OBJECT((PyObject *)var_bio);
    Py_DECREF(var_bio);
    var_bio = NULL;

    CHECK_OBJECT((PyObject *)var_pypkcs7);
    Py_DECREF(var_pypkcs7);
    var_pypkcs7 = NULL;

    Py_XDECREF(var_pkcs7);
    var_pkcs7 = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(par_buffer);
    par_buffer = NULL;

    Py_XDECREF(var_bio);
    var_bio = NULL;

    Py_XDECREF(var_pypkcs7);
    var_pypkcs7 = NULL;

    Py_XDECREF(var_pkcs7);
    var_pkcs7 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_156_load_pkcs7_data);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_157_load_pkcs12(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_buffer = python_pars[0];
    PyObject *par_passphrase = python_pars[1];
    PyObject *var_bio = NULL;
    PyObject *var_pykey = NULL;
    PyObject *var_x509 = NULL;
    PyObject *var_friendlyname_buffer = NULL;
    PyObject *var_pkey = NULL;
    PyObject *var_i = NULL;
    PyObject *var_cert = NULL;
    PyObject *var_cacerts = NULL;
    PyObject *var_pycert = NULL;
    PyObject *var_friendlyname_length = NULL;
    PyObject *var_p12 = NULL;
    PyObject *var_pycacert = NULL;
    PyObject *var_pkcs12 = NULL;
    PyObject *var_friendlyname = NULL;
    PyObject *var_pycacerts = NULL;
    PyObject *var_parse_result = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_cb2229b3594b0ea74e790a288340fb5b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    bool tmp_result;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    static struct Nuitka_FrameObject *cache_frame_cb2229b3594b0ea74e790a288340fb5b = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_cb2229b3594b0ea74e790a288340fb5b, codeobj_cb2229b3594b0ea74e790a288340fb5b, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_cb2229b3594b0ea74e790a288340fb5b = cache_frame_cb2229b3594b0ea74e790a288340fb5b;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_cb2229b3594b0ea74e790a288340fb5b);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_cb2229b3594b0ea74e790a288340fb5b) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1011 ], 52, 0);
            exception_tb = NULL;

            exception_lineno = 3042;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        tmp_args_element_name_1 = const_str_plain_passphrase;
        CHECK_OBJECT(par_passphrase);
        tmp_args_element_name_2 = par_passphrase;
        frame_cb2229b3594b0ea74e790a288340fb5b->m_frame.f_lineno = 3042;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3042;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = par_passphrase;
            assert(old != NULL);
            par_passphrase = tmp_assign_source_1;
            Py_DECREF(old);
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT(par_buffer);
        tmp_isinstance_inst_1 = par_buffer;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__text_type);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__text_type);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3552 ], 39, 0);
            exception_tb = NULL;

            exception_lineno = 3044;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_2;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3044;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_called_instance_1;
            CHECK_OBJECT(par_buffer);
            tmp_called_instance_1 = par_buffer;
            frame_cb2229b3594b0ea74e790a288340fb5b->m_frame.f_lineno = 3045;
            tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_encode, &PyTuple_GET_ITEM(const_tuple_str_plain_ascii_tuple, 0));

            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 3045;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_buffer;
                assert(old != NULL);
                par_buffer = tmp_assign_source_2;
                Py_DECREF(old);
            }

        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3591 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 3047;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_3;
        CHECK_OBJECT(par_buffer);
        tmp_args_element_name_3 = par_buffer;
        frame_cb2229b3594b0ea74e790a288340fb5b->m_frame.f_lineno = 3047;
        tmp_assign_source_3 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_3);
        if (tmp_assign_source_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3047;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_bio == NULL);
        var_bio = tmp_assign_source_3;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_1;
        CHECK_OBJECT(par_passphrase);
        tmp_operand_name_1 = par_passphrase;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3053;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_4;
            PyObject *tmp_source_name_1;
            PyObject *tmp_mvar_value_4;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_4 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 3054;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_1 = tmp_mvar_value_4;
            tmp_assign_source_4 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_NULL);
            if (tmp_assign_source_4 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 3054;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_passphrase;
                assert(old != NULL);
                par_passphrase = tmp_assign_source_4;
                Py_DECREF(old);
            }

        }
        branch_no_2:;
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_6;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 3056;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_5;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_d2i_PKCS12_bio);
        if (tmp_called_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3056;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_bio);
        tmp_args_element_name_4 = var_bio;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_6 == NULL) {
            Py_DECREF(tmp_called_name_3);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 3056;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_6;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_NULL);
        if (tmp_args_element_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);

            exception_lineno = 3056;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        frame_cb2229b3594b0ea74e790a288340fb5b->m_frame.f_lineno = 3056;
        {
            PyObject *call_args[] = {tmp_args_element_name_4, tmp_args_element_name_5};
            tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_3, call_args);
        }

        Py_DECREF(tmp_called_name_3);
        Py_DECREF(tmp_args_element_name_5);
        if (tmp_assign_source_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3056;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_p12 == NULL);
        var_p12 = tmp_assign_source_5;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_7;
        CHECK_OBJECT(var_p12);
        tmp_compexpr_left_1 = var_p12;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_7 == NULL)) {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_7 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 3057;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_7;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_NULL);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3057;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3057;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
            goto branch_yes_3;
        } else {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_called_name_4;
            PyObject *tmp_mvar_value_8;
            PyObject *tmp_call_result_1;
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error);

            if (unlikely(tmp_mvar_value_8 == NULL)) {
                tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error);
            }

            if (tmp_mvar_value_8 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 0 ], 49, 0);
                exception_tb = NULL;

                exception_lineno = 3058;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_4 = tmp_mvar_value_8;
            frame_cb2229b3594b0ea74e790a288340fb5b->m_frame.f_lineno = 3058;
            tmp_call_result_1 = CALL_FUNCTION_NO_ARGS(tmp_called_name_4);
            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 3058;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_1);
        }
        branch_no_3:;
    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_called_name_5;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_9;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_10;
        tmp_mvar_value_9 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_9 == NULL)) {
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_9 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 3059;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_9;
        tmp_called_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_gc);
        if (tmp_called_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3059;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_p12);
        tmp_args_element_name_6 = var_p12;
        tmp_mvar_value_10 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_10 == NULL)) {
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_10 == NULL) {
            Py_DECREF(tmp_called_name_5);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 3059;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_10;
        tmp_args_element_name_7 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_PKCS12_free);
        if (tmp_args_element_name_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_5);

            exception_lineno = 3059;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        frame_cb2229b3594b0ea74e790a288340fb5b->m_frame.f_lineno = 3059;
        {
            PyObject *call_args[] = {tmp_args_element_name_6, tmp_args_element_name_7};
            tmp_assign_source_6 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_5, call_args);
        }

        Py_DECREF(tmp_called_name_5);
        Py_DECREF(tmp_args_element_name_7);
        if (tmp_assign_source_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3059;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var_p12;
            assert(old != NULL);
            var_p12 = tmp_assign_source_6;
            Py_DECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_11;
        tmp_mvar_value_11 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_11 == NULL)) {
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_11 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 3061;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_11;
        frame_cb2229b3594b0ea74e790a288340fb5b->m_frame.f_lineno = 3061;
        tmp_assign_source_7 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_new, &PyTuple_GET_ITEM(const_tuple_str_digest_016ce3807ea72a262d921fa7d1804717_tuple, 0));

        if (tmp_assign_source_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3061;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_pkey == NULL);
        var_pkey = tmp_assign_source_7;
    }
    {
        PyObject *tmp_assign_source_8;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_12;
        tmp_mvar_value_12 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_12 == NULL)) {
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_12 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 3062;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_3 = tmp_mvar_value_12;
        frame_cb2229b3594b0ea74e790a288340fb5b->m_frame.f_lineno = 3062;
        tmp_assign_source_8 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_3, const_str_plain_new, &PyTuple_GET_ITEM(const_tuple_str_digest_e1dc452ac5e3c17f3e15bbf44d17e339_tuple, 0));

        if (tmp_assign_source_8 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3062;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_cert == NULL);
        var_cert = tmp_assign_source_8;
    }
    {
        PyObject *tmp_assign_source_9;
        PyObject *tmp_called_instance_4;
        PyObject *tmp_mvar_value_13;
        tmp_mvar_value_13 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_13 == NULL)) {
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_13 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 3063;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_4 = tmp_mvar_value_13;
        frame_cb2229b3594b0ea74e790a288340fb5b->m_frame.f_lineno = 3063;
        tmp_assign_source_9 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_4, const_str_plain_new, &PyTuple_GET_ITEM(const_tuple_str_digest_4560cdf69c017b7cd264323295e708cb_tuple, 0));

        if (tmp_assign_source_9 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3063;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_cacerts == NULL);
        var_cacerts = tmp_assign_source_9;
    }
    {
        PyObject *tmp_assign_source_10;
        PyObject *tmp_called_instance_5;
        PyObject *tmp_mvar_value_14;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_args_element_name_11;
        PyObject *tmp_args_element_name_12;
        tmp_mvar_value_14 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_14 == NULL)) {
            tmp_mvar_value_14 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_14 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 3065;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_5 = tmp_mvar_value_14;
        CHECK_OBJECT(var_p12);
        tmp_args_element_name_8 = var_p12;
        CHECK_OBJECT(par_passphrase);
        tmp_args_element_name_9 = par_passphrase;
        CHECK_OBJECT(var_pkey);
        tmp_args_element_name_10 = var_pkey;
        CHECK_OBJECT(var_cert);
        tmp_args_element_name_11 = var_cert;
        CHECK_OBJECT(var_cacerts);
        tmp_args_element_name_12 = var_cacerts;
        frame_cb2229b3594b0ea74e790a288340fb5b->m_frame.f_lineno = 3065;
        {
            PyObject *call_args[] = {tmp_args_element_name_8, tmp_args_element_name_9, tmp_args_element_name_10, tmp_args_element_name_11, tmp_args_element_name_12};
            tmp_assign_source_10 = CALL_METHOD_WITH_ARGS5(tmp_called_instance_5, const_str_plain_PKCS12_parse, call_args);
        }

        if (tmp_assign_source_10 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3065;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_parse_result == NULL);
        var_parse_result = tmp_assign_source_10;
    }
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_operand_name_2;
        CHECK_OBJECT(var_parse_result);
        tmp_operand_name_2 = var_parse_result;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3066;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_4 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_4 == NUITKA_BOOL_TRUE) {
            goto branch_yes_4;
        } else {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_called_name_6;
            PyObject *tmp_mvar_value_15;
            PyObject *tmp_call_result_2;
            tmp_mvar_value_15 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error);

            if (unlikely(tmp_mvar_value_15 == NULL)) {
                tmp_mvar_value_15 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error);
            }

            if (tmp_mvar_value_15 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 0 ], 49, 0);
                exception_tb = NULL;

                exception_lineno = 3067;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_6 = tmp_mvar_value_15;
            frame_cb2229b3594b0ea74e790a288340fb5b->m_frame.f_lineno = 3067;
            tmp_call_result_2 = CALL_FUNCTION_NO_ARGS(tmp_called_name_6);
            if (tmp_call_result_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 3067;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_2);
        }
        branch_no_4:;
    }
    {
        PyObject *tmp_assign_source_11;
        PyObject *tmp_called_name_7;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_16;
        PyObject *tmp_args_element_name_13;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_subscript_name_1;
        PyObject *tmp_args_element_name_14;
        PyObject *tmp_source_name_8;
        PyObject *tmp_mvar_value_17;
        tmp_mvar_value_16 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_16 == NULL)) {
            tmp_mvar_value_16 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_16 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 3069;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = tmp_mvar_value_16;
        tmp_called_name_7 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain_gc);
        if (tmp_called_name_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3069;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_cacerts);
        tmp_subscribed_name_1 = var_cacerts;
        tmp_subscript_name_1 = const_int_0;
        tmp_args_element_name_13 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_1, tmp_subscript_name_1, 0);
        if (tmp_args_element_name_13 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_7);

            exception_lineno = 3069;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_17 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_17 == NULL)) {
            tmp_mvar_value_17 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_17 == NULL) {
            Py_DECREF(tmp_called_name_7);
            Py_DECREF(tmp_args_element_name_13);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 3069;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_8 = tmp_mvar_value_17;
        tmp_args_element_name_14 = LOOKUP_ATTRIBUTE(tmp_source_name_8, const_str_plain_sk_X509_free);
        if (tmp_args_element_name_14 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_7);
            Py_DECREF(tmp_args_element_name_13);

            exception_lineno = 3069;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        frame_cb2229b3594b0ea74e790a288340fb5b->m_frame.f_lineno = 3069;
        {
            PyObject *call_args[] = {tmp_args_element_name_13, tmp_args_element_name_14};
            tmp_assign_source_11 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_7, call_args);
        }

        Py_DECREF(tmp_called_name_7);
        Py_DECREF(tmp_args_element_name_13);
        Py_DECREF(tmp_args_element_name_14);
        if (tmp_assign_source_11 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3069;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var_cacerts;
            assert(old != NULL);
            var_cacerts = tmp_assign_source_11;
            Py_DECREF(old);
        }

    }
    // Tried code:
    {
        PyObject *tmp_called_name_8;
        PyObject *tmp_mvar_value_18;
        PyObject *tmp_call_result_3;
        tmp_mvar_value_18 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error);

        if (unlikely(tmp_mvar_value_18 == NULL)) {
            tmp_mvar_value_18 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error);
        }

        if (tmp_mvar_value_18 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 0 ], 49, 0);
            exception_tb = NULL;

            exception_lineno = 3075;
            type_description_1 = "oooooooooooooooooo";
            goto try_except_handler_2;
        }

        tmp_called_name_8 = tmp_mvar_value_18;
        frame_cb2229b3594b0ea74e790a288340fb5b->m_frame.f_lineno = 3075;
        tmp_call_result_3 = CALL_FUNCTION_NO_ARGS(tmp_called_name_8);
        if (tmp_call_result_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3075;
            type_description_1 = "oooooooooooooooooo";
            goto try_except_handler_2;
        }
        Py_DECREF(tmp_call_result_3);
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION(frame_cb2229b3594b0ea74e790a288340fb5b);
    if (exception_keeper_tb_1 == NULL) {
        exception_keeper_tb_1 = MAKE_TRACEBACK(frame_cb2229b3594b0ea74e790a288340fb5b, exception_keeper_lineno_1);
    } else if (exception_keeper_lineno_1 != 0) {
        exception_keeper_tb_1 = ADD_TRACEBACK(exception_keeper_tb_1, frame_cb2229b3594b0ea74e790a288340fb5b, exception_keeper_lineno_1);
    }

    NORMALIZE_EXCEPTION(&exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1);
    PUBLISH_EXCEPTION(&exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1);
    {
        nuitka_bool tmp_condition_result_5;
        PyObject *tmp_operand_name_3;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_mvar_value_19;
        tmp_compexpr_left_2 = EXC_TYPE(PyThreadState_GET());
        tmp_mvar_value_19 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_Error);

        if (unlikely(tmp_mvar_value_19 == NULL)) {
            tmp_mvar_value_19 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_Error);
        }

        if (tmp_mvar_value_19 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 49 ], 34, 0);
            exception_tb = NULL;

            exception_lineno = 3076;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_2 = tmp_mvar_value_19;
        tmp_res = EXCEPTION_MATCH_BOOL(tmp_compexpr_left_2, tmp_compexpr_right_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3076;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_3 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_3);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3076;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_5 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_5 == NUITKA_BOOL_TRUE) {
            goto branch_yes_5;
        } else {
            goto branch_no_5;
        }
        branch_yes_5:;
        tmp_result = RERAISE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
        if (unlikely(tmp_result == false)) {
            exception_lineno = 3074;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_cb2229b3594b0ea74e790a288340fb5b->m_frame) frame_cb2229b3594b0ea74e790a288340fb5b->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
        branch_no_5:;
    }
    goto try_end_1;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_157_load_pkcs12);
    return NULL;
    // End of try:
    try_end_1:;
    {
        nuitka_bool tmp_condition_result_6;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_subscribed_name_2;
        PyObject *tmp_subscript_name_2;
        PyObject *tmp_source_name_9;
        PyObject *tmp_mvar_value_20;
        CHECK_OBJECT(var_pkey);
        tmp_subscribed_name_2 = var_pkey;
        tmp_subscript_name_2 = const_int_0;
        tmp_compexpr_left_3 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_2, tmp_subscript_name_2, 0);
        if (tmp_compexpr_left_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3079;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_20 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_20 == NULL)) {
            tmp_mvar_value_20 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_20 == NULL) {
            Py_DECREF(tmp_compexpr_left_3);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 3079;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_9 = tmp_mvar_value_20;
        tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE(tmp_source_name_9, const_str_plain_NULL);
        if (tmp_compexpr_right_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_3);

            exception_lineno = 3079;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_3, tmp_compexpr_right_3);
        Py_DECREF(tmp_compexpr_left_3);
        Py_DECREF(tmp_compexpr_right_3);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3079;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_6 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_6 == NUITKA_BOOL_TRUE) {
            goto branch_yes_6;
        } else {
            goto branch_no_6;
        }
        branch_yes_6:;
        {
            PyObject *tmp_assign_source_12;
            tmp_assign_source_12 = Py_None;
            assert(var_pykey == NULL);
            Py_INCREF(tmp_assign_source_12);
            var_pykey = tmp_assign_source_12;
        }
        goto branch_end_6;
        branch_no_6:;
        {
            PyObject *tmp_assign_source_13;
            PyObject *tmp_called_name_9;
            PyObject *tmp_source_name_10;
            PyObject *tmp_mvar_value_21;
            PyObject *tmp_args_element_name_15;
            PyObject *tmp_mvar_value_22;
            tmp_mvar_value_21 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey);

            if (unlikely(tmp_mvar_value_21 == NULL)) {
                tmp_mvar_value_21 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey);
            }

            if (tmp_mvar_value_21 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 978 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 3082;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_10 = tmp_mvar_value_21;
            tmp_called_name_9 = LOOKUP_ATTRIBUTE(tmp_source_name_10, const_str_plain___new__);
            if (tmp_called_name_9 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 3082;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_22 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey);

            if (unlikely(tmp_mvar_value_22 == NULL)) {
                tmp_mvar_value_22 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey);
            }

            if (tmp_mvar_value_22 == NULL) {
                Py_DECREF(tmp_called_name_9);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 978 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 3082;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_args_element_name_15 = tmp_mvar_value_22;
            frame_cb2229b3594b0ea74e790a288340fb5b->m_frame.f_lineno = 3082;
            tmp_assign_source_13 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_9, tmp_args_element_name_15);
            Py_DECREF(tmp_called_name_9);
            if (tmp_assign_source_13 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 3082;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            assert(var_pykey == NULL);
            var_pykey = tmp_assign_source_13;
        }
        {
            PyObject *tmp_assattr_name_1;
            PyObject *tmp_called_name_10;
            PyObject *tmp_source_name_11;
            PyObject *tmp_mvar_value_23;
            PyObject *tmp_args_element_name_16;
            PyObject *tmp_subscribed_name_3;
            PyObject *tmp_subscript_name_3;
            PyObject *tmp_args_element_name_17;
            PyObject *tmp_source_name_12;
            PyObject *tmp_mvar_value_24;
            PyObject *tmp_assattr_target_1;
            tmp_mvar_value_23 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_23 == NULL)) {
                tmp_mvar_value_23 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_23 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 3083;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_11 = tmp_mvar_value_23;
            tmp_called_name_10 = LOOKUP_ATTRIBUTE(tmp_source_name_11, const_str_plain_gc);
            if (tmp_called_name_10 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 3083;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_pkey);
            tmp_subscribed_name_3 = var_pkey;
            tmp_subscript_name_3 = const_int_0;
            tmp_args_element_name_16 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_3, tmp_subscript_name_3, 0);
            if (tmp_args_element_name_16 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_10);

                exception_lineno = 3083;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_24 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_24 == NULL)) {
                tmp_mvar_value_24 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_24 == NULL) {
                Py_DECREF(tmp_called_name_10);
                Py_DECREF(tmp_args_element_name_16);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 3083;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_12 = tmp_mvar_value_24;
            tmp_args_element_name_17 = LOOKUP_ATTRIBUTE(tmp_source_name_12, const_str_plain_EVP_PKEY_free);
            if (tmp_args_element_name_17 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_10);
                Py_DECREF(tmp_args_element_name_16);

                exception_lineno = 3083;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            frame_cb2229b3594b0ea74e790a288340fb5b->m_frame.f_lineno = 3083;
            {
                PyObject *call_args[] = {tmp_args_element_name_16, tmp_args_element_name_17};
                tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_10, call_args);
            }

            Py_DECREF(tmp_called_name_10);
            Py_DECREF(tmp_args_element_name_16);
            Py_DECREF(tmp_args_element_name_17);
            if (tmp_assattr_name_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 3083;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_pykey);
            tmp_assattr_target_1 = var_pykey;
            tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__pkey, tmp_assattr_name_1);
            Py_DECREF(tmp_assattr_name_1);
            if (tmp_result == false) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 3083;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
        }
        branch_end_6:;
    }
    {
        nuitka_bool tmp_condition_result_7;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        PyObject *tmp_subscribed_name_4;
        PyObject *tmp_subscript_name_4;
        PyObject *tmp_source_name_13;
        PyObject *tmp_mvar_value_25;
        CHECK_OBJECT(var_cert);
        tmp_subscribed_name_4 = var_cert;
        tmp_subscript_name_4 = const_int_0;
        tmp_compexpr_left_4 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_4, tmp_subscript_name_4, 0);
        if (tmp_compexpr_left_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3085;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_25 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_25 == NULL)) {
            tmp_mvar_value_25 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_25 == NULL) {
            Py_DECREF(tmp_compexpr_left_4);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 3085;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_13 = tmp_mvar_value_25;
        tmp_compexpr_right_4 = LOOKUP_ATTRIBUTE(tmp_source_name_13, const_str_plain_NULL);
        if (tmp_compexpr_right_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_compexpr_left_4);

            exception_lineno = 3085;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_4, tmp_compexpr_right_4);
        Py_DECREF(tmp_compexpr_left_4);
        Py_DECREF(tmp_compexpr_right_4);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3085;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_7 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_7 == NUITKA_BOOL_TRUE) {
            goto branch_yes_7;
        } else {
            goto branch_no_7;
        }
        branch_yes_7:;
        {
            PyObject *tmp_assign_source_14;
            tmp_assign_source_14 = Py_None;
            assert(var_pycert == NULL);
            Py_INCREF(tmp_assign_source_14);
            var_pycert = tmp_assign_source_14;
        }
        {
            PyObject *tmp_assign_source_15;
            tmp_assign_source_15 = Py_None;
            assert(var_friendlyname == NULL);
            Py_INCREF(tmp_assign_source_15);
            var_friendlyname = tmp_assign_source_15;
        }
        goto branch_end_7;
        branch_no_7:;
        {
            PyObject *tmp_assign_source_16;
            PyObject *tmp_called_name_11;
            PyObject *tmp_source_name_14;
            PyObject *tmp_mvar_value_26;
            PyObject *tmp_args_element_name_18;
            PyObject *tmp_subscribed_name_5;
            PyObject *tmp_subscript_name_5;
            tmp_mvar_value_26 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509);

            if (unlikely(tmp_mvar_value_26 == NULL)) {
                tmp_mvar_value_26 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509);
            }

            if (tmp_mvar_value_26 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 236 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 3089;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_14 = tmp_mvar_value_26;
            tmp_called_name_11 = LOOKUP_ATTRIBUTE(tmp_source_name_14, const_str_plain__from_raw_x509_ptr);
            if (tmp_called_name_11 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 3089;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_cert);
            tmp_subscribed_name_5 = var_cert;
            tmp_subscript_name_5 = const_int_0;
            tmp_args_element_name_18 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_5, tmp_subscript_name_5, 0);
            if (tmp_args_element_name_18 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_11);

                exception_lineno = 3089;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            frame_cb2229b3594b0ea74e790a288340fb5b->m_frame.f_lineno = 3089;
            tmp_assign_source_16 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_11, tmp_args_element_name_18);
            Py_DECREF(tmp_called_name_11);
            Py_DECREF(tmp_args_element_name_18);
            if (tmp_assign_source_16 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 3089;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            assert(var_pycert == NULL);
            var_pycert = tmp_assign_source_16;
        }
        {
            PyObject *tmp_assign_source_17;
            PyObject *tmp_called_instance_6;
            PyObject *tmp_mvar_value_27;
            tmp_mvar_value_27 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_27 == NULL)) {
                tmp_mvar_value_27 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_27 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 3091;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_6 = tmp_mvar_value_27;
            frame_cb2229b3594b0ea74e790a288340fb5b->m_frame.f_lineno = 3091;
            tmp_assign_source_17 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_6, const_str_plain_new, &PyTuple_GET_ITEM(const_tuple_str_digest_8e9fba48e24a08144a915d52e31f6d23_tuple, 0));

            if (tmp_assign_source_17 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 3091;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            assert(var_friendlyname_length == NULL);
            var_friendlyname_length = tmp_assign_source_17;
        }
        {
            PyObject *tmp_assign_source_18;
            PyObject *tmp_called_name_12;
            PyObject *tmp_source_name_15;
            PyObject *tmp_mvar_value_28;
            PyObject *tmp_args_element_name_19;
            PyObject *tmp_subscribed_name_6;
            PyObject *tmp_subscript_name_6;
            PyObject *tmp_args_element_name_20;
            tmp_mvar_value_28 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_28 == NULL)) {
                tmp_mvar_value_28 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_28 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 3092;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_15 = tmp_mvar_value_28;
            tmp_called_name_12 = LOOKUP_ATTRIBUTE(tmp_source_name_15, const_str_plain_X509_alias_get0);
            if (tmp_called_name_12 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 3092;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_cert);
            tmp_subscribed_name_6 = var_cert;
            tmp_subscript_name_6 = const_int_0;
            tmp_args_element_name_19 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_6, tmp_subscript_name_6, 0);
            if (tmp_args_element_name_19 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_12);

                exception_lineno = 3093;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_friendlyname_length);
            tmp_args_element_name_20 = var_friendlyname_length;
            frame_cb2229b3594b0ea74e790a288340fb5b->m_frame.f_lineno = 3092;
            {
                PyObject *call_args[] = {tmp_args_element_name_19, tmp_args_element_name_20};
                tmp_assign_source_18 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_12, call_args);
            }

            Py_DECREF(tmp_called_name_12);
            Py_DECREF(tmp_args_element_name_19);
            if (tmp_assign_source_18 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 3092;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            assert(var_friendlyname_buffer == NULL);
            var_friendlyname_buffer = tmp_assign_source_18;
        }
        {
            PyObject *tmp_assign_source_19;
            Py_ssize_t tmp_sliceslicedel_index_lower_1;
            Py_ssize_t tmp_slice_index_upper_1;
            PyObject *tmp_slice_source_1;
            PyObject *tmp_called_name_13;
            PyObject *tmp_source_name_16;
            PyObject *tmp_mvar_value_29;
            PyObject *tmp_args_element_name_21;
            PyObject *tmp_args_element_name_22;
            PyObject *tmp_subscribed_name_7;
            PyObject *tmp_subscript_name_7;
            tmp_sliceslicedel_index_lower_1 = 0;
            tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
            tmp_mvar_value_29 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_29 == NULL)) {
                tmp_mvar_value_29 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_29 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 3095;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_16 = tmp_mvar_value_29;
            tmp_called_name_13 = LOOKUP_ATTRIBUTE(tmp_source_name_16, const_str_plain_buffer);
            if (tmp_called_name_13 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 3095;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_friendlyname_buffer);
            tmp_args_element_name_21 = var_friendlyname_buffer;
            CHECK_OBJECT(var_friendlyname_length);
            tmp_subscribed_name_7 = var_friendlyname_length;
            tmp_subscript_name_7 = const_int_0;
            tmp_args_element_name_22 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_7, tmp_subscript_name_7, 0);
            if (tmp_args_element_name_22 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_13);

                exception_lineno = 3096;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            frame_cb2229b3594b0ea74e790a288340fb5b->m_frame.f_lineno = 3095;
            {
                PyObject *call_args[] = {tmp_args_element_name_21, tmp_args_element_name_22};
                tmp_slice_source_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_13, call_args);
            }

            Py_DECREF(tmp_called_name_13);
            Py_DECREF(tmp_args_element_name_22);
            if (tmp_slice_source_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 3095;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_assign_source_19 = LOOKUP_INDEX_SLICE(tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1);
            Py_DECREF(tmp_slice_source_1);
            if (tmp_assign_source_19 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 3095;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            assert(var_friendlyname == NULL);
            var_friendlyname = tmp_assign_source_19;
        }
        {
            nuitka_bool tmp_condition_result_8;
            PyObject *tmp_compexpr_left_5;
            PyObject *tmp_compexpr_right_5;
            PyObject *tmp_source_name_17;
            PyObject *tmp_mvar_value_30;
            CHECK_OBJECT(var_friendlyname_buffer);
            tmp_compexpr_left_5 = var_friendlyname_buffer;
            tmp_mvar_value_30 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_30 == NULL)) {
                tmp_mvar_value_30 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_30 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 3098;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_17 = tmp_mvar_value_30;
            tmp_compexpr_right_5 = LOOKUP_ATTRIBUTE(tmp_source_name_17, const_str_plain_NULL);
            if (tmp_compexpr_right_5 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 3098;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_5, tmp_compexpr_right_5);
            Py_DECREF(tmp_compexpr_right_5);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 3098;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_8 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_8 == NUITKA_BOOL_TRUE) {
                goto branch_yes_8;
            } else {
                goto branch_no_8;
            }
            branch_yes_8:;
            {
                PyObject *tmp_assign_source_20;
                tmp_assign_source_20 = Py_None;
                {
                    PyObject *old = var_friendlyname;
                    assert(old != NULL);
                    var_friendlyname = tmp_assign_source_20;
                    Py_INCREF(var_friendlyname);
                    Py_DECREF(old);
                }

            }
            branch_no_8:;
        }
        branch_end_7:;
    }
    {
        PyObject *tmp_assign_source_21;
        tmp_assign_source_21 = PyList_New(0);
        assert(var_pycacerts == NULL);
        var_pycacerts = tmp_assign_source_21;
    }
    {
        PyObject *tmp_assign_source_22;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_range_arg_1;
        PyObject *tmp_called_instance_7;
        PyObject *tmp_mvar_value_31;
        PyObject *tmp_args_element_name_23;
        tmp_mvar_value_31 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_31 == NULL)) {
            tmp_mvar_value_31 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_31 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 3102;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_7 = tmp_mvar_value_31;
        CHECK_OBJECT(var_cacerts);
        tmp_args_element_name_23 = var_cacerts;
        frame_cb2229b3594b0ea74e790a288340fb5b->m_frame.f_lineno = 3102;
        {
            PyObject *call_args[] = {tmp_args_element_name_23};
            tmp_range_arg_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_7, const_str_plain_sk_X509_num, call_args);
        }

        if (tmp_range_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3102;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_iter_arg_1 = BUILTIN_RANGE(tmp_range_arg_1);
        Py_DECREF(tmp_range_arg_1);
        if (tmp_iter_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3102;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_22 = MAKE_ITERATOR(tmp_iter_arg_1);
        Py_DECREF(tmp_iter_arg_1);
        if (tmp_assign_source_22 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3102;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        assert(tmp_for_loop_1__for_iterator == NULL);
        tmp_for_loop_1__for_iterator = tmp_assign_source_22;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_23;
        CHECK_OBJECT(tmp_for_loop_1__for_iterator);
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_23 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_23 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "oooooooooooooooooo";
                exception_lineno = 3102;
                goto try_except_handler_3;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_23;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_24;
        CHECK_OBJECT(tmp_for_loop_1__iter_value);
        tmp_assign_source_24 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_i;
            var_i = tmp_assign_source_24;
            Py_INCREF(var_i);
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_25;
        PyObject *tmp_called_instance_8;
        PyObject *tmp_mvar_value_32;
        PyObject *tmp_args_element_name_24;
        PyObject *tmp_args_element_name_25;
        tmp_mvar_value_32 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_32 == NULL)) {
            tmp_mvar_value_32 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_32 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 3103;
            type_description_1 = "oooooooooooooooooo";
            goto try_except_handler_3;
        }

        tmp_called_instance_8 = tmp_mvar_value_32;
        CHECK_OBJECT(var_cacerts);
        tmp_args_element_name_24 = var_cacerts;
        CHECK_OBJECT(var_i);
        tmp_args_element_name_25 = var_i;
        frame_cb2229b3594b0ea74e790a288340fb5b->m_frame.f_lineno = 3103;
        {
            PyObject *call_args[] = {tmp_args_element_name_24, tmp_args_element_name_25};
            tmp_assign_source_25 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_8, const_str_plain_sk_X509_value, call_args);
        }

        if (tmp_assign_source_25 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3103;
            type_description_1 = "oooooooooooooooooo";
            goto try_except_handler_3;
        }
        {
            PyObject *old = var_x509;
            var_x509 = tmp_assign_source_25;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_26;
        PyObject *tmp_called_instance_9;
        PyObject *tmp_mvar_value_33;
        PyObject *tmp_args_element_name_26;
        tmp_mvar_value_33 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509);

        if (unlikely(tmp_mvar_value_33 == NULL)) {
            tmp_mvar_value_33 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509);
        }

        if (tmp_mvar_value_33 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 236 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 3104;
            type_description_1 = "oooooooooooooooooo";
            goto try_except_handler_3;
        }

        tmp_called_instance_9 = tmp_mvar_value_33;
        CHECK_OBJECT(var_x509);
        tmp_args_element_name_26 = var_x509;
        frame_cb2229b3594b0ea74e790a288340fb5b->m_frame.f_lineno = 3104;
        {
            PyObject *call_args[] = {tmp_args_element_name_26};
            tmp_assign_source_26 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_9, const_str_plain__from_raw_x509_ptr, call_args);
        }

        if (tmp_assign_source_26 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3104;
            type_description_1 = "oooooooooooooooooo";
            goto try_except_handler_3;
        }
        {
            PyObject *old = var_pycacert;
            var_pycacert = tmp_assign_source_26;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_called_instance_10;
        PyObject *tmp_call_result_4;
        PyObject *tmp_args_element_name_27;
        CHECK_OBJECT(var_pycacerts);
        tmp_called_instance_10 = var_pycacerts;
        CHECK_OBJECT(var_pycacert);
        tmp_args_element_name_27 = var_pycacert;
        frame_cb2229b3594b0ea74e790a288340fb5b->m_frame.f_lineno = 3105;
        {
            PyObject *call_args[] = {tmp_args_element_name_27};
            tmp_call_result_4 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_10, const_str_plain_append, call_args);
        }

        if (tmp_call_result_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3105;
            type_description_1 = "oooooooooooooooooo";
            goto try_except_handler_3;
        }
        Py_DECREF(tmp_call_result_4);
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


        exception_lineno = 3102;
        type_description_1 = "oooooooooooooooooo";
        goto try_except_handler_3;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    {
        nuitka_bool tmp_condition_result_9;
        PyObject *tmp_operand_name_4;
        CHECK_OBJECT(var_pycacerts);
        tmp_operand_name_4 = var_pycacerts;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_4);
        assert(!(tmp_res == -1));
        tmp_condition_result_9 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_9 == NUITKA_BOOL_TRUE) {
            goto branch_yes_9;
        } else {
            goto branch_no_9;
        }
        branch_yes_9:;
        {
            PyObject *tmp_assign_source_27;
            tmp_assign_source_27 = Py_None;
            {
                PyObject *old = var_pycacerts;
                assert(old != NULL);
                var_pycacerts = tmp_assign_source_27;
                Py_INCREF(var_pycacerts);
                Py_DECREF(old);
            }

        }
        branch_no_9:;
    }
    {
        PyObject *tmp_assign_source_28;
        PyObject *tmp_called_name_14;
        PyObject *tmp_source_name_18;
        PyObject *tmp_mvar_value_34;
        PyObject *tmp_args_element_name_28;
        PyObject *tmp_mvar_value_35;
        tmp_mvar_value_34 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKCS12);

        if (unlikely(tmp_mvar_value_34 == NULL)) {
            tmp_mvar_value_34 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_PKCS12);
        }

        if (tmp_mvar_value_34 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 4368 ], 35, 0);
            exception_tb = NULL;

            exception_lineno = 3109;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_18 = tmp_mvar_value_34;
        tmp_called_name_14 = LOOKUP_ATTRIBUTE(tmp_source_name_18, const_str_plain___new__);
        if (tmp_called_name_14 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3109;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_35 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKCS12);

        if (unlikely(tmp_mvar_value_35 == NULL)) {
            tmp_mvar_value_35 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_PKCS12);
        }

        if (tmp_mvar_value_35 == NULL) {
            Py_DECREF(tmp_called_name_14);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 4368 ], 35, 0);
            exception_tb = NULL;

            exception_lineno = 3109;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_28 = tmp_mvar_value_35;
        frame_cb2229b3594b0ea74e790a288340fb5b->m_frame.f_lineno = 3109;
        tmp_assign_source_28 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_14, tmp_args_element_name_28);
        Py_DECREF(tmp_called_name_14);
        if (tmp_assign_source_28 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3109;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_pkcs12 == NULL);
        var_pkcs12 = tmp_assign_source_28;
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT(var_pykey);
        tmp_assattr_name_2 = var_pykey;
        CHECK_OBJECT(var_pkcs12);
        tmp_assattr_target_2 = var_pkcs12;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain__pkey, tmp_assattr_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3110;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_assattr_target_3;
        CHECK_OBJECT(var_pycert);
        tmp_assattr_name_3 = var_pycert;
        CHECK_OBJECT(var_pkcs12);
        tmp_assattr_target_3 = var_pkcs12;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_3, const_str_plain__cert, tmp_assattr_name_3);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3111;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_4;
        PyObject *tmp_assattr_target_4;
        CHECK_OBJECT(var_pycacerts);
        tmp_assattr_name_4 = var_pycacerts;
        CHECK_OBJECT(var_pkcs12);
        tmp_assattr_target_4 = var_pkcs12;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_4, const_str_plain__cacerts, tmp_assattr_name_4);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3112;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_5;
        PyObject *tmp_assattr_target_5;
        if (var_friendlyname == NULL) {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("local variable '%s' referenced before assignment", "friendlyname");
            exception_tb = NULL;

            exception_lineno = 3113;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_assattr_name_5 = var_friendlyname;
        CHECK_OBJECT(var_pkcs12);
        tmp_assattr_target_5 = var_pkcs12;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_5, const_str_plain__friendlyname, tmp_assattr_name_5);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3113;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
    }

#if 1
    RESTORE_FRAME_EXCEPTION(frame_cb2229b3594b0ea74e790a288340fb5b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION(frame_cb2229b3594b0ea74e790a288340fb5b);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_cb2229b3594b0ea74e790a288340fb5b, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_cb2229b3594b0ea74e790a288340fb5b->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_cb2229b3594b0ea74e790a288340fb5b, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_cb2229b3594b0ea74e790a288340fb5b,
        type_description_1,
        par_buffer,
        par_passphrase,
        var_bio,
        var_pykey,
        var_x509,
        var_friendlyname_buffer,
        var_pkey,
        var_i,
        var_cert,
        var_cacerts,
        var_pycert,
        var_friendlyname_length,
        var_p12,
        var_pycacert,
        var_pkcs12,
        var_friendlyname,
        var_pycacerts,
        var_parse_result
    );


    // Release cached frame.
    if (frame_cb2229b3594b0ea74e790a288340fb5b == cache_frame_cb2229b3594b0ea74e790a288340fb5b) {
        Py_DECREF(frame_cb2229b3594b0ea74e790a288340fb5b);
    }
    cache_frame_cb2229b3594b0ea74e790a288340fb5b = NULL;

    assertFrameObject(frame_cb2229b3594b0ea74e790a288340fb5b);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT(var_pkcs12);
    tmp_return_value = var_pkcs12;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_157_load_pkcs12);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_bio);
    Py_DECREF(var_bio);
    var_bio = NULL;

    CHECK_OBJECT((PyObject *)var_pykey);
    Py_DECREF(var_pykey);
    var_pykey = NULL;

    Py_XDECREF(var_x509);
    var_x509 = NULL;

    Py_XDECREF(var_friendlyname_buffer);
    var_friendlyname_buffer = NULL;

    CHECK_OBJECT((PyObject *)var_pkey);
    Py_DECREF(var_pkey);
    var_pkey = NULL;

    CHECK_OBJECT((PyObject *)par_buffer);
    Py_DECREF(par_buffer);
    par_buffer = NULL;

    Py_XDECREF(var_i);
    var_i = NULL;

    CHECK_OBJECT((PyObject *)var_cert);
    Py_DECREF(var_cert);
    var_cert = NULL;

    CHECK_OBJECT((PyObject *)var_cacerts);
    Py_DECREF(var_cacerts);
    var_cacerts = NULL;

    CHECK_OBJECT((PyObject *)var_pycert);
    Py_DECREF(var_pycert);
    var_pycert = NULL;

    Py_XDECREF(var_friendlyname_length);
    var_friendlyname_length = NULL;

    CHECK_OBJECT((PyObject *)var_p12);
    Py_DECREF(var_p12);
    var_p12 = NULL;

    Py_XDECREF(var_pycacert);
    var_pycacert = NULL;

    CHECK_OBJECT((PyObject *)var_pkcs12);
    Py_DECREF(var_pkcs12);
    var_pkcs12 = NULL;

    CHECK_OBJECT((PyObject *)par_passphrase);
    Py_DECREF(par_passphrase);
    par_passphrase = NULL;

    Py_XDECREF(var_friendlyname);
    var_friendlyname = NULL;

    CHECK_OBJECT((PyObject *)var_pycacerts);
    Py_DECREF(var_pycacerts);
    var_pycacerts = NULL;

    CHECK_OBJECT((PyObject *)var_parse_result);
    Py_DECREF(var_parse_result);
    var_parse_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_bio);
    var_bio = NULL;

    Py_XDECREF(var_pykey);
    var_pykey = NULL;

    Py_XDECREF(var_x509);
    var_x509 = NULL;

    Py_XDECREF(var_friendlyname_buffer);
    var_friendlyname_buffer = NULL;

    Py_XDECREF(var_pkey);
    var_pkey = NULL;

    Py_XDECREF(par_buffer);
    par_buffer = NULL;

    Py_XDECREF(var_i);
    var_i = NULL;

    Py_XDECREF(var_cert);
    var_cert = NULL;

    Py_XDECREF(var_cacerts);
    var_cacerts = NULL;

    Py_XDECREF(var_pycert);
    var_pycert = NULL;

    Py_XDECREF(var_friendlyname_length);
    var_friendlyname_length = NULL;

    Py_XDECREF(var_p12);
    var_p12 = NULL;

    Py_XDECREF(var_pycacert);
    var_pycacert = NULL;

    Py_XDECREF(var_pkcs12);
    var_pkcs12 = NULL;

    Py_XDECREF(par_passphrase);
    par_passphrase = NULL;

    Py_XDECREF(var_friendlyname);
    var_friendlyname = NULL;

    Py_XDECREF(var_pycacerts);
    var_pycacerts = NULL;

    Py_XDECREF(var_parse_result);
    var_parse_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$crypto$$$function_157_load_pkcs12);
    return NULL;

function_exception_exit:
    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_100_dump_privatekey(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_100_dump_privatekey,
        const_str_plain_dump_privatekey,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_87202647bd1de477b2de0eb2aa352e4f,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_c71c443223c73b253b21961ef3bd7c9e,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_101___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_101___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_b23a0f51f84827c54de24c1656bcf51f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_102_set_serial() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_102_set_serial,
        const_str_plain_set_serial,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_5654d7a7e7e1d262193996dc0e844779,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_8bcf6e6fbaf96377cbe58ba9960c9d58,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_103_get_serial() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_103_get_serial,
        const_str_plain_get_serial,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_368e52860340c0239edd479ec201e937,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_007f81c06fa49e709fd9306cc6c26627,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_104__delete_reason() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_104__delete_reason,
        const_str_plain__delete_reason,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_5cabe66b4bd10e5fcd686ac603345ff9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_105_set_reason() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_105_set_reason,
        const_str_plain_set_reason,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_69ba33aac22465dc3e11fe94f2672358,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_a12e23c82fcdd4004653da2260294f18,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_106_get_reason() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_106_get_reason,
        const_str_plain_get_reason,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ab078d627a4f8a1ea8d9fa8ec2ab7620,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_435662c26b2c422edb954b82c85c55d9,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_107_all_reasons() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_107_all_reasons,
        const_str_plain_all_reasons,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_fa5b81e573b15ecdf6f1dca4e70b2a76,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_4097a084fab55cf5c5baa1b785e7c82a,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_108_set_rev_date() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_108_set_rev_date,
        const_str_plain_set_rev_date,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_151b1f6515b68f745ad19e8b1fbe6905,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_11e1356f3459cf012eb88d7288e20e85,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_109_get_rev_date() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_109_get_rev_date,
        const_str_plain_get_rev_date,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_2f75f854001e71ff4003dca12987865c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_1ca413f5b66374db6a573ac0926a99ae,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_10___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_10___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_e6be03b19f17c55a33c123c191305d01,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_110___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_110___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_4f7957c52b7d5aeb30baabbb3d3cb7ab,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_111_to_cryptography() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_111_to_cryptography,
        const_str_plain_to_cryptography,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c813942487f91c1997585eb0b387e327,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_2f591e55cc116ed5223c119e2f7da344,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_112_from_cryptography() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_112_from_cryptography,
        const_str_plain_from_cryptography,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_6ac5e01a4091f7c0a9e36a34af31a1a9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_f56881bccbbc40c6643f9603628e7a5c,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_113_get_revoked() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_113_get_revoked,
        const_str_plain_get_revoked,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_e4f22ea9413d3c0f22c2aa13efebb1d8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_0b9d4db9119537682a1f5302a9cbcc57,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_114_add_revoked() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_114_add_revoked,
        const_str_plain_add_revoked,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_68a1e3325fbb1f364eb9342008f9697e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_880f67f2b28115a7ad1d1bfb533fc6bc,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_115_get_issuer() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_115_get_issuer,
        const_str_plain_get_issuer,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_83dbeb702a8014baa25622a5026507ba,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_48639cf22fbd4e6b3714265dae0dbed8,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_116_set_version() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_116_set_version,
        const_str_plain_set_version,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_1ea23726b81bbec2d72c3f055e13f1f3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_0b708bb28192f1a165c843c47343f35a,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_117__set_boundary_time() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_117__set_boundary_time,
        const_str_plain__set_boundary_time,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c7126baf39e9c42b3efde559aa07f143,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_118_set_lastUpdate() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_118_set_lastUpdate,
        const_str_plain_set_lastUpdate,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_6adba4da8c74bf815c0210e671b10c64,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_333948d9e51f0e161201a16305959930,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_119_set_nextUpdate() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_119_set_nextUpdate,
        const_str_plain_set_nextUpdate,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_09ba91e9bcc11b447039b645c382509f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_2c2564e59b067260d7d96d252fc73cd1,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_11_to_cryptography_key() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_11_to_cryptography_key,
        const_str_plain_to_cryptography_key,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_17fae881cac6fcbcb689c6d8ff5eee21,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_26a65c58106d086427e37cb87b0bc3b3,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_120_sign() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_120_sign,
        const_str_plain_sign,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a5dfabf8fb4be3653adb4ee5e3a9d1ee,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_cf86a9123926465ab14a7bd2861326f6,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_121_export(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_121_export,
        const_str_plain_export,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_63d5d54775413644d68413130bf8b01c,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_14af5bef46557b92b5b6c4d670b7a1b8,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_122_type_is_signed() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_122_type_is_signed,
        const_str_plain_type_is_signed,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_3675b56e8a472299e465a6cac7a20233,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_c384f9f99d5890cd2aae342c30dbaa14,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_123_type_is_enveloped() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_123_type_is_enveloped,
        const_str_plain_type_is_enveloped,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_404049e2a875869f38e29055c42cb643,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_40ce736ad6e52bc3df10a00233b89318,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_124_type_is_signedAndEnveloped() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_124_type_is_signedAndEnveloped,
        const_str_plain_type_is_signedAndEnveloped,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_03c4cee92a073dc3714d696db7ba0ad3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_a078d66f5fc281c4117a5e5c24749809,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_125_type_is_data() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_125_type_is_data,
        const_str_plain_type_is_data,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_9bf9cf1b8da4c938f3ae767506473565,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_90de967a5219b9210479f7eac5c285c8,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_126_get_type_name() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_126_get_type_name,
        const_str_plain_get_type_name,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c084b3860bf0d3247773b3ddb209b309,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_782fa7272fdd3d3abdc1a0298e5e83fc,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_127___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_127___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c90140b7a0c346bc70320cca292002db,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_128_get_certificate() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_128_get_certificate,
        const_str_plain_get_certificate,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_b9f83c00bb65fd2c7bce3d5bc80d9004,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_f68048107421fed17c8f1bc19be3ec03,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_129_set_certificate() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_129_set_certificate,
        const_str_plain_set_certificate,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_999486723fe5c8277b4a8914c9586c78,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_62c9c3f244d467c166be64cd38a755a7,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_12_from_cryptography_key() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_12_from_cryptography_key,
        const_str_plain_from_cryptography_key,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_40b3430de5e3101d094061fa2d5cec01,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_ffd290e8bf49a587d94041b1fd6c3c55,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_130_get_privatekey() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_130_get_privatekey,
        const_str_plain_get_privatekey,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_426fef8004659e269aa693019fc0f0fd,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_a9bcf1af78e6d912e13685d8a606fe30,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_131_set_privatekey() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_131_set_privatekey,
        const_str_plain_set_privatekey,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f40f51dde7e8f7585957d7400a166b67,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_5e37d069c5e76ee6d50c7e91b7181934,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_132_get_ca_certificates() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_132_get_ca_certificates,
        const_str_plain_get_ca_certificates,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_cdc04db7a74dd11ea6b2177a19c32798,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_978cd476d4acffdfb043e6a5e0ebae26,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_133_set_ca_certificates() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_133_set_ca_certificates,
        const_str_plain_set_ca_certificates,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_75232e283be8a43fe94949460ca59119,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_9781f115d6516693d922717b11376a73,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_134_set_friendlyname() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_134_set_friendlyname,
        const_str_plain_set_friendlyname,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_60a54c7eb9de93d0fd2fe53bbdafcf10,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_9c28b2ef32679900c21c54152be8ce03,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_135_get_friendlyname() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_135_get_friendlyname,
        const_str_plain_get_friendlyname,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_295f1119c769c014813a47d7534945e3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_4357c956c1f3628f437632877b5d8593,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_136_export(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_136_export,
        const_str_plain_export,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_e7cef9cdd61becb04e1edcd19e659b06,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_44f664275c70041c9ae4bef2565506f3,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_137___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_137___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_3823949e19d48b686be78204ad33eba9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_138_sign() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_138_sign,
        const_str_plain_sign,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_603b25455c6bfd7b211c177899c083b0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_03f3989a7f0f1ec9623bd001f5a005a7,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_139_verify() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_139_verify,
        const_str_plain_verify,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_6580b2147d66eb9876d3eb667c120ce7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_5699814601a04aa972bd2f18de396c39,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_13_generate_key() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_13_generate_key,
        const_str_plain_generate_key,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_b718d7c7e21f2f8cf1e62e44bd27b1df,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_9a71d9e6319c409dff859e67083fc41c,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_140_b64_encode() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_140_b64_encode,
        const_str_plain_b64_encode,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_46e833f2a78ffcfd023683533321764a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_af63c2663b0a5e83daac69d308dcb1d6,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_141_get_pubkey() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_141_get_pubkey,
        const_str_plain_get_pubkey,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_12a92438471858197cd72f0dfaa82ede,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_3b5fd85224219fd172d589ec8f98a12a,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_142_set_pubkey() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_142_set_pubkey,
        const_str_plain_set_pubkey,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_cfb453c9877c1441541c8778d573d561,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_686e4f9f1c51b7038afe792590c33346,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_143___init__(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_143___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_91db092762599116cb72df14f7165542,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_144_callback() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_144_callback,
        const_str_plain_callback,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_3afae2cb1616023deaf9f3e5ada83ddc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_145_callback_args() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_145_callback_args,
        const_str_plain_callback_args,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_dae642fc1d00d46dc97a94e0671a6f94,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_146_raise_if_problem(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_146_raise_if_problem,
        const_str_plain_raise_if_problem,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0d63d1af7f4ff3d26e5354dc78437737,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_147__read_passphrase() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_147__read_passphrase,
        const_str_plain__read_passphrase,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_4beb331670662238f060a150b02707c9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_148_load_publickey() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_148_load_publickey,
        const_str_plain_load_publickey,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_84543461673eee61a7305bb77fc49b09,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_0a3eb1716e7caaaf09c8582b572bcb60,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_149_load_privatekey(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_149_load_privatekey,
        const_str_plain_load_privatekey,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_b7fff7ac811f5c1447b68a592d106780,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_f41f911aba33894e1da796354264d96a,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_14_check() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_14_check,
        const_str_plain_check,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_72e2fe225c7664a56842ff4e880953c2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_8db7448b8246dd51f74c33bda58590bd,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_150_dump_certificate_request() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_150_dump_certificate_request,
        const_str_plain_dump_certificate_request,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_37ee45b6be0afd221cf7a538d742d0bf,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_97388c7ddfea4f913fec5c846dd26ef1,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_151_load_certificate_request() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_151_load_certificate_request,
        const_str_plain_load_certificate_request,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_dd9bf8ebdf933d2516db3e82c61898d8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_1c1759444507dc6d4c0d7b4ce6b62611,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_152_sign() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_152_sign,
        const_str_plain_sign,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_8c86ab161458de9d92d55080e4948b8b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_d6b3262f79e4b59cd83ab54699c92117,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_153_verify() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_153_verify,
        const_str_plain_verify,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_7d7f67b2a9e1de973b6a168bc3652501,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_9acbe023ce14d1d2ba528bd23b2423a0,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_154_dump_crl() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_154_dump_crl,
        const_str_plain_dump_crl,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_937719077c95baa6246e33cb27a31dc5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_721230a42e287d5632d061ff8f0376d6,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_155_load_crl() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_155_load_crl,
        const_str_plain_load_crl,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_6e98a073ab05ca431e08e0cd283b2282,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_05b2bb16e6ee73fd972536e52cc4cabf,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_156_load_pkcs7_data() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_156_load_pkcs7_data,
        const_str_plain_load_pkcs7_data,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_bd97d2185c62e99374c1533c90a95f19,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_1565887baecc678658a50e7d1f245653,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_157_load_pkcs12(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_157_load_pkcs12,
        const_str_plain_load_pkcs12,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_cb2229b3594b0ea74e790a288340fb5b,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_75a631b53fc267af68d162051a06411c,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_15_type() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_15_type,
        const_str_plain_type,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_592334dbe6f644d58958dafe39779ba7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_c237653198d1acecae3452511968b22e,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_16_bits() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_16_bits,
        const_str_plain_bits,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_52082d9f842a277aa94ee6a0252a7f07,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_a658b60d9bffa55a9bdfb85ba96aec98,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_17___ne__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_17___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a3749c6c6ff08577b8d8b833eefc14bb,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_4d14f6e4d6647c6573e3ca9449c2b51f,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_18__load_elliptic_curves() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_18__load_elliptic_curves,
        const_str_plain__load_elliptic_curves,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_96e5ab6839a5b468daf580820eac0fba,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_74b73fd54833bfb6b761307c477c0a28,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_19__get_elliptic_curves() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_19__get_elliptic_curves,
        const_str_plain__get_elliptic_curves,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_273dd0eea5c54fb2d8406e6bc14d5e15,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_7de17ac920010129977e4280610f275c,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_1__get_backend() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_1__get_backend,
        const_str_plain__get_backend,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_305731e8abbf83d9573a0ae65d31c97c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_d03be6fc9f3e6729b366e69e0856a450,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_20_from_nid() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_20_from_nid,
        const_str_plain_from_nid,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_fe948b55a81e35b717d1b9b97c2db26b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_0ba82c04a076f46925a74539c2a8ba40,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_21___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_21___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_67b084766e0c2154c70a16d23028087b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_f76c1a90d81cc9627b0b6df42991dbc9,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_22___repr__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_22___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_9fcd3c1df2ae19417cd7c1bcb969e1f5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_23__to_EC_KEY() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_23__to_EC_KEY,
        const_str_plain__to_EC_KEY,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c83a206dfc0a5b352706e7cad0f33b53,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_c4a5d29f3ecd810d59e3d04a7a935f38,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_24_get_elliptic_curves() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_24_get_elliptic_curves,
        const_str_plain_get_elliptic_curves,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_abddb661c4d0d4ad0339365c339f0316,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_3121be4a855650e38916196ca238bf2b,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_25_get_elliptic_curve() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_25_get_elliptic_curve,
        const_str_plain_get_elliptic_curve,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_e3d47dcc2e5c78370ad068837f5c1643,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_f583009b639aad56f3c96c175e595626,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_26___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_26___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_06e2adf77b5f629c14d7d22dc40bc355,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_12c1bc175ad6309f9cfc24942b8c76ac,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_27___setattr__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_27___setattr__,
        const_str_plain___setattr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_53fed2bee792bc330db8eb5d73e6e5ef,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_28___getattr__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_28___getattr__,
        const_str_plain___getattr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_3731d5a3d74f70f79665c7581fc4f176,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_c7bf9684574689f7d764ff6fbd5eab60,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_29__cmp() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_29__cmp,
        const_str_plain__cmp,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ab2b9954406330adf0a2ccc8c799cd72,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_29__cmp$$$function_1_f() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_29__cmp$$$function_1_f,
        const_str_plain_f,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_22beaaaea5c6ee0a49315be496a852c0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_2__untested_error() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_2__untested_error,
        const_str_plain__untested_error,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_41b835cb0b40d60758bdeb7772fa66f4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_de1d9872d12371b2ead20f3aa79dc834,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_30___repr__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_30___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d193f68fff8cd4832932098a276bfaeb,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_463cb3c7dbe7753c6683d3195629dca3,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_31_hash() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_31_hash,
        const_str_plain_hash,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_9108a7396152423879c9fb4fd180f6ef,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_e4c79524acf8a72de25c6c6491f370a8,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_32_der() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_32_der,
        const_str_plain_der,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_fc7001d155a0450e09ea5b4d5d2bc9f9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_61d70cefdce1472400ab8a06d64ef78a,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_33_get_components() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_33_get_components,
        const_str_plain_get_components,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_8f12fd3ce35b73023a06827bde816a58,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_7e62ce69c000886ecc0ae0b3e8ae9e79,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_34___init__(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_34___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_454ecf415d37cf2ce7deb60c0cb6fa3d,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_152d11f8848fac60442a26592ab3da87,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_35__nid() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_35__nid,
        const_str_plain__nid,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_e5f1885b429cf8c4e78efa560593ce5d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_36__subjectAltNameString() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_36__subjectAltNameString,
        const_str_plain__subjectAltNameString,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_9d20210919ad40c1e8d81a9f37aef9bb,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_37___str__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_37___str__,
        const_str_plain___str__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_bc037b68e8bf53563613e38c02309b68,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_5bd123cbe57a454c8d9d37867b598cb2,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_38_get_critical() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_38_get_critical,
        const_str_plain_get_critical,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_b100013f16a2576dec9318822455e6e9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_5f245d1740d80da82563e21c9c4f4fbf,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_39_get_short_name() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_39_get_short_name,
        const_str_plain_get_short_name,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ba8c4dae468348f7ff9c62739bc12bc4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_213346f5e36f3faf7ff7a566deec4adb,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_3__new_mem_buf(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_3__new_mem_buf,
        const_str_plain__new_mem_buf,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_10246d31c9c113ffc000a4408916df7b,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_1a7a898c4490dd89b305492a40bf2633,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_3__new_mem_buf$$$function_1_free(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_3__new_mem_buf$$$function_1_free,
        const_str_plain_free,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f4d7239bd6f37a2305732ecc4423ba01,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_40_get_data() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_40_get_data,
        const_str_plain_get_data,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c00a9d5fb891facbacf0fc1ab1c7e398,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_719137938e890576c1050ba31a668078,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_41___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_41___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_80f015fcfa447ca62d4c55502f1ecad1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_42_to_cryptography() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_42_to_cryptography,
        const_str_plain_to_cryptography,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_183dcbba32fef389a142755b74a73efe,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_66b2a3b8e35254752e96fbbddc255dfd,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_43_from_cryptography() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_43_from_cryptography,
        const_str_plain_from_cryptography,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d5561b45ad99d14efabf12463381b5d5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_b16563a844474e8eed4710209909ab32,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_44_set_pubkey() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_44_set_pubkey,
        const_str_plain_set_pubkey,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_e7a5b9023d1f01cca25bb4c11d94736c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_ab9563b0fc32f09cfde9a1636d8d2b80,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_45_get_pubkey() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_45_get_pubkey,
        const_str_plain_get_pubkey,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_7ebcd9852a4c17ff014df7666a66c809,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_07697dd6fa4854473fa24b52569d5636,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_46_set_version() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_46_set_version,
        const_str_plain_set_version,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_80d62758301ca388b22f45ed7f965aa4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_b2d5bbfa3f949ddcc231b89e71aa8d92,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_47_get_version() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_47_get_version,
        const_str_plain_get_version,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_638f670f35af3781de5f2f4c9835741e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_ac089bdfaafc466d410fc6ffe7dfee50,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_48_get_subject() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_48_get_subject,
        const_str_plain_get_subject,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ab9238934dc2a850ec08f1603c825e21,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_cac81eaf46e08badbc89f13fa3bbdf6b,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_49_add_extensions() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_49_add_extensions,
        const_str_plain_add_extensions,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_23a2727bfec75a11d2ac8664eefa517a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_52cbe8d655a10e46907a30970ef9889a,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_4__bio_to_string() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_4__bio_to_string,
        const_str_plain__bio_to_string,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_9b1e39652aee4650ee015af31b51eda4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_859c7c43c5cf3124cdd58374d6e7359e,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_50_get_extensions() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_50_get_extensions,
        const_str_plain_get_extensions,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_45711045417d5734fe1ffb353cc7753b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_2e4273bc9cbcc16bcfe5bca70ee1b585,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_51_sign() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_51_sign,
        const_str_plain_sign,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c91f46b1da28091dae5fe2a35b791807,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_cd7d7b6c262cf257f5bafa26f39b567e,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_52_verify() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_52_verify,
        const_str_plain_verify,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a6f140d90bf737cea4d50cfd537ab5e2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_0d3c537bf958e2cc2494cf1be5c283dd,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_53___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_53___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_464dcdbbc2ccc429632456551d5ba288,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_54__from_raw_x509_ptr() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_54__from_raw_x509_ptr,
        const_str_plain__from_raw_x509_ptr,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f994384600d98651e10407a7de0bb709,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_55_to_cryptography() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_55_to_cryptography,
        const_str_plain_to_cryptography,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_97f156a5c2f4577fd55162ed1d43b342,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_f737de4a45174195dc1e46101235dc35,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_56_from_cryptography() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_56_from_cryptography,
        const_str_plain_from_cryptography,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_1427e696c3581db99d7e88aa6e2d20e2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_1f681e9f80c6df652cbc3a085be49171,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_57_set_version() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_57_set_version,
        const_str_plain_set_version,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_3e08719da027c8ef5763e0014ecff43a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_603c60edaf58a8746faa757f20f3f938,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_58_get_version() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_58_get_version,
        const_str_plain_get_version,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_fcdc69651d69daf00844268634ce9361,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_c47cfcedcc7803c0a6ef28b85213e16f,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_59_get_pubkey() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_59_get_pubkey,
        const_str_plain_get_pubkey,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_b2d34b562f393e96bd01c8d2200fd8b0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_11dbf726734533c622c12e725d15648e,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_5__set_asn1_time() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_5__set_asn1_time,
        const_str_plain__set_asn1_time,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_8569be16f63185d6aef0adf92c520ee5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_670c62a34c6767f6ecd5db6f969b2f34,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_60_set_pubkey() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_60_set_pubkey,
        const_str_plain_set_pubkey,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_144ee34ca155af9932b2f45dad52e660,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_a7eaace656db47cf2975484b27c818e9,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_61_sign() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_61_sign,
        const_str_plain_sign,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_4f6e8e494b7d709f425892031ee6c86e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_685b3ded6e482839a3710e6a448d8669,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_62_get_signature_algorithm() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_62_get_signature_algorithm,
        const_str_plain_get_signature_algorithm,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_cdc94e00f8d570018ee7361d163914a9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_79b48b443a4edf88bd64a278e98529d3,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_63_digest() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_63_digest,
        const_str_plain_digest,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_4f7104a5c773de3617ea99428a718a9f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_5cb0319d0378026eb0ef49838e525520,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_64_subject_name_hash() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_64_subject_name_hash,
        const_str_plain_subject_name_hash,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_bff0f237096588ea8e24a7bf1bb681f0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_e69f89000e2dc720ec6a70b8f9cb0cac,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_65_set_serial_number() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_65_set_serial_number,
        const_str_plain_set_serial_number,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f86a27bee71853ffe2494335d054f9c2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_6b664ec0d0974a050be8b09b84bd0a5d,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_66_get_serial_number() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_66_get_serial_number,
        const_str_plain_get_serial_number,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_62f5aa8a8fda43f2d7f41809819c949c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_7d6056c968d1eebfab898757e6f3054e,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_67_gmtime_adj_notAfter() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_67_gmtime_adj_notAfter,
        const_str_plain_gmtime_adj_notAfter,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_4de131a75c684fec0469c48115745d08,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_a643e6a1050d6f3782a0d190235d80a7,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_68_gmtime_adj_notBefore() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_68_gmtime_adj_notBefore,
        const_str_plain_gmtime_adj_notBefore,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_50ee192f9d0e8e84633297c994f58a6a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_0807c1b9c5bc0ac3cc25375c4a9ebb2e,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_69_has_expired() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_69_has_expired,
        const_str_plain_has_expired,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_fbdfdccccf232276b858abd51cb882bb,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_8ad6e418a1b04e7939cf7e738b8257d2,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_6__get_asn1_time() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_6__get_asn1_time,
        const_str_plain__get_asn1_time,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_246be403ac420ea7d6be029dab25a09c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_c0aedec8dc85440d3dace529a9d9050e,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_70__get_boundary_time() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_70__get_boundary_time,
        const_str_plain__get_boundary_time,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_901f14040af7aac06f554767a4550324,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_71_get_notBefore() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_71_get_notBefore,
        const_str_plain_get_notBefore,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_38e0d057067d90e2fbb10ff012ac6d82,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_60cf4d81fa4ac0fb8a6d16cafc145b24,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_72__set_boundary_time() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_72__set_boundary_time,
        const_str_plain__set_boundary_time,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_cb358a0ddff832515567a748ef6af7f5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_73_set_notBefore() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_73_set_notBefore,
        const_str_plain_set_notBefore,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f85802ded5ad9e24c28efb6d7f3ae0de,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_f35548e1d45f67292233a83f1d0adcce,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_74_get_notAfter() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_74_get_notAfter,
        const_str_plain_get_notAfter,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a7d4834ead0a1a60fe3119338536d0f3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_35e2a27cee76091329550405e1cb7dc4,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_75_set_notAfter() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_75_set_notAfter,
        const_str_plain_set_notAfter,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_7d3a859e1d891c970bd1bda57166fb91,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_e335a7c8a0dd4d8ab6096b1597d79143,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_76__get_name() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_76__get_name,
        const_str_plain__get_name,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_80105bd3cbfef104f47288369fe3a34c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_77__set_name() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_77__set_name,
        const_str_plain__set_name,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a985957de3abbe239f1f1229dc888507,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_78_get_issuer() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_78_get_issuer,
        const_str_plain_get_issuer,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c92bad46c4a7152b022309b9441ca8ed,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_40e46351c3b918f338d6e675fea0b1ca,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_79_set_issuer() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_79_set_issuer,
        const_str_plain_set_issuer,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_7b28dcc872c0fc1e599bc7f4fd0593c7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_92b8d1a7fa93b4e7d2fab02e37bc15f8,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_7___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_7___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_62546cfe1d011d24bbde27bbb93b6ea0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_80_get_subject() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_80_get_subject,
        const_str_plain_get_subject,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0167861cea57ebc738ecf400cc04ebfa,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_2f350f536232587387680a9435c758f6,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_81_set_subject() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_81_set_subject,
        const_str_plain_set_subject,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_555e64665b36c5489cfa1aab914f4b68,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_e2d5c2f473553b6759cc455da987e04a,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_82_get_extension_count() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_82_get_extension_count,
        const_str_plain_get_extension_count,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a3d6ff1e9626c3f8ac77d23bb924b11c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_3f7d687efa133ae490fe62a28c3c2584,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_83_add_extensions() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_83_add_extensions,
        const_str_plain_add_extensions,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_1e39bc936ea94807eaf0b02a24efd7e5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_141cd36b231fb1bf7caa692f86984b7e,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_84_get_extension() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_84_get_extension,
        const_str_plain_get_extension,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_2f6eda6ffd4b44390873f4f24070482e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_d0137950921f709b6c00a3276a078e5f,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_85___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_85___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d7eda580e48a4e0112100f560fb2f9fd,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_86_add_cert() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_86_add_cert,
        const_str_plain_add_cert,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_457f951bde44f2371cea4fa29a1876af,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_866d2e2176ccb47ef7515cbc6c993151,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_87_add_crl() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_87_add_crl,
        const_str_plain_add_crl,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_98c960373d8e9f9023212df2b317530b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_998fe297d663eb0475d60a56d2b84182,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_88_set_flags() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_88_set_flags,
        const_str_plain_set_flags,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_60b024772fde8ae0bc098cb534c29ad5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_1d1fec7c0642196df296efbe43db1801,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_89_set_time() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_89_set_time,
        const_str_plain_set_time,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_5206be546a6fa8e25a02dc839db5f52a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_1d608c98cc8048d3f7b439059ee29b66,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_8_add() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_8_add,
        const_str_plain_add,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_913c87f9ab8d54a08d5eac957c322eee,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_90___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_90___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_8f2729c6c39bb67f3ed78460f5e5408b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_91___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_91___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_3f33b64820845ae325979d13781edcfd,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_92__init() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_92__init,
        const_str_plain__init,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_00371fda50c01bb4d85c5c5a04406452,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_32726a73c20427f70712d109be7712b4,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_93__cleanup() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_93__cleanup,
        const_str_plain__cleanup,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_66c965dc3bd160a9871b648a43656817,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_61dbd227935e54cb40eecc7de8b8596b,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_94__exception_from_context() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_94__exception_from_context,
        const_str_plain__exception_from_context,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_3891a493a4dd850f62e56c17ddb5ee47,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_8fda740163dc7d07c78736dc2ebb17b1,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_95_set_store() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_95_set_store,
        const_str_plain_set_store,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_5ed9e5e6e97c4656f6c19f9fb33742ec,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_d85051204198165c5d51e35c1e5d5077,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_96_verify_certificate() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_96_verify_certificate,
        const_str_plain_verify_certificate,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_cf70a0fe535b0c265515473726b4c514,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_a2b9bb33a11d02b696dfc736bf45c56d,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_97_load_certificate() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_97_load_certificate,
        const_str_plain_load_certificate,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_3ba03b4a83863db0211776596d7369dc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_f979ae5e9b0a9a41a05276169a44e7e9,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_98_dump_certificate() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_98_dump_certificate,
        const_str_plain_dump_certificate,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_549d02a6f8fe9c9053e01fafd28ef642,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_193e0ef9a8bffd6c41bf909f2da817bd,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_99_dump_publickey() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_99_dump_publickey,
        const_str_plain_dump_publickey,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ac78feb39cb3a4f1fcd5ca3fb25b3cc6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_0d8911e895179dcd467b4e9de2f411d4,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_9_clear() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_9_clear,
        const_str_plain_clear,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_826e459e0dc58f5a99e0a127a3e82d23,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



#if PYTHON_VERSION >= 300
static struct PyModuleDef mdef_OpenSSL$crypto =
{
    PyModuleDef_HEAD_INIT,
    NULL,                /* m_name, filled later */
    NULL,                /* m_doc */
    -1,                  /* m_size */
    NULL,                /* m_methods */
    NULL,                /* m_reload */
    NULL,                /* m_traverse */
    NULL,                /* m_clear */
    NULL,                /* m_free */
  };
#endif

extern PyObject *const_str_plain___compiled__;

extern PyObject *const_str_plain___package__;
extern PyObject *const_str_empty;

#if PYTHON_VERSION >= 300
extern PyObject *const_str_dot;
extern PyObject *const_str_plain___loader__;
#endif

#if PYTHON_VERSION >= 340
extern PyObject *const_str_plain___spec__;
extern PyObject *const_str_plain__initializing;
extern PyObject *const_str_plain_submodule_search_locations;
#endif

extern void _initCompiledCellType();
extern void _initCompiledGeneratorType();
extern void _initCompiledFunctionType();
extern void _initCompiledMethodType();
extern void _initCompiledFrameType();
#if PYTHON_VERSION >= 350
extern void _initCompiledCoroutineTypes();
#endif
#if PYTHON_VERSION >= 360
extern void _initCompiledAsyncgenTypes();
#endif

extern PyTypeObject Nuitka_Loader_Type;

#ifdef _NUITKA_PLUGIN_DILL_ENABLED
// Provide a way to create find a function via its C code and create it back
// in another process, useful for multiprocessing extensions like dill

function_impl_code functable_OpenSSL$crypto[] = {
    impl_OpenSSL$crypto$$$function_3__new_mem_buf$$$function_1_free,
    impl_OpenSSL$crypto$$$function_29__cmp$$$function_1_f,
    impl_OpenSSL$crypto$$$function_1__get_backend,
    impl_OpenSSL$crypto$$$function_2__untested_error,
    impl_OpenSSL$crypto$$$function_3__new_mem_buf,
    impl_OpenSSL$crypto$$$function_4__bio_to_string,
    impl_OpenSSL$crypto$$$function_5__set_asn1_time,
    impl_OpenSSL$crypto$$$function_6__get_asn1_time,
    impl_OpenSSL$crypto$$$function_7___init__,
    impl_OpenSSL$crypto$$$function_8_add,
    impl_OpenSSL$crypto$$$function_9_clear,
    impl_OpenSSL$crypto$$$function_10___init__,
    impl_OpenSSL$crypto$$$function_11_to_cryptography_key,
    impl_OpenSSL$crypto$$$function_12_from_cryptography_key,
    impl_OpenSSL$crypto$$$function_13_generate_key,
    impl_OpenSSL$crypto$$$function_14_check,
    impl_OpenSSL$crypto$$$function_15_type,
    impl_OpenSSL$crypto$$$function_16_bits,
    impl_OpenSSL$crypto$$$function_17___ne__,
    impl_OpenSSL$crypto$$$function_18__load_elliptic_curves,
    impl_OpenSSL$crypto$$$function_19__get_elliptic_curves,
    impl_OpenSSL$crypto$$$function_20_from_nid,
    impl_OpenSSL$crypto$$$function_21___init__,
    impl_OpenSSL$crypto$$$function_22___repr__,
    impl_OpenSSL$crypto$$$function_23__to_EC_KEY,
    impl_OpenSSL$crypto$$$function_24_get_elliptic_curves,
    impl_OpenSSL$crypto$$$function_25_get_elliptic_curve,
    impl_OpenSSL$crypto$$$function_26___init__,
    impl_OpenSSL$crypto$$$function_27___setattr__,
    impl_OpenSSL$crypto$$$function_28___getattr__,
    impl_OpenSSL$crypto$$$function_29__cmp,
    impl_OpenSSL$crypto$$$function_30___repr__,
    impl_OpenSSL$crypto$$$function_31_hash,
    impl_OpenSSL$crypto$$$function_32_der,
    impl_OpenSSL$crypto$$$function_33_get_components,
    impl_OpenSSL$crypto$$$function_34___init__,
    impl_OpenSSL$crypto$$$function_35__nid,
    impl_OpenSSL$crypto$$$function_36__subjectAltNameString,
    impl_OpenSSL$crypto$$$function_37___str__,
    impl_OpenSSL$crypto$$$function_38_get_critical,
    impl_OpenSSL$crypto$$$function_39_get_short_name,
    impl_OpenSSL$crypto$$$function_40_get_data,
    impl_OpenSSL$crypto$$$function_41___init__,
    impl_OpenSSL$crypto$$$function_42_to_cryptography,
    impl_OpenSSL$crypto$$$function_43_from_cryptography,
    impl_OpenSSL$crypto$$$function_44_set_pubkey,
    impl_OpenSSL$crypto$$$function_45_get_pubkey,
    impl_OpenSSL$crypto$$$function_46_set_version,
    impl_OpenSSL$crypto$$$function_47_get_version,
    impl_OpenSSL$crypto$$$function_48_get_subject,
    impl_OpenSSL$crypto$$$function_49_add_extensions,
    impl_OpenSSL$crypto$$$function_50_get_extensions,
    impl_OpenSSL$crypto$$$function_51_sign,
    impl_OpenSSL$crypto$$$function_52_verify,
    impl_OpenSSL$crypto$$$function_53___init__,
    impl_OpenSSL$crypto$$$function_54__from_raw_x509_ptr,
    impl_OpenSSL$crypto$$$function_55_to_cryptography,
    impl_OpenSSL$crypto$$$function_56_from_cryptography,
    impl_OpenSSL$crypto$$$function_57_set_version,
    impl_OpenSSL$crypto$$$function_58_get_version,
    impl_OpenSSL$crypto$$$function_59_get_pubkey,
    impl_OpenSSL$crypto$$$function_60_set_pubkey,
    impl_OpenSSL$crypto$$$function_61_sign,
    impl_OpenSSL$crypto$$$function_62_get_signature_algorithm,
    impl_OpenSSL$crypto$$$function_63_digest,
    impl_OpenSSL$crypto$$$function_64_subject_name_hash,
    impl_OpenSSL$crypto$$$function_65_set_serial_number,
    impl_OpenSSL$crypto$$$function_66_get_serial_number,
    impl_OpenSSL$crypto$$$function_67_gmtime_adj_notAfter,
    impl_OpenSSL$crypto$$$function_68_gmtime_adj_notBefore,
    impl_OpenSSL$crypto$$$function_69_has_expired,
    impl_OpenSSL$crypto$$$function_70__get_boundary_time,
    impl_OpenSSL$crypto$$$function_71_get_notBefore,
    impl_OpenSSL$crypto$$$function_72__set_boundary_time,
    impl_OpenSSL$crypto$$$function_73_set_notBefore,
    impl_OpenSSL$crypto$$$function_74_get_notAfter,
    impl_OpenSSL$crypto$$$function_75_set_notAfter,
    impl_OpenSSL$crypto$$$function_76__get_name,
    impl_OpenSSL$crypto$$$function_77__set_name,
    impl_OpenSSL$crypto$$$function_78_get_issuer,
    impl_OpenSSL$crypto$$$function_79_set_issuer,
    impl_OpenSSL$crypto$$$function_80_get_subject,
    impl_OpenSSL$crypto$$$function_81_set_subject,
    impl_OpenSSL$crypto$$$function_82_get_extension_count,
    impl_OpenSSL$crypto$$$function_83_add_extensions,
    impl_OpenSSL$crypto$$$function_84_get_extension,
    impl_OpenSSL$crypto$$$function_85___init__,
    impl_OpenSSL$crypto$$$function_86_add_cert,
    impl_OpenSSL$crypto$$$function_87_add_crl,
    impl_OpenSSL$crypto$$$function_88_set_flags,
    impl_OpenSSL$crypto$$$function_89_set_time,
    impl_OpenSSL$crypto$$$function_90___init__,
    impl_OpenSSL$crypto$$$function_91___init__,
    impl_OpenSSL$crypto$$$function_92__init,
    impl_OpenSSL$crypto$$$function_93__cleanup,
    impl_OpenSSL$crypto$$$function_94__exception_from_context,
    impl_OpenSSL$crypto$$$function_95_set_store,
    impl_OpenSSL$crypto$$$function_96_verify_certificate,
    impl_OpenSSL$crypto$$$function_97_load_certificate,
    impl_OpenSSL$crypto$$$function_98_dump_certificate,
    impl_OpenSSL$crypto$$$function_99_dump_publickey,
    impl_OpenSSL$crypto$$$function_100_dump_privatekey,
    impl_OpenSSL$crypto$$$function_101___init__,
    impl_OpenSSL$crypto$$$function_102_set_serial,
    impl_OpenSSL$crypto$$$function_103_get_serial,
    impl_OpenSSL$crypto$$$function_104__delete_reason,
    impl_OpenSSL$crypto$$$function_105_set_reason,
    impl_OpenSSL$crypto$$$function_106_get_reason,
    impl_OpenSSL$crypto$$$function_107_all_reasons,
    impl_OpenSSL$crypto$$$function_108_set_rev_date,
    impl_OpenSSL$crypto$$$function_109_get_rev_date,
    impl_OpenSSL$crypto$$$function_110___init__,
    impl_OpenSSL$crypto$$$function_111_to_cryptography,
    impl_OpenSSL$crypto$$$function_112_from_cryptography,
    impl_OpenSSL$crypto$$$function_113_get_revoked,
    impl_OpenSSL$crypto$$$function_114_add_revoked,
    impl_OpenSSL$crypto$$$function_115_get_issuer,
    impl_OpenSSL$crypto$$$function_116_set_version,
    impl_OpenSSL$crypto$$$function_117__set_boundary_time,
    impl_OpenSSL$crypto$$$function_118_set_lastUpdate,
    impl_OpenSSL$crypto$$$function_119_set_nextUpdate,
    impl_OpenSSL$crypto$$$function_120_sign,
    impl_OpenSSL$crypto$$$function_121_export,
    impl_OpenSSL$crypto$$$function_122_type_is_signed,
    impl_OpenSSL$crypto$$$function_123_type_is_enveloped,
    impl_OpenSSL$crypto$$$function_124_type_is_signedAndEnveloped,
    impl_OpenSSL$crypto$$$function_125_type_is_data,
    impl_OpenSSL$crypto$$$function_126_get_type_name,
    impl_OpenSSL$crypto$$$function_127___init__,
    impl_OpenSSL$crypto$$$function_128_get_certificate,
    impl_OpenSSL$crypto$$$function_129_set_certificate,
    impl_OpenSSL$crypto$$$function_130_get_privatekey,
    impl_OpenSSL$crypto$$$function_131_set_privatekey,
    impl_OpenSSL$crypto$$$function_132_get_ca_certificates,
    impl_OpenSSL$crypto$$$function_133_set_ca_certificates,
    impl_OpenSSL$crypto$$$function_134_set_friendlyname,
    impl_OpenSSL$crypto$$$function_135_get_friendlyname,
    impl_OpenSSL$crypto$$$function_136_export,
    impl_OpenSSL$crypto$$$function_137___init__,
    impl_OpenSSL$crypto$$$function_138_sign,
    impl_OpenSSL$crypto$$$function_139_verify,
    impl_OpenSSL$crypto$$$function_140_b64_encode,
    impl_OpenSSL$crypto$$$function_141_get_pubkey,
    impl_OpenSSL$crypto$$$function_142_set_pubkey,
    impl_OpenSSL$crypto$$$function_143___init__,
    impl_OpenSSL$crypto$$$function_144_callback,
    impl_OpenSSL$crypto$$$function_145_callback_args,
    impl_OpenSSL$crypto$$$function_146_raise_if_problem,
    impl_OpenSSL$crypto$$$function_147__read_passphrase,
    impl_OpenSSL$crypto$$$function_148_load_publickey,
    impl_OpenSSL$crypto$$$function_149_load_privatekey,
    impl_OpenSSL$crypto$$$function_150_dump_certificate_request,
    impl_OpenSSL$crypto$$$function_151_load_certificate_request,
    impl_OpenSSL$crypto$$$function_152_sign,
    impl_OpenSSL$crypto$$$function_153_verify,
    impl_OpenSSL$crypto$$$function_154_dump_crl,
    impl_OpenSSL$crypto$$$function_155_load_crl,
    impl_OpenSSL$crypto$$$function_156_load_pkcs7_data,
    impl_OpenSSL$crypto$$$function_157_load_pkcs12,
    NULL
};

static char const *_reduce_compiled_function_argnames[] = {
    "func",
    NULL
};

static PyObject *_reduce_compiled_function(PyObject *self, PyObject *args, PyObject *kwds) {
    PyObject *func;

    if (!PyArg_ParseTupleAndKeywords(args, kwds, "O:reduce_compiled_function", (char **)_reduce_compiled_function_argnames, &func, NULL)) {
        return NULL;
    }

    if (Nuitka_Function_Check(func) == false) {
        PyErr_Format(PyExc_TypeError, "not a compiled function");
        return NULL;
    }

    struct Nuitka_FunctionObject *function = (struct Nuitka_FunctionObject *)func;

    function_impl_code *current = functable_OpenSSL$crypto;
    int offset = 0;

    while (*current != NULL) {
        if (*current == function->m_c_code) {
            break;
        }

        current += 1;
        offset += 1;
    }

    if (*current == NULL) {
        PyErr_Format(PyExc_TypeError, "Cannot find compiled function in module.");
        return NULL;
    }

    PyObject *code_object_desc = PyTuple_New(6);
    PyTuple_SET_ITEM0(code_object_desc, 0, function->m_code_object->co_filename);
    PyTuple_SET_ITEM0(code_object_desc, 1, function->m_code_object->co_name);
    PyTuple_SET_ITEM(code_object_desc, 2, PyLong_FromLong(function->m_code_object->co_firstlineno));
    PyTuple_SET_ITEM0(code_object_desc, 3, function->m_code_object->co_varnames);
    PyTuple_SET_ITEM(code_object_desc, 4, PyLong_FromLong(function->m_code_object->co_argcount));
    PyTuple_SET_ITEM(code_object_desc, 5, PyLong_FromLong(function->m_code_object->co_flags));

    CHECK_OBJECT_DEEP(code_object_desc);

    PyObject *result = PyTuple_New(4);
    PyTuple_SET_ITEM(result, 0, PyLong_FromLong(offset));
    PyTuple_SET_ITEM(result, 1, code_object_desc);
    PyTuple_SET_ITEM0(result, 2, function->m_defaults);
    PyTuple_SET_ITEM0(result, 3, function->m_doc != NULL ? function->m_doc : Py_None);

    CHECK_OBJECT_DEEP(result);

    return result;
}

static PyMethodDef _method_def_reduce_compiled_function = {"reduce_compiled_function", (PyCFunction)_reduce_compiled_function,
                                                           METH_VARARGS | METH_KEYWORDS, NULL};

static char const *_create_compiled_function_argnames[] = {
    "func",
    "code_object_desc",
    "defaults",
    "doc",
    NULL
};


static PyObject *_create_compiled_function(PyObject *self, PyObject *args, PyObject *kwds) {
    CHECK_OBJECT_DEEP(args);

    PyObject *func;
    PyObject *code_object_desc;
    PyObject *defaults;
    PyObject *doc;

    if (!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:create_compiled_function", (char **)_create_compiled_function_argnames, &func, &code_object_desc, &defaults, &doc, NULL)) {
        return NULL;
    }

    int offset = PyLong_AsLong(func);

    if (offset == -1 && ERROR_OCCURRED()) {
        return NULL;
    }

    if (offset > sizeof(functable_OpenSSL$crypto) || offset < 0) {
        PyErr_Format(PyExc_TypeError, "Wrong offset for compiled function.");
        return NULL;
    }

    PyObject *filename = PyTuple_GET_ITEM(code_object_desc, 0);
    PyObject *function_name = PyTuple_GET_ITEM(code_object_desc, 1);
    PyObject *line = PyTuple_GET_ITEM(code_object_desc, 2);
    int line_int = PyLong_AsLong(line);
    assert(!ERROR_OCCURRED());

    PyObject *argnames = PyTuple_GET_ITEM(code_object_desc, 3);
    PyObject *arg_count = PyTuple_GET_ITEM(code_object_desc, 4);
    int arg_count_int = PyLong_AsLong(arg_count);
    assert(!ERROR_OCCURRED());
    PyObject *flags = PyTuple_GET_ITEM(code_object_desc, 5);
    int flags_int = PyLong_AsLong(flags);
    assert(!ERROR_OCCURRED());

    PyCodeObject *code_object = MAKE_CODEOBJECT(
        filename,
        line_int,
        flags_int,
        function_name,
        argnames,
        arg_count_int,
        0, // TODO: Missing kw_only_count
        0 // TODO: Missing pos_only_count
    );

    // TODO: More stuff needed for Python3, best to re-order arguments of MAKE_CODEOBJECT.
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        functable_OpenSSL$crypto[offset],
        code_object->co_name,
#if PYTHON_VERSION >= 300
        NULL, // TODO: Not transferring qualname yet
#endif
        code_object,
        defaults,
#if PYTHON_VERSION >= 300
        NULL, // kwdefaults are done on the outside currently
        NULL, // TODO: Not transferring annotations
#endif
        module_OpenSSL$crypto,
        doc,
        0
    );

    return (PyObject *)result;
}

static PyMethodDef _method_def_create_compiled_function = {
    "create_compiled_function",
    (PyCFunction)_create_compiled_function,
    METH_VARARGS | METH_KEYWORDS, NULL
};


#endif

// Internal entry point for module code.
PyObject *modulecode_OpenSSL$crypto(char const *module_full_name) {
#if defined(_NUITKA_EXE) || PYTHON_VERSION >= 300
    static bool _init_done = false;

    // Modules might be imported repeatedly, which is to be ignored.
    if (_init_done) {
        return module_OpenSSL$crypto;
    } else {
        _init_done = true;
    }
#endif

#ifdef _NUITKA_MODULE
    // In case of a stand alone extension module, need to call initialization
    // the init here because that's the first and only time we are going to get
    // called here.

    // May have to activate constants blob.
#if defined(_NUITKA_CONSTANTS_FROM_RESOURCE)
    loadConstantsResource();
#endif

    // Initialize the constant values used.
    _initBuiltinModule();
    createGlobalConstants();

    /* Initialize the compiled types of Nuitka. */
    _initCompiledCellType();
    _initCompiledGeneratorType();
    _initCompiledFunctionType();
    _initCompiledMethodType();
    _initCompiledFrameType();
#if PYTHON_VERSION >= 350
    _initCompiledCoroutineTypes();
#endif
#if PYTHON_VERSION >= 360
    _initCompiledAsyncgenTypes();
#endif

#if PYTHON_VERSION < 300
    _initSlotCompare();
#endif
#if PYTHON_VERSION >= 270
    _initSlotIternext();
#endif

    patchBuiltinModule();
    patchTypeComparison();

    // Enable meta path based loader if not already done.
#ifdef _NUITKA_TRACE
    PRINT_STRING("OpenSSL.crypto: Calling setupMetaPathBasedLoader().\n");
#endif
    setupMetaPathBasedLoader();

#if PYTHON_VERSION >= 300
    patchInspectModule();
#endif

#endif

    /* The constants only used by this module are created now. */
#ifdef _NUITKA_TRACE
    PRINT_STRING("OpenSSL.crypto: Calling createModuleConstants().\n");
#endif
    createModuleConstants();

    /* The code objects used by this module are created now. */
#ifdef _NUITKA_TRACE
    PRINT_STRING("OpenSSL.crypto: Calling createModuleCodeObjects().\n");
#endif
    createModuleCodeObjects();

    // PRINT_STRING("in initOpenSSL$crypto\n");

    // Create the module object first. There are no methods initially, all are
    // added dynamically in actual code only.  Also no "__doc__" is initially
    // set at this time, as it could not contain NUL characters this way, they
    // are instead set in early module code.  No "self" for modules, we have no
    // use for it.
#if PYTHON_VERSION < 300
    module_OpenSSL$crypto = Py_InitModule4(
        module_full_name,        // Module Name
        NULL,                    // No methods initially, all are added
                                 // dynamically in actual module code only.
        NULL,                    // No "__doc__" is initially set, as it could
                                 // not contain NUL this way, added early in
                                 // actual code.
        NULL,                    // No self for modules, we don't use it.
        PYTHON_API_VERSION
    );
#else
    mdef_OpenSSL$crypto.m_name = module_full_name;
    module_OpenSSL$crypto = PyModule_Create(&mdef_OpenSSL$crypto);
#endif

    moduledict_OpenSSL$crypto = MODULE_DICT(module_OpenSSL$crypto);

#ifdef _NUITKA_PLUGIN_DILL_ENABLED
    {
        PyObject *function_tables = PyObject_GetAttrString((PyObject *)builtin_module, "compiled_function_tables");
        if (function_tables == NULL)
        {
            DROP_ERROR_OCCURRED();
            function_tables = PyDict_New();
        }
        PyObject_SetAttrString((PyObject *)builtin_module, "compiled_function_tables", function_tables);
        PyObject *funcs = PyTuple_New(2);
        PyTuple_SetItem(funcs, 0, PyCFunction_New(&_method_def_reduce_compiled_function, NULL));
        PyTuple_SetItem(funcs, 1, PyCFunction_New(&_method_def_create_compiled_function, NULL));
        PyDict_SetItemString(function_tables, module_full_name, funcs);
    }
#endif

    // Set "__compiled__" to what version information we have.
    UPDATE_STRING_DICT0(
        moduledict_OpenSSL$crypto,
        (Nuitka_StringObject *)const_str_plain___compiled__,
        Nuitka_dunder_compiled_value
    );

    // Update "__package__" value to what it ought to be.
    {
#if 0
        UPDATE_STRING_DICT0(
            moduledict_OpenSSL$crypto,
            (Nuitka_StringObject *)const_str_plain___package__,
            const_str_empty
        );
#elif 0
        PyObject *module_name = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___name__);

        UPDATE_STRING_DICT0(
            moduledict_OpenSSL$crypto,
            (Nuitka_StringObject *)const_str_plain___package__,
            module_name
        );
#else

#if PYTHON_VERSION < 300
        PyObject *module_name = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___name__);
        char const *module_name_cstr = PyString_AS_STRING(module_name);

        char const *last_dot = strrchr(module_name_cstr, '.');

        if (last_dot != NULL)
        {
            UPDATE_STRING_DICT1(
                moduledict_OpenSSL$crypto,
                (Nuitka_StringObject *)const_str_plain___package__,
                PyString_FromStringAndSize(module_name_cstr, last_dot - module_name_cstr)
            );
        }
#else
        PyObject *module_name = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___name__);
        Py_ssize_t dot_index = PyUnicode_Find(module_name, const_str_dot, 0, PyUnicode_GetLength(module_name), -1);

        if (dot_index != -1)
        {
            UPDATE_STRING_DICT1(
                moduledict_OpenSSL$crypto,
                (Nuitka_StringObject *)const_str_plain___package__,
                PyUnicode_Substring(module_name, 0, dot_index)
            );
        }
#endif
#endif
    }

    CHECK_OBJECT(module_OpenSSL$crypto);

// Seems to work for Python2.7 out of the box, but for Python3, the module
// doesn't automatically enter "sys.modules", so do it manually.
#if PYTHON_VERSION >= 300
    {
        int r = PyDict_SetItemString(PyImport_GetModuleDict(), module_full_name, module_OpenSSL$crypto);
        assert(r != -1);
    }
#endif

    // For deep importing of a module we need to have "__builtins__", so we set
    // it ourselves in the same way than CPython does. Note: This must be done
    // before the frame object is allocated, or else it may fail.

    if (GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___builtins__) == NULL)
    {
        PyObject *value = (PyObject *)builtin_module;

        // Check if main module, not a dict then but the module itself.
#if !defined(_NUITKA_EXE) || !0
        value = PyModule_GetDict(value);
#endif

        UPDATE_STRING_DICT0(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___builtins__, value);
    }

#if PYTHON_VERSION >= 300
    UPDATE_STRING_DICT0(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___loader__, (PyObject *)&Nuitka_Loader_Type);
#endif

#if PYTHON_VERSION >= 340
// Set the "__spec__" value

#if 0
    // Main modules just get "None" as spec.
    UPDATE_STRING_DICT0(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___spec__, Py_None);
#else
    // Other modules get a "ModuleSpec" from the standard mechanism.
    {
        PyObject *bootstrap_module = PyImport_ImportModule("importlib._bootstrap");
        CHECK_OBJECT(bootstrap_module);
        PyObject *module_spec_class = PyObject_GetAttrString(bootstrap_module, "ModuleSpec");
        Py_DECREF(bootstrap_module);

        PyObject *args[] = {
            GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___name__),
            (PyObject *)&Nuitka_Loader_Type
        };

        PyObject *spec_value = CALL_FUNCTION_WITH_ARGS2(
            module_spec_class,
            args
        );
        Py_DECREF(module_spec_class);

        // We can assume this to never fail, or else we are in trouble anyway.
        CHECK_OBJECT(spec_value);

// For packages set the submodule search locations as well, even if to empty
// list, so investigating code will consider it a package.
#if 0
        SET_ATTRIBUTE(spec_value, const_str_plain_submodule_search_locations, PyList_New(0));
#endif

// Mark the execution in the "__spec__" value.
        SET_ATTRIBUTE(spec_value, const_str_plain__initializing, Py_True);

        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___spec__, spec_value);
    }
#endif
#endif

    // Temp variables if any
    PyObject *tmp_class_creation_10__class = NULL;
    PyObject *tmp_class_creation_10__class_dict = NULL;
    PyObject *tmp_class_creation_10__metaclass = NULL;
    PyObject *tmp_class_creation_11__class = NULL;
    PyObject *tmp_class_creation_11__class_dict = NULL;
    PyObject *tmp_class_creation_11__metaclass = NULL;
    PyObject *tmp_class_creation_12__class = NULL;
    PyObject *tmp_class_creation_12__class_dict = NULL;
    PyObject *tmp_class_creation_12__metaclass = NULL;
    PyObject *tmp_class_creation_13__class = NULL;
    PyObject *tmp_class_creation_13__class_dict = NULL;
    PyObject *tmp_class_creation_13__metaclass = NULL;
    PyObject *tmp_class_creation_14__class = NULL;
    PyObject *tmp_class_creation_14__class_dict = NULL;
    PyObject *tmp_class_creation_14__metaclass = NULL;
    PyObject *tmp_class_creation_15__class = NULL;
    PyObject *tmp_class_creation_15__class_dict = NULL;
    PyObject *tmp_class_creation_15__metaclass = NULL;
    PyObject *tmp_class_creation_16__class = NULL;
    PyObject *tmp_class_creation_16__class_dict = NULL;
    PyObject *tmp_class_creation_16__metaclass = NULL;
    PyObject *tmp_class_creation_17__class = NULL;
    PyObject *tmp_class_creation_17__class_dict = NULL;
    PyObject *tmp_class_creation_17__metaclass = NULL;
    PyObject *tmp_class_creation_18__class = NULL;
    PyObject *tmp_class_creation_18__class_dict = NULL;
    PyObject *tmp_class_creation_18__metaclass = NULL;
    PyObject *tmp_class_creation_1__class = NULL;
    PyObject *tmp_class_creation_1__class_dict = NULL;
    PyObject *tmp_class_creation_1__metaclass = NULL;
    PyObject *tmp_class_creation_2__class = NULL;
    PyObject *tmp_class_creation_2__class_dict = NULL;
    PyObject *tmp_class_creation_2__metaclass = NULL;
    PyObject *tmp_class_creation_3__class = NULL;
    PyObject *tmp_class_creation_3__class_dict = NULL;
    PyObject *tmp_class_creation_3__metaclass = NULL;
    PyObject *tmp_class_creation_4__class = NULL;
    PyObject *tmp_class_creation_4__class_dict = NULL;
    PyObject *tmp_class_creation_4__metaclass = NULL;
    PyObject *tmp_class_creation_5__class = NULL;
    PyObject *tmp_class_creation_5__class_dict = NULL;
    PyObject *tmp_class_creation_5__metaclass = NULL;
    PyObject *tmp_class_creation_6__class = NULL;
    PyObject *tmp_class_creation_6__class_dict = NULL;
    PyObject *tmp_class_creation_6__metaclass = NULL;
    PyObject *tmp_class_creation_7__class = NULL;
    PyObject *tmp_class_creation_7__class_dict = NULL;
    PyObject *tmp_class_creation_7__metaclass = NULL;
    PyObject *tmp_class_creation_8__class = NULL;
    PyObject *tmp_class_creation_8__class_dict = NULL;
    PyObject *tmp_class_creation_8__metaclass = NULL;
    PyObject *tmp_class_creation_9__class = NULL;
    PyObject *tmp_class_creation_9__class_dict = NULL;
    PyObject *tmp_class_creation_9__metaclass = NULL;
    PyObject *tmp_import_from_1__module = NULL;
    PyObject *tmp_import_from_2__module = NULL;
    PyObject *tmp_import_from_3__module = NULL;
    PyObject *tmp_import_from_4__module = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1576_key___init__ = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1576_key_add_cert = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1576_key_add_crl = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1576_key_set_flags = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1576_key_set_time = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1694_key___init__ = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1708_key___init__ = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1708_key__cleanup = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1708_key__exception_from_context = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1708_key__init = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1708_key_set_store = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1708_key_verify_certificate = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1953_key___init__ = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1953_key__crl_reasons = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1953_key__delete_reason = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1953_key_all_reasons = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1953_key_get_reason = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1953_key_get_rev_date = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1953_key_get_serial = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1953_key_set_reason = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1953_key_set_rev_date = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1953_key_set_serial = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_206_key___init__ = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_206_key_add = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_206_key_clear = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_2348_key_get_type_name = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_2348_key_type_is_data = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_2348_key_type_is_enveloped = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_2348_key_type_is_signed = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_2348_key_type_is_signedAndEnveloped = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_2399_key___init__ = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_2399_key_export = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_2399_key_get_ca_certificates = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_2399_key_get_certificate = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_2399_key_get_friendlyname = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_2399_key_get_privatekey = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_2399_key_set_ca_certificates = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_2399_key_set_certificate = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_2399_key_set_friendlyname = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_2399_key_set_privatekey = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_2580_key___init__ = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_2580_key_b64_encode = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_2580_key_get_pubkey = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_2580_key_set_pubkey = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_2580_key_sign = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_2580_key_verify = NULL;
    struct Nuitka_FrameObject *frame_d796a9417638ea0fc15dcdcd73475757;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    int tmp_res;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;
    PyObject *locals_OpenSSL$crypto_219 = NULL;
    PyObject *tmp_dictset_value;
    struct Nuitka_FrameObject *frame_0f24a32b5663577b8612198b9ee32e1e_2;
    NUITKA_MAY_BE_UNUSED char const *type_description_2 = NULL;
    static struct Nuitka_FrameObject *cache_frame_0f24a32b5663577b8612198b9ee32e1e_2 = NULL;
    PyObject *exception_keeper_type_6;
    PyObject *exception_keeper_value_6;
    PyTracebackObject *exception_keeper_tb_6;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_6;
    PyObject *exception_keeper_type_7;
    PyObject *exception_keeper_value_7;
    PyTracebackObject *exception_keeper_tb_7;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_7;
    PyObject *locals_OpenSSL$crypto_377 = NULL;
    struct Nuitka_FrameObject *frame_6159802766a8a7093088b919012df71c_3;
    NUITKA_MAY_BE_UNUSED char const *type_description_3 = NULL;
    static struct Nuitka_FrameObject *cache_frame_6159802766a8a7093088b919012df71c_3 = NULL;
    PyObject *exception_keeper_type_8;
    PyObject *exception_keeper_value_8;
    PyTracebackObject *exception_keeper_tb_8;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_8;
    PyObject *exception_keeper_type_9;
    PyObject *exception_keeper_value_9;
    PyTracebackObject *exception_keeper_tb_9;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_9;
    PyObject *locals_OpenSSL$crypto_516 = NULL;
    struct Nuitka_FrameObject *frame_26554ef6367a9e88a5185ae01f6efee0_4;
    NUITKA_MAY_BE_UNUSED char const *type_description_4 = NULL;
    static struct Nuitka_FrameObject *cache_frame_26554ef6367a9e88a5185ae01f6efee0_4 = NULL;
    PyObject *exception_keeper_type_10;
    PyObject *exception_keeper_value_10;
    PyTracebackObject *exception_keeper_tb_10;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_10;
    PyObject *exception_keeper_type_11;
    PyObject *exception_keeper_value_11;
    PyTracebackObject *exception_keeper_tb_11;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_11;
    PyObject *locals_OpenSSL$crypto_716 = NULL;
    struct Nuitka_FrameObject *frame_584960adc98f2327e7352a334ee7240a_5;
    NUITKA_MAY_BE_UNUSED char const *type_description_5 = NULL;
    static struct Nuitka_FrameObject *cache_frame_584960adc98f2327e7352a334ee7240a_5 = NULL;
    PyObject *exception_keeper_type_12;
    PyObject *exception_keeper_value_12;
    PyTracebackObject *exception_keeper_tb_12;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_12;
    PyObject *exception_keeper_type_13;
    PyObject *exception_keeper_value_13;
    PyTracebackObject *exception_keeper_tb_13;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_13;
    PyObject *locals_OpenSSL$crypto_874 = NULL;
    struct Nuitka_FrameObject *frame_b729aae3be3cb5ee6312ba7b28f48a0d_6;
    NUITKA_MAY_BE_UNUSED char const *type_description_6 = NULL;
    static struct Nuitka_FrameObject *cache_frame_b729aae3be3cb5ee6312ba7b28f48a0d_6 = NULL;
    PyObject *exception_keeper_type_14;
    PyObject *exception_keeper_value_14;
    PyTracebackObject *exception_keeper_tb_14;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_14;
    PyObject *exception_keeper_type_15;
    PyObject *exception_keeper_value_15;
    PyTracebackObject *exception_keeper_tb_15;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_15;
    PyObject *locals_OpenSSL$crypto_1080 = NULL;
    struct Nuitka_FrameObject *frame_e48c7ada7caf70ebce53c5531940cfed_7;
    NUITKA_MAY_BE_UNUSED char const *type_description_7 = NULL;
    static struct Nuitka_FrameObject *cache_frame_e48c7ada7caf70ebce53c5531940cfed_7 = NULL;
    PyObject *exception_keeper_type_16;
    PyObject *exception_keeper_value_16;
    PyTracebackObject *exception_keeper_tb_16;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_16;
    PyObject *exception_keeper_type_17;
    PyObject *exception_keeper_value_17;
    PyTracebackObject *exception_keeper_tb_17;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_17;
    PyObject *locals_OpenSSL$crypto_1553 = NULL;
    struct Nuitka_FrameObject *frame_bdc51ef1a1907bf0b04d0d14fa40b94d_8;
    NUITKA_MAY_BE_UNUSED char const *type_description_8 = NULL;
    static struct Nuitka_FrameObject *cache_frame_bdc51ef1a1907bf0b04d0d14fa40b94d_8 = NULL;
    PyObject *exception_keeper_type_18;
    PyObject *exception_keeper_value_18;
    PyTracebackObject *exception_keeper_tb_18;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_18;
    PyObject *exception_keeper_type_19;
    PyObject *exception_keeper_value_19;
    PyTracebackObject *exception_keeper_tb_19;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_19;
    PyObject *exception_keeper_type_20;
    PyObject *exception_keeper_value_20;
    PyTracebackObject *exception_keeper_tb_20;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_20;
    PyObject *exception_keeper_type_21;
    PyObject *exception_keeper_value_21;
    PyTracebackObject *exception_keeper_tb_21;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_21;
    PyObject *exception_keeper_type_22;
    PyObject *exception_keeper_value_22;
    PyTracebackObject *exception_keeper_tb_22;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_22;
    PyObject *exception_keeper_type_23;
    PyObject *exception_keeper_value_23;
    PyTracebackObject *exception_keeper_tb_23;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_23;
    PyObject *locals_OpenSSL$crypto_2123 = NULL;
    struct Nuitka_FrameObject *frame_de021b22d6a553ff379ffc2219845a9b_9;
    NUITKA_MAY_BE_UNUSED char const *type_description_9 = NULL;
    static struct Nuitka_FrameObject *cache_frame_de021b22d6a553ff379ffc2219845a9b_9 = NULL;
    PyObject *exception_keeper_type_24;
    PyObject *exception_keeper_value_24;
    PyTracebackObject *exception_keeper_tb_24;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_24;
    PyObject *exception_keeper_type_25;
    PyObject *exception_keeper_value_25;
    PyTracebackObject *exception_keeper_tb_25;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_25;
    PyObject *exception_keeper_type_26;
    PyObject *exception_keeper_value_26;
    PyTracebackObject *exception_keeper_tb_26;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_26;
    PyObject *exception_keeper_type_27;
    PyObject *exception_keeper_value_27;
    PyTracebackObject *exception_keeper_tb_27;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_27;
    PyObject *exception_keeper_type_28;
    PyObject *exception_keeper_value_28;
    PyTracebackObject *exception_keeper_tb_28;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_28;
    PyObject *locals_OpenSSL$crypto_2677 = NULL;
    struct Nuitka_FrameObject *frame_53b82250513b686ddc71f0e4ae92fdc3_10;
    NUITKA_MAY_BE_UNUSED char const *type_description_10 = NULL;
    static struct Nuitka_FrameObject *cache_frame_53b82250513b686ddc71f0e4ae92fdc3_10 = NULL;
    PyObject *exception_keeper_type_29;
    PyObject *exception_keeper_value_29;
    PyTracebackObject *exception_keeper_tb_29;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_29;
    PyObject *exception_keeper_type_30;
    PyObject *exception_keeper_value_30;
    PyTracebackObject *exception_keeper_tb_30;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_30;

    // Module code.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = Py_None;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___doc__, tmp_assign_source_1);
    }
    {
        PyObject *tmp_assign_source_2;
        tmp_assign_source_2 = module_filename_obj;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___file__, tmp_assign_source_2);
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_name_name_1;
        PyObject *tmp_globals_name_1;
        PyObject *tmp_locals_name_1;
        PyObject *tmp_fromlist_name_1;
        tmp_name_name_1 = const_str_plain_datetime;
        tmp_globals_name_1 = (PyObject *)moduledict_OpenSSL$crypto;
        tmp_locals_name_1 = Py_None;
        tmp_fromlist_name_1 = Py_None;
        tmp_assign_source_3 = IMPORT_MODULE4(tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1);
        assert(!(tmp_assign_source_3 == NULL));
        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_datetime, tmp_assign_source_3);
    }
    // Frame without reuse.
    frame_d796a9417638ea0fc15dcdcd73475757 = MAKE_MODULE_FRAME(codeobj_d796a9417638ea0fc15dcdcd73475757, module_OpenSSL$crypto);

    // Push the new frame as the currently active one, and we should be exclusively
    // owning it.
    pushFrameStack(frame_d796a9417638ea0fc15dcdcd73475757);
    assert(Py_REFCNT(frame_d796a9417638ea0fc15dcdcd73475757) == 2);

    // Framed code:
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_import_name_from_1;
        PyObject *tmp_name_name_2;
        PyObject *tmp_globals_name_2;
        PyObject *tmp_locals_name_2;
        PyObject *tmp_fromlist_name_2;
        tmp_name_name_2 = const_str_plain_base64;
        tmp_globals_name_2 = (PyObject *)moduledict_OpenSSL$crypto;
        tmp_locals_name_2 = Py_None;
        tmp_fromlist_name_2 = const_tuple_str_plain_b16encode_tuple;
        frame_d796a9417638ea0fc15dcdcd73475757->m_frame.f_lineno = 3;
        tmp_import_name_from_1 = IMPORT_MODULE4(tmp_name_name_2, tmp_globals_name_2, tmp_locals_name_2, tmp_fromlist_name_2);
        if (tmp_import_name_from_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3;

            goto frame_exception_exit_1;
        }
        tmp_assign_source_4 = IMPORT_NAME(tmp_import_name_from_1, const_str_plain_b16encode);
        Py_DECREF(tmp_import_name_from_1);
        if (tmp_assign_source_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_b16encode, tmp_assign_source_4);
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_import_name_from_2;
        PyObject *tmp_name_name_3;
        PyObject *tmp_globals_name_3;
        PyObject *tmp_locals_name_3;
        PyObject *tmp_fromlist_name_3;
        tmp_name_name_3 = const_str_plain_functools;
        tmp_globals_name_3 = (PyObject *)moduledict_OpenSSL$crypto;
        tmp_locals_name_3 = Py_None;
        tmp_fromlist_name_3 = const_tuple_str_plain_partial_tuple;
        frame_d796a9417638ea0fc15dcdcd73475757->m_frame.f_lineno = 4;
        tmp_import_name_from_2 = IMPORT_MODULE4(tmp_name_name_3, tmp_globals_name_3, tmp_locals_name_3, tmp_fromlist_name_3);
        if (tmp_import_name_from_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 4;

            goto frame_exception_exit_1;
        }
        tmp_assign_source_5 = IMPORT_NAME(tmp_import_name_from_2, const_str_plain_partial);
        Py_DECREF(tmp_import_name_from_2);
        if (tmp_assign_source_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 4;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_partial, tmp_assign_source_5);
    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_name_name_4;
        PyObject *tmp_globals_name_4;
        PyObject *tmp_locals_name_4;
        PyObject *tmp_fromlist_name_4;
        tmp_name_name_4 = const_str_plain_operator;
        tmp_globals_name_4 = (PyObject *)moduledict_OpenSSL$crypto;
        tmp_locals_name_4 = Py_None;
        tmp_fromlist_name_4 = const_tuple_8291ba4d3b501c7d6047aff9c84147fc_tuple;
        frame_d796a9417638ea0fc15dcdcd73475757->m_frame.f_lineno = 5;
        tmp_assign_source_6 = IMPORT_MODULE4(tmp_name_name_4, tmp_globals_name_4, tmp_locals_name_4, tmp_fromlist_name_4);
        assert(!(tmp_assign_source_6 == NULL));
        assert(tmp_import_from_1__module == NULL);
        tmp_import_from_1__module = tmp_assign_source_6;
    }
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_import_name_from_3;
        CHECK_OBJECT(tmp_import_from_1__module);
        tmp_import_name_from_3 = tmp_import_from_1__module;
        tmp_assign_source_7 = IMPORT_NAME(tmp_import_name_from_3, const_str_plain___eq__);
        assert(!(tmp_assign_source_7 == NULL));
        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___eq__, tmp_assign_source_7);
    }
    {
        PyObject *tmp_assign_source_8;
        PyObject *tmp_import_name_from_4;
        CHECK_OBJECT(tmp_import_from_1__module);
        tmp_import_name_from_4 = tmp_import_from_1__module;
        tmp_assign_source_8 = IMPORT_NAME(tmp_import_name_from_4, const_str_plain___ne__);
        assert(!(tmp_assign_source_8 == NULL));
        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___ne__, tmp_assign_source_8);
    }
    {
        PyObject *tmp_assign_source_9;
        PyObject *tmp_import_name_from_5;
        CHECK_OBJECT(tmp_import_from_1__module);
        tmp_import_name_from_5 = tmp_import_from_1__module;
        tmp_assign_source_9 = IMPORT_NAME(tmp_import_name_from_5, const_str_plain___lt__);
        assert(!(tmp_assign_source_9 == NULL));
        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___lt__, tmp_assign_source_9);
    }
    {
        PyObject *tmp_assign_source_10;
        PyObject *tmp_import_name_from_6;
        CHECK_OBJECT(tmp_import_from_1__module);
        tmp_import_name_from_6 = tmp_import_from_1__module;
        tmp_assign_source_10 = IMPORT_NAME(tmp_import_name_from_6, const_str_plain___le__);
        assert(!(tmp_assign_source_10 == NULL));
        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___le__, tmp_assign_source_10);
    }
    {
        PyObject *tmp_assign_source_11;
        PyObject *tmp_import_name_from_7;
        CHECK_OBJECT(tmp_import_from_1__module);
        tmp_import_name_from_7 = tmp_import_from_1__module;
        tmp_assign_source_11 = IMPORT_NAME(tmp_import_name_from_7, const_str_plain___gt__);
        assert(!(tmp_assign_source_11 == NULL));
        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___gt__, tmp_assign_source_11);
    }
    {
        PyObject *tmp_assign_source_12;
        PyObject *tmp_import_name_from_8;
        CHECK_OBJECT(tmp_import_from_1__module);
        tmp_import_name_from_8 = tmp_import_from_1__module;
        tmp_assign_source_12 = IMPORT_NAME(tmp_import_name_from_8, const_str_plain___ge__);
        assert(!(tmp_assign_source_12 == NULL));
        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___ge__, tmp_assign_source_12);
    }
    CHECK_OBJECT((PyObject *)tmp_import_from_1__module);
    Py_DECREF(tmp_import_from_1__module);
    tmp_import_from_1__module = NULL;

    {
        PyObject *tmp_assign_source_13;
        PyObject *tmp_name_name_5;
        PyObject *tmp_globals_name_5;
        PyObject *tmp_locals_name_5;
        PyObject *tmp_fromlist_name_5;
        tmp_name_name_5 = const_str_plain_six;
        tmp_globals_name_5 = (PyObject *)moduledict_OpenSSL$crypto;
        tmp_locals_name_5 = Py_None;
        tmp_fromlist_name_5 = const_tuple_str_plain_integer_types_str_plain_text_type_str_plain_PY3_tuple;
        frame_d796a9417638ea0fc15dcdcd73475757->m_frame.f_lineno = 7;
        tmp_assign_source_13 = IMPORT_MODULE4(tmp_name_name_5, tmp_globals_name_5, tmp_locals_name_5, tmp_fromlist_name_5);
        if (tmp_assign_source_13 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 7;

            goto frame_exception_exit_1;
        }
        assert(tmp_import_from_2__module == NULL);
        tmp_import_from_2__module = tmp_assign_source_13;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_14;
        PyObject *tmp_import_name_from_9;
        CHECK_OBJECT(tmp_import_from_2__module);
        tmp_import_name_from_9 = tmp_import_from_2__module;
        tmp_assign_source_14 = IMPORT_NAME(tmp_import_name_from_9, const_str_plain_integer_types);
        if (tmp_assign_source_14 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 7;

            goto try_except_handler_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__integer_types, tmp_assign_source_14);
    }
    {
        PyObject *tmp_assign_source_15;
        PyObject *tmp_import_name_from_10;
        CHECK_OBJECT(tmp_import_from_2__module);
        tmp_import_name_from_10 = tmp_import_from_2__module;
        tmp_assign_source_15 = IMPORT_NAME(tmp_import_name_from_10, const_str_plain_text_type);
        if (tmp_assign_source_15 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 7;

            goto try_except_handler_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__text_type, tmp_assign_source_15);
    }
    {
        PyObject *tmp_assign_source_16;
        PyObject *tmp_import_name_from_11;
        CHECK_OBJECT(tmp_import_from_2__module);
        tmp_import_name_from_11 = tmp_import_from_2__module;
        tmp_assign_source_16 = IMPORT_NAME(tmp_import_name_from_11, const_str_plain_PY3);
        if (tmp_assign_source_16 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 7;

            goto try_except_handler_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__PY3, tmp_assign_source_16);
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)tmp_import_from_2__module);
    Py_DECREF(tmp_import_from_2__module);
    tmp_import_from_2__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    CHECK_OBJECT((PyObject *)tmp_import_from_2__module);
    Py_DECREF(tmp_import_from_2__module);
    tmp_import_from_2__module = NULL;

    {
        PyObject *tmp_assign_source_17;
        PyObject *tmp_import_name_from_12;
        PyObject *tmp_name_name_6;
        PyObject *tmp_globals_name_6;
        PyObject *tmp_locals_name_6;
        PyObject *tmp_fromlist_name_6;
        tmp_name_name_6 = const_str_plain_cryptography;
        tmp_globals_name_6 = (PyObject *)moduledict_OpenSSL$crypto;
        tmp_locals_name_6 = Py_None;
        tmp_fromlist_name_6 = const_tuple_str_plain_x509_tuple;
        frame_d796a9417638ea0fc15dcdcd73475757->m_frame.f_lineno = 12;
        tmp_import_name_from_12 = IMPORT_MODULE4(tmp_name_name_6, tmp_globals_name_6, tmp_locals_name_6, tmp_fromlist_name_6);
        if (tmp_import_name_from_12 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 12;

            goto frame_exception_exit_1;
        }
        tmp_assign_source_17 = IMPORT_NAME(tmp_import_name_from_12, const_str_plain_x509);
        Py_DECREF(tmp_import_name_from_12);
        if (tmp_assign_source_17 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 12;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_x509, tmp_assign_source_17);
    }
    {
        PyObject *tmp_assign_source_18;
        PyObject *tmp_name_name_7;
        PyObject *tmp_globals_name_7;
        PyObject *tmp_locals_name_7;
        PyObject *tmp_fromlist_name_7;
        tmp_name_name_7 = const_str_digest_426349c7e201b358f2086eb3f7fb6f47;
        tmp_globals_name_7 = (PyObject *)moduledict_OpenSSL$crypto;
        tmp_locals_name_7 = Py_None;
        tmp_fromlist_name_7 = const_tuple_str_plain_dsa_str_plain_rsa_tuple;
        frame_d796a9417638ea0fc15dcdcd73475757->m_frame.f_lineno = 13;
        tmp_assign_source_18 = IMPORT_MODULE4(tmp_name_name_7, tmp_globals_name_7, tmp_locals_name_7, tmp_fromlist_name_7);
        if (tmp_assign_source_18 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 13;

            goto frame_exception_exit_1;
        }
        assert(tmp_import_from_3__module == NULL);
        tmp_import_from_3__module = tmp_assign_source_18;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_19;
        PyObject *tmp_import_name_from_13;
        CHECK_OBJECT(tmp_import_from_3__module);
        tmp_import_name_from_13 = tmp_import_from_3__module;
        tmp_assign_source_19 = IMPORT_NAME(tmp_import_name_from_13, const_str_plain_dsa);
        if (tmp_assign_source_19 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 13;

            goto try_except_handler_2;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_dsa, tmp_assign_source_19);
    }
    {
        PyObject *tmp_assign_source_20;
        PyObject *tmp_import_name_from_14;
        CHECK_OBJECT(tmp_import_from_3__module);
        tmp_import_name_from_14 = tmp_import_from_3__module;
        tmp_assign_source_20 = IMPORT_NAME(tmp_import_name_from_14, const_str_plain_rsa);
        if (tmp_assign_source_20 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 13;

            goto try_except_handler_2;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_rsa, tmp_assign_source_20);
    }
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)tmp_import_from_3__module);
    Py_DECREF(tmp_import_from_3__module);
    tmp_import_from_3__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    CHECK_OBJECT((PyObject *)tmp_import_from_3__module);
    Py_DECREF(tmp_import_from_3__module);
    tmp_import_from_3__module = NULL;

    {
        PyObject *tmp_assign_source_21;
        PyObject *tmp_import_name_from_15;
        PyObject *tmp_name_name_8;
        PyObject *tmp_globals_name_8;
        PyObject *tmp_locals_name_8;
        PyObject *tmp_fromlist_name_8;
        tmp_name_name_8 = const_str_digest_8b0e1374dcc590bdb16ac8ec2446b5d1;
        tmp_globals_name_8 = (PyObject *)moduledict_OpenSSL$crypto;
        tmp_locals_name_8 = Py_None;
        tmp_fromlist_name_8 = const_tuple_str_plain_deprecated_tuple;
        frame_d796a9417638ea0fc15dcdcd73475757->m_frame.f_lineno = 14;
        tmp_import_name_from_15 = IMPORT_MODULE4(tmp_name_name_8, tmp_globals_name_8, tmp_locals_name_8, tmp_fromlist_name_8);
        if (tmp_import_name_from_15 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 14;

            goto frame_exception_exit_1;
        }
        tmp_assign_source_21 = IMPORT_NAME(tmp_import_name_from_15, const_str_plain_deprecated);
        Py_DECREF(tmp_import_name_from_15);
        if (tmp_assign_source_21 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 14;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_deprecated, tmp_assign_source_21);
    }
    {
        PyObject *tmp_assign_source_22;
        PyObject *tmp_name_name_9;
        PyObject *tmp_globals_name_9;
        PyObject *tmp_locals_name_9;
        PyObject *tmp_fromlist_name_9;
        tmp_name_name_9 = const_str_digest_2c0accc407028fbaba46fefdee9c6c06;
        tmp_globals_name_9 = (PyObject *)moduledict_OpenSSL$crypto;
        tmp_locals_name_9 = Py_None;
        tmp_fromlist_name_9 = const_tuple_5b465d0345e9fe836325135a03b6a86e_tuple;
        frame_d796a9417638ea0fc15dcdcd73475757->m_frame.f_lineno = 16;
        tmp_assign_source_22 = IMPORT_MODULE4(tmp_name_name_9, tmp_globals_name_9, tmp_locals_name_9, tmp_fromlist_name_9);
        if (tmp_assign_source_22 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 16;

            goto frame_exception_exit_1;
        }
        assert(tmp_import_from_4__module == NULL);
        tmp_import_from_4__module = tmp_assign_source_22;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_23;
        PyObject *tmp_import_name_from_16;
        CHECK_OBJECT(tmp_import_from_4__module);
        tmp_import_name_from_16 = tmp_import_from_4__module;
        tmp_assign_source_23 = IMPORT_NAME(tmp_import_name_from_16, const_str_plain_ffi);
        if (tmp_assign_source_23 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 16;

            goto try_except_handler_3;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi, tmp_assign_source_23);
    }
    {
        PyObject *tmp_assign_source_24;
        PyObject *tmp_import_name_from_17;
        CHECK_OBJECT(tmp_import_from_4__module);
        tmp_import_name_from_17 = tmp_import_from_4__module;
        tmp_assign_source_24 = IMPORT_NAME(tmp_import_name_from_17, const_str_plain_lib);
        if (tmp_assign_source_24 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 16;

            goto try_except_handler_3;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib, tmp_assign_source_24);
    }
    {
        PyObject *tmp_assign_source_25;
        PyObject *tmp_import_name_from_18;
        CHECK_OBJECT(tmp_import_from_4__module);
        tmp_import_name_from_18 = tmp_import_from_4__module;
        tmp_assign_source_25 = IMPORT_NAME(tmp_import_name_from_18, const_str_plain_exception_from_error_queue);
        if (tmp_assign_source_25 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 16;

            goto try_except_handler_3;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__exception_from_error_queue, tmp_assign_source_25);
    }
    {
        PyObject *tmp_assign_source_26;
        PyObject *tmp_import_name_from_19;
        CHECK_OBJECT(tmp_import_from_4__module);
        tmp_import_name_from_19 = tmp_import_from_4__module;
        tmp_assign_source_26 = IMPORT_NAME(tmp_import_name_from_19, const_str_plain_byte_string);
        if (tmp_assign_source_26 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 16;

            goto try_except_handler_3;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__byte_string, tmp_assign_source_26);
    }
    {
        PyObject *tmp_assign_source_27;
        PyObject *tmp_import_name_from_20;
        CHECK_OBJECT(tmp_import_from_4__module);
        tmp_import_name_from_20 = tmp_import_from_4__module;
        tmp_assign_source_27 = IMPORT_NAME(tmp_import_name_from_20, const_str_plain_native);
        if (tmp_assign_source_27 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 16;

            goto try_except_handler_3;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__native, tmp_assign_source_27);
    }
    {
        PyObject *tmp_assign_source_28;
        PyObject *tmp_import_name_from_21;
        CHECK_OBJECT(tmp_import_from_4__module);
        tmp_import_name_from_21 = tmp_import_from_4__module;
        tmp_assign_source_28 = IMPORT_NAME(tmp_import_name_from_21, const_str_plain_UNSPECIFIED);
        if (tmp_assign_source_28 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 16;

            goto try_except_handler_3;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__UNSPECIFIED, tmp_assign_source_28);
    }
    {
        PyObject *tmp_assign_source_29;
        PyObject *tmp_import_name_from_22;
        CHECK_OBJECT(tmp_import_from_4__module);
        tmp_import_name_from_22 = tmp_import_from_4__module;
        tmp_assign_source_29 = IMPORT_NAME(tmp_import_name_from_22, const_str_plain_text_to_bytes_and_warn);
        if (tmp_assign_source_29 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 16;

            goto try_except_handler_3;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn, tmp_assign_source_29);
    }
    {
        PyObject *tmp_assign_source_30;
        PyObject *tmp_import_name_from_23;
        CHECK_OBJECT(tmp_import_from_4__module);
        tmp_import_name_from_23 = tmp_import_from_4__module;
        tmp_assign_source_30 = IMPORT_NAME(tmp_import_name_from_23, const_str_plain_make_assert);
        if (tmp_assign_source_30 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 16;

            goto try_except_handler_3;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__make_assert, tmp_assign_source_30);
    }
    goto try_end_3;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)tmp_import_from_4__module);
    Py_DECREF(tmp_import_from_4__module);
    tmp_import_from_4__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;
    CHECK_OBJECT((PyObject *)tmp_import_from_4__module);
    Py_DECREF(tmp_import_from_4__module);
    tmp_import_from_4__module = NULL;

    {
        PyObject *tmp_assign_source_31;
        tmp_assign_source_31 = LIST_COPY(const_list_b8e29824b436479d358fd3771a611e70_list);
        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___all__, tmp_assign_source_31);
    }
    {
        PyObject *tmp_assign_source_32;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 66;

            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_assign_source_32 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_FILETYPE_PEM);
        if (tmp_assign_source_32 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 66;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM, tmp_assign_source_32);
    }
    {
        PyObject *tmp_assign_source_33;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 67;

            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_assign_source_33 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_SSL_FILETYPE_ASN1);
        if (tmp_assign_source_33 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 67;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1, tmp_assign_source_33);
    }
    {
        PyObject *tmp_assign_source_34;
        tmp_assign_source_34 = const_int_pos_65535;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_TEXT, tmp_assign_source_34);
    }
    {
        PyObject *tmp_assign_source_35;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_3;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 72;

            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_3;
        tmp_assign_source_35 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_EVP_PKEY_RSA);
        if (tmp_assign_source_35 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 72;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_TYPE_RSA, tmp_assign_source_35);
    }
    {
        PyObject *tmp_assign_source_36;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_4;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 73;

            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_4;
        tmp_assign_source_36 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_EVP_PKEY_DSA);
        if (tmp_assign_source_36 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 73;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_TYPE_DSA, tmp_assign_source_36);
    }
    {
        PyObject *tmp_assign_source_37;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_5;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 74;

            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_5;
        tmp_assign_source_37 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_EVP_PKEY_DH);
        if (tmp_assign_source_37 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 74;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_TYPE_DH, tmp_assign_source_37);
    }
    {
        PyObject *tmp_assign_source_38;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_6;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_6 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 75;

            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_6;
        tmp_assign_source_38 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_EVP_PKEY_EC);
        if (tmp_assign_source_38 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 75;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_TYPE_EC, tmp_assign_source_38);
    }
    {
        PyObject *tmp_assign_source_39;
        tmp_assign_source_39 = PyDict_Copy(const_dict_5608fce8424ef5aca22387357d834999);
        assert(tmp_class_creation_1__class_dict == NULL);
        tmp_class_creation_1__class_dict = tmp_assign_source_39;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_40;
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_key_name_1;
        PyObject *tmp_dict_name_1;
        PyObject *tmp_dict_name_2;
        PyObject *tmp_key_name_2;
        tmp_key_name_1 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_1__class_dict);
        tmp_dict_name_1 = tmp_class_creation_1__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_1, tmp_key_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 78;

            goto try_except_handler_4;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_1;
        } else {
            goto condexpr_false_1;
        }
        condexpr_true_1:;
        CHECK_OBJECT(tmp_class_creation_1__class_dict);
        tmp_dict_name_2 = tmp_class_creation_1__class_dict;
        tmp_key_name_2 = const_str_plain___metaclass__;
        tmp_assign_source_40 = DICT_GET_ITEM(tmp_dict_name_2, tmp_key_name_2);
        if (tmp_assign_source_40 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 78;

            goto try_except_handler_4;
        }
        goto condexpr_end_1;
        condexpr_false_1:;
        tmp_assign_source_40 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_40);
        condexpr_end_1:;
        assert(tmp_class_creation_1__metaclass == NULL);
        tmp_class_creation_1__metaclass = tmp_assign_source_40;
    }
    {
        PyObject *tmp_assign_source_41;
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        CHECK_OBJECT(tmp_class_creation_1__metaclass);
        tmp_called_name_1 = tmp_class_creation_1__metaclass;
        tmp_args_element_name_1 = const_str_plain_Error;
        tmp_args_element_name_2 = const_tuple_type_Exception_tuple;
        CHECK_OBJECT(tmp_class_creation_1__class_dict);
        tmp_args_element_name_3 = tmp_class_creation_1__class_dict;
        frame_d796a9417638ea0fc15dcdcd73475757->m_frame.f_lineno = 78;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_assign_source_41 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_1, call_args);
        }

        if (tmp_assign_source_41 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 78;

            goto try_except_handler_4;
        }
        assert(tmp_class_creation_1__class == NULL);
        tmp_class_creation_1__class = tmp_assign_source_41;
    }
    goto try_end_4;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)tmp_class_creation_1__class_dict);
    Py_DECREF(tmp_class_creation_1__class_dict);
    tmp_class_creation_1__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_1__metaclass);
    tmp_class_creation_1__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto frame_exception_exit_1;
    // End of try:
    try_end_4:;
    {
        PyObject *tmp_assign_source_42;
        CHECK_OBJECT(tmp_class_creation_1__class);
        tmp_assign_source_42 = tmp_class_creation_1__class;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_Error, tmp_assign_source_42);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_1__class);
    Py_DECREF(tmp_class_creation_1__class);
    tmp_class_creation_1__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_1__class_dict);
    Py_DECREF(tmp_class_creation_1__class_dict);
    tmp_class_creation_1__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_1__metaclass);
    Py_DECREF(tmp_class_creation_1__metaclass);
    tmp_class_creation_1__metaclass = NULL;

    {
        PyObject *tmp_assign_source_43;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_mvar_value_9;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_partial);

        if (unlikely(tmp_mvar_value_7 == NULL)) {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_partial);
        }

        if (tmp_mvar_value_7 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 2055 ], 29, 0);
            exception_tb = NULL;

            exception_lineno = 84;

            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_7;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__exception_from_error_queue);

        if (unlikely(tmp_mvar_value_8 == NULL)) {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__exception_from_error_queue);
        }

        if (tmp_mvar_value_8 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 2084 ], 49, 0);
            exception_tb = NULL;

            exception_lineno = 84;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_4 = tmp_mvar_value_8;
        tmp_mvar_value_9 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_Error);

        if (unlikely(tmp_mvar_value_9 == NULL)) {
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_Error);
        }

        if (tmp_mvar_value_9 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 56 ], 27, 0);
            exception_tb = NULL;

            exception_lineno = 84;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_5 = tmp_mvar_value_9;
        frame_d796a9417638ea0fc15dcdcd73475757->m_frame.f_lineno = 84;
        {
            PyObject *call_args[] = {tmp_args_element_name_4, tmp_args_element_name_5};
            tmp_assign_source_43 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        if (tmp_assign_source_43 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 84;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error, tmp_assign_source_43);
    }
    {
        PyObject *tmp_assign_source_44;
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_10;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_mvar_value_11;
        tmp_mvar_value_10 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__make_assert);

        if (unlikely(tmp_mvar_value_10 == NULL)) {
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__make_assert);
        }

        if (tmp_mvar_value_10 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 2133 ], 34, 0);
            exception_tb = NULL;

            exception_lineno = 85;

            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_10;
        tmp_mvar_value_11 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_Error);

        if (unlikely(tmp_mvar_value_11 == NULL)) {
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_Error);
        }

        if (tmp_mvar_value_11 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 56 ], 27, 0);
            exception_tb = NULL;

            exception_lineno = 85;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_6 = tmp_mvar_value_11;
        frame_d796a9417638ea0fc15dcdcd73475757->m_frame.f_lineno = 85;
        tmp_assign_source_44 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_3, tmp_args_element_name_6);
        if (tmp_assign_source_44 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 85;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert, tmp_assign_source_44);
    }
    {
        PyObject *tmp_assign_source_45;
        tmp_assign_source_45 = MAKE_FUNCTION_OpenSSL$crypto$$$function_1__get_backend();



        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__get_backend, tmp_assign_source_45);
    }
    {
        PyObject *tmp_assign_source_46;
        tmp_assign_source_46 = MAKE_FUNCTION_OpenSSL$crypto$$$function_2__untested_error();



        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__untested_error, tmp_assign_source_46);
    }
    {
        PyObject *tmp_assign_source_47;
        PyObject *tmp_defaults_1;
        tmp_defaults_1 = const_tuple_none_tuple;
        Py_INCREF(tmp_defaults_1);
        tmp_assign_source_47 = MAKE_FUNCTION_OpenSSL$crypto$$$function_3__new_mem_buf(tmp_defaults_1);



        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf, tmp_assign_source_47);
    }
    {
        PyObject *tmp_assign_source_48;
        tmp_assign_source_48 = MAKE_FUNCTION_OpenSSL$crypto$$$function_4__bio_to_string();



        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__bio_to_string, tmp_assign_source_48);
    }
    {
        PyObject *tmp_assign_source_49;
        tmp_assign_source_49 = MAKE_FUNCTION_OpenSSL$crypto$$$function_5__set_asn1_time();



        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__set_asn1_time, tmp_assign_source_49);
    }
    {
        PyObject *tmp_assign_source_50;
        tmp_assign_source_50 = MAKE_FUNCTION_OpenSSL$crypto$$$function_6__get_asn1_time();



        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__get_asn1_time, tmp_assign_source_50);
    }
    {
        PyObject *tmp_assign_source_51;
        {
            PyObject *tmp_assign_source_52;
            tmp_assign_source_52 = MAKE_FUNCTION_OpenSSL$crypto$$$function_7___init__();



            assert(tmp_locals_OpenSSL$crypto_206_key___init__ == NULL);
            tmp_locals_OpenSSL$crypto_206_key___init__ = tmp_assign_source_52;
        }
        {
            PyObject *tmp_assign_source_53;
            tmp_assign_source_53 = MAKE_FUNCTION_OpenSSL$crypto$$$function_8_add();



            assert(tmp_locals_OpenSSL$crypto_206_key_add == NULL);
            tmp_locals_OpenSSL$crypto_206_key_add = tmp_assign_source_53;
        }
        {
            PyObject *tmp_assign_source_54;
            tmp_assign_source_54 = MAKE_FUNCTION_OpenSSL$crypto$$$function_9_clear();



            assert(tmp_locals_OpenSSL$crypto_206_key_clear == NULL);
            tmp_locals_OpenSSL$crypto_206_key_clear = tmp_assign_source_54;
        }
        // Tried code:
        {
            PyObject *tmp_dict_key_1;
            PyObject *tmp_dict_value_1;
            PyObject *tmp_dict_key_2;
            PyObject *tmp_dict_value_2;
            PyObject *tmp_dict_key_3;
            PyObject *tmp_dict_value_3;
            PyObject *tmp_dict_key_4;
            PyObject *tmp_dict_value_4;
            tmp_dict_value_1 = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
            tmp_dict_key_1 = const_str_plain___module__;
            tmp_assign_source_51 = _PyDict_NewPresized( 4 );
            tmp_res = PyDict_SetItem(tmp_assign_source_51, tmp_dict_key_1, tmp_dict_value_1);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_206_key___init__);
            tmp_dict_value_2 = tmp_locals_OpenSSL$crypto_206_key___init__;
            tmp_dict_key_2 = const_str_plain___init__;
            tmp_res = PyDict_SetItem(tmp_assign_source_51, tmp_dict_key_2, tmp_dict_value_2);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_206_key_add);
            tmp_dict_value_3 = tmp_locals_OpenSSL$crypto_206_key_add;
            tmp_dict_key_3 = const_str_plain_add;
            tmp_res = PyDict_SetItem(tmp_assign_source_51, tmp_dict_key_3, tmp_dict_value_3);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_206_key_clear);
            tmp_dict_value_4 = tmp_locals_OpenSSL$crypto_206_key_clear;
            tmp_dict_key_4 = const_str_plain_clear;
            tmp_res = PyDict_SetItem(tmp_assign_source_51, tmp_dict_key_4, tmp_dict_value_4);
            assert(!(tmp_res != 0));
            goto try_return_handler_5;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$crypto);
        return NULL;
        // Return handler code:
        try_return_handler_5:;
        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_206_key___init__);
        Py_DECREF(tmp_locals_OpenSSL$crypto_206_key___init__);
        tmp_locals_OpenSSL$crypto_206_key___init__ = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_206_key_add);
        Py_DECREF(tmp_locals_OpenSSL$crypto_206_key_add);
        tmp_locals_OpenSSL$crypto_206_key_add = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_206_key_clear);
        Py_DECREF(tmp_locals_OpenSSL$crypto_206_key_clear);
        tmp_locals_OpenSSL$crypto_206_key_clear = NULL;

        goto outline_result_1;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$crypto);
        return NULL;
        outline_result_1:;
        assert(tmp_class_creation_2__class_dict == NULL);
        tmp_class_creation_2__class_dict = tmp_assign_source_51;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_55;
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_key_name_3;
        PyObject *tmp_dict_name_3;
        PyObject *tmp_dict_name_4;
        PyObject *tmp_key_name_4;
        tmp_key_name_3 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_2__class_dict);
        tmp_dict_name_3 = tmp_class_creation_2__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_3, tmp_key_name_3);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 206;

            goto try_except_handler_6;
        }
        tmp_condition_result_2 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_2;
        } else {
            goto condexpr_false_2;
        }
        condexpr_true_2:;
        CHECK_OBJECT(tmp_class_creation_2__class_dict);
        tmp_dict_name_4 = tmp_class_creation_2__class_dict;
        tmp_key_name_4 = const_str_plain___metaclass__;
        tmp_assign_source_55 = DICT_GET_ITEM(tmp_dict_name_4, tmp_key_name_4);
        if (tmp_assign_source_55 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 206;

            goto try_except_handler_6;
        }
        goto condexpr_end_2;
        condexpr_false_2:;
        tmp_assign_source_55 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_55);
        condexpr_end_2:;
        assert(tmp_class_creation_2__metaclass == NULL);
        tmp_class_creation_2__metaclass = tmp_assign_source_55;
    }
    {
        PyObject *tmp_assign_source_56;
        PyObject *tmp_called_name_4;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_args_element_name_9;
        CHECK_OBJECT(tmp_class_creation_2__metaclass);
        tmp_called_name_4 = tmp_class_creation_2__metaclass;
        tmp_args_element_name_7 = const_str_plain__X509NameInvalidator;
        tmp_args_element_name_8 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_2__class_dict);
        tmp_args_element_name_9 = tmp_class_creation_2__class_dict;
        frame_d796a9417638ea0fc15dcdcd73475757->m_frame.f_lineno = 206;
        {
            PyObject *call_args[] = {tmp_args_element_name_7, tmp_args_element_name_8, tmp_args_element_name_9};
            tmp_assign_source_56 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_4, call_args);
        }

        if (tmp_assign_source_56 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 206;

            goto try_except_handler_6;
        }
        assert(tmp_class_creation_2__class == NULL);
        tmp_class_creation_2__class = tmp_assign_source_56;
    }
    goto try_end_5;
    // Exception handler code:
    try_except_handler_6:;
    exception_keeper_type_5 = exception_type;
    exception_keeper_value_5 = exception_value;
    exception_keeper_tb_5 = exception_tb;
    exception_keeper_lineno_5 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)tmp_class_creation_2__class_dict);
    Py_DECREF(tmp_class_creation_2__class_dict);
    tmp_class_creation_2__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_2__metaclass);
    tmp_class_creation_2__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_5;
    exception_value = exception_keeper_value_5;
    exception_tb = exception_keeper_tb_5;
    exception_lineno = exception_keeper_lineno_5;

    goto frame_exception_exit_1;
    // End of try:
    try_end_5:;
    {
        PyObject *tmp_assign_source_57;
        CHECK_OBJECT(tmp_class_creation_2__class);
        tmp_assign_source_57 = tmp_class_creation_2__class;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__X509NameInvalidator, tmp_assign_source_57);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_2__class);
    Py_DECREF(tmp_class_creation_2__class);
    tmp_class_creation_2__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_2__class_dict);
    Py_DECREF(tmp_class_creation_2__class_dict);
    tmp_class_creation_2__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_2__metaclass);
    Py_DECREF(tmp_class_creation_2__metaclass);
    tmp_class_creation_2__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_58;
        {
            PyObject *tmp_set_locals_1;
            tmp_set_locals_1 = PyDict_New();
            locals_OpenSSL$crypto_219 = tmp_set_locals_1;
        }
        tmp_dictset_value = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_219, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = const_str_digest_5997506aef8ffc5e12c453030416acc6;
        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_219, const_str_plain___doc__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = Py_False;
        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_219, const_str_plain__only_public, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = Py_True;
        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_219, const_str_plain__initialized, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_10___init__();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_219, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_11_to_cryptography_key();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_219, const_str_plain_to_cryptography_key, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_0f24a32b5663577b8612198b9ee32e1e_2, codeobj_0f24a32b5663577b8612198b9ee32e1e, module_OpenSSL$crypto, 0);
        frame_0f24a32b5663577b8612198b9ee32e1e_2 = cache_frame_0f24a32b5663577b8612198b9ee32e1e_2;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_0f24a32b5663577b8612198b9ee32e1e_2);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_0f24a32b5663577b8612198b9ee32e1e_2) == 2); // Frame stack

        // Framed code:
        {
            PyObject *tmp_classmethod_arg_1;
            tmp_classmethod_arg_1 = MAKE_FUNCTION_OpenSSL$crypto$$$function_12_from_cryptography_key();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_1);
            Py_DECREF(tmp_classmethod_arg_1);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 248;

                goto frame_exception_exit_2;
            }
            tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_219, const_str_plain_from_cryptography_key, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 248;

                goto frame_exception_exit_2;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_0f24a32b5663577b8612198b9ee32e1e_2);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_1;

        frame_exception_exit_2:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_0f24a32b5663577b8612198b9ee32e1e_2);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_0f24a32b5663577b8612198b9ee32e1e_2, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_0f24a32b5663577b8612198b9ee32e1e_2->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_0f24a32b5663577b8612198b9ee32e1e_2, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_0f24a32b5663577b8612198b9ee32e1e_2,
            type_description_2
        );


        // Release cached frame.
        if (frame_0f24a32b5663577b8612198b9ee32e1e_2 == cache_frame_0f24a32b5663577b8612198b9ee32e1e_2) {
            Py_DECREF(frame_0f24a32b5663577b8612198b9ee32e1e_2);
        }
        cache_frame_0f24a32b5663577b8612198b9ee32e1e_2 = NULL;

        assertFrameObject(frame_0f24a32b5663577b8612198b9ee32e1e_2);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_1;

        frame_no_exception_1:;
        goto skip_nested_handling_1;
        nested_frame_exit_1:;

        goto try_except_handler_8;
        skip_nested_handling_1:;
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_13_generate_key();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_219, const_str_plain_generate_key, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_14_check();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_219, const_str_plain_check, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_15_type();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_219, const_str_plain_type, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_16_bits();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_219, const_str_plain_bits, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_assign_source_58 = locals_OpenSSL$crypto_219;
        Py_INCREF(tmp_assign_source_58);
        goto try_return_handler_8;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$crypto);
        return NULL;
        // Return handler code:
        try_return_handler_8:;
        Py_DECREF(locals_OpenSSL$crypto_219);
        locals_OpenSSL$crypto_219 = NULL;
        goto outline_result_2;
        // Exception handler code:
        try_except_handler_8:;
        exception_keeper_type_6 = exception_type;
        exception_keeper_value_6 = exception_value;
        exception_keeper_tb_6 = exception_tb;
        exception_keeper_lineno_6 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_OpenSSL$crypto_219);
        locals_OpenSSL$crypto_219 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_6;
        exception_value = exception_keeper_value_6;
        exception_tb = exception_keeper_tb_6;
        exception_lineno = exception_keeper_lineno_6;

        goto outline_exception_1;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$crypto);
        return NULL;
        outline_exception_1:;
        exception_lineno = 219;
        goto try_except_handler_7;
        outline_result_2:;
        assert(tmp_class_creation_3__class_dict == NULL);
        tmp_class_creation_3__class_dict = tmp_assign_source_58;
    }
    {
        PyObject *tmp_assign_source_59;
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_key_name_5;
        PyObject *tmp_dict_name_5;
        PyObject *tmp_dict_name_6;
        PyObject *tmp_key_name_6;
        tmp_key_name_5 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_3__class_dict);
        tmp_dict_name_5 = tmp_class_creation_3__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_5, tmp_key_name_5);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 219;

            goto try_except_handler_7;
        }
        tmp_condition_result_3 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_3;
        } else {
            goto condexpr_false_3;
        }
        condexpr_true_3:;
        CHECK_OBJECT(tmp_class_creation_3__class_dict);
        tmp_dict_name_6 = tmp_class_creation_3__class_dict;
        tmp_key_name_6 = const_str_plain___metaclass__;
        tmp_assign_source_59 = DICT_GET_ITEM(tmp_dict_name_6, tmp_key_name_6);
        if (tmp_assign_source_59 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 219;

            goto try_except_handler_7;
        }
        goto condexpr_end_3;
        condexpr_false_3:;
        tmp_assign_source_59 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_59);
        condexpr_end_3:;
        assert(tmp_class_creation_3__metaclass == NULL);
        tmp_class_creation_3__metaclass = tmp_assign_source_59;
    }
    {
        PyObject *tmp_assign_source_60;
        PyObject *tmp_called_name_5;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_args_element_name_11;
        PyObject *tmp_args_element_name_12;
        CHECK_OBJECT(tmp_class_creation_3__metaclass);
        tmp_called_name_5 = tmp_class_creation_3__metaclass;
        tmp_args_element_name_10 = const_str_plain_PKey;
        tmp_args_element_name_11 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_3__class_dict);
        tmp_args_element_name_12 = tmp_class_creation_3__class_dict;
        frame_d796a9417638ea0fc15dcdcd73475757->m_frame.f_lineno = 219;
        {
            PyObject *call_args[] = {tmp_args_element_name_10, tmp_args_element_name_11, tmp_args_element_name_12};
            tmp_assign_source_60 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_5, call_args);
        }

        if (tmp_assign_source_60 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 219;

            goto try_except_handler_7;
        }
        assert(tmp_class_creation_3__class == NULL);
        tmp_class_creation_3__class = tmp_assign_source_60;
    }
    goto try_end_6;
    // Exception handler code:
    try_except_handler_7:;
    exception_keeper_type_7 = exception_type;
    exception_keeper_value_7 = exception_value;
    exception_keeper_tb_7 = exception_tb;
    exception_keeper_lineno_7 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_3__class_dict);
    tmp_class_creation_3__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_3__metaclass);
    tmp_class_creation_3__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_7;
    exception_value = exception_keeper_value_7;
    exception_tb = exception_keeper_tb_7;
    exception_lineno = exception_keeper_lineno_7;

    goto frame_exception_exit_1;
    // End of try:
    try_end_6:;
    {
        PyObject *tmp_assign_source_61;
        CHECK_OBJECT(tmp_class_creation_3__class);
        tmp_assign_source_61 = tmp_class_creation_3__class;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey, tmp_assign_source_61);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_3__class);
    Py_DECREF(tmp_class_creation_3__class);
    tmp_class_creation_3__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_3__class_dict);
    Py_DECREF(tmp_class_creation_3__class_dict);
    tmp_class_creation_3__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_3__metaclass);
    Py_DECREF(tmp_class_creation_3__metaclass);
    tmp_class_creation_3__metaclass = NULL;

    {
        PyObject *tmp_assign_source_62;
        PyObject *tmp_called_name_6;
        PyObject *tmp_mvar_value_12;
        PyObject *tmp_args_element_name_13;
        PyObject *tmp_mvar_value_13;
        PyObject *tmp_args_element_name_14;
        PyObject *tmp_args_element_name_15;
        PyObject *tmp_args_element_name_16;
        PyObject *tmp_mvar_value_14;
        tmp_mvar_value_12 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_deprecated);

        if (unlikely(tmp_mvar_value_12 == NULL)) {
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_deprecated);
        }

        if (tmp_mvar_value_12 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 2548 ], 32, 0);
            exception_tb = NULL;

            exception_lineno = 370;

            goto frame_exception_exit_1;
        }

        tmp_called_name_6 = tmp_mvar_value_12;
        tmp_mvar_value_13 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey);

        if (unlikely(tmp_mvar_value_13 == NULL)) {
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey);
        }

        if (tmp_mvar_value_13 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 985 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 371;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_13 = tmp_mvar_value_13;
        tmp_args_element_name_14 = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
        tmp_args_element_name_15 = const_str_digest_989a9acfa289de1c2c451525451533c9;
        tmp_mvar_value_14 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_DeprecationWarning);

        if (unlikely(tmp_mvar_value_14 == NULL)) {
            tmp_mvar_value_14 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_DeprecationWarning);
        }

        if (tmp_mvar_value_14 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 2580 ], 40, 0);
            exception_tb = NULL;

            exception_lineno = 373;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_16 = tmp_mvar_value_14;
        frame_d796a9417638ea0fc15dcdcd73475757->m_frame.f_lineno = 370;
        {
            PyObject *call_args[] = {tmp_args_element_name_13, tmp_args_element_name_14, tmp_args_element_name_15, tmp_args_element_name_16};
            tmp_assign_source_62 = CALL_FUNCTION_WITH_ARGS4(tmp_called_name_6, call_args);
        }

        if (tmp_assign_source_62 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 370;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKeyType, tmp_assign_source_62);
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_63;
        {
            PyObject *tmp_set_locals_2;
            tmp_set_locals_2 = PyDict_New();
            locals_OpenSSL$crypto_377 = tmp_set_locals_2;
        }
        tmp_dictset_value = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_377, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = const_str_digest_4a193fbd1ccf06765e0cb44620b7d74a;
        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_377, const_str_plain___doc__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = Py_None;
        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_377, const_str_plain__curves, tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_6159802766a8a7093088b919012df71c_3, codeobj_6159802766a8a7093088b919012df71c, module_OpenSSL$crypto, 0);
        frame_6159802766a8a7093088b919012df71c_3 = cache_frame_6159802766a8a7093088b919012df71c_3;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_6159802766a8a7093088b919012df71c_3);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_6159802766a8a7093088b919012df71c_3) == 2); // Frame stack

        // Framed code:
        {
            nuitka_bool tmp_condition_result_4;
            PyObject *tmp_mvar_value_15;
            int tmp_truth_name_1;
            tmp_mvar_value_15 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__PY3);

            if (unlikely(tmp_mvar_value_15 == NULL)) {
                tmp_mvar_value_15 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__PY3);
            }

            if (tmp_mvar_value_15 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 4403 ], 26, 0);
                exception_tb = NULL;

                exception_lineno = 388;

                goto frame_exception_exit_3;
            }

            tmp_truth_name_1 = CHECK_IF_TRUE(tmp_mvar_value_15);
            if (tmp_truth_name_1 == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 388;

                goto frame_exception_exit_3;
            }
            tmp_condition_result_4 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_4 == NUITKA_BOOL_TRUE) {
                goto branch_yes_1;
            } else {
                goto branch_no_1;
            }
            branch_yes_1:;
            tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_17___ne__();



            tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_377, const_str_plain___ne__, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            assert(!(tmp_res != 0));
            branch_no_1:;
        }
        {
            PyObject *tmp_classmethod_arg_2;
            tmp_classmethod_arg_2 = MAKE_FUNCTION_OpenSSL$crypto$$$function_18__load_elliptic_curves();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_2);
            Py_DECREF(tmp_classmethod_arg_2);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 401;

                goto frame_exception_exit_3;
            }
            tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_377, const_str_plain__load_elliptic_curves, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 401;

                goto frame_exception_exit_3;
            }
        }
        {
            PyObject *tmp_classmethod_arg_3;
            tmp_classmethod_arg_3 = MAKE_FUNCTION_OpenSSL$crypto$$$function_19__get_elliptic_curves();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_3);
            Py_DECREF(tmp_classmethod_arg_3);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 421;

                goto frame_exception_exit_3;
            }
            tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_377, const_str_plain__get_elliptic_curves, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 421;

                goto frame_exception_exit_3;
            }
        }
        {
            PyObject *tmp_classmethod_arg_4;
            tmp_classmethod_arg_4 = MAKE_FUNCTION_OpenSSL$crypto$$$function_20_from_nid();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_4);
            Py_DECREF(tmp_classmethod_arg_4);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 435;

                goto frame_exception_exit_3;
            }
            tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_377, const_str_plain_from_nid, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 435;

                goto frame_exception_exit_3;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_6159802766a8a7093088b919012df71c_3);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_2;

        frame_exception_exit_3:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_6159802766a8a7093088b919012df71c_3);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_6159802766a8a7093088b919012df71c_3, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_6159802766a8a7093088b919012df71c_3->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_6159802766a8a7093088b919012df71c_3, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_6159802766a8a7093088b919012df71c_3,
            type_description_2
        );


        // Release cached frame.
        if (frame_6159802766a8a7093088b919012df71c_3 == cache_frame_6159802766a8a7093088b919012df71c_3) {
            Py_DECREF(frame_6159802766a8a7093088b919012df71c_3);
        }
        cache_frame_6159802766a8a7093088b919012df71c_3 = NULL;

        assertFrameObject(frame_6159802766a8a7093088b919012df71c_3);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_2;

        frame_no_exception_2:;
        goto skip_nested_handling_2;
        nested_frame_exit_2:;

        goto try_except_handler_10;
        skip_nested_handling_2:;
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_21___init__();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_377, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_22___repr__();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_377, const_str_plain___repr__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_23__to_EC_KEY();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_377, const_str_plain__to_EC_KEY, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_assign_source_63 = locals_OpenSSL$crypto_377;
        Py_INCREF(tmp_assign_source_63);
        goto try_return_handler_10;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$crypto);
        return NULL;
        // Return handler code:
        try_return_handler_10:;
        Py_DECREF(locals_OpenSSL$crypto_377);
        locals_OpenSSL$crypto_377 = NULL;
        goto outline_result_3;
        // Exception handler code:
        try_except_handler_10:;
        exception_keeper_type_8 = exception_type;
        exception_keeper_value_8 = exception_value;
        exception_keeper_tb_8 = exception_tb;
        exception_keeper_lineno_8 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_OpenSSL$crypto_377);
        locals_OpenSSL$crypto_377 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_8;
        exception_value = exception_keeper_value_8;
        exception_tb = exception_keeper_tb_8;
        exception_lineno = exception_keeper_lineno_8;

        goto outline_exception_2;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$crypto);
        return NULL;
        outline_exception_2:;
        exception_lineno = 377;
        goto try_except_handler_9;
        outline_result_3:;
        assert(tmp_class_creation_4__class_dict == NULL);
        tmp_class_creation_4__class_dict = tmp_assign_source_63;
    }
    {
        PyObject *tmp_assign_source_64;
        nuitka_bool tmp_condition_result_5;
        PyObject *tmp_key_name_7;
        PyObject *tmp_dict_name_7;
        PyObject *tmp_dict_name_8;
        PyObject *tmp_key_name_8;
        tmp_key_name_7 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_4__class_dict);
        tmp_dict_name_7 = tmp_class_creation_4__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_7, tmp_key_name_7);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 377;

            goto try_except_handler_9;
        }
        tmp_condition_result_5 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_5 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_4;
        } else {
            goto condexpr_false_4;
        }
        condexpr_true_4:;
        CHECK_OBJECT(tmp_class_creation_4__class_dict);
        tmp_dict_name_8 = tmp_class_creation_4__class_dict;
        tmp_key_name_8 = const_str_plain___metaclass__;
        tmp_assign_source_64 = DICT_GET_ITEM(tmp_dict_name_8, tmp_key_name_8);
        if (tmp_assign_source_64 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 377;

            goto try_except_handler_9;
        }
        goto condexpr_end_4;
        condexpr_false_4:;
        tmp_assign_source_64 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_64);
        condexpr_end_4:;
        assert(tmp_class_creation_4__metaclass == NULL);
        tmp_class_creation_4__metaclass = tmp_assign_source_64;
    }
    {
        PyObject *tmp_assign_source_65;
        PyObject *tmp_called_name_7;
        PyObject *tmp_args_element_name_17;
        PyObject *tmp_args_element_name_18;
        PyObject *tmp_args_element_name_19;
        CHECK_OBJECT(tmp_class_creation_4__metaclass);
        tmp_called_name_7 = tmp_class_creation_4__metaclass;
        tmp_args_element_name_17 = const_str_plain__EllipticCurve;
        tmp_args_element_name_18 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_4__class_dict);
        tmp_args_element_name_19 = tmp_class_creation_4__class_dict;
        frame_d796a9417638ea0fc15dcdcd73475757->m_frame.f_lineno = 377;
        {
            PyObject *call_args[] = {tmp_args_element_name_17, tmp_args_element_name_18, tmp_args_element_name_19};
            tmp_assign_source_65 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_7, call_args);
        }

        if (tmp_assign_source_65 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 377;

            goto try_except_handler_9;
        }
        assert(tmp_class_creation_4__class == NULL);
        tmp_class_creation_4__class = tmp_assign_source_65;
    }
    goto try_end_7;
    // Exception handler code:
    try_except_handler_9:;
    exception_keeper_type_9 = exception_type;
    exception_keeper_value_9 = exception_value;
    exception_keeper_tb_9 = exception_tb;
    exception_keeper_lineno_9 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_4__class_dict);
    tmp_class_creation_4__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_4__metaclass);
    tmp_class_creation_4__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_9;
    exception_value = exception_keeper_value_9;
    exception_tb = exception_keeper_tb_9;
    exception_lineno = exception_keeper_lineno_9;

    goto frame_exception_exit_1;
    // End of try:
    try_end_7:;
    {
        PyObject *tmp_assign_source_66;
        CHECK_OBJECT(tmp_class_creation_4__class);
        tmp_assign_source_66 = tmp_class_creation_4__class;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__EllipticCurve, tmp_assign_source_66);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_4__class);
    Py_DECREF(tmp_class_creation_4__class);
    tmp_class_creation_4__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_4__class_dict);
    Py_DECREF(tmp_class_creation_4__class_dict);
    tmp_class_creation_4__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_4__metaclass);
    Py_DECREF(tmp_class_creation_4__metaclass);
    tmp_class_creation_4__metaclass = NULL;

    {
        PyObject *tmp_assign_source_67;
        tmp_assign_source_67 = MAKE_FUNCTION_OpenSSL$crypto$$$function_24_get_elliptic_curves();



        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_get_elliptic_curves, tmp_assign_source_67);
    }
    {
        PyObject *tmp_assign_source_68;
        tmp_assign_source_68 = MAKE_FUNCTION_OpenSSL$crypto$$$function_25_get_elliptic_curve();



        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_get_elliptic_curve, tmp_assign_source_68);
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_69;
        {
            PyObject *tmp_set_locals_3;
            tmp_set_locals_3 = PyDict_New();
            locals_OpenSSL$crypto_516 = tmp_set_locals_3;
        }
        tmp_dictset_value = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_516, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = const_str_digest_5a3f7f69104a4ed1267a21c950d94463;
        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_516, const_str_plain___doc__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_26___init__();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_516, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_27___setattr__();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_516, const_str_plain___setattr__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_28___getattr__();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_516, const_str_plain___getattr__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_29__cmp();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_516, const_str_plain__cmp, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_26554ef6367a9e88a5185ae01f6efee0_4, codeobj_26554ef6367a9e88a5185ae01f6efee0, module_OpenSSL$crypto, 0);
        frame_26554ef6367a9e88a5185ae01f6efee0_4 = cache_frame_26554ef6367a9e88a5185ae01f6efee0_4;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_26554ef6367a9e88a5185ae01f6efee0_4);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_26554ef6367a9e88a5185ae01f6efee0_4) == 2); // Frame stack

        // Framed code:
        {
            PyObject *tmp_called_name_8;
            PyObject *tmp_args_element_name_20;
            PyObject *tmp_mvar_value_16;
            tmp_called_name_8 = PyDict_GetItem(locals_OpenSSL$crypto_516, const_str_plain__cmp);

            if (tmp_called_name_8 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 4429 ], 26, 0);
                exception_tb = NULL;

                exception_lineno = 635;

                goto frame_exception_exit_4;
            }

            if (tmp_called_name_8 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 635;

                goto frame_exception_exit_4;
            }
            tmp_mvar_value_16 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___eq__);

            if (unlikely(tmp_mvar_value_16 == NULL)) {
                tmp_mvar_value_16 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain___eq__);
            }

            if (tmp_mvar_value_16 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 4455 ], 28, 0);
                exception_tb = NULL;

                exception_lineno = 635;

                goto frame_exception_exit_4;
            }

            tmp_args_element_name_20 = tmp_mvar_value_16;
            frame_26554ef6367a9e88a5185ae01f6efee0_4->m_frame.f_lineno = 635;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_8, tmp_args_element_name_20);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 635;

                goto frame_exception_exit_4;
            }
            tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_516, const_str_plain___eq__, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 635;

                goto frame_exception_exit_4;
            }
        }
        {
            PyObject *tmp_called_name_9;
            PyObject *tmp_args_element_name_21;
            PyObject *tmp_mvar_value_17;
            tmp_called_name_9 = PyDict_GetItem(locals_OpenSSL$crypto_516, const_str_plain__cmp);

            if (tmp_called_name_9 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 4429 ], 26, 0);
                exception_tb = NULL;

                exception_lineno = 636;

                goto frame_exception_exit_4;
            }

            if (tmp_called_name_9 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 636;

                goto frame_exception_exit_4;
            }
            tmp_mvar_value_17 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___ne__);

            if (unlikely(tmp_mvar_value_17 == NULL)) {
                tmp_mvar_value_17 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain___ne__);
            }

            if (tmp_mvar_value_17 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 4483 ], 28, 0);
                exception_tb = NULL;

                exception_lineno = 636;

                goto frame_exception_exit_4;
            }

            tmp_args_element_name_21 = tmp_mvar_value_17;
            frame_26554ef6367a9e88a5185ae01f6efee0_4->m_frame.f_lineno = 636;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_9, tmp_args_element_name_21);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 636;

                goto frame_exception_exit_4;
            }
            tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_516, const_str_plain___ne__, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 636;

                goto frame_exception_exit_4;
            }
        }
        {
            PyObject *tmp_called_name_10;
            PyObject *tmp_args_element_name_22;
            PyObject *tmp_mvar_value_18;
            tmp_called_name_10 = PyDict_GetItem(locals_OpenSSL$crypto_516, const_str_plain__cmp);

            if (tmp_called_name_10 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 4429 ], 26, 0);
                exception_tb = NULL;

                exception_lineno = 638;

                goto frame_exception_exit_4;
            }

            if (tmp_called_name_10 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 638;

                goto frame_exception_exit_4;
            }
            tmp_mvar_value_18 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___lt__);

            if (unlikely(tmp_mvar_value_18 == NULL)) {
                tmp_mvar_value_18 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain___lt__);
            }

            if (tmp_mvar_value_18 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 4511 ], 28, 0);
                exception_tb = NULL;

                exception_lineno = 638;

                goto frame_exception_exit_4;
            }

            tmp_args_element_name_22 = tmp_mvar_value_18;
            frame_26554ef6367a9e88a5185ae01f6efee0_4->m_frame.f_lineno = 638;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_10, tmp_args_element_name_22);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 638;

                goto frame_exception_exit_4;
            }
            tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_516, const_str_plain___lt__, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 638;

                goto frame_exception_exit_4;
            }
        }
        {
            PyObject *tmp_called_name_11;
            PyObject *tmp_args_element_name_23;
            PyObject *tmp_mvar_value_19;
            tmp_called_name_11 = PyDict_GetItem(locals_OpenSSL$crypto_516, const_str_plain__cmp);

            if (tmp_called_name_11 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 4429 ], 26, 0);
                exception_tb = NULL;

                exception_lineno = 639;

                goto frame_exception_exit_4;
            }

            if (tmp_called_name_11 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 639;

                goto frame_exception_exit_4;
            }
            tmp_mvar_value_19 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___le__);

            if (unlikely(tmp_mvar_value_19 == NULL)) {
                tmp_mvar_value_19 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain___le__);
            }

            if (tmp_mvar_value_19 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 4539 ], 28, 0);
                exception_tb = NULL;

                exception_lineno = 639;

                goto frame_exception_exit_4;
            }

            tmp_args_element_name_23 = tmp_mvar_value_19;
            frame_26554ef6367a9e88a5185ae01f6efee0_4->m_frame.f_lineno = 639;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_11, tmp_args_element_name_23);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 639;

                goto frame_exception_exit_4;
            }
            tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_516, const_str_plain___le__, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 639;

                goto frame_exception_exit_4;
            }
        }
        {
            PyObject *tmp_called_name_12;
            PyObject *tmp_args_element_name_24;
            PyObject *tmp_mvar_value_20;
            tmp_called_name_12 = PyDict_GetItem(locals_OpenSSL$crypto_516, const_str_plain__cmp);

            if (tmp_called_name_12 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 4429 ], 26, 0);
                exception_tb = NULL;

                exception_lineno = 641;

                goto frame_exception_exit_4;
            }

            if (tmp_called_name_12 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 641;

                goto frame_exception_exit_4;
            }
            tmp_mvar_value_20 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___gt__);

            if (unlikely(tmp_mvar_value_20 == NULL)) {
                tmp_mvar_value_20 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain___gt__);
            }

            if (tmp_mvar_value_20 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 4567 ], 28, 0);
                exception_tb = NULL;

                exception_lineno = 641;

                goto frame_exception_exit_4;
            }

            tmp_args_element_name_24 = tmp_mvar_value_20;
            frame_26554ef6367a9e88a5185ae01f6efee0_4->m_frame.f_lineno = 641;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_12, tmp_args_element_name_24);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 641;

                goto frame_exception_exit_4;
            }
            tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_516, const_str_plain___gt__, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 641;

                goto frame_exception_exit_4;
            }
        }
        {
            PyObject *tmp_called_name_13;
            PyObject *tmp_args_element_name_25;
            PyObject *tmp_mvar_value_21;
            tmp_called_name_13 = PyDict_GetItem(locals_OpenSSL$crypto_516, const_str_plain__cmp);

            if (tmp_called_name_13 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 4429 ], 26, 0);
                exception_tb = NULL;

                exception_lineno = 642;

                goto frame_exception_exit_4;
            }

            if (tmp_called_name_13 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 642;

                goto frame_exception_exit_4;
            }
            tmp_mvar_value_21 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___ge__);

            if (unlikely(tmp_mvar_value_21 == NULL)) {
                tmp_mvar_value_21 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain___ge__);
            }

            if (tmp_mvar_value_21 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 4595 ], 28, 0);
                exception_tb = NULL;

                exception_lineno = 642;

                goto frame_exception_exit_4;
            }

            tmp_args_element_name_25 = tmp_mvar_value_21;
            frame_26554ef6367a9e88a5185ae01f6efee0_4->m_frame.f_lineno = 642;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_13, tmp_args_element_name_25);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 642;

                goto frame_exception_exit_4;
            }
            tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_516, const_str_plain___ge__, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 642;

                goto frame_exception_exit_4;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_26554ef6367a9e88a5185ae01f6efee0_4);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_3;

        frame_exception_exit_4:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_26554ef6367a9e88a5185ae01f6efee0_4);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_26554ef6367a9e88a5185ae01f6efee0_4, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_26554ef6367a9e88a5185ae01f6efee0_4->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_26554ef6367a9e88a5185ae01f6efee0_4, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_26554ef6367a9e88a5185ae01f6efee0_4,
            type_description_2
        );


        // Release cached frame.
        if (frame_26554ef6367a9e88a5185ae01f6efee0_4 == cache_frame_26554ef6367a9e88a5185ae01f6efee0_4) {
            Py_DECREF(frame_26554ef6367a9e88a5185ae01f6efee0_4);
        }
        cache_frame_26554ef6367a9e88a5185ae01f6efee0_4 = NULL;

        assertFrameObject(frame_26554ef6367a9e88a5185ae01f6efee0_4);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_3;

        frame_no_exception_3:;
        goto skip_nested_handling_3;
        nested_frame_exit_3:;

        goto try_except_handler_12;
        skip_nested_handling_3:;
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_30___repr__();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_516, const_str_plain___repr__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_31_hash();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_516, const_str_plain_hash, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_32_der();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_516, const_str_plain_der, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_33_get_components();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_516, const_str_plain_get_components, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_assign_source_69 = locals_OpenSSL$crypto_516;
        Py_INCREF(tmp_assign_source_69);
        goto try_return_handler_12;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$crypto);
        return NULL;
        // Return handler code:
        try_return_handler_12:;
        Py_DECREF(locals_OpenSSL$crypto_516);
        locals_OpenSSL$crypto_516 = NULL;
        goto outline_result_4;
        // Exception handler code:
        try_except_handler_12:;
        exception_keeper_type_10 = exception_type;
        exception_keeper_value_10 = exception_value;
        exception_keeper_tb_10 = exception_tb;
        exception_keeper_lineno_10 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_OpenSSL$crypto_516);
        locals_OpenSSL$crypto_516 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_10;
        exception_value = exception_keeper_value_10;
        exception_tb = exception_keeper_tb_10;
        exception_lineno = exception_keeper_lineno_10;

        goto outline_exception_3;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$crypto);
        return NULL;
        outline_exception_3:;
        exception_lineno = 516;
        goto try_except_handler_11;
        outline_result_4:;
        assert(tmp_class_creation_5__class_dict == NULL);
        tmp_class_creation_5__class_dict = tmp_assign_source_69;
    }
    {
        PyObject *tmp_assign_source_70;
        nuitka_bool tmp_condition_result_6;
        PyObject *tmp_key_name_9;
        PyObject *tmp_dict_name_9;
        PyObject *tmp_dict_name_10;
        PyObject *tmp_key_name_10;
        tmp_key_name_9 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_5__class_dict);
        tmp_dict_name_9 = tmp_class_creation_5__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_9, tmp_key_name_9);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 516;

            goto try_except_handler_11;
        }
        tmp_condition_result_6 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_6 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_5;
        } else {
            goto condexpr_false_5;
        }
        condexpr_true_5:;
        CHECK_OBJECT(tmp_class_creation_5__class_dict);
        tmp_dict_name_10 = tmp_class_creation_5__class_dict;
        tmp_key_name_10 = const_str_plain___metaclass__;
        tmp_assign_source_70 = DICT_GET_ITEM(tmp_dict_name_10, tmp_key_name_10);
        if (tmp_assign_source_70 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 516;

            goto try_except_handler_11;
        }
        goto condexpr_end_5;
        condexpr_false_5:;
        tmp_assign_source_70 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_70);
        condexpr_end_5:;
        assert(tmp_class_creation_5__metaclass == NULL);
        tmp_class_creation_5__metaclass = tmp_assign_source_70;
    }
    {
        PyObject *tmp_assign_source_71;
        PyObject *tmp_called_name_14;
        PyObject *tmp_args_element_name_26;
        PyObject *tmp_args_element_name_27;
        PyObject *tmp_args_element_name_28;
        CHECK_OBJECT(tmp_class_creation_5__metaclass);
        tmp_called_name_14 = tmp_class_creation_5__metaclass;
        tmp_args_element_name_26 = const_str_plain_X509Name;
        tmp_args_element_name_27 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_5__class_dict);
        tmp_args_element_name_28 = tmp_class_creation_5__class_dict;
        frame_d796a9417638ea0fc15dcdcd73475757->m_frame.f_lineno = 516;
        {
            PyObject *call_args[] = {tmp_args_element_name_26, tmp_args_element_name_27, tmp_args_element_name_28};
            tmp_assign_source_71 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_14, call_args);
        }

        if (tmp_assign_source_71 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 516;

            goto try_except_handler_11;
        }
        assert(tmp_class_creation_5__class == NULL);
        tmp_class_creation_5__class = tmp_assign_source_71;
    }
    goto try_end_8;
    // Exception handler code:
    try_except_handler_11:;
    exception_keeper_type_11 = exception_type;
    exception_keeper_value_11 = exception_value;
    exception_keeper_tb_11 = exception_tb;
    exception_keeper_lineno_11 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_5__class_dict);
    tmp_class_creation_5__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_5__metaclass);
    tmp_class_creation_5__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_11;
    exception_value = exception_keeper_value_11;
    exception_tb = exception_keeper_tb_11;
    exception_lineno = exception_keeper_lineno_11;

    goto frame_exception_exit_1;
    // End of try:
    try_end_8:;
    {
        PyObject *tmp_assign_source_72;
        CHECK_OBJECT(tmp_class_creation_5__class);
        tmp_assign_source_72 = tmp_class_creation_5__class;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Name, tmp_assign_source_72);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_5__class);
    Py_DECREF(tmp_class_creation_5__class);
    tmp_class_creation_5__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_5__class_dict);
    Py_DECREF(tmp_class_creation_5__class_dict);
    tmp_class_creation_5__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_5__metaclass);
    Py_DECREF(tmp_class_creation_5__metaclass);
    tmp_class_creation_5__metaclass = NULL;

    {
        PyObject *tmp_assign_source_73;
        PyObject *tmp_called_name_15;
        PyObject *tmp_mvar_value_22;
        PyObject *tmp_args_element_name_29;
        PyObject *tmp_mvar_value_23;
        PyObject *tmp_args_element_name_30;
        PyObject *tmp_args_element_name_31;
        PyObject *tmp_args_element_name_32;
        PyObject *tmp_mvar_value_24;
        tmp_mvar_value_22 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_deprecated);

        if (unlikely(tmp_mvar_value_22 == NULL)) {
            tmp_mvar_value_22 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_deprecated);
        }

        if (tmp_mvar_value_22 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 2548 ], 32, 0);
            exception_tb = NULL;

            exception_lineno = 709;

            goto frame_exception_exit_1;
        }

        tmp_called_name_15 = tmp_mvar_value_22;
        tmp_mvar_value_23 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Name);

        if (unlikely(tmp_mvar_value_23 == NULL)) {
            tmp_mvar_value_23 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Name);
        }

        if (tmp_mvar_value_23 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1112 ], 30, 0);
            exception_tb = NULL;

            exception_lineno = 710;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_29 = tmp_mvar_value_23;
        tmp_args_element_name_30 = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
        tmp_args_element_name_31 = const_str_digest_ee89bc744832ab3afc27c4e7a4a73b66;
        tmp_mvar_value_24 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_DeprecationWarning);

        if (unlikely(tmp_mvar_value_24 == NULL)) {
            tmp_mvar_value_24 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_DeprecationWarning);
        }

        if (tmp_mvar_value_24 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 2580 ], 40, 0);
            exception_tb = NULL;

            exception_lineno = 712;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_32 = tmp_mvar_value_24;
        frame_d796a9417638ea0fc15dcdcd73475757->m_frame.f_lineno = 709;
        {
            PyObject *call_args[] = {tmp_args_element_name_29, tmp_args_element_name_30, tmp_args_element_name_31, tmp_args_element_name_32};
            tmp_assign_source_73 = CALL_FUNCTION_WITH_ARGS4(tmp_called_name_15, call_args);
        }

        if (tmp_assign_source_73 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 709;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509NameType, tmp_assign_source_73);
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_74;
        {
            PyObject *tmp_set_locals_4;
            tmp_set_locals_4 = PyDict_New();
            locals_OpenSSL$crypto_716 = tmp_set_locals_4;
        }
        tmp_dictset_value = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_716, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = const_str_digest_b52a484c26b348bfec0a17217a58ad7e;
        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_716, const_str_plain___doc__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        {
            PyObject *tmp_defaults_2;
            tmp_defaults_2 = const_tuple_none_none_tuple;
            Py_INCREF(tmp_defaults_2);
            tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_34___init__(tmp_defaults_2);



            tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_716, const_str_plain___init__, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            assert(!(tmp_res != 0));
        }
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_584960adc98f2327e7352a334ee7240a_5, codeobj_584960adc98f2327e7352a334ee7240a, module_OpenSSL$crypto, 0);
        frame_584960adc98f2327e7352a334ee7240a_5 = cache_frame_584960adc98f2327e7352a334ee7240a_5;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_584960adc98f2327e7352a334ee7240a_5);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_584960adc98f2327e7352a334ee7240a_5) == 2); // Frame stack

        // Framed code:
        {
            PyObject *tmp_called_name_16;
            PyObject *tmp_args_element_name_33;
            tmp_called_name_16 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_33 = MAKE_FUNCTION_OpenSSL$crypto$$$function_35__nid();



            frame_584960adc98f2327e7352a334ee7240a_5->m_frame.f_lineno = 782;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_16, tmp_args_element_name_33);
            Py_DECREF(tmp_args_element_name_33);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 782;

                goto frame_exception_exit_5;
            }
            tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_716, const_str_plain__nid, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 782;

                goto frame_exception_exit_5;
            }
        }
        {
            PyObject *tmp_dict_key_5;
            PyObject *tmp_dict_value_5;
            PyObject *tmp_source_name_7;
            PyObject *tmp_mvar_value_25;
            PyObject *tmp_dict_key_6;
            PyObject *tmp_dict_value_6;
            PyObject *tmp_source_name_8;
            PyObject *tmp_mvar_value_26;
            PyObject *tmp_dict_key_7;
            PyObject *tmp_dict_value_7;
            PyObject *tmp_source_name_9;
            PyObject *tmp_mvar_value_27;
            tmp_dict_value_5 = const_str_plain_email;
            tmp_mvar_value_25 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_25 == NULL)) {
                tmp_mvar_value_25 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_25 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
                exception_tb = NULL;

                exception_lineno = 789;

                goto frame_exception_exit_5;
            }

            tmp_source_name_7 = tmp_mvar_value_25;
            tmp_dict_key_5 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain_GEN_EMAIL);
            if (tmp_dict_key_5 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 789;

                goto frame_exception_exit_5;
            }
            tmp_dictset_value = _PyDict_NewPresized( 3 );
            tmp_res = PyDict_SetItem(tmp_dictset_value, tmp_dict_key_5, tmp_dict_value_5);
            Py_DECREF(tmp_dict_key_5);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_dictset_value);

                exception_lineno = 788;

                goto frame_exception_exit_5;
            }
            tmp_dict_value_6 = const_str_plain_DNS;
            tmp_mvar_value_26 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_26 == NULL)) {
                tmp_mvar_value_26 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_26 == NULL) {
                Py_DECREF(tmp_dictset_value);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
                exception_tb = NULL;

                exception_lineno = 790;

                goto frame_exception_exit_5;
            }

            tmp_source_name_8 = tmp_mvar_value_26;
            tmp_dict_key_6 = LOOKUP_ATTRIBUTE(tmp_source_name_8, const_str_plain_GEN_DNS);
            if (tmp_dict_key_6 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_dictset_value);

                exception_lineno = 790;

                goto frame_exception_exit_5;
            }
            tmp_res = PyDict_SetItem(tmp_dictset_value, tmp_dict_key_6, tmp_dict_value_6);
            Py_DECREF(tmp_dict_key_6);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_dictset_value);

                exception_lineno = 788;

                goto frame_exception_exit_5;
            }
            tmp_dict_value_7 = const_str_plain_URI;
            tmp_mvar_value_27 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_27 == NULL)) {
                tmp_mvar_value_27 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_27 == NULL) {
                Py_DECREF(tmp_dictset_value);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
                exception_tb = NULL;

                exception_lineno = 791;

                goto frame_exception_exit_5;
            }

            tmp_source_name_9 = tmp_mvar_value_27;
            tmp_dict_key_7 = LOOKUP_ATTRIBUTE(tmp_source_name_9, const_str_plain_GEN_URI);
            if (tmp_dict_key_7 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_dictset_value);

                exception_lineno = 791;

                goto frame_exception_exit_5;
            }
            tmp_res = PyDict_SetItem(tmp_dictset_value, tmp_dict_key_7, tmp_dict_value_7);
            Py_DECREF(tmp_dict_key_7);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_dictset_value);

                exception_lineno = 788;

                goto frame_exception_exit_5;
            }
            tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_716, const_str_plain__prefixes, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 788;

                goto frame_exception_exit_5;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_584960adc98f2327e7352a334ee7240a_5);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_4;

        frame_exception_exit_5:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_584960adc98f2327e7352a334ee7240a_5);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_584960adc98f2327e7352a334ee7240a_5, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_584960adc98f2327e7352a334ee7240a_5->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_584960adc98f2327e7352a334ee7240a_5, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_584960adc98f2327e7352a334ee7240a_5,
            type_description_2
        );


        // Release cached frame.
        if (frame_584960adc98f2327e7352a334ee7240a_5 == cache_frame_584960adc98f2327e7352a334ee7240a_5) {
            Py_DECREF(frame_584960adc98f2327e7352a334ee7240a_5);
        }
        cache_frame_584960adc98f2327e7352a334ee7240a_5 = NULL;

        assertFrameObject(frame_584960adc98f2327e7352a334ee7240a_5);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_4;

        frame_no_exception_4:;
        goto skip_nested_handling_4;
        nested_frame_exit_4:;

        goto try_except_handler_14;
        skip_nested_handling_4:;
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_36__subjectAltNameString();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_716, const_str_plain__subjectAltNameString, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_37___str__();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_716, const_str_plain___str__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_38_get_critical();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_716, const_str_plain_get_critical, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_39_get_short_name();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_716, const_str_plain_get_short_name, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_40_get_data();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_716, const_str_plain_get_data, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_assign_source_74 = locals_OpenSSL$crypto_716;
        Py_INCREF(tmp_assign_source_74);
        goto try_return_handler_14;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$crypto);
        return NULL;
        // Return handler code:
        try_return_handler_14:;
        Py_DECREF(locals_OpenSSL$crypto_716);
        locals_OpenSSL$crypto_716 = NULL;
        goto outline_result_5;
        // Exception handler code:
        try_except_handler_14:;
        exception_keeper_type_12 = exception_type;
        exception_keeper_value_12 = exception_value;
        exception_keeper_tb_12 = exception_tb;
        exception_keeper_lineno_12 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_OpenSSL$crypto_716);
        locals_OpenSSL$crypto_716 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_12;
        exception_value = exception_keeper_value_12;
        exception_tb = exception_keeper_tb_12;
        exception_lineno = exception_keeper_lineno_12;

        goto outline_exception_4;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$crypto);
        return NULL;
        outline_exception_4:;
        exception_lineno = 716;
        goto try_except_handler_13;
        outline_result_5:;
        assert(tmp_class_creation_6__class_dict == NULL);
        tmp_class_creation_6__class_dict = tmp_assign_source_74;
    }
    {
        PyObject *tmp_assign_source_75;
        nuitka_bool tmp_condition_result_7;
        PyObject *tmp_key_name_11;
        PyObject *tmp_dict_name_11;
        PyObject *tmp_dict_name_12;
        PyObject *tmp_key_name_12;
        tmp_key_name_11 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_6__class_dict);
        tmp_dict_name_11 = tmp_class_creation_6__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_11, tmp_key_name_11);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 716;

            goto try_except_handler_13;
        }
        tmp_condition_result_7 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_7 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_6;
        } else {
            goto condexpr_false_6;
        }
        condexpr_true_6:;
        CHECK_OBJECT(tmp_class_creation_6__class_dict);
        tmp_dict_name_12 = tmp_class_creation_6__class_dict;
        tmp_key_name_12 = const_str_plain___metaclass__;
        tmp_assign_source_75 = DICT_GET_ITEM(tmp_dict_name_12, tmp_key_name_12);
        if (tmp_assign_source_75 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 716;

            goto try_except_handler_13;
        }
        goto condexpr_end_6;
        condexpr_false_6:;
        tmp_assign_source_75 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_75);
        condexpr_end_6:;
        assert(tmp_class_creation_6__metaclass == NULL);
        tmp_class_creation_6__metaclass = tmp_assign_source_75;
    }
    {
        PyObject *tmp_assign_source_76;
        PyObject *tmp_called_name_17;
        PyObject *tmp_args_element_name_34;
        PyObject *tmp_args_element_name_35;
        PyObject *tmp_args_element_name_36;
        CHECK_OBJECT(tmp_class_creation_6__metaclass);
        tmp_called_name_17 = tmp_class_creation_6__metaclass;
        tmp_args_element_name_34 = const_str_plain_X509Extension;
        tmp_args_element_name_35 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_6__class_dict);
        tmp_args_element_name_36 = tmp_class_creation_6__class_dict;
        frame_d796a9417638ea0fc15dcdcd73475757->m_frame.f_lineno = 716;
        {
            PyObject *call_args[] = {tmp_args_element_name_34, tmp_args_element_name_35, tmp_args_element_name_36};
            tmp_assign_source_76 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_17, call_args);
        }

        if (tmp_assign_source_76 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 716;

            goto try_except_handler_13;
        }
        assert(tmp_class_creation_6__class == NULL);
        tmp_class_creation_6__class = tmp_assign_source_76;
    }
    goto try_end_9;
    // Exception handler code:
    try_except_handler_13:;
    exception_keeper_type_13 = exception_type;
    exception_keeper_value_13 = exception_value;
    exception_keeper_tb_13 = exception_tb;
    exception_keeper_lineno_13 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_6__class_dict);
    tmp_class_creation_6__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_6__metaclass);
    tmp_class_creation_6__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_13;
    exception_value = exception_keeper_value_13;
    exception_tb = exception_keeper_tb_13;
    exception_lineno = exception_keeper_lineno_13;

    goto frame_exception_exit_1;
    // End of try:
    try_end_9:;
    {
        PyObject *tmp_assign_source_77;
        CHECK_OBJECT(tmp_class_creation_6__class);
        tmp_assign_source_77 = tmp_class_creation_6__class;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Extension, tmp_assign_source_77);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_6__class);
    Py_DECREF(tmp_class_creation_6__class);
    tmp_class_creation_6__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_6__class_dict);
    Py_DECREF(tmp_class_creation_6__class_dict);
    tmp_class_creation_6__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_6__metaclass);
    Py_DECREF(tmp_class_creation_6__metaclass);
    tmp_class_creation_6__metaclass = NULL;

    {
        PyObject *tmp_assign_source_78;
        PyObject *tmp_called_name_18;
        PyObject *tmp_mvar_value_28;
        PyObject *tmp_args_element_name_37;
        PyObject *tmp_mvar_value_29;
        PyObject *tmp_args_element_name_38;
        PyObject *tmp_args_element_name_39;
        PyObject *tmp_args_element_name_40;
        PyObject *tmp_mvar_value_30;
        tmp_mvar_value_28 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_deprecated);

        if (unlikely(tmp_mvar_value_28 == NULL)) {
            tmp_mvar_value_28 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_deprecated);
        }

        if (tmp_mvar_value_28 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 2548 ], 32, 0);
            exception_tb = NULL;

            exception_lineno = 867;

            goto frame_exception_exit_1;
        }

        tmp_called_name_18 = tmp_mvar_value_28;
        tmp_mvar_value_29 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Extension);

        if (unlikely(tmp_mvar_value_29 == NULL)) {
            tmp_mvar_value_29 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Extension);
        }

        if (tmp_mvar_value_29 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 3715 ], 35, 0);
            exception_tb = NULL;

            exception_lineno = 868;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_37 = tmp_mvar_value_29;
        tmp_args_element_name_38 = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
        tmp_args_element_name_39 = const_str_digest_3918253e50729a002fea544312970ff5;
        tmp_mvar_value_30 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_DeprecationWarning);

        if (unlikely(tmp_mvar_value_30 == NULL)) {
            tmp_mvar_value_30 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_DeprecationWarning);
        }

        if (tmp_mvar_value_30 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 2580 ], 40, 0);
            exception_tb = NULL;

            exception_lineno = 870;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_40 = tmp_mvar_value_30;
        frame_d796a9417638ea0fc15dcdcd73475757->m_frame.f_lineno = 867;
        {
            PyObject *call_args[] = {tmp_args_element_name_37, tmp_args_element_name_38, tmp_args_element_name_39, tmp_args_element_name_40};
            tmp_assign_source_78 = CALL_FUNCTION_WITH_ARGS4(tmp_called_name_18, call_args);
        }

        if (tmp_assign_source_78 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 867;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509ExtensionType, tmp_assign_source_78);
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_79;
        {
            PyObject *tmp_set_locals_5;
            tmp_set_locals_5 = PyDict_New();
            locals_OpenSSL$crypto_874 = tmp_set_locals_5;
        }
        tmp_dictset_value = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_874, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = const_str_digest_9226325aac109a91f8326c1a26ede065;
        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_874, const_str_plain___doc__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_41___init__();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_874, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_42_to_cryptography();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_874, const_str_plain_to_cryptography, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_b729aae3be3cb5ee6312ba7b28f48a0d_6, codeobj_b729aae3be3cb5ee6312ba7b28f48a0d, module_OpenSSL$crypto, 0);
        frame_b729aae3be3cb5ee6312ba7b28f48a0d_6 = cache_frame_b729aae3be3cb5ee6312ba7b28f48a0d_6;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_b729aae3be3cb5ee6312ba7b28f48a0d_6);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_b729aae3be3cb5ee6312ba7b28f48a0d_6) == 2); // Frame stack

        // Framed code:
        {
            PyObject *tmp_classmethod_arg_5;
            tmp_classmethod_arg_5 = MAKE_FUNCTION_OpenSSL$crypto$$$function_43_from_cryptography();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_5);
            Py_DECREF(tmp_classmethod_arg_5);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 899;

                goto frame_exception_exit_6;
            }
            tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_874, const_str_plain_from_cryptography, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 899;

                goto frame_exception_exit_6;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_b729aae3be3cb5ee6312ba7b28f48a0d_6);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_5;

        frame_exception_exit_6:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_b729aae3be3cb5ee6312ba7b28f48a0d_6);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_b729aae3be3cb5ee6312ba7b28f48a0d_6, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_b729aae3be3cb5ee6312ba7b28f48a0d_6->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_b729aae3be3cb5ee6312ba7b28f48a0d_6, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_b729aae3be3cb5ee6312ba7b28f48a0d_6,
            type_description_2
        );


        // Release cached frame.
        if (frame_b729aae3be3cb5ee6312ba7b28f48a0d_6 == cache_frame_b729aae3be3cb5ee6312ba7b28f48a0d_6) {
            Py_DECREF(frame_b729aae3be3cb5ee6312ba7b28f48a0d_6);
        }
        cache_frame_b729aae3be3cb5ee6312ba7b28f48a0d_6 = NULL;

        assertFrameObject(frame_b729aae3be3cb5ee6312ba7b28f48a0d_6);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_5;

        frame_no_exception_5:;
        goto skip_nested_handling_5;
        nested_frame_exit_5:;

        goto try_except_handler_16;
        skip_nested_handling_5:;
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_44_set_pubkey();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_874, const_str_plain_set_pubkey, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_45_get_pubkey();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_874, const_str_plain_get_pubkey, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_46_set_version();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_874, const_str_plain_set_version, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_47_get_version();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_874, const_str_plain_get_version, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_48_get_subject();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_874, const_str_plain_get_subject, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_49_add_extensions();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_874, const_str_plain_add_extensions, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_50_get_extensions();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_874, const_str_plain_get_extensions, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_51_sign();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_874, const_str_plain_sign, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_52_verify();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_874, const_str_plain_verify, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_assign_source_79 = locals_OpenSSL$crypto_874;
        Py_INCREF(tmp_assign_source_79);
        goto try_return_handler_16;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$crypto);
        return NULL;
        // Return handler code:
        try_return_handler_16:;
        Py_DECREF(locals_OpenSSL$crypto_874);
        locals_OpenSSL$crypto_874 = NULL;
        goto outline_result_6;
        // Exception handler code:
        try_except_handler_16:;
        exception_keeper_type_14 = exception_type;
        exception_keeper_value_14 = exception_value;
        exception_keeper_tb_14 = exception_tb;
        exception_keeper_lineno_14 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_OpenSSL$crypto_874);
        locals_OpenSSL$crypto_874 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_14;
        exception_value = exception_keeper_value_14;
        exception_tb = exception_keeper_tb_14;
        exception_lineno = exception_keeper_lineno_14;

        goto outline_exception_5;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$crypto);
        return NULL;
        outline_exception_5:;
        exception_lineno = 874;
        goto try_except_handler_15;
        outline_result_6:;
        assert(tmp_class_creation_7__class_dict == NULL);
        tmp_class_creation_7__class_dict = tmp_assign_source_79;
    }
    {
        PyObject *tmp_assign_source_80;
        nuitka_bool tmp_condition_result_8;
        PyObject *tmp_key_name_13;
        PyObject *tmp_dict_name_13;
        PyObject *tmp_dict_name_14;
        PyObject *tmp_key_name_14;
        tmp_key_name_13 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_7__class_dict);
        tmp_dict_name_13 = tmp_class_creation_7__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_13, tmp_key_name_13);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 874;

            goto try_except_handler_15;
        }
        tmp_condition_result_8 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_8 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_7;
        } else {
            goto condexpr_false_7;
        }
        condexpr_true_7:;
        CHECK_OBJECT(tmp_class_creation_7__class_dict);
        tmp_dict_name_14 = tmp_class_creation_7__class_dict;
        tmp_key_name_14 = const_str_plain___metaclass__;
        tmp_assign_source_80 = DICT_GET_ITEM(tmp_dict_name_14, tmp_key_name_14);
        if (tmp_assign_source_80 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 874;

            goto try_except_handler_15;
        }
        goto condexpr_end_7;
        condexpr_false_7:;
        tmp_assign_source_80 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_80);
        condexpr_end_7:;
        assert(tmp_class_creation_7__metaclass == NULL);
        tmp_class_creation_7__metaclass = tmp_assign_source_80;
    }
    {
        PyObject *tmp_assign_source_81;
        PyObject *tmp_called_name_19;
        PyObject *tmp_args_element_name_41;
        PyObject *tmp_args_element_name_42;
        PyObject *tmp_args_element_name_43;
        CHECK_OBJECT(tmp_class_creation_7__metaclass);
        tmp_called_name_19 = tmp_class_creation_7__metaclass;
        tmp_args_element_name_41 = const_str_plain_X509Req;
        tmp_args_element_name_42 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_7__class_dict);
        tmp_args_element_name_43 = tmp_class_creation_7__class_dict;
        frame_d796a9417638ea0fc15dcdcd73475757->m_frame.f_lineno = 874;
        {
            PyObject *call_args[] = {tmp_args_element_name_41, tmp_args_element_name_42, tmp_args_element_name_43};
            tmp_assign_source_81 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_19, call_args);
        }

        if (tmp_assign_source_81 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 874;

            goto try_except_handler_15;
        }
        assert(tmp_class_creation_7__class == NULL);
        tmp_class_creation_7__class = tmp_assign_source_81;
    }
    goto try_end_10;
    // Exception handler code:
    try_except_handler_15:;
    exception_keeper_type_15 = exception_type;
    exception_keeper_value_15 = exception_value;
    exception_keeper_tb_15 = exception_tb;
    exception_keeper_lineno_15 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_7__class_dict);
    tmp_class_creation_7__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_7__metaclass);
    tmp_class_creation_7__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_15;
    exception_value = exception_keeper_value_15;
    exception_tb = exception_keeper_tb_15;
    exception_lineno = exception_keeper_lineno_15;

    goto frame_exception_exit_1;
    // End of try:
    try_end_10:;
    {
        PyObject *tmp_assign_source_82;
        CHECK_OBJECT(tmp_class_creation_7__class);
        tmp_assign_source_82 = tmp_class_creation_7__class;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Req, tmp_assign_source_82);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_7__class);
    Py_DECREF(tmp_class_creation_7__class);
    tmp_class_creation_7__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_7__class_dict);
    Py_DECREF(tmp_class_creation_7__class_dict);
    tmp_class_creation_7__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_7__metaclass);
    Py_DECREF(tmp_class_creation_7__metaclass);
    tmp_class_creation_7__metaclass = NULL;

    {
        PyObject *tmp_assign_source_83;
        PyObject *tmp_called_name_20;
        PyObject *tmp_mvar_value_31;
        PyObject *tmp_args_element_name_44;
        PyObject *tmp_mvar_value_32;
        PyObject *tmp_args_element_name_45;
        PyObject *tmp_args_element_name_46;
        PyObject *tmp_args_element_name_47;
        PyObject *tmp_mvar_value_33;
        tmp_mvar_value_31 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_deprecated);

        if (unlikely(tmp_mvar_value_31 == NULL)) {
            tmp_mvar_value_31 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_deprecated);
        }

        if (tmp_mvar_value_31 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 2548 ], 32, 0);
            exception_tb = NULL;

            exception_lineno = 1073;

            goto frame_exception_exit_1;
        }

        tmp_called_name_20 = tmp_mvar_value_31;
        tmp_mvar_value_32 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Req);

        if (unlikely(tmp_mvar_value_32 == NULL)) {
            tmp_mvar_value_32 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Req);
        }

        if (tmp_mvar_value_32 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 4273 ], 29, 0);
            exception_tb = NULL;

            exception_lineno = 1074;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_44 = tmp_mvar_value_32;
        tmp_args_element_name_45 = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
        tmp_args_element_name_46 = const_str_digest_4d148c7b7c1bc2fec101962dc1ce2c2f;
        tmp_mvar_value_33 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_DeprecationWarning);

        if (unlikely(tmp_mvar_value_33 == NULL)) {
            tmp_mvar_value_33 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_DeprecationWarning);
        }

        if (tmp_mvar_value_33 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 2580 ], 40, 0);
            exception_tb = NULL;

            exception_lineno = 1076;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_47 = tmp_mvar_value_33;
        frame_d796a9417638ea0fc15dcdcd73475757->m_frame.f_lineno = 1073;
        {
            PyObject *call_args[] = {tmp_args_element_name_44, tmp_args_element_name_45, tmp_args_element_name_46, tmp_args_element_name_47};
            tmp_assign_source_83 = CALL_FUNCTION_WITH_ARGS4(tmp_called_name_20, call_args);
        }

        if (tmp_assign_source_83 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1073;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509ReqType, tmp_assign_source_83);
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_84;
        {
            PyObject *tmp_set_locals_6;
            tmp_set_locals_6 = PyDict_New();
            locals_OpenSSL$crypto_1080 = tmp_set_locals_6;
        }
        tmp_dictset_value = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1080, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = const_str_digest_2cf9e4c7f607857df636a128997ff3fc;
        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1080, const_str_plain___doc__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_53___init__();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1080, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_e48c7ada7caf70ebce53c5531940cfed_7, codeobj_e48c7ada7caf70ebce53c5531940cfed, module_OpenSSL$crypto, 0);
        frame_e48c7ada7caf70ebce53c5531940cfed_7 = cache_frame_e48c7ada7caf70ebce53c5531940cfed_7;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_e48c7ada7caf70ebce53c5531940cfed_7);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_e48c7ada7caf70ebce53c5531940cfed_7) == 2); // Frame stack

        // Framed code:
        {
            PyObject *tmp_classmethod_arg_6;
            tmp_classmethod_arg_6 = MAKE_FUNCTION_OpenSSL$crypto$$$function_54__from_raw_x509_ptr();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_6);
            Py_DECREF(tmp_classmethod_arg_6);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1092;

                goto frame_exception_exit_7;
            }
            tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1080, const_str_plain__from_raw_x509_ptr, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1092;

                goto frame_exception_exit_7;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_55_to_cryptography();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1080, const_str_plain_to_cryptography, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        {
            PyObject *tmp_classmethod_arg_7;
            tmp_classmethod_arg_7 = MAKE_FUNCTION_OpenSSL$crypto$$$function_56_from_cryptography();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_7);
            Py_DECREF(tmp_classmethod_arg_7);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1112;

                goto frame_exception_exit_7;
            }
            tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1080, const_str_plain_from_cryptography, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1112;

                goto frame_exception_exit_7;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_e48c7ada7caf70ebce53c5531940cfed_7);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_6;

        frame_exception_exit_7:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_e48c7ada7caf70ebce53c5531940cfed_7);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_e48c7ada7caf70ebce53c5531940cfed_7, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_e48c7ada7caf70ebce53c5531940cfed_7->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_e48c7ada7caf70ebce53c5531940cfed_7, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_e48c7ada7caf70ebce53c5531940cfed_7,
            type_description_2
        );


        // Release cached frame.
        if (frame_e48c7ada7caf70ebce53c5531940cfed_7 == cache_frame_e48c7ada7caf70ebce53c5531940cfed_7) {
            Py_DECREF(frame_e48c7ada7caf70ebce53c5531940cfed_7);
        }
        cache_frame_e48c7ada7caf70ebce53c5531940cfed_7 = NULL;

        assertFrameObject(frame_e48c7ada7caf70ebce53c5531940cfed_7);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_6;

        frame_no_exception_6:;
        goto skip_nested_handling_6;
        nested_frame_exit_6:;

        goto try_except_handler_18;
        skip_nested_handling_6:;
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_57_set_version();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1080, const_str_plain_set_version, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_58_get_version();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1080, const_str_plain_get_version, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_59_get_pubkey();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1080, const_str_plain_get_pubkey, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_60_set_pubkey();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1080, const_str_plain_set_pubkey, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_61_sign();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1080, const_str_plain_sign, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_62_get_signature_algorithm();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1080, const_str_plain_get_signature_algorithm, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_63_digest();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1080, const_str_plain_digest, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_64_subject_name_hash();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1080, const_str_plain_subject_name_hash, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_65_set_serial_number();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1080, const_str_plain_set_serial_number, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_66_get_serial_number();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1080, const_str_plain_get_serial_number, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_67_gmtime_adj_notAfter();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1080, const_str_plain_gmtime_adj_notAfter, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_68_gmtime_adj_notBefore();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1080, const_str_plain_gmtime_adj_notBefore, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_69_has_expired();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1080, const_str_plain_has_expired, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_70__get_boundary_time();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1080, const_str_plain__get_boundary_time, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_71_get_notBefore();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1080, const_str_plain_get_notBefore, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_72__set_boundary_time();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1080, const_str_plain__set_boundary_time, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_73_set_notBefore();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1080, const_str_plain_set_notBefore, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_74_get_notAfter();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1080, const_str_plain_get_notAfter, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_75_set_notAfter();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1080, const_str_plain_set_notAfter, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_76__get_name();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1080, const_str_plain__get_name, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_77__set_name();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1080, const_str_plain__set_name, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_78_get_issuer();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1080, const_str_plain_get_issuer, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_79_set_issuer();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1080, const_str_plain_set_issuer, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_80_get_subject();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1080, const_str_plain_get_subject, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_81_set_subject();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1080, const_str_plain_set_subject, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_82_get_extension_count();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1080, const_str_plain_get_extension_count, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_83_add_extensions();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1080, const_str_plain_add_extensions, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_84_get_extension();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1080, const_str_plain_get_extension, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_assign_source_84 = locals_OpenSSL$crypto_1080;
        Py_INCREF(tmp_assign_source_84);
        goto try_return_handler_18;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$crypto);
        return NULL;
        // Return handler code:
        try_return_handler_18:;
        Py_DECREF(locals_OpenSSL$crypto_1080);
        locals_OpenSSL$crypto_1080 = NULL;
        goto outline_result_7;
        // Exception handler code:
        try_except_handler_18:;
        exception_keeper_type_16 = exception_type;
        exception_keeper_value_16 = exception_value;
        exception_keeper_tb_16 = exception_tb;
        exception_keeper_lineno_16 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_OpenSSL$crypto_1080);
        locals_OpenSSL$crypto_1080 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_16;
        exception_value = exception_keeper_value_16;
        exception_tb = exception_keeper_tb_16;
        exception_lineno = exception_keeper_lineno_16;

        goto outline_exception_6;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$crypto);
        return NULL;
        outline_exception_6:;
        exception_lineno = 1080;
        goto try_except_handler_17;
        outline_result_7:;
        assert(tmp_class_creation_8__class_dict == NULL);
        tmp_class_creation_8__class_dict = tmp_assign_source_84;
    }
    {
        PyObject *tmp_assign_source_85;
        nuitka_bool tmp_condition_result_9;
        PyObject *tmp_key_name_15;
        PyObject *tmp_dict_name_15;
        PyObject *tmp_dict_name_16;
        PyObject *tmp_key_name_16;
        tmp_key_name_15 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_8__class_dict);
        tmp_dict_name_15 = tmp_class_creation_8__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_15, tmp_key_name_15);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1080;

            goto try_except_handler_17;
        }
        tmp_condition_result_9 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_9 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_8;
        } else {
            goto condexpr_false_8;
        }
        condexpr_true_8:;
        CHECK_OBJECT(tmp_class_creation_8__class_dict);
        tmp_dict_name_16 = tmp_class_creation_8__class_dict;
        tmp_key_name_16 = const_str_plain___metaclass__;
        tmp_assign_source_85 = DICT_GET_ITEM(tmp_dict_name_16, tmp_key_name_16);
        if (tmp_assign_source_85 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1080;

            goto try_except_handler_17;
        }
        goto condexpr_end_8;
        condexpr_false_8:;
        tmp_assign_source_85 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_85);
        condexpr_end_8:;
        assert(tmp_class_creation_8__metaclass == NULL);
        tmp_class_creation_8__metaclass = tmp_assign_source_85;
    }
    {
        PyObject *tmp_assign_source_86;
        PyObject *tmp_called_name_21;
        PyObject *tmp_args_element_name_48;
        PyObject *tmp_args_element_name_49;
        PyObject *tmp_args_element_name_50;
        CHECK_OBJECT(tmp_class_creation_8__metaclass);
        tmp_called_name_21 = tmp_class_creation_8__metaclass;
        tmp_args_element_name_48 = const_str_plain_X509;
        tmp_args_element_name_49 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_8__class_dict);
        tmp_args_element_name_50 = tmp_class_creation_8__class_dict;
        frame_d796a9417638ea0fc15dcdcd73475757->m_frame.f_lineno = 1080;
        {
            PyObject *call_args[] = {tmp_args_element_name_48, tmp_args_element_name_49, tmp_args_element_name_50};
            tmp_assign_source_86 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_21, call_args);
        }

        if (tmp_assign_source_86 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1080;

            goto try_except_handler_17;
        }
        assert(tmp_class_creation_8__class == NULL);
        tmp_class_creation_8__class = tmp_assign_source_86;
    }
    goto try_end_11;
    // Exception handler code:
    try_except_handler_17:;
    exception_keeper_type_17 = exception_type;
    exception_keeper_value_17 = exception_value;
    exception_keeper_tb_17 = exception_tb;
    exception_keeper_lineno_17 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_8__class_dict);
    tmp_class_creation_8__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_8__metaclass);
    tmp_class_creation_8__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_17;
    exception_value = exception_keeper_value_17;
    exception_tb = exception_keeper_tb_17;
    exception_lineno = exception_keeper_lineno_17;

    goto frame_exception_exit_1;
    // End of try:
    try_end_11:;
    {
        PyObject *tmp_assign_source_87;
        CHECK_OBJECT(tmp_class_creation_8__class);
        tmp_assign_source_87 = tmp_class_creation_8__class;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509, tmp_assign_source_87);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_8__class);
    Py_DECREF(tmp_class_creation_8__class);
    tmp_class_creation_8__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_8__class_dict);
    Py_DECREF(tmp_class_creation_8__class_dict);
    tmp_class_creation_8__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_8__metaclass);
    Py_DECREF(tmp_class_creation_8__metaclass);
    tmp_class_creation_8__metaclass = NULL;

    {
        PyObject *tmp_assign_source_88;
        PyObject *tmp_called_name_22;
        PyObject *tmp_mvar_value_34;
        PyObject *tmp_args_element_name_51;
        PyObject *tmp_mvar_value_35;
        PyObject *tmp_args_element_name_52;
        PyObject *tmp_args_element_name_53;
        PyObject *tmp_args_element_name_54;
        PyObject *tmp_mvar_value_36;
        tmp_mvar_value_34 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_deprecated);

        if (unlikely(tmp_mvar_value_34 == NULL)) {
            tmp_mvar_value_34 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_deprecated);
        }

        if (tmp_mvar_value_34 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 2548 ], 32, 0);
            exception_tb = NULL;

            exception_lineno = 1546;

            goto frame_exception_exit_1;
        }

        tmp_called_name_22 = tmp_mvar_value_34;
        tmp_mvar_value_35 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509);

        if (unlikely(tmp_mvar_value_35 == NULL)) {
            tmp_mvar_value_35 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509);
        }

        if (tmp_mvar_value_35 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 243 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 1547;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_51 = tmp_mvar_value_35;
        tmp_args_element_name_52 = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
        tmp_args_element_name_53 = const_str_digest_5194c46decfddbd64da780c8c0e4faa3;
        tmp_mvar_value_36 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_DeprecationWarning);

        if (unlikely(tmp_mvar_value_36 == NULL)) {
            tmp_mvar_value_36 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_DeprecationWarning);
        }

        if (tmp_mvar_value_36 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 2580 ], 40, 0);
            exception_tb = NULL;

            exception_lineno = 1549;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_54 = tmp_mvar_value_36;
        frame_d796a9417638ea0fc15dcdcd73475757->m_frame.f_lineno = 1546;
        {
            PyObject *call_args[] = {tmp_args_element_name_51, tmp_args_element_name_52, tmp_args_element_name_53, tmp_args_element_name_54};
            tmp_assign_source_88 = CALL_FUNCTION_WITH_ARGS4(tmp_called_name_22, call_args);
        }

        if (tmp_assign_source_88 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1546;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Type, tmp_assign_source_88);
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_89;
        {
            PyObject *tmp_set_locals_7;
            tmp_set_locals_7 = PyDict_New();
            locals_OpenSSL$crypto_1553 = tmp_set_locals_7;
        }
        tmp_dictset_value = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1553, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = const_str_digest_6ef28169edd3cfe530885f6f9d09c390;
        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1553, const_str_plain___doc__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_bdc51ef1a1907bf0b04d0d14fa40b94d_8, codeobj_bdc51ef1a1907bf0b04d0d14fa40b94d, module_OpenSSL$crypto, 0);
        frame_bdc51ef1a1907bf0b04d0d14fa40b94d_8 = cache_frame_bdc51ef1a1907bf0b04d0d14fa40b94d_8;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_bdc51ef1a1907bf0b04d0d14fa40b94d_8);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_bdc51ef1a1907bf0b04d0d14fa40b94d_8) == 2); // Frame stack

        // Framed code:
        {
            PyObject *tmp_source_name_10;
            PyObject *tmp_mvar_value_37;
            tmp_mvar_value_37 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_37 == NULL)) {
                tmp_mvar_value_37 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_37 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
                exception_tb = NULL;

                exception_lineno = 1563;

                goto frame_exception_exit_8;
            }

            tmp_source_name_10 = tmp_mvar_value_37;
            tmp_dictset_value = LOOKUP_ATTRIBUTE(tmp_source_name_10, const_str_plain_X509_V_FLAG_CRL_CHECK);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1563;

                goto frame_exception_exit_8;
            }
            tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1553, const_str_plain_CRL_CHECK, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1563;

                goto frame_exception_exit_8;
            }
        }
        {
            PyObject *tmp_source_name_11;
            PyObject *tmp_mvar_value_38;
            tmp_mvar_value_38 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_38 == NULL)) {
                tmp_mvar_value_38 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_38 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
                exception_tb = NULL;

                exception_lineno = 1564;

                goto frame_exception_exit_8;
            }

            tmp_source_name_11 = tmp_mvar_value_38;
            tmp_dictset_value = LOOKUP_ATTRIBUTE(tmp_source_name_11, const_str_plain_X509_V_FLAG_CRL_CHECK_ALL);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1564;

                goto frame_exception_exit_8;
            }
            tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1553, const_str_plain_CRL_CHECK_ALL, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1564;

                goto frame_exception_exit_8;
            }
        }
        {
            PyObject *tmp_source_name_12;
            PyObject *tmp_mvar_value_39;
            tmp_mvar_value_39 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_39 == NULL)) {
                tmp_mvar_value_39 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_39 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
                exception_tb = NULL;

                exception_lineno = 1565;

                goto frame_exception_exit_8;
            }

            tmp_source_name_12 = tmp_mvar_value_39;
            tmp_dictset_value = LOOKUP_ATTRIBUTE(tmp_source_name_12, const_str_plain_X509_V_FLAG_IGNORE_CRITICAL);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1565;

                goto frame_exception_exit_8;
            }
            tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1553, const_str_plain_IGNORE_CRITICAL, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1565;

                goto frame_exception_exit_8;
            }
        }
        {
            PyObject *tmp_source_name_13;
            PyObject *tmp_mvar_value_40;
            tmp_mvar_value_40 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_40 == NULL)) {
                tmp_mvar_value_40 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_40 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
                exception_tb = NULL;

                exception_lineno = 1566;

                goto frame_exception_exit_8;
            }

            tmp_source_name_13 = tmp_mvar_value_40;
            tmp_dictset_value = LOOKUP_ATTRIBUTE(tmp_source_name_13, const_str_plain_X509_V_FLAG_X509_STRICT);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1566;

                goto frame_exception_exit_8;
            }
            tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1553, const_str_plain_X509_STRICT, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1566;

                goto frame_exception_exit_8;
            }
        }
        {
            PyObject *tmp_source_name_14;
            PyObject *tmp_mvar_value_41;
            tmp_mvar_value_41 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_41 == NULL)) {
                tmp_mvar_value_41 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_41 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
                exception_tb = NULL;

                exception_lineno = 1567;

                goto frame_exception_exit_8;
            }

            tmp_source_name_14 = tmp_mvar_value_41;
            tmp_dictset_value = LOOKUP_ATTRIBUTE(tmp_source_name_14, const_str_plain_X509_V_FLAG_ALLOW_PROXY_CERTS);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1567;

                goto frame_exception_exit_8;
            }
            tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1553, const_str_plain_ALLOW_PROXY_CERTS, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1567;

                goto frame_exception_exit_8;
            }
        }
        {
            PyObject *tmp_source_name_15;
            PyObject *tmp_mvar_value_42;
            tmp_mvar_value_42 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_42 == NULL)) {
                tmp_mvar_value_42 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_42 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
                exception_tb = NULL;

                exception_lineno = 1568;

                goto frame_exception_exit_8;
            }

            tmp_source_name_15 = tmp_mvar_value_42;
            tmp_dictset_value = LOOKUP_ATTRIBUTE(tmp_source_name_15, const_str_plain_X509_V_FLAG_POLICY_CHECK);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1568;

                goto frame_exception_exit_8;
            }
            tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1553, const_str_plain_POLICY_CHECK, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1568;

                goto frame_exception_exit_8;
            }
        }
        {
            PyObject *tmp_source_name_16;
            PyObject *tmp_mvar_value_43;
            tmp_mvar_value_43 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_43 == NULL)) {
                tmp_mvar_value_43 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_43 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
                exception_tb = NULL;

                exception_lineno = 1569;

                goto frame_exception_exit_8;
            }

            tmp_source_name_16 = tmp_mvar_value_43;
            tmp_dictset_value = LOOKUP_ATTRIBUTE(tmp_source_name_16, const_str_plain_X509_V_FLAG_EXPLICIT_POLICY);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1569;

                goto frame_exception_exit_8;
            }
            tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1553, const_str_plain_EXPLICIT_POLICY, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1569;

                goto frame_exception_exit_8;
            }
        }
        {
            PyObject *tmp_source_name_17;
            PyObject *tmp_mvar_value_44;
            tmp_mvar_value_44 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_44 == NULL)) {
                tmp_mvar_value_44 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_44 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
                exception_tb = NULL;

                exception_lineno = 1570;

                goto frame_exception_exit_8;
            }

            tmp_source_name_17 = tmp_mvar_value_44;
            tmp_dictset_value = LOOKUP_ATTRIBUTE(tmp_source_name_17, const_str_plain_X509_V_FLAG_INHIBIT_MAP);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1570;

                goto frame_exception_exit_8;
            }
            tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1553, const_str_plain_INHIBIT_MAP, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1570;

                goto frame_exception_exit_8;
            }
        }
        {
            PyObject *tmp_source_name_18;
            PyObject *tmp_mvar_value_45;
            tmp_mvar_value_45 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_45 == NULL)) {
                tmp_mvar_value_45 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_45 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
                exception_tb = NULL;

                exception_lineno = 1571;

                goto frame_exception_exit_8;
            }

            tmp_source_name_18 = tmp_mvar_value_45;
            tmp_dictset_value = LOOKUP_ATTRIBUTE(tmp_source_name_18, const_str_plain_X509_V_FLAG_NOTIFY_POLICY);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1571;

                goto frame_exception_exit_8;
            }
            tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1553, const_str_plain_NOTIFY_POLICY, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1571;

                goto frame_exception_exit_8;
            }
        }
        {
            PyObject *tmp_source_name_19;
            PyObject *tmp_mvar_value_46;
            tmp_mvar_value_46 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_46 == NULL)) {
                tmp_mvar_value_46 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_46 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
                exception_tb = NULL;

                exception_lineno = 1572;

                goto frame_exception_exit_8;
            }

            tmp_source_name_19 = tmp_mvar_value_46;
            tmp_dictset_value = LOOKUP_ATTRIBUTE(tmp_source_name_19, const_str_plain_X509_V_FLAG_CHECK_SS_SIGNATURE);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1572;

                goto frame_exception_exit_8;
            }
            tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1553, const_str_plain_CHECK_SS_SIGNATURE, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1572;

                goto frame_exception_exit_8;
            }
        }
        {
            PyObject *tmp_source_name_20;
            PyObject *tmp_mvar_value_47;
            tmp_mvar_value_47 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_47 == NULL)) {
                tmp_mvar_value_47 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_47 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
                exception_tb = NULL;

                exception_lineno = 1573;

                goto frame_exception_exit_8;
            }

            tmp_source_name_20 = tmp_mvar_value_47;
            tmp_dictset_value = LOOKUP_ATTRIBUTE(tmp_source_name_20, const_str_plain_X509_V_FLAG_CB_ISSUER_CHECK);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1573;

                goto frame_exception_exit_8;
            }
            tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_1553, const_str_plain_CB_ISSUER_CHECK, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1573;

                goto frame_exception_exit_8;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_bdc51ef1a1907bf0b04d0d14fa40b94d_8);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_7;

        frame_exception_exit_8:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_bdc51ef1a1907bf0b04d0d14fa40b94d_8);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_bdc51ef1a1907bf0b04d0d14fa40b94d_8, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_bdc51ef1a1907bf0b04d0d14fa40b94d_8->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_bdc51ef1a1907bf0b04d0d14fa40b94d_8, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_bdc51ef1a1907bf0b04d0d14fa40b94d_8,
            type_description_2
        );


        // Release cached frame.
        if (frame_bdc51ef1a1907bf0b04d0d14fa40b94d_8 == cache_frame_bdc51ef1a1907bf0b04d0d14fa40b94d_8) {
            Py_DECREF(frame_bdc51ef1a1907bf0b04d0d14fa40b94d_8);
        }
        cache_frame_bdc51ef1a1907bf0b04d0d14fa40b94d_8 = NULL;

        assertFrameObject(frame_bdc51ef1a1907bf0b04d0d14fa40b94d_8);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_7;

        frame_no_exception_7:;
        goto skip_nested_handling_7;
        nested_frame_exit_7:;

        goto try_except_handler_20;
        skip_nested_handling_7:;
        tmp_assign_source_89 = locals_OpenSSL$crypto_1553;
        Py_INCREF(tmp_assign_source_89);
        goto try_return_handler_20;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$crypto);
        return NULL;
        // Return handler code:
        try_return_handler_20:;
        Py_DECREF(locals_OpenSSL$crypto_1553);
        locals_OpenSSL$crypto_1553 = NULL;
        goto outline_result_8;
        // Exception handler code:
        try_except_handler_20:;
        exception_keeper_type_18 = exception_type;
        exception_keeper_value_18 = exception_value;
        exception_keeper_tb_18 = exception_tb;
        exception_keeper_lineno_18 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_OpenSSL$crypto_1553);
        locals_OpenSSL$crypto_1553 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_18;
        exception_value = exception_keeper_value_18;
        exception_tb = exception_keeper_tb_18;
        exception_lineno = exception_keeper_lineno_18;

        goto outline_exception_7;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$crypto);
        return NULL;
        outline_exception_7:;
        exception_lineno = 1553;
        goto try_except_handler_19;
        outline_result_8:;
        assert(tmp_class_creation_9__class_dict == NULL);
        tmp_class_creation_9__class_dict = tmp_assign_source_89;
    }
    {
        PyObject *tmp_assign_source_90;
        nuitka_bool tmp_condition_result_10;
        PyObject *tmp_key_name_17;
        PyObject *tmp_dict_name_17;
        PyObject *tmp_dict_name_18;
        PyObject *tmp_key_name_18;
        tmp_key_name_17 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_9__class_dict);
        tmp_dict_name_17 = tmp_class_creation_9__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_17, tmp_key_name_17);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1553;

            goto try_except_handler_19;
        }
        tmp_condition_result_10 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_10 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_9;
        } else {
            goto condexpr_false_9;
        }
        condexpr_true_9:;
        CHECK_OBJECT(tmp_class_creation_9__class_dict);
        tmp_dict_name_18 = tmp_class_creation_9__class_dict;
        tmp_key_name_18 = const_str_plain___metaclass__;
        tmp_assign_source_90 = DICT_GET_ITEM(tmp_dict_name_18, tmp_key_name_18);
        if (tmp_assign_source_90 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1553;

            goto try_except_handler_19;
        }
        goto condexpr_end_9;
        condexpr_false_9:;
        tmp_assign_source_90 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_90);
        condexpr_end_9:;
        assert(tmp_class_creation_9__metaclass == NULL);
        tmp_class_creation_9__metaclass = tmp_assign_source_90;
    }
    {
        PyObject *tmp_assign_source_91;
        PyObject *tmp_called_name_23;
        PyObject *tmp_args_element_name_55;
        PyObject *tmp_args_element_name_56;
        PyObject *tmp_args_element_name_57;
        CHECK_OBJECT(tmp_class_creation_9__metaclass);
        tmp_called_name_23 = tmp_class_creation_9__metaclass;
        tmp_args_element_name_55 = const_str_plain_X509StoreFlags;
        tmp_args_element_name_56 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_9__class_dict);
        tmp_args_element_name_57 = tmp_class_creation_9__class_dict;
        frame_d796a9417638ea0fc15dcdcd73475757->m_frame.f_lineno = 1553;
        {
            PyObject *call_args[] = {tmp_args_element_name_55, tmp_args_element_name_56, tmp_args_element_name_57};
            tmp_assign_source_91 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_23, call_args);
        }

        if (tmp_assign_source_91 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1553;

            goto try_except_handler_19;
        }
        assert(tmp_class_creation_9__class == NULL);
        tmp_class_creation_9__class = tmp_assign_source_91;
    }
    goto try_end_12;
    // Exception handler code:
    try_except_handler_19:;
    exception_keeper_type_19 = exception_type;
    exception_keeper_value_19 = exception_value;
    exception_keeper_tb_19 = exception_tb;
    exception_keeper_lineno_19 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_9__class_dict);
    tmp_class_creation_9__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_9__metaclass);
    tmp_class_creation_9__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_19;
    exception_value = exception_keeper_value_19;
    exception_tb = exception_keeper_tb_19;
    exception_lineno = exception_keeper_lineno_19;

    goto frame_exception_exit_1;
    // End of try:
    try_end_12:;
    {
        PyObject *tmp_assign_source_92;
        CHECK_OBJECT(tmp_class_creation_9__class);
        tmp_assign_source_92 = tmp_class_creation_9__class;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509StoreFlags, tmp_assign_source_92);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_9__class);
    Py_DECREF(tmp_class_creation_9__class);
    tmp_class_creation_9__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_9__class_dict);
    Py_DECREF(tmp_class_creation_9__class_dict);
    tmp_class_creation_9__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_9__metaclass);
    Py_DECREF(tmp_class_creation_9__metaclass);
    tmp_class_creation_9__metaclass = NULL;

    {
        PyObject *tmp_assign_source_93;
        {
            PyObject *tmp_assign_source_94;
            tmp_assign_source_94 = MAKE_FUNCTION_OpenSSL$crypto$$$function_85___init__();



            assert(tmp_locals_OpenSSL$crypto_1576_key___init__ == NULL);
            tmp_locals_OpenSSL$crypto_1576_key___init__ = tmp_assign_source_94;
        }
        {
            PyObject *tmp_assign_source_95;
            tmp_assign_source_95 = MAKE_FUNCTION_OpenSSL$crypto$$$function_86_add_cert();



            assert(tmp_locals_OpenSSL$crypto_1576_key_add_cert == NULL);
            tmp_locals_OpenSSL$crypto_1576_key_add_cert = tmp_assign_source_95;
        }
        {
            PyObject *tmp_assign_source_96;
            tmp_assign_source_96 = MAKE_FUNCTION_OpenSSL$crypto$$$function_87_add_crl();



            assert(tmp_locals_OpenSSL$crypto_1576_key_add_crl == NULL);
            tmp_locals_OpenSSL$crypto_1576_key_add_crl = tmp_assign_source_96;
        }
        {
            PyObject *tmp_assign_source_97;
            tmp_assign_source_97 = MAKE_FUNCTION_OpenSSL$crypto$$$function_88_set_flags();



            assert(tmp_locals_OpenSSL$crypto_1576_key_set_flags == NULL);
            tmp_locals_OpenSSL$crypto_1576_key_set_flags = tmp_assign_source_97;
        }
        {
            PyObject *tmp_assign_source_98;
            tmp_assign_source_98 = MAKE_FUNCTION_OpenSSL$crypto$$$function_89_set_time();



            assert(tmp_locals_OpenSSL$crypto_1576_key_set_time == NULL);
            tmp_locals_OpenSSL$crypto_1576_key_set_time = tmp_assign_source_98;
        }
        // Tried code:
        {
            PyObject *tmp_dict_key_8;
            PyObject *tmp_dict_value_8;
            PyObject *tmp_dict_key_9;
            PyObject *tmp_dict_value_9;
            PyObject *tmp_dict_key_10;
            PyObject *tmp_dict_value_10;
            PyObject *tmp_dict_key_11;
            PyObject *tmp_dict_value_11;
            PyObject *tmp_dict_key_12;
            PyObject *tmp_dict_value_12;
            PyObject *tmp_dict_key_13;
            PyObject *tmp_dict_value_13;
            PyObject *tmp_dict_key_14;
            PyObject *tmp_dict_value_14;
            tmp_dict_value_8 = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
            tmp_dict_key_8 = const_str_plain___module__;
            tmp_assign_source_93 = _PyDict_NewPresized( 7 );
            tmp_res = PyDict_SetItem(tmp_assign_source_93, tmp_dict_key_8, tmp_dict_value_8);
            assert(!(tmp_res != 0));
            tmp_dict_value_9 = const_str_digest_6a19008e8f9a834793cf38dcba68883a;
            tmp_dict_key_9 = const_str_plain___doc__;
            tmp_res = PyDict_SetItem(tmp_assign_source_93, tmp_dict_key_9, tmp_dict_value_9);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_1576_key___init__);
            tmp_dict_value_10 = tmp_locals_OpenSSL$crypto_1576_key___init__;
            tmp_dict_key_10 = const_str_plain___init__;
            tmp_res = PyDict_SetItem(tmp_assign_source_93, tmp_dict_key_10, tmp_dict_value_10);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_1576_key_add_cert);
            tmp_dict_value_11 = tmp_locals_OpenSSL$crypto_1576_key_add_cert;
            tmp_dict_key_11 = const_str_plain_add_cert;
            tmp_res = PyDict_SetItem(tmp_assign_source_93, tmp_dict_key_11, tmp_dict_value_11);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_1576_key_add_crl);
            tmp_dict_value_12 = tmp_locals_OpenSSL$crypto_1576_key_add_crl;
            tmp_dict_key_12 = const_str_plain_add_crl;
            tmp_res = PyDict_SetItem(tmp_assign_source_93, tmp_dict_key_12, tmp_dict_value_12);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_1576_key_set_flags);
            tmp_dict_value_13 = tmp_locals_OpenSSL$crypto_1576_key_set_flags;
            tmp_dict_key_13 = const_str_plain_set_flags;
            tmp_res = PyDict_SetItem(tmp_assign_source_93, tmp_dict_key_13, tmp_dict_value_13);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_1576_key_set_time);
            tmp_dict_value_14 = tmp_locals_OpenSSL$crypto_1576_key_set_time;
            tmp_dict_key_14 = const_str_plain_set_time;
            tmp_res = PyDict_SetItem(tmp_assign_source_93, tmp_dict_key_14, tmp_dict_value_14);
            assert(!(tmp_res != 0));
            goto try_return_handler_21;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$crypto);
        return NULL;
        // Return handler code:
        try_return_handler_21:;
        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_1576_key___init__);
        Py_DECREF(tmp_locals_OpenSSL$crypto_1576_key___init__);
        tmp_locals_OpenSSL$crypto_1576_key___init__ = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_1576_key_add_cert);
        Py_DECREF(tmp_locals_OpenSSL$crypto_1576_key_add_cert);
        tmp_locals_OpenSSL$crypto_1576_key_add_cert = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_1576_key_add_crl);
        Py_DECREF(tmp_locals_OpenSSL$crypto_1576_key_add_crl);
        tmp_locals_OpenSSL$crypto_1576_key_add_crl = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_1576_key_set_flags);
        Py_DECREF(tmp_locals_OpenSSL$crypto_1576_key_set_flags);
        tmp_locals_OpenSSL$crypto_1576_key_set_flags = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_1576_key_set_time);
        Py_DECREF(tmp_locals_OpenSSL$crypto_1576_key_set_time);
        tmp_locals_OpenSSL$crypto_1576_key_set_time = NULL;

        goto outline_result_9;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$crypto);
        return NULL;
        outline_result_9:;
        assert(tmp_class_creation_10__class_dict == NULL);
        tmp_class_creation_10__class_dict = tmp_assign_source_93;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_99;
        nuitka_bool tmp_condition_result_11;
        PyObject *tmp_key_name_19;
        PyObject *tmp_dict_name_19;
        PyObject *tmp_dict_name_20;
        PyObject *tmp_key_name_20;
        tmp_key_name_19 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_10__class_dict);
        tmp_dict_name_19 = tmp_class_creation_10__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_19, tmp_key_name_19);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1576;

            goto try_except_handler_22;
        }
        tmp_condition_result_11 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_11 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_10;
        } else {
            goto condexpr_false_10;
        }
        condexpr_true_10:;
        CHECK_OBJECT(tmp_class_creation_10__class_dict);
        tmp_dict_name_20 = tmp_class_creation_10__class_dict;
        tmp_key_name_20 = const_str_plain___metaclass__;
        tmp_assign_source_99 = DICT_GET_ITEM(tmp_dict_name_20, tmp_key_name_20);
        if (tmp_assign_source_99 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1576;

            goto try_except_handler_22;
        }
        goto condexpr_end_10;
        condexpr_false_10:;
        tmp_assign_source_99 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_99);
        condexpr_end_10:;
        assert(tmp_class_creation_10__metaclass == NULL);
        tmp_class_creation_10__metaclass = tmp_assign_source_99;
    }
    {
        PyObject *tmp_assign_source_100;
        PyObject *tmp_called_name_24;
        PyObject *tmp_args_element_name_58;
        PyObject *tmp_args_element_name_59;
        PyObject *tmp_args_element_name_60;
        CHECK_OBJECT(tmp_class_creation_10__metaclass);
        tmp_called_name_24 = tmp_class_creation_10__metaclass;
        tmp_args_element_name_58 = const_str_plain_X509Store;
        tmp_args_element_name_59 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_10__class_dict);
        tmp_args_element_name_60 = tmp_class_creation_10__class_dict;
        frame_d796a9417638ea0fc15dcdcd73475757->m_frame.f_lineno = 1576;
        {
            PyObject *call_args[] = {tmp_args_element_name_58, tmp_args_element_name_59, tmp_args_element_name_60};
            tmp_assign_source_100 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_24, call_args);
        }

        if (tmp_assign_source_100 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1576;

            goto try_except_handler_22;
        }
        assert(tmp_class_creation_10__class == NULL);
        tmp_class_creation_10__class = tmp_assign_source_100;
    }
    goto try_end_13;
    // Exception handler code:
    try_except_handler_22:;
    exception_keeper_type_20 = exception_type;
    exception_keeper_value_20 = exception_value;
    exception_keeper_tb_20 = exception_tb;
    exception_keeper_lineno_20 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)tmp_class_creation_10__class_dict);
    Py_DECREF(tmp_class_creation_10__class_dict);
    tmp_class_creation_10__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_10__metaclass);
    tmp_class_creation_10__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_20;
    exception_value = exception_keeper_value_20;
    exception_tb = exception_keeper_tb_20;
    exception_lineno = exception_keeper_lineno_20;

    goto frame_exception_exit_1;
    // End of try:
    try_end_13:;
    {
        PyObject *tmp_assign_source_101;
        CHECK_OBJECT(tmp_class_creation_10__class);
        tmp_assign_source_101 = tmp_class_creation_10__class;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Store, tmp_assign_source_101);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_10__class);
    Py_DECREF(tmp_class_creation_10__class);
    tmp_class_creation_10__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_10__class_dict);
    Py_DECREF(tmp_class_creation_10__class_dict);
    tmp_class_creation_10__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_10__metaclass);
    Py_DECREF(tmp_class_creation_10__metaclass);
    tmp_class_creation_10__metaclass = NULL;

    {
        PyObject *tmp_assign_source_102;
        PyObject *tmp_called_name_25;
        PyObject *tmp_mvar_value_48;
        PyObject *tmp_args_element_name_61;
        PyObject *tmp_mvar_value_49;
        PyObject *tmp_args_element_name_62;
        PyObject *tmp_args_element_name_63;
        PyObject *tmp_args_element_name_64;
        PyObject *tmp_mvar_value_50;
        tmp_mvar_value_48 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_deprecated);

        if (unlikely(tmp_mvar_value_48 == NULL)) {
            tmp_mvar_value_48 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_deprecated);
        }

        if (tmp_mvar_value_48 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 2548 ], 32, 0);
            exception_tb = NULL;

            exception_lineno = 1687;

            goto frame_exception_exit_1;
        }

        tmp_called_name_25 = tmp_mvar_value_48;
        tmp_mvar_value_49 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Store);

        if (unlikely(tmp_mvar_value_49 == NULL)) {
            tmp_mvar_value_49 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Store);
        }

        if (tmp_mvar_value_49 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1149 ], 31, 0);
            exception_tb = NULL;

            exception_lineno = 1688;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_61 = tmp_mvar_value_49;
        tmp_args_element_name_62 = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
        tmp_args_element_name_63 = const_str_digest_aca114104f73a7934675fb06a5336647;
        tmp_mvar_value_50 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_DeprecationWarning);

        if (unlikely(tmp_mvar_value_50 == NULL)) {
            tmp_mvar_value_50 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_DeprecationWarning);
        }

        if (tmp_mvar_value_50 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 2580 ], 40, 0);
            exception_tb = NULL;

            exception_lineno = 1690;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_64 = tmp_mvar_value_50;
        frame_d796a9417638ea0fc15dcdcd73475757->m_frame.f_lineno = 1687;
        {
            PyObject *call_args[] = {tmp_args_element_name_61, tmp_args_element_name_62, tmp_args_element_name_63, tmp_args_element_name_64};
            tmp_assign_source_102 = CALL_FUNCTION_WITH_ARGS4(tmp_called_name_25, call_args);
        }

        if (tmp_assign_source_102 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1687;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509StoreType, tmp_assign_source_102);
    }
    {
        PyObject *tmp_assign_source_103;
        {
            PyObject *tmp_assign_source_104;
            tmp_assign_source_104 = MAKE_FUNCTION_OpenSSL$crypto$$$function_90___init__();



            assert(tmp_locals_OpenSSL$crypto_1694_key___init__ == NULL);
            tmp_locals_OpenSSL$crypto_1694_key___init__ = tmp_assign_source_104;
        }
        // Tried code:
        {
            PyObject *tmp_dict_key_15;
            PyObject *tmp_dict_value_15;
            PyObject *tmp_dict_key_16;
            PyObject *tmp_dict_value_16;
            PyObject *tmp_dict_key_17;
            PyObject *tmp_dict_value_17;
            tmp_dict_value_15 = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
            tmp_dict_key_15 = const_str_plain___module__;
            tmp_assign_source_103 = _PyDict_NewPresized( 3 );
            tmp_res = PyDict_SetItem(tmp_assign_source_103, tmp_dict_key_15, tmp_dict_value_15);
            assert(!(tmp_res != 0));
            tmp_dict_value_16 = const_str_digest_a9fcf3ea8b3ff05d45964d00ac386113;
            tmp_dict_key_16 = const_str_plain___doc__;
            tmp_res = PyDict_SetItem(tmp_assign_source_103, tmp_dict_key_16, tmp_dict_value_16);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_1694_key___init__);
            tmp_dict_value_17 = tmp_locals_OpenSSL$crypto_1694_key___init__;
            tmp_dict_key_17 = const_str_plain___init__;
            tmp_res = PyDict_SetItem(tmp_assign_source_103, tmp_dict_key_17, tmp_dict_value_17);
            assert(!(tmp_res != 0));
            goto try_return_handler_23;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$crypto);
        return NULL;
        // Return handler code:
        try_return_handler_23:;
        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_1694_key___init__);
        Py_DECREF(tmp_locals_OpenSSL$crypto_1694_key___init__);
        tmp_locals_OpenSSL$crypto_1694_key___init__ = NULL;

        goto outline_result_10;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$crypto);
        return NULL;
        outline_result_10:;
        assert(tmp_class_creation_11__class_dict == NULL);
        tmp_class_creation_11__class_dict = tmp_assign_source_103;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_105;
        nuitka_bool tmp_condition_result_12;
        PyObject *tmp_key_name_21;
        PyObject *tmp_dict_name_21;
        PyObject *tmp_dict_name_22;
        PyObject *tmp_key_name_22;
        tmp_key_name_21 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_11__class_dict);
        tmp_dict_name_21 = tmp_class_creation_11__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_21, tmp_key_name_21);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1694;

            goto try_except_handler_24;
        }
        tmp_condition_result_12 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_12 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_11;
        } else {
            goto condexpr_false_11;
        }
        condexpr_true_11:;
        CHECK_OBJECT(tmp_class_creation_11__class_dict);
        tmp_dict_name_22 = tmp_class_creation_11__class_dict;
        tmp_key_name_22 = const_str_plain___metaclass__;
        tmp_assign_source_105 = DICT_GET_ITEM(tmp_dict_name_22, tmp_key_name_22);
        if (tmp_assign_source_105 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1694;

            goto try_except_handler_24;
        }
        goto condexpr_end_11;
        condexpr_false_11:;
        tmp_assign_source_105 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_105);
        condexpr_end_11:;
        assert(tmp_class_creation_11__metaclass == NULL);
        tmp_class_creation_11__metaclass = tmp_assign_source_105;
    }
    {
        PyObject *tmp_assign_source_106;
        PyObject *tmp_called_name_26;
        PyObject *tmp_args_element_name_65;
        PyObject *tmp_args_element_name_66;
        PyObject *tmp_args_element_name_67;
        CHECK_OBJECT(tmp_class_creation_11__metaclass);
        tmp_called_name_26 = tmp_class_creation_11__metaclass;
        tmp_args_element_name_65 = const_str_plain_X509StoreContextError;
        tmp_args_element_name_66 = const_tuple_type_Exception_tuple;
        CHECK_OBJECT(tmp_class_creation_11__class_dict);
        tmp_args_element_name_67 = tmp_class_creation_11__class_dict;
        frame_d796a9417638ea0fc15dcdcd73475757->m_frame.f_lineno = 1694;
        {
            PyObject *call_args[] = {tmp_args_element_name_65, tmp_args_element_name_66, tmp_args_element_name_67};
            tmp_assign_source_106 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_26, call_args);
        }

        if (tmp_assign_source_106 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1694;

            goto try_except_handler_24;
        }
        assert(tmp_class_creation_11__class == NULL);
        tmp_class_creation_11__class = tmp_assign_source_106;
    }
    goto try_end_14;
    // Exception handler code:
    try_except_handler_24:;
    exception_keeper_type_21 = exception_type;
    exception_keeper_value_21 = exception_value;
    exception_keeper_tb_21 = exception_tb;
    exception_keeper_lineno_21 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)tmp_class_creation_11__class_dict);
    Py_DECREF(tmp_class_creation_11__class_dict);
    tmp_class_creation_11__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_11__metaclass);
    tmp_class_creation_11__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_21;
    exception_value = exception_keeper_value_21;
    exception_tb = exception_keeper_tb_21;
    exception_lineno = exception_keeper_lineno_21;

    goto frame_exception_exit_1;
    // End of try:
    try_end_14:;
    {
        PyObject *tmp_assign_source_107;
        CHECK_OBJECT(tmp_class_creation_11__class);
        tmp_assign_source_107 = tmp_class_creation_11__class;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509StoreContextError, tmp_assign_source_107);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_11__class);
    Py_DECREF(tmp_class_creation_11__class);
    tmp_class_creation_11__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_11__class_dict);
    Py_DECREF(tmp_class_creation_11__class_dict);
    tmp_class_creation_11__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_11__metaclass);
    Py_DECREF(tmp_class_creation_11__metaclass);
    tmp_class_creation_11__metaclass = NULL;

    {
        PyObject *tmp_assign_source_108;
        {
            PyObject *tmp_assign_source_109;
            tmp_assign_source_109 = MAKE_FUNCTION_OpenSSL$crypto$$$function_91___init__();



            assert(tmp_locals_OpenSSL$crypto_1708_key___init__ == NULL);
            tmp_locals_OpenSSL$crypto_1708_key___init__ = tmp_assign_source_109;
        }
        {
            PyObject *tmp_assign_source_110;
            tmp_assign_source_110 = MAKE_FUNCTION_OpenSSL$crypto$$$function_92__init();



            assert(tmp_locals_OpenSSL$crypto_1708_key__init == NULL);
            tmp_locals_OpenSSL$crypto_1708_key__init = tmp_assign_source_110;
        }
        {
            PyObject *tmp_assign_source_111;
            tmp_assign_source_111 = MAKE_FUNCTION_OpenSSL$crypto$$$function_93__cleanup();



            assert(tmp_locals_OpenSSL$crypto_1708_key__cleanup == NULL);
            tmp_locals_OpenSSL$crypto_1708_key__cleanup = tmp_assign_source_111;
        }
        {
            PyObject *tmp_assign_source_112;
            tmp_assign_source_112 = MAKE_FUNCTION_OpenSSL$crypto$$$function_94__exception_from_context();



            assert(tmp_locals_OpenSSL$crypto_1708_key__exception_from_context == NULL);
            tmp_locals_OpenSSL$crypto_1708_key__exception_from_context = tmp_assign_source_112;
        }
        {
            PyObject *tmp_assign_source_113;
            tmp_assign_source_113 = MAKE_FUNCTION_OpenSSL$crypto$$$function_95_set_store();



            assert(tmp_locals_OpenSSL$crypto_1708_key_set_store == NULL);
            tmp_locals_OpenSSL$crypto_1708_key_set_store = tmp_assign_source_113;
        }
        {
            PyObject *tmp_assign_source_114;
            tmp_assign_source_114 = MAKE_FUNCTION_OpenSSL$crypto$$$function_96_verify_certificate();



            assert(tmp_locals_OpenSSL$crypto_1708_key_verify_certificate == NULL);
            tmp_locals_OpenSSL$crypto_1708_key_verify_certificate = tmp_assign_source_114;
        }
        // Tried code:
        {
            PyObject *tmp_dict_key_18;
            PyObject *tmp_dict_value_18;
            PyObject *tmp_dict_key_19;
            PyObject *tmp_dict_value_19;
            PyObject *tmp_dict_key_20;
            PyObject *tmp_dict_value_20;
            PyObject *tmp_dict_key_21;
            PyObject *tmp_dict_value_21;
            PyObject *tmp_dict_key_22;
            PyObject *tmp_dict_value_22;
            PyObject *tmp_dict_key_23;
            PyObject *tmp_dict_value_23;
            PyObject *tmp_dict_key_24;
            PyObject *tmp_dict_value_24;
            PyObject *tmp_dict_key_25;
            PyObject *tmp_dict_value_25;
            tmp_dict_value_18 = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
            tmp_dict_key_18 = const_str_plain___module__;
            tmp_assign_source_108 = _PyDict_NewPresized( 8 );
            tmp_res = PyDict_SetItem(tmp_assign_source_108, tmp_dict_key_18, tmp_dict_value_18);
            assert(!(tmp_res != 0));
            tmp_dict_value_19 = const_str_digest_bd5b7ac1c36a2ac4b448366689be109e;
            tmp_dict_key_19 = const_str_plain___doc__;
            tmp_res = PyDict_SetItem(tmp_assign_source_108, tmp_dict_key_19, tmp_dict_value_19);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_1708_key___init__);
            tmp_dict_value_20 = tmp_locals_OpenSSL$crypto_1708_key___init__;
            tmp_dict_key_20 = const_str_plain___init__;
            tmp_res = PyDict_SetItem(tmp_assign_source_108, tmp_dict_key_20, tmp_dict_value_20);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_1708_key__init);
            tmp_dict_value_21 = tmp_locals_OpenSSL$crypto_1708_key__init;
            tmp_dict_key_21 = const_str_plain__init;
            tmp_res = PyDict_SetItem(tmp_assign_source_108, tmp_dict_key_21, tmp_dict_value_21);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_1708_key__cleanup);
            tmp_dict_value_22 = tmp_locals_OpenSSL$crypto_1708_key__cleanup;
            tmp_dict_key_22 = const_str_plain__cleanup;
            tmp_res = PyDict_SetItem(tmp_assign_source_108, tmp_dict_key_22, tmp_dict_value_22);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_1708_key__exception_from_context);
            tmp_dict_value_23 = tmp_locals_OpenSSL$crypto_1708_key__exception_from_context;
            tmp_dict_key_23 = const_str_plain__exception_from_context;
            tmp_res = PyDict_SetItem(tmp_assign_source_108, tmp_dict_key_23, tmp_dict_value_23);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_1708_key_set_store);
            tmp_dict_value_24 = tmp_locals_OpenSSL$crypto_1708_key_set_store;
            tmp_dict_key_24 = const_str_plain_set_store;
            tmp_res = PyDict_SetItem(tmp_assign_source_108, tmp_dict_key_24, tmp_dict_value_24);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_1708_key_verify_certificate);
            tmp_dict_value_25 = tmp_locals_OpenSSL$crypto_1708_key_verify_certificate;
            tmp_dict_key_25 = const_str_plain_verify_certificate;
            tmp_res = PyDict_SetItem(tmp_assign_source_108, tmp_dict_key_25, tmp_dict_value_25);
            assert(!(tmp_res != 0));
            goto try_return_handler_25;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$crypto);
        return NULL;
        // Return handler code:
        try_return_handler_25:;
        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_1708_key___init__);
        Py_DECREF(tmp_locals_OpenSSL$crypto_1708_key___init__);
        tmp_locals_OpenSSL$crypto_1708_key___init__ = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_1708_key__init);
        Py_DECREF(tmp_locals_OpenSSL$crypto_1708_key__init);
        tmp_locals_OpenSSL$crypto_1708_key__init = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_1708_key__cleanup);
        Py_DECREF(tmp_locals_OpenSSL$crypto_1708_key__cleanup);
        tmp_locals_OpenSSL$crypto_1708_key__cleanup = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_1708_key__exception_from_context);
        Py_DECREF(tmp_locals_OpenSSL$crypto_1708_key__exception_from_context);
        tmp_locals_OpenSSL$crypto_1708_key__exception_from_context = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_1708_key_set_store);
        Py_DECREF(tmp_locals_OpenSSL$crypto_1708_key_set_store);
        tmp_locals_OpenSSL$crypto_1708_key_set_store = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_1708_key_verify_certificate);
        Py_DECREF(tmp_locals_OpenSSL$crypto_1708_key_verify_certificate);
        tmp_locals_OpenSSL$crypto_1708_key_verify_certificate = NULL;

        goto outline_result_11;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$crypto);
        return NULL;
        outline_result_11:;
        assert(tmp_class_creation_12__class_dict == NULL);
        tmp_class_creation_12__class_dict = tmp_assign_source_108;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_115;
        nuitka_bool tmp_condition_result_13;
        PyObject *tmp_key_name_23;
        PyObject *tmp_dict_name_23;
        PyObject *tmp_dict_name_24;
        PyObject *tmp_key_name_24;
        tmp_key_name_23 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_12__class_dict);
        tmp_dict_name_23 = tmp_class_creation_12__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_23, tmp_key_name_23);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1708;

            goto try_except_handler_26;
        }
        tmp_condition_result_13 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_13 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_12;
        } else {
            goto condexpr_false_12;
        }
        condexpr_true_12:;
        CHECK_OBJECT(tmp_class_creation_12__class_dict);
        tmp_dict_name_24 = tmp_class_creation_12__class_dict;
        tmp_key_name_24 = const_str_plain___metaclass__;
        tmp_assign_source_115 = DICT_GET_ITEM(tmp_dict_name_24, tmp_key_name_24);
        if (tmp_assign_source_115 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1708;

            goto try_except_handler_26;
        }
        goto condexpr_end_12;
        condexpr_false_12:;
        tmp_assign_source_115 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_115);
        condexpr_end_12:;
        assert(tmp_class_creation_12__metaclass == NULL);
        tmp_class_creation_12__metaclass = tmp_assign_source_115;
    }
    {
        PyObject *tmp_assign_source_116;
        PyObject *tmp_called_name_27;
        PyObject *tmp_args_element_name_68;
        PyObject *tmp_args_element_name_69;
        PyObject *tmp_args_element_name_70;
        CHECK_OBJECT(tmp_class_creation_12__metaclass);
        tmp_called_name_27 = tmp_class_creation_12__metaclass;
        tmp_args_element_name_68 = const_str_plain_X509StoreContext;
        tmp_args_element_name_69 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_12__class_dict);
        tmp_args_element_name_70 = tmp_class_creation_12__class_dict;
        frame_d796a9417638ea0fc15dcdcd73475757->m_frame.f_lineno = 1708;
        {
            PyObject *call_args[] = {tmp_args_element_name_68, tmp_args_element_name_69, tmp_args_element_name_70};
            tmp_assign_source_116 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_27, call_args);
        }

        if (tmp_assign_source_116 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1708;

            goto try_except_handler_26;
        }
        assert(tmp_class_creation_12__class == NULL);
        tmp_class_creation_12__class = tmp_assign_source_116;
    }
    goto try_end_15;
    // Exception handler code:
    try_except_handler_26:;
    exception_keeper_type_22 = exception_type;
    exception_keeper_value_22 = exception_value;
    exception_keeper_tb_22 = exception_tb;
    exception_keeper_lineno_22 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)tmp_class_creation_12__class_dict);
    Py_DECREF(tmp_class_creation_12__class_dict);
    tmp_class_creation_12__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_12__metaclass);
    tmp_class_creation_12__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_22;
    exception_value = exception_keeper_value_22;
    exception_tb = exception_keeper_tb_22;
    exception_lineno = exception_keeper_lineno_22;

    goto frame_exception_exit_1;
    // End of try:
    try_end_15:;
    {
        PyObject *tmp_assign_source_117;
        CHECK_OBJECT(tmp_class_creation_12__class);
        tmp_assign_source_117 = tmp_class_creation_12__class;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509StoreContext, tmp_assign_source_117);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_12__class);
    Py_DECREF(tmp_class_creation_12__class);
    tmp_class_creation_12__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_12__class_dict);
    Py_DECREF(tmp_class_creation_12__class_dict);
    tmp_class_creation_12__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_12__metaclass);
    Py_DECREF(tmp_class_creation_12__metaclass);
    tmp_class_creation_12__metaclass = NULL;

    {
        PyObject *tmp_assign_source_118;
        tmp_assign_source_118 = MAKE_FUNCTION_OpenSSL$crypto$$$function_97_load_certificate();



        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_load_certificate, tmp_assign_source_118);
    }
    {
        PyObject *tmp_assign_source_119;
        tmp_assign_source_119 = MAKE_FUNCTION_OpenSSL$crypto$$$function_98_dump_certificate();



        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_dump_certificate, tmp_assign_source_119);
    }
    {
        PyObject *tmp_assign_source_120;
        tmp_assign_source_120 = MAKE_FUNCTION_OpenSSL$crypto$$$function_99_dump_publickey();



        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_dump_publickey, tmp_assign_source_120);
    }
    {
        PyObject *tmp_assign_source_121;
        PyObject *tmp_defaults_3;
        tmp_defaults_3 = const_tuple_none_none_tuple;
        Py_INCREF(tmp_defaults_3);
        tmp_assign_source_121 = MAKE_FUNCTION_OpenSSL$crypto$$$function_100_dump_privatekey(tmp_defaults_3);



        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_dump_privatekey, tmp_assign_source_121);
    }
    {
        PyObject *tmp_assign_source_122;
        {
            PyObject *tmp_assign_source_123;
            tmp_assign_source_123 = LIST_COPY(const_list_298f4a46a008df82aecc87d37443e76b_list);
            assert(tmp_locals_OpenSSL$crypto_1953_key__crl_reasons == NULL);
            tmp_locals_OpenSSL$crypto_1953_key__crl_reasons = tmp_assign_source_123;
        }
        {
            PyObject *tmp_assign_source_124;
            tmp_assign_source_124 = MAKE_FUNCTION_OpenSSL$crypto$$$function_101___init__();



            assert(tmp_locals_OpenSSL$crypto_1953_key___init__ == NULL);
            tmp_locals_OpenSSL$crypto_1953_key___init__ = tmp_assign_source_124;
        }
        {
            PyObject *tmp_assign_source_125;
            tmp_assign_source_125 = MAKE_FUNCTION_OpenSSL$crypto$$$function_102_set_serial();



            assert(tmp_locals_OpenSSL$crypto_1953_key_set_serial == NULL);
            tmp_locals_OpenSSL$crypto_1953_key_set_serial = tmp_assign_source_125;
        }
        {
            PyObject *tmp_assign_source_126;
            tmp_assign_source_126 = MAKE_FUNCTION_OpenSSL$crypto$$$function_103_get_serial();



            assert(tmp_locals_OpenSSL$crypto_1953_key_get_serial == NULL);
            tmp_locals_OpenSSL$crypto_1953_key_get_serial = tmp_assign_source_126;
        }
        {
            PyObject *tmp_assign_source_127;
            tmp_assign_source_127 = MAKE_FUNCTION_OpenSSL$crypto$$$function_104__delete_reason();



            assert(tmp_locals_OpenSSL$crypto_1953_key__delete_reason == NULL);
            tmp_locals_OpenSSL$crypto_1953_key__delete_reason = tmp_assign_source_127;
        }
        {
            PyObject *tmp_assign_source_128;
            tmp_assign_source_128 = MAKE_FUNCTION_OpenSSL$crypto$$$function_105_set_reason();



            assert(tmp_locals_OpenSSL$crypto_1953_key_set_reason == NULL);
            tmp_locals_OpenSSL$crypto_1953_key_set_reason = tmp_assign_source_128;
        }
        {
            PyObject *tmp_assign_source_129;
            tmp_assign_source_129 = MAKE_FUNCTION_OpenSSL$crypto$$$function_106_get_reason();



            assert(tmp_locals_OpenSSL$crypto_1953_key_get_reason == NULL);
            tmp_locals_OpenSSL$crypto_1953_key_get_reason = tmp_assign_source_129;
        }
        {
            PyObject *tmp_assign_source_130;
            tmp_assign_source_130 = MAKE_FUNCTION_OpenSSL$crypto$$$function_107_all_reasons();



            assert(tmp_locals_OpenSSL$crypto_1953_key_all_reasons == NULL);
            tmp_locals_OpenSSL$crypto_1953_key_all_reasons = tmp_assign_source_130;
        }
        {
            PyObject *tmp_assign_source_131;
            tmp_assign_source_131 = MAKE_FUNCTION_OpenSSL$crypto$$$function_108_set_rev_date();



            assert(tmp_locals_OpenSSL$crypto_1953_key_set_rev_date == NULL);
            tmp_locals_OpenSSL$crypto_1953_key_set_rev_date = tmp_assign_source_131;
        }
        {
            PyObject *tmp_assign_source_132;
            tmp_assign_source_132 = MAKE_FUNCTION_OpenSSL$crypto$$$function_109_get_rev_date();



            assert(tmp_locals_OpenSSL$crypto_1953_key_get_rev_date == NULL);
            tmp_locals_OpenSSL$crypto_1953_key_get_rev_date = tmp_assign_source_132;
        }
        // Tried code:
        {
            PyObject *tmp_dict_key_26;
            PyObject *tmp_dict_value_26;
            PyObject *tmp_dict_key_27;
            PyObject *tmp_dict_value_27;
            PyObject *tmp_dict_key_28;
            PyObject *tmp_dict_value_28;
            PyObject *tmp_dict_key_29;
            PyObject *tmp_dict_value_29;
            PyObject *tmp_dict_key_30;
            PyObject *tmp_dict_value_30;
            PyObject *tmp_dict_key_31;
            PyObject *tmp_dict_value_31;
            PyObject *tmp_dict_key_32;
            PyObject *tmp_dict_value_32;
            PyObject *tmp_dict_key_33;
            PyObject *tmp_dict_value_33;
            PyObject *tmp_dict_key_34;
            PyObject *tmp_dict_value_34;
            PyObject *tmp_dict_key_35;
            PyObject *tmp_dict_value_35;
            PyObject *tmp_dict_key_36;
            PyObject *tmp_dict_value_36;
            PyObject *tmp_dict_key_37;
            PyObject *tmp_dict_value_37;
            tmp_dict_value_26 = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
            tmp_dict_key_26 = const_str_plain___module__;
            tmp_assign_source_122 = _PyDict_NewPresized( 12 );
            tmp_res = PyDict_SetItem(tmp_assign_source_122, tmp_dict_key_26, tmp_dict_value_26);
            assert(!(tmp_res != 0));
            tmp_dict_value_27 = const_str_digest_6b975dcb77568b31c2312e045b6c638c;
            tmp_dict_key_27 = const_str_plain___doc__;
            tmp_res = PyDict_SetItem(tmp_assign_source_122, tmp_dict_key_27, tmp_dict_value_27);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_1953_key__crl_reasons);
            tmp_dict_value_28 = tmp_locals_OpenSSL$crypto_1953_key__crl_reasons;
            tmp_dict_key_28 = const_str_plain__crl_reasons;
            tmp_res = PyDict_SetItem(tmp_assign_source_122, tmp_dict_key_28, tmp_dict_value_28);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_1953_key___init__);
            tmp_dict_value_29 = tmp_locals_OpenSSL$crypto_1953_key___init__;
            tmp_dict_key_29 = const_str_plain___init__;
            tmp_res = PyDict_SetItem(tmp_assign_source_122, tmp_dict_key_29, tmp_dict_value_29);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_1953_key_set_serial);
            tmp_dict_value_30 = tmp_locals_OpenSSL$crypto_1953_key_set_serial;
            tmp_dict_key_30 = const_str_plain_set_serial;
            tmp_res = PyDict_SetItem(tmp_assign_source_122, tmp_dict_key_30, tmp_dict_value_30);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_1953_key_get_serial);
            tmp_dict_value_31 = tmp_locals_OpenSSL$crypto_1953_key_get_serial;
            tmp_dict_key_31 = const_str_plain_get_serial;
            tmp_res = PyDict_SetItem(tmp_assign_source_122, tmp_dict_key_31, tmp_dict_value_31);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_1953_key__delete_reason);
            tmp_dict_value_32 = tmp_locals_OpenSSL$crypto_1953_key__delete_reason;
            tmp_dict_key_32 = const_str_plain__delete_reason;
            tmp_res = PyDict_SetItem(tmp_assign_source_122, tmp_dict_key_32, tmp_dict_value_32);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_1953_key_set_reason);
            tmp_dict_value_33 = tmp_locals_OpenSSL$crypto_1953_key_set_reason;
            tmp_dict_key_33 = const_str_plain_set_reason;
            tmp_res = PyDict_SetItem(tmp_assign_source_122, tmp_dict_key_33, tmp_dict_value_33);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_1953_key_get_reason);
            tmp_dict_value_34 = tmp_locals_OpenSSL$crypto_1953_key_get_reason;
            tmp_dict_key_34 = const_str_plain_get_reason;
            tmp_res = PyDict_SetItem(tmp_assign_source_122, tmp_dict_key_34, tmp_dict_value_34);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_1953_key_all_reasons);
            tmp_dict_value_35 = tmp_locals_OpenSSL$crypto_1953_key_all_reasons;
            tmp_dict_key_35 = const_str_plain_all_reasons;
            tmp_res = PyDict_SetItem(tmp_assign_source_122, tmp_dict_key_35, tmp_dict_value_35);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_1953_key_set_rev_date);
            tmp_dict_value_36 = tmp_locals_OpenSSL$crypto_1953_key_set_rev_date;
            tmp_dict_key_36 = const_str_plain_set_rev_date;
            tmp_res = PyDict_SetItem(tmp_assign_source_122, tmp_dict_key_36, tmp_dict_value_36);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_1953_key_get_rev_date);
            tmp_dict_value_37 = tmp_locals_OpenSSL$crypto_1953_key_get_rev_date;
            tmp_dict_key_37 = const_str_plain_get_rev_date;
            tmp_res = PyDict_SetItem(tmp_assign_source_122, tmp_dict_key_37, tmp_dict_value_37);
            assert(!(tmp_res != 0));
            goto try_return_handler_27;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$crypto);
        return NULL;
        // Return handler code:
        try_return_handler_27:;
        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_1953_key__crl_reasons);
        Py_DECREF(tmp_locals_OpenSSL$crypto_1953_key__crl_reasons);
        tmp_locals_OpenSSL$crypto_1953_key__crl_reasons = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_1953_key___init__);
        Py_DECREF(tmp_locals_OpenSSL$crypto_1953_key___init__);
        tmp_locals_OpenSSL$crypto_1953_key___init__ = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_1953_key_set_serial);
        Py_DECREF(tmp_locals_OpenSSL$crypto_1953_key_set_serial);
        tmp_locals_OpenSSL$crypto_1953_key_set_serial = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_1953_key_get_serial);
        Py_DECREF(tmp_locals_OpenSSL$crypto_1953_key_get_serial);
        tmp_locals_OpenSSL$crypto_1953_key_get_serial = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_1953_key__delete_reason);
        Py_DECREF(tmp_locals_OpenSSL$crypto_1953_key__delete_reason);
        tmp_locals_OpenSSL$crypto_1953_key__delete_reason = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_1953_key_set_reason);
        Py_DECREF(tmp_locals_OpenSSL$crypto_1953_key_set_reason);
        tmp_locals_OpenSSL$crypto_1953_key_set_reason = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_1953_key_get_reason);
        Py_DECREF(tmp_locals_OpenSSL$crypto_1953_key_get_reason);
        tmp_locals_OpenSSL$crypto_1953_key_get_reason = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_1953_key_all_reasons);
        Py_DECREF(tmp_locals_OpenSSL$crypto_1953_key_all_reasons);
        tmp_locals_OpenSSL$crypto_1953_key_all_reasons = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_1953_key_set_rev_date);
        Py_DECREF(tmp_locals_OpenSSL$crypto_1953_key_set_rev_date);
        tmp_locals_OpenSSL$crypto_1953_key_set_rev_date = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_1953_key_get_rev_date);
        Py_DECREF(tmp_locals_OpenSSL$crypto_1953_key_get_rev_date);
        tmp_locals_OpenSSL$crypto_1953_key_get_rev_date = NULL;

        goto outline_result_12;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$crypto);
        return NULL;
        outline_result_12:;
        assert(tmp_class_creation_13__class_dict == NULL);
        tmp_class_creation_13__class_dict = tmp_assign_source_122;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_133;
        nuitka_bool tmp_condition_result_14;
        PyObject *tmp_key_name_25;
        PyObject *tmp_dict_name_25;
        PyObject *tmp_dict_name_26;
        PyObject *tmp_key_name_26;
        tmp_key_name_25 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_13__class_dict);
        tmp_dict_name_25 = tmp_class_creation_13__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_25, tmp_key_name_25);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1953;

            goto try_except_handler_28;
        }
        tmp_condition_result_14 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_14 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_13;
        } else {
            goto condexpr_false_13;
        }
        condexpr_true_13:;
        CHECK_OBJECT(tmp_class_creation_13__class_dict);
        tmp_dict_name_26 = tmp_class_creation_13__class_dict;
        tmp_key_name_26 = const_str_plain___metaclass__;
        tmp_assign_source_133 = DICT_GET_ITEM(tmp_dict_name_26, tmp_key_name_26);
        if (tmp_assign_source_133 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1953;

            goto try_except_handler_28;
        }
        goto condexpr_end_13;
        condexpr_false_13:;
        tmp_assign_source_133 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_133);
        condexpr_end_13:;
        assert(tmp_class_creation_13__metaclass == NULL);
        tmp_class_creation_13__metaclass = tmp_assign_source_133;
    }
    {
        PyObject *tmp_assign_source_134;
        PyObject *tmp_called_name_28;
        PyObject *tmp_args_element_name_71;
        PyObject *tmp_args_element_name_72;
        PyObject *tmp_args_element_name_73;
        CHECK_OBJECT(tmp_class_creation_13__metaclass);
        tmp_called_name_28 = tmp_class_creation_13__metaclass;
        tmp_args_element_name_71 = const_str_plain_Revoked;
        tmp_args_element_name_72 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_13__class_dict);
        tmp_args_element_name_73 = tmp_class_creation_13__class_dict;
        frame_d796a9417638ea0fc15dcdcd73475757->m_frame.f_lineno = 1953;
        {
            PyObject *call_args[] = {tmp_args_element_name_71, tmp_args_element_name_72, tmp_args_element_name_73};
            tmp_assign_source_134 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_28, call_args);
        }

        if (tmp_assign_source_134 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1953;

            goto try_except_handler_28;
        }
        assert(tmp_class_creation_13__class == NULL);
        tmp_class_creation_13__class = tmp_assign_source_134;
    }
    goto try_end_16;
    // Exception handler code:
    try_except_handler_28:;
    exception_keeper_type_23 = exception_type;
    exception_keeper_value_23 = exception_value;
    exception_keeper_tb_23 = exception_tb;
    exception_keeper_lineno_23 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)tmp_class_creation_13__class_dict);
    Py_DECREF(tmp_class_creation_13__class_dict);
    tmp_class_creation_13__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_13__metaclass);
    tmp_class_creation_13__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_23;
    exception_value = exception_keeper_value_23;
    exception_tb = exception_keeper_tb_23;
    exception_lineno = exception_keeper_lineno_23;

    goto frame_exception_exit_1;
    // End of try:
    try_end_16:;
    {
        PyObject *tmp_assign_source_135;
        CHECK_OBJECT(tmp_class_creation_13__class);
        tmp_assign_source_135 = tmp_class_creation_13__class;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_Revoked, tmp_assign_source_135);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_13__class);
    Py_DECREF(tmp_class_creation_13__class);
    tmp_class_creation_13__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_13__class_dict);
    Py_DECREF(tmp_class_creation_13__class_dict);
    tmp_class_creation_13__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_13__metaclass);
    Py_DECREF(tmp_class_creation_13__metaclass);
    tmp_class_creation_13__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_136;
        {
            PyObject *tmp_set_locals_8;
            tmp_set_locals_8 = PyDict_New();
            locals_OpenSSL$crypto_2123 = tmp_set_locals_8;
        }
        tmp_dictset_value = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_2123, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = const_str_digest_6b6b180b644052fa34c3e81151f6ea0a;
        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_2123, const_str_plain___doc__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_110___init__();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_2123, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_111_to_cryptography();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_2123, const_str_plain_to_cryptography, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_de021b22d6a553ff379ffc2219845a9b_9, codeobj_de021b22d6a553ff379ffc2219845a9b, module_OpenSSL$crypto, 0);
        frame_de021b22d6a553ff379ffc2219845a9b_9 = cache_frame_de021b22d6a553ff379ffc2219845a9b_9;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_de021b22d6a553ff379ffc2219845a9b_9);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_de021b22d6a553ff379ffc2219845a9b_9) == 2); // Frame stack

        // Framed code:
        {
            PyObject *tmp_classmethod_arg_8;
            tmp_classmethod_arg_8 = MAKE_FUNCTION_OpenSSL$crypto$$$function_112_from_cryptography();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_8);
            Py_DECREF(tmp_classmethod_arg_8);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2146;

                goto frame_exception_exit_9;
            }
            tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_2123, const_str_plain_from_cryptography, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2146;

                goto frame_exception_exit_9;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_113_get_revoked();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_2123, const_str_plain_get_revoked, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_114_add_revoked();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_2123, const_str_plain_add_revoked, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_115_get_issuer();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_2123, const_str_plain_get_issuer, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_116_set_version();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_2123, const_str_plain_set_version, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_117__set_boundary_time();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_2123, const_str_plain__set_boundary_time, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_118_set_lastUpdate();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_2123, const_str_plain_set_lastUpdate, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_119_set_nextUpdate();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_2123, const_str_plain_set_nextUpdate, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_120_sign();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_2123, const_str_plain_sign, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        {
            PyObject *tmp_defaults_4;
            PyObject *tmp_tuple_element_1;
            PyObject *tmp_mvar_value_51;
            PyObject *tmp_mvar_value_52;
            tmp_mvar_value_51 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM);

            if (unlikely(tmp_mvar_value_51 == NULL)) {
                tmp_mvar_value_51 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM);
            }

            if (tmp_mvar_value_51 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 639 ], 34, 0);
                exception_tb = NULL;

                exception_lineno = 2287;

                goto frame_exception_exit_9;
            }

            tmp_tuple_element_1 = tmp_mvar_value_51;
            tmp_defaults_4 = PyTuple_New(3);
            Py_INCREF(tmp_tuple_element_1);
            PyTuple_SET_ITEM(tmp_defaults_4, 0, tmp_tuple_element_1);
            tmp_tuple_element_1 = const_int_pos_100;
            Py_INCREF(tmp_tuple_element_1);
            PyTuple_SET_ITEM(tmp_defaults_4, 1, tmp_tuple_element_1);
            tmp_mvar_value_52 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__UNSPECIFIED);

            if (unlikely(tmp_mvar_value_52 == NULL)) {
                tmp_mvar_value_52 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__UNSPECIFIED);
            }

            if (tmp_mvar_value_52 == NULL) {
                Py_DECREF(tmp_defaults_4);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 944 ], 34, 0);
                exception_tb = NULL;

                exception_lineno = 2288;

                goto frame_exception_exit_9;
            }

            tmp_tuple_element_1 = tmp_mvar_value_52;
            Py_INCREF(tmp_tuple_element_1);
            PyTuple_SET_ITEM(tmp_defaults_4, 2, tmp_tuple_element_1);
            tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_121_export(tmp_defaults_4);



            tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_2123, const_str_plain_export, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2287;

                goto frame_exception_exit_9;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_de021b22d6a553ff379ffc2219845a9b_9);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_8;

        frame_exception_exit_9:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_de021b22d6a553ff379ffc2219845a9b_9);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_de021b22d6a553ff379ffc2219845a9b_9, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_de021b22d6a553ff379ffc2219845a9b_9->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_de021b22d6a553ff379ffc2219845a9b_9, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_de021b22d6a553ff379ffc2219845a9b_9,
            type_description_2
        );


        // Release cached frame.
        if (frame_de021b22d6a553ff379ffc2219845a9b_9 == cache_frame_de021b22d6a553ff379ffc2219845a9b_9) {
            Py_DECREF(frame_de021b22d6a553ff379ffc2219845a9b_9);
        }
        cache_frame_de021b22d6a553ff379ffc2219845a9b_9 = NULL;

        assertFrameObject(frame_de021b22d6a553ff379ffc2219845a9b_9);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_8;

        frame_no_exception_8:;
        goto skip_nested_handling_8;
        nested_frame_exit_8:;

        goto try_except_handler_30;
        skip_nested_handling_8:;
        tmp_assign_source_136 = locals_OpenSSL$crypto_2123;
        Py_INCREF(tmp_assign_source_136);
        goto try_return_handler_30;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$crypto);
        return NULL;
        // Return handler code:
        try_return_handler_30:;
        Py_DECREF(locals_OpenSSL$crypto_2123);
        locals_OpenSSL$crypto_2123 = NULL;
        goto outline_result_13;
        // Exception handler code:
        try_except_handler_30:;
        exception_keeper_type_24 = exception_type;
        exception_keeper_value_24 = exception_value;
        exception_keeper_tb_24 = exception_tb;
        exception_keeper_lineno_24 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_OpenSSL$crypto_2123);
        locals_OpenSSL$crypto_2123 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_24;
        exception_value = exception_keeper_value_24;
        exception_tb = exception_keeper_tb_24;
        exception_lineno = exception_keeper_lineno_24;

        goto outline_exception_8;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$crypto);
        return NULL;
        outline_exception_8:;
        exception_lineno = 2123;
        goto try_except_handler_29;
        outline_result_13:;
        assert(tmp_class_creation_14__class_dict == NULL);
        tmp_class_creation_14__class_dict = tmp_assign_source_136;
    }
    {
        PyObject *tmp_assign_source_137;
        nuitka_bool tmp_condition_result_15;
        PyObject *tmp_key_name_27;
        PyObject *tmp_dict_name_27;
        PyObject *tmp_dict_name_28;
        PyObject *tmp_key_name_28;
        tmp_key_name_27 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_14__class_dict);
        tmp_dict_name_27 = tmp_class_creation_14__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_27, tmp_key_name_27);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2123;

            goto try_except_handler_29;
        }
        tmp_condition_result_15 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_15 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_14;
        } else {
            goto condexpr_false_14;
        }
        condexpr_true_14:;
        CHECK_OBJECT(tmp_class_creation_14__class_dict);
        tmp_dict_name_28 = tmp_class_creation_14__class_dict;
        tmp_key_name_28 = const_str_plain___metaclass__;
        tmp_assign_source_137 = DICT_GET_ITEM(tmp_dict_name_28, tmp_key_name_28);
        if (tmp_assign_source_137 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2123;

            goto try_except_handler_29;
        }
        goto condexpr_end_14;
        condexpr_false_14:;
        tmp_assign_source_137 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_137);
        condexpr_end_14:;
        assert(tmp_class_creation_14__metaclass == NULL);
        tmp_class_creation_14__metaclass = tmp_assign_source_137;
    }
    {
        PyObject *tmp_assign_source_138;
        PyObject *tmp_called_name_29;
        PyObject *tmp_args_element_name_74;
        PyObject *tmp_args_element_name_75;
        PyObject *tmp_args_element_name_76;
        CHECK_OBJECT(tmp_class_creation_14__metaclass);
        tmp_called_name_29 = tmp_class_creation_14__metaclass;
        tmp_args_element_name_74 = const_str_plain_CRL;
        tmp_args_element_name_75 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_14__class_dict);
        tmp_args_element_name_76 = tmp_class_creation_14__class_dict;
        frame_d796a9417638ea0fc15dcdcd73475757->m_frame.f_lineno = 2123;
        {
            PyObject *call_args[] = {tmp_args_element_name_74, tmp_args_element_name_75, tmp_args_element_name_76};
            tmp_assign_source_138 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_29, call_args);
        }

        if (tmp_assign_source_138 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2123;

            goto try_except_handler_29;
        }
        assert(tmp_class_creation_14__class == NULL);
        tmp_class_creation_14__class = tmp_assign_source_138;
    }
    goto try_end_17;
    // Exception handler code:
    try_except_handler_29:;
    exception_keeper_type_25 = exception_type;
    exception_keeper_value_25 = exception_value;
    exception_keeper_tb_25 = exception_tb;
    exception_keeper_lineno_25 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_14__class_dict);
    tmp_class_creation_14__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_14__metaclass);
    tmp_class_creation_14__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_25;
    exception_value = exception_keeper_value_25;
    exception_tb = exception_keeper_tb_25;
    exception_lineno = exception_keeper_lineno_25;

    goto frame_exception_exit_1;
    // End of try:
    try_end_17:;
    {
        PyObject *tmp_assign_source_139;
        CHECK_OBJECT(tmp_class_creation_14__class);
        tmp_assign_source_139 = tmp_class_creation_14__class;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_CRL, tmp_assign_source_139);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_14__class);
    Py_DECREF(tmp_class_creation_14__class);
    tmp_class_creation_14__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_14__class_dict);
    Py_DECREF(tmp_class_creation_14__class_dict);
    tmp_class_creation_14__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_14__metaclass);
    Py_DECREF(tmp_class_creation_14__metaclass);
    tmp_class_creation_14__metaclass = NULL;

    {
        PyObject *tmp_assign_source_140;
        PyObject *tmp_called_name_30;
        PyObject *tmp_mvar_value_53;
        PyObject *tmp_args_element_name_77;
        PyObject *tmp_mvar_value_54;
        PyObject *tmp_args_element_name_78;
        PyObject *tmp_args_element_name_79;
        PyObject *tmp_args_element_name_80;
        PyObject *tmp_mvar_value_55;
        tmp_mvar_value_53 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_deprecated);

        if (unlikely(tmp_mvar_value_53 == NULL)) {
            tmp_mvar_value_53 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_deprecated);
        }

        if (tmp_mvar_value_53 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 2548 ], 32, 0);
            exception_tb = NULL;

            exception_lineno = 2341;

            goto frame_exception_exit_1;
        }

        tmp_called_name_30 = tmp_mvar_value_53;
        tmp_mvar_value_54 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_CRL);

        if (unlikely(tmp_mvar_value_54 == NULL)) {
            tmp_mvar_value_54 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_CRL);
        }

        if (tmp_mvar_value_54 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 4309 ], 25, 0);
            exception_tb = NULL;

            exception_lineno = 2342;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_77 = tmp_mvar_value_54;
        tmp_args_element_name_78 = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
        tmp_args_element_name_79 = const_str_digest_08a0d510acdd77f37b666a4668538f96;
        tmp_mvar_value_55 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_DeprecationWarning);

        if (unlikely(tmp_mvar_value_55 == NULL)) {
            tmp_mvar_value_55 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_DeprecationWarning);
        }

        if (tmp_mvar_value_55 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 2580 ], 40, 0);
            exception_tb = NULL;

            exception_lineno = 2344;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_80 = tmp_mvar_value_55;
        frame_d796a9417638ea0fc15dcdcd73475757->m_frame.f_lineno = 2341;
        {
            PyObject *call_args[] = {tmp_args_element_name_77, tmp_args_element_name_78, tmp_args_element_name_79, tmp_args_element_name_80};
            tmp_assign_source_140 = CALL_FUNCTION_WITH_ARGS4(tmp_called_name_30, call_args);
        }

        if (tmp_assign_source_140 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2341;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_CRLType, tmp_assign_source_140);
    }
    {
        PyObject *tmp_assign_source_141;
        {
            PyObject *tmp_assign_source_142;
            tmp_assign_source_142 = MAKE_FUNCTION_OpenSSL$crypto$$$function_122_type_is_signed();



            assert(tmp_locals_OpenSSL$crypto_2348_key_type_is_signed == NULL);
            tmp_locals_OpenSSL$crypto_2348_key_type_is_signed = tmp_assign_source_142;
        }
        {
            PyObject *tmp_assign_source_143;
            tmp_assign_source_143 = MAKE_FUNCTION_OpenSSL$crypto$$$function_123_type_is_enveloped();



            assert(tmp_locals_OpenSSL$crypto_2348_key_type_is_enveloped == NULL);
            tmp_locals_OpenSSL$crypto_2348_key_type_is_enveloped = tmp_assign_source_143;
        }
        {
            PyObject *tmp_assign_source_144;
            tmp_assign_source_144 = MAKE_FUNCTION_OpenSSL$crypto$$$function_124_type_is_signedAndEnveloped();



            assert(tmp_locals_OpenSSL$crypto_2348_key_type_is_signedAndEnveloped == NULL);
            tmp_locals_OpenSSL$crypto_2348_key_type_is_signedAndEnveloped = tmp_assign_source_144;
        }
        {
            PyObject *tmp_assign_source_145;
            tmp_assign_source_145 = MAKE_FUNCTION_OpenSSL$crypto$$$function_125_type_is_data();



            assert(tmp_locals_OpenSSL$crypto_2348_key_type_is_data == NULL);
            tmp_locals_OpenSSL$crypto_2348_key_type_is_data = tmp_assign_source_145;
        }
        {
            PyObject *tmp_assign_source_146;
            tmp_assign_source_146 = MAKE_FUNCTION_OpenSSL$crypto$$$function_126_get_type_name();



            assert(tmp_locals_OpenSSL$crypto_2348_key_get_type_name == NULL);
            tmp_locals_OpenSSL$crypto_2348_key_get_type_name = tmp_assign_source_146;
        }
        // Tried code:
        {
            PyObject *tmp_dict_key_38;
            PyObject *tmp_dict_value_38;
            PyObject *tmp_dict_key_39;
            PyObject *tmp_dict_value_39;
            PyObject *tmp_dict_key_40;
            PyObject *tmp_dict_value_40;
            PyObject *tmp_dict_key_41;
            PyObject *tmp_dict_value_41;
            PyObject *tmp_dict_key_42;
            PyObject *tmp_dict_value_42;
            PyObject *tmp_dict_key_43;
            PyObject *tmp_dict_value_43;
            tmp_dict_value_38 = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
            tmp_dict_key_38 = const_str_plain___module__;
            tmp_assign_source_141 = _PyDict_NewPresized( 6 );
            tmp_res = PyDict_SetItem(tmp_assign_source_141, tmp_dict_key_38, tmp_dict_value_38);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_2348_key_type_is_signed);
            tmp_dict_value_39 = tmp_locals_OpenSSL$crypto_2348_key_type_is_signed;
            tmp_dict_key_39 = const_str_plain_type_is_signed;
            tmp_res = PyDict_SetItem(tmp_assign_source_141, tmp_dict_key_39, tmp_dict_value_39);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_2348_key_type_is_enveloped);
            tmp_dict_value_40 = tmp_locals_OpenSSL$crypto_2348_key_type_is_enveloped;
            tmp_dict_key_40 = const_str_plain_type_is_enveloped;
            tmp_res = PyDict_SetItem(tmp_assign_source_141, tmp_dict_key_40, tmp_dict_value_40);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_2348_key_type_is_signedAndEnveloped);
            tmp_dict_value_41 = tmp_locals_OpenSSL$crypto_2348_key_type_is_signedAndEnveloped;
            tmp_dict_key_41 = const_str_plain_type_is_signedAndEnveloped;
            tmp_res = PyDict_SetItem(tmp_assign_source_141, tmp_dict_key_41, tmp_dict_value_41);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_2348_key_type_is_data);
            tmp_dict_value_42 = tmp_locals_OpenSSL$crypto_2348_key_type_is_data;
            tmp_dict_key_42 = const_str_plain_type_is_data;
            tmp_res = PyDict_SetItem(tmp_assign_source_141, tmp_dict_key_42, tmp_dict_value_42);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_2348_key_get_type_name);
            tmp_dict_value_43 = tmp_locals_OpenSSL$crypto_2348_key_get_type_name;
            tmp_dict_key_43 = const_str_plain_get_type_name;
            tmp_res = PyDict_SetItem(tmp_assign_source_141, tmp_dict_key_43, tmp_dict_value_43);
            assert(!(tmp_res != 0));
            goto try_return_handler_31;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$crypto);
        return NULL;
        // Return handler code:
        try_return_handler_31:;
        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_2348_key_type_is_signed);
        Py_DECREF(tmp_locals_OpenSSL$crypto_2348_key_type_is_signed);
        tmp_locals_OpenSSL$crypto_2348_key_type_is_signed = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_2348_key_type_is_enveloped);
        Py_DECREF(tmp_locals_OpenSSL$crypto_2348_key_type_is_enveloped);
        tmp_locals_OpenSSL$crypto_2348_key_type_is_enveloped = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_2348_key_type_is_signedAndEnveloped);
        Py_DECREF(tmp_locals_OpenSSL$crypto_2348_key_type_is_signedAndEnveloped);
        tmp_locals_OpenSSL$crypto_2348_key_type_is_signedAndEnveloped = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_2348_key_type_is_data);
        Py_DECREF(tmp_locals_OpenSSL$crypto_2348_key_type_is_data);
        tmp_locals_OpenSSL$crypto_2348_key_type_is_data = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_2348_key_get_type_name);
        Py_DECREF(tmp_locals_OpenSSL$crypto_2348_key_get_type_name);
        tmp_locals_OpenSSL$crypto_2348_key_get_type_name = NULL;

        goto outline_result_14;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$crypto);
        return NULL;
        outline_result_14:;
        assert(tmp_class_creation_15__class_dict == NULL);
        tmp_class_creation_15__class_dict = tmp_assign_source_141;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_147;
        nuitka_bool tmp_condition_result_16;
        PyObject *tmp_key_name_29;
        PyObject *tmp_dict_name_29;
        PyObject *tmp_dict_name_30;
        PyObject *tmp_key_name_30;
        tmp_key_name_29 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_15__class_dict);
        tmp_dict_name_29 = tmp_class_creation_15__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_29, tmp_key_name_29);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2348;

            goto try_except_handler_32;
        }
        tmp_condition_result_16 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_16 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_15;
        } else {
            goto condexpr_false_15;
        }
        condexpr_true_15:;
        CHECK_OBJECT(tmp_class_creation_15__class_dict);
        tmp_dict_name_30 = tmp_class_creation_15__class_dict;
        tmp_key_name_30 = const_str_plain___metaclass__;
        tmp_assign_source_147 = DICT_GET_ITEM(tmp_dict_name_30, tmp_key_name_30);
        if (tmp_assign_source_147 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2348;

            goto try_except_handler_32;
        }
        goto condexpr_end_15;
        condexpr_false_15:;
        tmp_assign_source_147 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_147);
        condexpr_end_15:;
        assert(tmp_class_creation_15__metaclass == NULL);
        tmp_class_creation_15__metaclass = tmp_assign_source_147;
    }
    {
        PyObject *tmp_assign_source_148;
        PyObject *tmp_called_name_31;
        PyObject *tmp_args_element_name_81;
        PyObject *tmp_args_element_name_82;
        PyObject *tmp_args_element_name_83;
        CHECK_OBJECT(tmp_class_creation_15__metaclass);
        tmp_called_name_31 = tmp_class_creation_15__metaclass;
        tmp_args_element_name_81 = const_str_plain_PKCS7;
        tmp_args_element_name_82 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_15__class_dict);
        tmp_args_element_name_83 = tmp_class_creation_15__class_dict;
        frame_d796a9417638ea0fc15dcdcd73475757->m_frame.f_lineno = 2348;
        {
            PyObject *call_args[] = {tmp_args_element_name_81, tmp_args_element_name_82, tmp_args_element_name_83};
            tmp_assign_source_148 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_31, call_args);
        }

        if (tmp_assign_source_148 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2348;

            goto try_except_handler_32;
        }
        assert(tmp_class_creation_15__class == NULL);
        tmp_class_creation_15__class = tmp_assign_source_148;
    }
    goto try_end_18;
    // Exception handler code:
    try_except_handler_32:;
    exception_keeper_type_26 = exception_type;
    exception_keeper_value_26 = exception_value;
    exception_keeper_tb_26 = exception_tb;
    exception_keeper_lineno_26 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)tmp_class_creation_15__class_dict);
    Py_DECREF(tmp_class_creation_15__class_dict);
    tmp_class_creation_15__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_15__metaclass);
    tmp_class_creation_15__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_26;
    exception_value = exception_keeper_value_26;
    exception_tb = exception_keeper_tb_26;
    exception_lineno = exception_keeper_lineno_26;

    goto frame_exception_exit_1;
    // End of try:
    try_end_18:;
    {
        PyObject *tmp_assign_source_149;
        CHECK_OBJECT(tmp_class_creation_15__class);
        tmp_assign_source_149 = tmp_class_creation_15__class;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKCS7, tmp_assign_source_149);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_15__class);
    Py_DECREF(tmp_class_creation_15__class);
    tmp_class_creation_15__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_15__class_dict);
    Py_DECREF(tmp_class_creation_15__class_dict);
    tmp_class_creation_15__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_15__metaclass);
    Py_DECREF(tmp_class_creation_15__metaclass);
    tmp_class_creation_15__metaclass = NULL;

    {
        PyObject *tmp_assign_source_150;
        PyObject *tmp_called_name_32;
        PyObject *tmp_mvar_value_56;
        PyObject *tmp_args_element_name_84;
        PyObject *tmp_mvar_value_57;
        PyObject *tmp_args_element_name_85;
        PyObject *tmp_args_element_name_86;
        PyObject *tmp_args_element_name_87;
        PyObject *tmp_mvar_value_58;
        tmp_mvar_value_56 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_deprecated);

        if (unlikely(tmp_mvar_value_56 == NULL)) {
            tmp_mvar_value_56 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_deprecated);
        }

        if (tmp_mvar_value_56 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 2548 ], 32, 0);
            exception_tb = NULL;

            exception_lineno = 2392;

            goto frame_exception_exit_1;
        }

        tmp_called_name_32 = tmp_mvar_value_56;
        tmp_mvar_value_57 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKCS7);

        if (unlikely(tmp_mvar_value_57 == NULL)) {
            tmp_mvar_value_57 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_PKCS7);
        }

        if (tmp_mvar_value_57 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 4341 ], 27, 0);
            exception_tb = NULL;

            exception_lineno = 2393;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_84 = tmp_mvar_value_57;
        tmp_args_element_name_85 = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
        tmp_args_element_name_86 = const_str_digest_1cf455235163a6978480cc7b12198a27;
        tmp_mvar_value_58 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_DeprecationWarning);

        if (unlikely(tmp_mvar_value_58 == NULL)) {
            tmp_mvar_value_58 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_DeprecationWarning);
        }

        if (tmp_mvar_value_58 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 2580 ], 40, 0);
            exception_tb = NULL;

            exception_lineno = 2395;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_87 = tmp_mvar_value_58;
        frame_d796a9417638ea0fc15dcdcd73475757->m_frame.f_lineno = 2392;
        {
            PyObject *call_args[] = {tmp_args_element_name_84, tmp_args_element_name_85, tmp_args_element_name_86, tmp_args_element_name_87};
            tmp_assign_source_150 = CALL_FUNCTION_WITH_ARGS4(tmp_called_name_32, call_args);
        }

        if (tmp_assign_source_150 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2392;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKCS7Type, tmp_assign_source_150);
    }
    {
        PyObject *tmp_assign_source_151;
        {
            PyObject *tmp_assign_source_152;
            tmp_assign_source_152 = MAKE_FUNCTION_OpenSSL$crypto$$$function_127___init__();



            assert(tmp_locals_OpenSSL$crypto_2399_key___init__ == NULL);
            tmp_locals_OpenSSL$crypto_2399_key___init__ = tmp_assign_source_152;
        }
        {
            PyObject *tmp_assign_source_153;
            tmp_assign_source_153 = MAKE_FUNCTION_OpenSSL$crypto$$$function_128_get_certificate();



            assert(tmp_locals_OpenSSL$crypto_2399_key_get_certificate == NULL);
            tmp_locals_OpenSSL$crypto_2399_key_get_certificate = tmp_assign_source_153;
        }
        {
            PyObject *tmp_assign_source_154;
            tmp_assign_source_154 = MAKE_FUNCTION_OpenSSL$crypto$$$function_129_set_certificate();



            assert(tmp_locals_OpenSSL$crypto_2399_key_set_certificate == NULL);
            tmp_locals_OpenSSL$crypto_2399_key_set_certificate = tmp_assign_source_154;
        }
        {
            PyObject *tmp_assign_source_155;
            tmp_assign_source_155 = MAKE_FUNCTION_OpenSSL$crypto$$$function_130_get_privatekey();



            assert(tmp_locals_OpenSSL$crypto_2399_key_get_privatekey == NULL);
            tmp_locals_OpenSSL$crypto_2399_key_get_privatekey = tmp_assign_source_155;
        }
        {
            PyObject *tmp_assign_source_156;
            tmp_assign_source_156 = MAKE_FUNCTION_OpenSSL$crypto$$$function_131_set_privatekey();



            assert(tmp_locals_OpenSSL$crypto_2399_key_set_privatekey == NULL);
            tmp_locals_OpenSSL$crypto_2399_key_set_privatekey = tmp_assign_source_156;
        }
        {
            PyObject *tmp_assign_source_157;
            tmp_assign_source_157 = MAKE_FUNCTION_OpenSSL$crypto$$$function_132_get_ca_certificates();



            assert(tmp_locals_OpenSSL$crypto_2399_key_get_ca_certificates == NULL);
            tmp_locals_OpenSSL$crypto_2399_key_get_ca_certificates = tmp_assign_source_157;
        }
        {
            PyObject *tmp_assign_source_158;
            tmp_assign_source_158 = MAKE_FUNCTION_OpenSSL$crypto$$$function_133_set_ca_certificates();



            assert(tmp_locals_OpenSSL$crypto_2399_key_set_ca_certificates == NULL);
            tmp_locals_OpenSSL$crypto_2399_key_set_ca_certificates = tmp_assign_source_158;
        }
        {
            PyObject *tmp_assign_source_159;
            tmp_assign_source_159 = MAKE_FUNCTION_OpenSSL$crypto$$$function_134_set_friendlyname();



            assert(tmp_locals_OpenSSL$crypto_2399_key_set_friendlyname == NULL);
            tmp_locals_OpenSSL$crypto_2399_key_set_friendlyname = tmp_assign_source_159;
        }
        {
            PyObject *tmp_assign_source_160;
            tmp_assign_source_160 = MAKE_FUNCTION_OpenSSL$crypto$$$function_135_get_friendlyname();



            assert(tmp_locals_OpenSSL$crypto_2399_key_get_friendlyname == NULL);
            tmp_locals_OpenSSL$crypto_2399_key_get_friendlyname = tmp_assign_source_160;
        }
        {
            PyObject *tmp_assign_source_161;
            PyObject *tmp_defaults_5;
            tmp_defaults_5 = const_tuple_none_int_pos_2048_int_pos_1_tuple;
            Py_INCREF(tmp_defaults_5);
            tmp_assign_source_161 = MAKE_FUNCTION_OpenSSL$crypto$$$function_136_export(tmp_defaults_5);



            assert(tmp_locals_OpenSSL$crypto_2399_key_export == NULL);
            tmp_locals_OpenSSL$crypto_2399_key_export = tmp_assign_source_161;
        }
        // Tried code:
        {
            PyObject *tmp_dict_key_44;
            PyObject *tmp_dict_value_44;
            PyObject *tmp_dict_key_45;
            PyObject *tmp_dict_value_45;
            PyObject *tmp_dict_key_46;
            PyObject *tmp_dict_value_46;
            PyObject *tmp_dict_key_47;
            PyObject *tmp_dict_value_47;
            PyObject *tmp_dict_key_48;
            PyObject *tmp_dict_value_48;
            PyObject *tmp_dict_key_49;
            PyObject *tmp_dict_value_49;
            PyObject *tmp_dict_key_50;
            PyObject *tmp_dict_value_50;
            PyObject *tmp_dict_key_51;
            PyObject *tmp_dict_value_51;
            PyObject *tmp_dict_key_52;
            PyObject *tmp_dict_value_52;
            PyObject *tmp_dict_key_53;
            PyObject *tmp_dict_value_53;
            PyObject *tmp_dict_key_54;
            PyObject *tmp_dict_value_54;
            PyObject *tmp_dict_key_55;
            PyObject *tmp_dict_value_55;
            tmp_dict_value_44 = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
            tmp_dict_key_44 = const_str_plain___module__;
            tmp_assign_source_151 = _PyDict_NewPresized( 12 );
            tmp_res = PyDict_SetItem(tmp_assign_source_151, tmp_dict_key_44, tmp_dict_value_44);
            assert(!(tmp_res != 0));
            tmp_dict_value_45 = const_str_digest_4b3673d04a6e4a628e29457d54d43c0d;
            tmp_dict_key_45 = const_str_plain___doc__;
            tmp_res = PyDict_SetItem(tmp_assign_source_151, tmp_dict_key_45, tmp_dict_value_45);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_2399_key___init__);
            tmp_dict_value_46 = tmp_locals_OpenSSL$crypto_2399_key___init__;
            tmp_dict_key_46 = const_str_plain___init__;
            tmp_res = PyDict_SetItem(tmp_assign_source_151, tmp_dict_key_46, tmp_dict_value_46);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_2399_key_get_certificate);
            tmp_dict_value_47 = tmp_locals_OpenSSL$crypto_2399_key_get_certificate;
            tmp_dict_key_47 = const_str_plain_get_certificate;
            tmp_res = PyDict_SetItem(tmp_assign_source_151, tmp_dict_key_47, tmp_dict_value_47);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_2399_key_set_certificate);
            tmp_dict_value_48 = tmp_locals_OpenSSL$crypto_2399_key_set_certificate;
            tmp_dict_key_48 = const_str_plain_set_certificate;
            tmp_res = PyDict_SetItem(tmp_assign_source_151, tmp_dict_key_48, tmp_dict_value_48);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_2399_key_get_privatekey);
            tmp_dict_value_49 = tmp_locals_OpenSSL$crypto_2399_key_get_privatekey;
            tmp_dict_key_49 = const_str_plain_get_privatekey;
            tmp_res = PyDict_SetItem(tmp_assign_source_151, tmp_dict_key_49, tmp_dict_value_49);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_2399_key_set_privatekey);
            tmp_dict_value_50 = tmp_locals_OpenSSL$crypto_2399_key_set_privatekey;
            tmp_dict_key_50 = const_str_plain_set_privatekey;
            tmp_res = PyDict_SetItem(tmp_assign_source_151, tmp_dict_key_50, tmp_dict_value_50);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_2399_key_get_ca_certificates);
            tmp_dict_value_51 = tmp_locals_OpenSSL$crypto_2399_key_get_ca_certificates;
            tmp_dict_key_51 = const_str_plain_get_ca_certificates;
            tmp_res = PyDict_SetItem(tmp_assign_source_151, tmp_dict_key_51, tmp_dict_value_51);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_2399_key_set_ca_certificates);
            tmp_dict_value_52 = tmp_locals_OpenSSL$crypto_2399_key_set_ca_certificates;
            tmp_dict_key_52 = const_str_plain_set_ca_certificates;
            tmp_res = PyDict_SetItem(tmp_assign_source_151, tmp_dict_key_52, tmp_dict_value_52);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_2399_key_set_friendlyname);
            tmp_dict_value_53 = tmp_locals_OpenSSL$crypto_2399_key_set_friendlyname;
            tmp_dict_key_53 = const_str_plain_set_friendlyname;
            tmp_res = PyDict_SetItem(tmp_assign_source_151, tmp_dict_key_53, tmp_dict_value_53);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_2399_key_get_friendlyname);
            tmp_dict_value_54 = tmp_locals_OpenSSL$crypto_2399_key_get_friendlyname;
            tmp_dict_key_54 = const_str_plain_get_friendlyname;
            tmp_res = PyDict_SetItem(tmp_assign_source_151, tmp_dict_key_54, tmp_dict_value_54);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_2399_key_export);
            tmp_dict_value_55 = tmp_locals_OpenSSL$crypto_2399_key_export;
            tmp_dict_key_55 = const_str_plain_export;
            tmp_res = PyDict_SetItem(tmp_assign_source_151, tmp_dict_key_55, tmp_dict_value_55);
            assert(!(tmp_res != 0));
            goto try_return_handler_33;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$crypto);
        return NULL;
        // Return handler code:
        try_return_handler_33:;
        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_2399_key___init__);
        Py_DECREF(tmp_locals_OpenSSL$crypto_2399_key___init__);
        tmp_locals_OpenSSL$crypto_2399_key___init__ = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_2399_key_get_certificate);
        Py_DECREF(tmp_locals_OpenSSL$crypto_2399_key_get_certificate);
        tmp_locals_OpenSSL$crypto_2399_key_get_certificate = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_2399_key_set_certificate);
        Py_DECREF(tmp_locals_OpenSSL$crypto_2399_key_set_certificate);
        tmp_locals_OpenSSL$crypto_2399_key_set_certificate = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_2399_key_get_privatekey);
        Py_DECREF(tmp_locals_OpenSSL$crypto_2399_key_get_privatekey);
        tmp_locals_OpenSSL$crypto_2399_key_get_privatekey = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_2399_key_set_privatekey);
        Py_DECREF(tmp_locals_OpenSSL$crypto_2399_key_set_privatekey);
        tmp_locals_OpenSSL$crypto_2399_key_set_privatekey = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_2399_key_get_ca_certificates);
        Py_DECREF(tmp_locals_OpenSSL$crypto_2399_key_get_ca_certificates);
        tmp_locals_OpenSSL$crypto_2399_key_get_ca_certificates = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_2399_key_set_ca_certificates);
        Py_DECREF(tmp_locals_OpenSSL$crypto_2399_key_set_ca_certificates);
        tmp_locals_OpenSSL$crypto_2399_key_set_ca_certificates = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_2399_key_set_friendlyname);
        Py_DECREF(tmp_locals_OpenSSL$crypto_2399_key_set_friendlyname);
        tmp_locals_OpenSSL$crypto_2399_key_set_friendlyname = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_2399_key_get_friendlyname);
        Py_DECREF(tmp_locals_OpenSSL$crypto_2399_key_get_friendlyname);
        tmp_locals_OpenSSL$crypto_2399_key_get_friendlyname = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_2399_key_export);
        Py_DECREF(tmp_locals_OpenSSL$crypto_2399_key_export);
        tmp_locals_OpenSSL$crypto_2399_key_export = NULL;

        goto outline_result_15;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$crypto);
        return NULL;
        outline_result_15:;
        assert(tmp_class_creation_16__class_dict == NULL);
        tmp_class_creation_16__class_dict = tmp_assign_source_151;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_162;
        nuitka_bool tmp_condition_result_17;
        PyObject *tmp_key_name_31;
        PyObject *tmp_dict_name_31;
        PyObject *tmp_dict_name_32;
        PyObject *tmp_key_name_32;
        tmp_key_name_31 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_16__class_dict);
        tmp_dict_name_31 = tmp_class_creation_16__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_31, tmp_key_name_31);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2399;

            goto try_except_handler_34;
        }
        tmp_condition_result_17 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_17 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_16;
        } else {
            goto condexpr_false_16;
        }
        condexpr_true_16:;
        CHECK_OBJECT(tmp_class_creation_16__class_dict);
        tmp_dict_name_32 = tmp_class_creation_16__class_dict;
        tmp_key_name_32 = const_str_plain___metaclass__;
        tmp_assign_source_162 = DICT_GET_ITEM(tmp_dict_name_32, tmp_key_name_32);
        if (tmp_assign_source_162 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2399;

            goto try_except_handler_34;
        }
        goto condexpr_end_16;
        condexpr_false_16:;
        tmp_assign_source_162 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_162);
        condexpr_end_16:;
        assert(tmp_class_creation_16__metaclass == NULL);
        tmp_class_creation_16__metaclass = tmp_assign_source_162;
    }
    {
        PyObject *tmp_assign_source_163;
        PyObject *tmp_called_name_33;
        PyObject *tmp_args_element_name_88;
        PyObject *tmp_args_element_name_89;
        PyObject *tmp_args_element_name_90;
        CHECK_OBJECT(tmp_class_creation_16__metaclass);
        tmp_called_name_33 = tmp_class_creation_16__metaclass;
        tmp_args_element_name_88 = const_str_plain_PKCS12;
        tmp_args_element_name_89 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_16__class_dict);
        tmp_args_element_name_90 = tmp_class_creation_16__class_dict;
        frame_d796a9417638ea0fc15dcdcd73475757->m_frame.f_lineno = 2399;
        {
            PyObject *call_args[] = {tmp_args_element_name_88, tmp_args_element_name_89, tmp_args_element_name_90};
            tmp_assign_source_163 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_33, call_args);
        }

        if (tmp_assign_source_163 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2399;

            goto try_except_handler_34;
        }
        assert(tmp_class_creation_16__class == NULL);
        tmp_class_creation_16__class = tmp_assign_source_163;
    }
    goto try_end_19;
    // Exception handler code:
    try_except_handler_34:;
    exception_keeper_type_27 = exception_type;
    exception_keeper_value_27 = exception_value;
    exception_keeper_tb_27 = exception_tb;
    exception_keeper_lineno_27 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)tmp_class_creation_16__class_dict);
    Py_DECREF(tmp_class_creation_16__class_dict);
    tmp_class_creation_16__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_16__metaclass);
    tmp_class_creation_16__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_27;
    exception_value = exception_keeper_value_27;
    exception_tb = exception_keeper_tb_27;
    exception_lineno = exception_keeper_lineno_27;

    goto frame_exception_exit_1;
    // End of try:
    try_end_19:;
    {
        PyObject *tmp_assign_source_164;
        CHECK_OBJECT(tmp_class_creation_16__class);
        tmp_assign_source_164 = tmp_class_creation_16__class;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKCS12, tmp_assign_source_164);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_16__class);
    Py_DECREF(tmp_class_creation_16__class);
    tmp_class_creation_16__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_16__class_dict);
    Py_DECREF(tmp_class_creation_16__class_dict);
    tmp_class_creation_16__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_16__metaclass);
    Py_DECREF(tmp_class_creation_16__metaclass);
    tmp_class_creation_16__metaclass = NULL;

    {
        PyObject *tmp_assign_source_165;
        PyObject *tmp_called_name_34;
        PyObject *tmp_mvar_value_59;
        PyObject *tmp_args_element_name_91;
        PyObject *tmp_mvar_value_60;
        PyObject *tmp_args_element_name_92;
        PyObject *tmp_args_element_name_93;
        PyObject *tmp_args_element_name_94;
        PyObject *tmp_mvar_value_61;
        tmp_mvar_value_59 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_deprecated);

        if (unlikely(tmp_mvar_value_59 == NULL)) {
            tmp_mvar_value_59 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_deprecated);
        }

        if (tmp_mvar_value_59 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 2548 ], 32, 0);
            exception_tb = NULL;

            exception_lineno = 2573;

            goto frame_exception_exit_1;
        }

        tmp_called_name_34 = tmp_mvar_value_59;
        tmp_mvar_value_60 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKCS12);

        if (unlikely(tmp_mvar_value_60 == NULL)) {
            tmp_mvar_value_60 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_PKCS12);
        }

        if (tmp_mvar_value_60 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 4375 ], 28, 0);
            exception_tb = NULL;

            exception_lineno = 2574;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_91 = tmp_mvar_value_60;
        tmp_args_element_name_92 = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
        tmp_args_element_name_93 = const_str_digest_3c7878f9f14c822b0ae6ebb3dbe0804c;
        tmp_mvar_value_61 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_DeprecationWarning);

        if (unlikely(tmp_mvar_value_61 == NULL)) {
            tmp_mvar_value_61 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_DeprecationWarning);
        }

        if (tmp_mvar_value_61 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 2580 ], 40, 0);
            exception_tb = NULL;

            exception_lineno = 2576;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_94 = tmp_mvar_value_61;
        frame_d796a9417638ea0fc15dcdcd73475757->m_frame.f_lineno = 2573;
        {
            PyObject *call_args[] = {tmp_args_element_name_91, tmp_args_element_name_92, tmp_args_element_name_93, tmp_args_element_name_94};
            tmp_assign_source_165 = CALL_FUNCTION_WITH_ARGS4(tmp_called_name_34, call_args);
        }

        if (tmp_assign_source_165 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2573;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKCS12Type, tmp_assign_source_165);
    }
    {
        PyObject *tmp_assign_source_166;
        {
            PyObject *tmp_assign_source_167;
            tmp_assign_source_167 = MAKE_FUNCTION_OpenSSL$crypto$$$function_137___init__();



            assert(tmp_locals_OpenSSL$crypto_2580_key___init__ == NULL);
            tmp_locals_OpenSSL$crypto_2580_key___init__ = tmp_assign_source_167;
        }
        {
            PyObject *tmp_assign_source_168;
            tmp_assign_source_168 = MAKE_FUNCTION_OpenSSL$crypto$$$function_138_sign();



            assert(tmp_locals_OpenSSL$crypto_2580_key_sign == NULL);
            tmp_locals_OpenSSL$crypto_2580_key_sign = tmp_assign_source_168;
        }
        {
            PyObject *tmp_assign_source_169;
            tmp_assign_source_169 = MAKE_FUNCTION_OpenSSL$crypto$$$function_139_verify();



            assert(tmp_locals_OpenSSL$crypto_2580_key_verify == NULL);
            tmp_locals_OpenSSL$crypto_2580_key_verify = tmp_assign_source_169;
        }
        {
            PyObject *tmp_assign_source_170;
            tmp_assign_source_170 = MAKE_FUNCTION_OpenSSL$crypto$$$function_140_b64_encode();



            assert(tmp_locals_OpenSSL$crypto_2580_key_b64_encode == NULL);
            tmp_locals_OpenSSL$crypto_2580_key_b64_encode = tmp_assign_source_170;
        }
        {
            PyObject *tmp_assign_source_171;
            tmp_assign_source_171 = MAKE_FUNCTION_OpenSSL$crypto$$$function_141_get_pubkey();



            assert(tmp_locals_OpenSSL$crypto_2580_key_get_pubkey == NULL);
            tmp_locals_OpenSSL$crypto_2580_key_get_pubkey = tmp_assign_source_171;
        }
        {
            PyObject *tmp_assign_source_172;
            tmp_assign_source_172 = MAKE_FUNCTION_OpenSSL$crypto$$$function_142_set_pubkey();



            assert(tmp_locals_OpenSSL$crypto_2580_key_set_pubkey == NULL);
            tmp_locals_OpenSSL$crypto_2580_key_set_pubkey = tmp_assign_source_172;
        }
        // Tried code:
        {
            PyObject *tmp_dict_key_56;
            PyObject *tmp_dict_value_56;
            PyObject *tmp_dict_key_57;
            PyObject *tmp_dict_value_57;
            PyObject *tmp_dict_key_58;
            PyObject *tmp_dict_value_58;
            PyObject *tmp_dict_key_59;
            PyObject *tmp_dict_value_59;
            PyObject *tmp_dict_key_60;
            PyObject *tmp_dict_value_60;
            PyObject *tmp_dict_key_61;
            PyObject *tmp_dict_value_61;
            PyObject *tmp_dict_key_62;
            PyObject *tmp_dict_value_62;
            PyObject *tmp_dict_key_63;
            PyObject *tmp_dict_value_63;
            tmp_dict_value_56 = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
            tmp_dict_key_56 = const_str_plain___module__;
            tmp_assign_source_166 = _PyDict_NewPresized( 8 );
            tmp_res = PyDict_SetItem(tmp_assign_source_166, tmp_dict_key_56, tmp_dict_value_56);
            assert(!(tmp_res != 0));
            tmp_dict_value_57 = const_str_digest_713d8c2afef94db133cda1bff1cb496f;
            tmp_dict_key_57 = const_str_plain___doc__;
            tmp_res = PyDict_SetItem(tmp_assign_source_166, tmp_dict_key_57, tmp_dict_value_57);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_2580_key___init__);
            tmp_dict_value_58 = tmp_locals_OpenSSL$crypto_2580_key___init__;
            tmp_dict_key_58 = const_str_plain___init__;
            tmp_res = PyDict_SetItem(tmp_assign_source_166, tmp_dict_key_58, tmp_dict_value_58);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_2580_key_sign);
            tmp_dict_value_59 = tmp_locals_OpenSSL$crypto_2580_key_sign;
            tmp_dict_key_59 = const_str_plain_sign;
            tmp_res = PyDict_SetItem(tmp_assign_source_166, tmp_dict_key_59, tmp_dict_value_59);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_2580_key_verify);
            tmp_dict_value_60 = tmp_locals_OpenSSL$crypto_2580_key_verify;
            tmp_dict_key_60 = const_str_plain_verify;
            tmp_res = PyDict_SetItem(tmp_assign_source_166, tmp_dict_key_60, tmp_dict_value_60);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_2580_key_b64_encode);
            tmp_dict_value_61 = tmp_locals_OpenSSL$crypto_2580_key_b64_encode;
            tmp_dict_key_61 = const_str_plain_b64_encode;
            tmp_res = PyDict_SetItem(tmp_assign_source_166, tmp_dict_key_61, tmp_dict_value_61);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_2580_key_get_pubkey);
            tmp_dict_value_62 = tmp_locals_OpenSSL$crypto_2580_key_get_pubkey;
            tmp_dict_key_62 = const_str_plain_get_pubkey;
            tmp_res = PyDict_SetItem(tmp_assign_source_166, tmp_dict_key_62, tmp_dict_value_62);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$crypto_2580_key_set_pubkey);
            tmp_dict_value_63 = tmp_locals_OpenSSL$crypto_2580_key_set_pubkey;
            tmp_dict_key_63 = const_str_plain_set_pubkey;
            tmp_res = PyDict_SetItem(tmp_assign_source_166, tmp_dict_key_63, tmp_dict_value_63);
            assert(!(tmp_res != 0));
            goto try_return_handler_35;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$crypto);
        return NULL;
        // Return handler code:
        try_return_handler_35:;
        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_2580_key___init__);
        Py_DECREF(tmp_locals_OpenSSL$crypto_2580_key___init__);
        tmp_locals_OpenSSL$crypto_2580_key___init__ = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_2580_key_sign);
        Py_DECREF(tmp_locals_OpenSSL$crypto_2580_key_sign);
        tmp_locals_OpenSSL$crypto_2580_key_sign = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_2580_key_verify);
        Py_DECREF(tmp_locals_OpenSSL$crypto_2580_key_verify);
        tmp_locals_OpenSSL$crypto_2580_key_verify = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_2580_key_b64_encode);
        Py_DECREF(tmp_locals_OpenSSL$crypto_2580_key_b64_encode);
        tmp_locals_OpenSSL$crypto_2580_key_b64_encode = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_2580_key_get_pubkey);
        Py_DECREF(tmp_locals_OpenSSL$crypto_2580_key_get_pubkey);
        tmp_locals_OpenSSL$crypto_2580_key_get_pubkey = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$crypto_2580_key_set_pubkey);
        Py_DECREF(tmp_locals_OpenSSL$crypto_2580_key_set_pubkey);
        tmp_locals_OpenSSL$crypto_2580_key_set_pubkey = NULL;

        goto outline_result_16;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$crypto);
        return NULL;
        outline_result_16:;
        assert(tmp_class_creation_17__class_dict == NULL);
        tmp_class_creation_17__class_dict = tmp_assign_source_166;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_173;
        nuitka_bool tmp_condition_result_18;
        PyObject *tmp_key_name_33;
        PyObject *tmp_dict_name_33;
        PyObject *tmp_dict_name_34;
        PyObject *tmp_key_name_34;
        tmp_key_name_33 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_17__class_dict);
        tmp_dict_name_33 = tmp_class_creation_17__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_33, tmp_key_name_33);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2580;

            goto try_except_handler_36;
        }
        tmp_condition_result_18 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_18 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_17;
        } else {
            goto condexpr_false_17;
        }
        condexpr_true_17:;
        CHECK_OBJECT(tmp_class_creation_17__class_dict);
        tmp_dict_name_34 = tmp_class_creation_17__class_dict;
        tmp_key_name_34 = const_str_plain___metaclass__;
        tmp_assign_source_173 = DICT_GET_ITEM(tmp_dict_name_34, tmp_key_name_34);
        if (tmp_assign_source_173 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2580;

            goto try_except_handler_36;
        }
        goto condexpr_end_17;
        condexpr_false_17:;
        tmp_assign_source_173 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_173);
        condexpr_end_17:;
        assert(tmp_class_creation_17__metaclass == NULL);
        tmp_class_creation_17__metaclass = tmp_assign_source_173;
    }
    {
        PyObject *tmp_assign_source_174;
        PyObject *tmp_called_name_35;
        PyObject *tmp_args_element_name_95;
        PyObject *tmp_args_element_name_96;
        PyObject *tmp_args_element_name_97;
        CHECK_OBJECT(tmp_class_creation_17__metaclass);
        tmp_called_name_35 = tmp_class_creation_17__metaclass;
        tmp_args_element_name_95 = const_str_plain_NetscapeSPKI;
        tmp_args_element_name_96 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_17__class_dict);
        tmp_args_element_name_97 = tmp_class_creation_17__class_dict;
        frame_d796a9417638ea0fc15dcdcd73475757->m_frame.f_lineno = 2580;
        {
            PyObject *call_args[] = {tmp_args_element_name_95, tmp_args_element_name_96, tmp_args_element_name_97};
            tmp_assign_source_174 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_35, call_args);
        }

        if (tmp_assign_source_174 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2580;

            goto try_except_handler_36;
        }
        assert(tmp_class_creation_17__class == NULL);
        tmp_class_creation_17__class = tmp_assign_source_174;
    }
    goto try_end_20;
    // Exception handler code:
    try_except_handler_36:;
    exception_keeper_type_28 = exception_type;
    exception_keeper_value_28 = exception_value;
    exception_keeper_tb_28 = exception_tb;
    exception_keeper_lineno_28 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)tmp_class_creation_17__class_dict);
    Py_DECREF(tmp_class_creation_17__class_dict);
    tmp_class_creation_17__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_17__metaclass);
    tmp_class_creation_17__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_28;
    exception_value = exception_keeper_value_28;
    exception_tb = exception_keeper_tb_28;
    exception_lineno = exception_keeper_lineno_28;

    goto frame_exception_exit_1;
    // End of try:
    try_end_20:;
    {
        PyObject *tmp_assign_source_175;
        CHECK_OBJECT(tmp_class_creation_17__class);
        tmp_assign_source_175 = tmp_class_creation_17__class;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_NetscapeSPKI, tmp_assign_source_175);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_17__class);
    Py_DECREF(tmp_class_creation_17__class);
    tmp_class_creation_17__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_17__class_dict);
    Py_DECREF(tmp_class_creation_17__class_dict);
    tmp_class_creation_17__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_17__metaclass);
    Py_DECREF(tmp_class_creation_17__metaclass);
    tmp_class_creation_17__metaclass = NULL;

    {
        PyObject *tmp_assign_source_176;
        PyObject *tmp_called_name_36;
        PyObject *tmp_mvar_value_62;
        PyObject *tmp_args_element_name_98;
        PyObject *tmp_mvar_value_63;
        PyObject *tmp_args_element_name_99;
        PyObject *tmp_args_element_name_100;
        PyObject *tmp_args_element_name_101;
        PyObject *tmp_mvar_value_64;
        tmp_mvar_value_62 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_deprecated);

        if (unlikely(tmp_mvar_value_62 == NULL)) {
            tmp_mvar_value_62 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_deprecated);
        }

        if (tmp_mvar_value_62 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 2548 ], 32, 0);
            exception_tb = NULL;

            exception_lineno = 2670;

            goto frame_exception_exit_1;
        }

        tmp_called_name_36 = tmp_mvar_value_62;
        tmp_mvar_value_63 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_NetscapeSPKI);

        if (unlikely(tmp_mvar_value_63 == NULL)) {
            tmp_mvar_value_63 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_NetscapeSPKI);
        }

        if (tmp_mvar_value_63 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 4623 ], 34, 0);
            exception_tb = NULL;

            exception_lineno = 2671;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_98 = tmp_mvar_value_63;
        tmp_args_element_name_99 = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
        tmp_args_element_name_100 = const_str_digest_fdf1281f34921aa68eda346883bb972d;
        tmp_mvar_value_64 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_DeprecationWarning);

        if (unlikely(tmp_mvar_value_64 == NULL)) {
            tmp_mvar_value_64 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_DeprecationWarning);
        }

        if (tmp_mvar_value_64 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 2580 ], 40, 0);
            exception_tb = NULL;

            exception_lineno = 2673;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_101 = tmp_mvar_value_64;
        frame_d796a9417638ea0fc15dcdcd73475757->m_frame.f_lineno = 2670;
        {
            PyObject *call_args[] = {tmp_args_element_name_98, tmp_args_element_name_99, tmp_args_element_name_100, tmp_args_element_name_101};
            tmp_assign_source_176 = CALL_FUNCTION_WITH_ARGS4(tmp_called_name_36, call_args);
        }

        if (tmp_assign_source_176 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2670;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_NetscapeSPKIType, tmp_assign_source_176);
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_177;
        {
            PyObject *tmp_set_locals_9;
            tmp_set_locals_9 = PyDict_New();
            locals_OpenSSL$crypto_2677 = tmp_set_locals_9;
        }
        tmp_dictset_value = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_2677, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        {
            PyObject *tmp_defaults_6;
            tmp_defaults_6 = const_tuple_false_false_tuple;
            Py_INCREF(tmp_defaults_6);
            tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_143___init__(tmp_defaults_6);



            tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_2677, const_str_plain___init__, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            assert(!(tmp_res != 0));
        }
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_53b82250513b686ddc71f0e4ae92fdc3_10, codeobj_53b82250513b686ddc71f0e4ae92fdc3, module_OpenSSL$crypto, 0);
        frame_53b82250513b686ddc71f0e4ae92fdc3_10 = cache_frame_53b82250513b686ddc71f0e4ae92fdc3_10;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_53b82250513b686ddc71f0e4ae92fdc3_10);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_53b82250513b686ddc71f0e4ae92fdc3_10) == 2); // Frame stack

        // Framed code:
        {
            PyObject *tmp_called_name_37;
            PyObject *tmp_args_element_name_102;
            tmp_called_name_37 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_102 = MAKE_FUNCTION_OpenSSL$crypto$$$function_144_callback();



            frame_53b82250513b686ddc71f0e4ae92fdc3_10->m_frame.f_lineno = 2688;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_37, tmp_args_element_name_102);
            Py_DECREF(tmp_args_element_name_102);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2688;

                goto frame_exception_exit_10;
            }
            tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_2677, const_str_plain_callback, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2688;

                goto frame_exception_exit_10;
            }
        }
        {
            PyObject *tmp_called_name_38;
            PyObject *tmp_args_element_name_103;
            tmp_called_name_38 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_103 = MAKE_FUNCTION_OpenSSL$crypto$$$function_145_callback_args();



            frame_53b82250513b686ddc71f0e4ae92fdc3_10->m_frame.f_lineno = 2701;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_38, tmp_args_element_name_103);
            Py_DECREF(tmp_args_element_name_103);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2701;

                goto frame_exception_exit_10;
            }
            tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_2677, const_str_plain_callback_args, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2701;

                goto frame_exception_exit_10;
            }
        }
        {
            PyObject *tmp_defaults_7;
            PyObject *tmp_tuple_element_2;
            PyObject *tmp_mvar_value_65;
            tmp_mvar_value_65 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_Error);

            if (unlikely(tmp_mvar_value_65 == NULL)) {
                tmp_mvar_value_65 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_Error);
            }

            if (tmp_mvar_value_65 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 56 ], 27, 0);
                exception_tb = NULL;

                exception_lineno = 2714;

                goto frame_exception_exit_10;
            }

            tmp_tuple_element_2 = tmp_mvar_value_65;
            tmp_defaults_7 = PyTuple_New(1);
            Py_INCREF(tmp_tuple_element_2);
            PyTuple_SET_ITEM(tmp_defaults_7, 0, tmp_tuple_element_2);
            tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_146_raise_if_problem(tmp_defaults_7);



            tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_2677, const_str_plain_raise_if_problem, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2714;

                goto frame_exception_exit_10;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_53b82250513b686ddc71f0e4ae92fdc3_10);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_9;

        frame_exception_exit_10:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_53b82250513b686ddc71f0e4ae92fdc3_10);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_53b82250513b686ddc71f0e4ae92fdc3_10, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_53b82250513b686ddc71f0e4ae92fdc3_10->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_53b82250513b686ddc71f0e4ae92fdc3_10, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_53b82250513b686ddc71f0e4ae92fdc3_10,
            type_description_2
        );


        // Release cached frame.
        if (frame_53b82250513b686ddc71f0e4ae92fdc3_10 == cache_frame_53b82250513b686ddc71f0e4ae92fdc3_10) {
            Py_DECREF(frame_53b82250513b686ddc71f0e4ae92fdc3_10);
        }
        cache_frame_53b82250513b686ddc71f0e4ae92fdc3_10 = NULL;

        assertFrameObject(frame_53b82250513b686ddc71f0e4ae92fdc3_10);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_9;

        frame_no_exception_9:;
        goto skip_nested_handling_9;
        nested_frame_exit_9:;

        goto try_except_handler_38;
        skip_nested_handling_9:;
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_147__read_passphrase();



        tmp_res = PyDict_SetItem(locals_OpenSSL$crypto_2677, const_str_plain__read_passphrase, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_assign_source_177 = locals_OpenSSL$crypto_2677;
        Py_INCREF(tmp_assign_source_177);
        goto try_return_handler_38;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$crypto);
        return NULL;
        // Return handler code:
        try_return_handler_38:;
        Py_DECREF(locals_OpenSSL$crypto_2677);
        locals_OpenSSL$crypto_2677 = NULL;
        goto outline_result_17;
        // Exception handler code:
        try_except_handler_38:;
        exception_keeper_type_29 = exception_type;
        exception_keeper_value_29 = exception_value;
        exception_keeper_tb_29 = exception_tb;
        exception_keeper_lineno_29 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_OpenSSL$crypto_2677);
        locals_OpenSSL$crypto_2677 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_29;
        exception_value = exception_keeper_value_29;
        exception_tb = exception_keeper_tb_29;
        exception_lineno = exception_keeper_lineno_29;

        goto outline_exception_9;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$crypto);
        return NULL;
        outline_exception_9:;
        exception_lineno = 2677;
        goto try_except_handler_37;
        outline_result_17:;
        assert(tmp_class_creation_18__class_dict == NULL);
        tmp_class_creation_18__class_dict = tmp_assign_source_177;
    }
    {
        PyObject *tmp_assign_source_178;
        nuitka_bool tmp_condition_result_19;
        PyObject *tmp_key_name_35;
        PyObject *tmp_dict_name_35;
        PyObject *tmp_dict_name_36;
        PyObject *tmp_key_name_36;
        tmp_key_name_35 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_18__class_dict);
        tmp_dict_name_35 = tmp_class_creation_18__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_35, tmp_key_name_35);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2677;

            goto try_except_handler_37;
        }
        tmp_condition_result_19 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_19 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_18;
        } else {
            goto condexpr_false_18;
        }
        condexpr_true_18:;
        CHECK_OBJECT(tmp_class_creation_18__class_dict);
        tmp_dict_name_36 = tmp_class_creation_18__class_dict;
        tmp_key_name_36 = const_str_plain___metaclass__;
        tmp_assign_source_178 = DICT_GET_ITEM(tmp_dict_name_36, tmp_key_name_36);
        if (tmp_assign_source_178 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2677;

            goto try_except_handler_37;
        }
        goto condexpr_end_18;
        condexpr_false_18:;
        tmp_assign_source_178 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_178);
        condexpr_end_18:;
        assert(tmp_class_creation_18__metaclass == NULL);
        tmp_class_creation_18__metaclass = tmp_assign_source_178;
    }
    {
        PyObject *tmp_assign_source_179;
        PyObject *tmp_called_name_39;
        PyObject *tmp_args_element_name_104;
        PyObject *tmp_args_element_name_105;
        PyObject *tmp_args_element_name_106;
        CHECK_OBJECT(tmp_class_creation_18__metaclass);
        tmp_called_name_39 = tmp_class_creation_18__metaclass;
        tmp_args_element_name_104 = const_str_plain__PassphraseHelper;
        tmp_args_element_name_105 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_18__class_dict);
        tmp_args_element_name_106 = tmp_class_creation_18__class_dict;
        frame_d796a9417638ea0fc15dcdcd73475757->m_frame.f_lineno = 2677;
        {
            PyObject *call_args[] = {tmp_args_element_name_104, tmp_args_element_name_105, tmp_args_element_name_106};
            tmp_assign_source_179 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_39, call_args);
        }

        if (tmp_assign_source_179 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2677;

            goto try_except_handler_37;
        }
        assert(tmp_class_creation_18__class == NULL);
        tmp_class_creation_18__class = tmp_assign_source_179;
    }
    goto try_end_21;
    // Exception handler code:
    try_except_handler_37:;
    exception_keeper_type_30 = exception_type;
    exception_keeper_value_30 = exception_value;
    exception_keeper_tb_30 = exception_tb;
    exception_keeper_lineno_30 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_18__class_dict);
    tmp_class_creation_18__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_18__metaclass);
    tmp_class_creation_18__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_30;
    exception_value = exception_keeper_value_30;
    exception_tb = exception_keeper_tb_30;
    exception_lineno = exception_keeper_lineno_30;

    goto frame_exception_exit_1;
    // End of try:
    try_end_21:;
    {
        PyObject *tmp_assign_source_180;
        CHECK_OBJECT(tmp_class_creation_18__class);
        tmp_assign_source_180 = tmp_class_creation_18__class;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__PassphraseHelper, tmp_assign_source_180);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_18__class);
    Py_DECREF(tmp_class_creation_18__class);
    tmp_class_creation_18__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_18__class_dict);
    Py_DECREF(tmp_class_creation_18__class_dict);
    tmp_class_creation_18__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_18__metaclass);
    Py_DECREF(tmp_class_creation_18__metaclass);
    tmp_class_creation_18__metaclass = NULL;

    {
        PyObject *tmp_assign_source_181;
        tmp_assign_source_181 = MAKE_FUNCTION_OpenSSL$crypto$$$function_148_load_publickey();



        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_load_publickey, tmp_assign_source_181);
    }
    {
        PyObject *tmp_assign_source_182;
        PyObject *tmp_defaults_8;
        tmp_defaults_8 = const_tuple_none_tuple;
        Py_INCREF(tmp_defaults_8);
        tmp_assign_source_182 = MAKE_FUNCTION_OpenSSL$crypto$$$function_149_load_privatekey(tmp_defaults_8);



        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_load_privatekey, tmp_assign_source_182);
    }
    {
        PyObject *tmp_assign_source_183;
        tmp_assign_source_183 = MAKE_FUNCTION_OpenSSL$crypto$$$function_150_dump_certificate_request();



        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_dump_certificate_request, tmp_assign_source_183);
    }
    {
        PyObject *tmp_assign_source_184;
        tmp_assign_source_184 = MAKE_FUNCTION_OpenSSL$crypto$$$function_151_load_certificate_request();



        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_load_certificate_request, tmp_assign_source_184);
    }
    {
        PyObject *tmp_assign_source_185;
        tmp_assign_source_185 = MAKE_FUNCTION_OpenSSL$crypto$$$function_152_sign();



        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_sign, tmp_assign_source_185);
    }
    {
        PyObject *tmp_assign_source_186;
        tmp_assign_source_186 = MAKE_FUNCTION_OpenSSL$crypto$$$function_153_verify();



        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_verify, tmp_assign_source_186);
    }
    {
        PyObject *tmp_assign_source_187;
        tmp_assign_source_187 = MAKE_FUNCTION_OpenSSL$crypto$$$function_154_dump_crl();



        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_dump_crl, tmp_assign_source_187);
    }
    {
        PyObject *tmp_assign_source_188;
        tmp_assign_source_188 = MAKE_FUNCTION_OpenSSL$crypto$$$function_155_load_crl();



        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_load_crl, tmp_assign_source_188);
    }
    {
        PyObject *tmp_assign_source_189;
        tmp_assign_source_189 = MAKE_FUNCTION_OpenSSL$crypto$$$function_156_load_pkcs7_data();



        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_load_pkcs7_data, tmp_assign_source_189);
    }
    {
        PyObject *tmp_assign_source_190;
        PyObject *tmp_defaults_9;
        tmp_defaults_9 = const_tuple_none_tuple;
        Py_INCREF(tmp_defaults_9);
        tmp_assign_source_190 = MAKE_FUNCTION_OpenSSL$crypto$$$function_157_load_pkcs12(tmp_defaults_9);



        UPDATE_STRING_DICT1(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_load_pkcs12, tmp_assign_source_190);
    }
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_66;
        PyObject *tmp_call_result_1;
        tmp_mvar_value_66 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_66 == NULL)) {
            tmp_mvar_value_66 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_66 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 3126;

            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_66;
        frame_d796a9417638ea0fc15dcdcd73475757->m_frame.f_lineno = 3126;
        tmp_call_result_1 = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_OpenSSL_add_all_algorithms);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3126;

            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_67;
        PyObject *tmp_call_result_2;
        tmp_mvar_value_67 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_67 == NULL)) {
            tmp_mvar_value_67 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_67 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 3130;

            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_67;
        frame_d796a9417638ea0fc15dcdcd73475757->m_frame.f_lineno = 3130;
        tmp_call_result_2 = CALL_METHOD_NO_ARGS(tmp_called_instance_2, const_str_plain_SSL_load_error_strings);
        if (tmp_call_result_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3130;

            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_2);
    }
    {
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_68;
        PyObject *tmp_call_result_3;
        tmp_mvar_value_68 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_68 == NULL)) {
            tmp_mvar_value_68 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_68 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 3135;

            goto frame_exception_exit_1;
        }

        tmp_called_instance_3 = tmp_mvar_value_68;
        frame_d796a9417638ea0fc15dcdcd73475757->m_frame.f_lineno = 3135;
        tmp_call_result_3 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_3, const_str_plain_ASN1_STRING_set_default_mask_asc, &PyTuple_GET_ITEM(const_tuple_str_plain_utf8only_tuple, 0));

        if (tmp_call_result_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 3135;

            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_3);
    }

    // Restore frame exception if necessary.
#if 0
    RESTORE_FRAME_EXCEPTION(frame_d796a9417638ea0fc15dcdcd73475757);
#endif
    popFrameStack();

    assertFrameObject(frame_d796a9417638ea0fc15dcdcd73475757);

    goto frame_no_exception_10;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_d796a9417638ea0fc15dcdcd73475757);
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK(frame_d796a9417638ea0fc15dcdcd73475757, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_d796a9417638ea0fc15dcdcd73475757->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_d796a9417638ea0fc15dcdcd73475757, exception_lineno);
    }

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto module_exception_exit;

    frame_no_exception_10:;

    return module_OpenSSL$crypto;
    module_exception_exit:
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);
    return NULL;
}
