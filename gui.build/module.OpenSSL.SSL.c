/* Generated code for Python module 'OpenSSL.SSL'
 * created by Nuitka version 0.6.6
 *
 * This code is in part copyright 2019 Kay Hayen.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "nuitka/prelude.h"

#include "__helpers.h"

/* The "_module_OpenSSL$SSL" is a Python object pointer of module type.
 *
 * Note: For full compatibility with CPython, every module variable access
 * needs to go through it except for cases where the module cannot possibly
 * have changed in the mean time.
 */

PyObject *module_OpenSSL$SSL;
PyDictObject *moduledict_OpenSSL$SSL;

/* The declarations of module constants used, if any. */
static PyObject *const_str_plain_SSL_CTX_set_next_proto_select_cb;
static PyObject *const_tuple_str_plain_errorcode_tuple;
extern PyObject *const_str_plain_get;
static PyObject *const_str_plain_SSL_CIPHER_get_bits;
static PyObject *const_tuple_str_plain_self_str_plain_session_str_plain_result_tuple;
static PyObject *const_str_plain_SSL_VERIFY_CLIENT_ONCE;
static PyObject *const_str_digest_360fff1f759f48242850b1a03fa368f8;
static PyObject *const_str_plain_SSL_CTX_use_PrivateKey;
extern PyObject *const_str_plain_SSLv23_METHOD;
static PyObject *const_str_digest_2db82bf07fbb595fa9b0bb5b41c7d7cb;
static PyObject *const_str_plain_filetype;
static PyObject *const_str_plain_BIO_write;
static PyObject *const_str_plain_errorcode;
static PyObject *const_str_digest_60759f97a8e448eec2208bd0c353d705;
static PyObject *const_list_3507872b18f9d5cd646e67697ec96e56_list;
static PyObject *const_str_plain__NpnAdvertiseHelper;
extern PyObject *const_str_plain_function;
static PyObject *const_str_plain_ca_list;
static PyObject *const_tuple_str_plain_func_str_plain_explode_str_plain_flag_tuple;
static PyObject *const_str_digest_92dae1d5c0e993b1b8bd25bfbbae5039;
static PyObject *const_str_plain_pyname;
extern PyObject *const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
extern PyObject *const_str_plain_use_privatekey_file;
static PyObject *const_str_plain_OP_COOKIE_EXCHANGE;
extern PyObject *const_str_plain_UNSPECIFIED;
static PyObject *const_str_plain_ca_names;
extern PyObject *const_str_plain_cdata;
static PyObject *const_str_plain__CRYPTOGRAPHY_MANYLINUX1_CA_FILE;
static PyObject *const_str_plain_OP_SINGLE_ECDH_USE;
static PyObject *const_str_digest_6e6304d3afc4a993b41c01e5af499f6b;
extern PyObject *const_str_plain_data;
static PyObject *const_str_plain_SSL_set_tlsext_host_name;
extern PyObject *const_str_plain_pkey;
static PyObject *const_tuple_str_plain_self_str_plain_depth_tuple;
static PyObject *const_str_digest_9575fec1eee4d60c15d3f7c228d8045c;
static PyObject *const_str_plain_depth;
static PyObject *const_str_plain_SSL_OP_NO_QUERY_MTU;
static PyObject *const_str_digest_ca4a6d4d96b227b5bd17bc5998515ec3;
static PyObject *const_str_plain_X509_STORE_CTX_get_ex_data;
extern PyObject *const_str_digest_c075052d723d6707083e869a0e3659bb;
extern PyObject *const_str_plain_SSL_set_alpn_protos;
static PyObject *const_tuple_711d722f51d6d6accf419f2bb9aeb5b5_tuple;
extern PyObject *const_str_plain_i;
extern PyObject *const_str_plain_encoded_len;
static PyObject *const_str_digest_1491fa532da0499070a77d607dd12a0d;
static PyObject *const_str_plain_SSL_get_servername;
static PyObject *const_str_plain_error_number;
extern PyObject *const_str_plain_OP_NO_SSLv2;
extern PyObject *const_str_plain_Cryptography_HAS_ALPN;
static PyObject *const_str_plain_SSL_ST_CONNECT;
static PyObject *const_str_plain_want_read;
static PyObject *const_str_plain_add_client_ca;
extern PyObject *const_str_plain_environ;
static PyObject *const_str_digest_536ef6d81295f4591dd87bc79e8440e7;
static PyObject *const_str_plain_OP_NO_QUERY_MTU;
extern PyObject *const_str_plain_e;
static PyObject *const_str_plain__from_ssl;
static PyObject *const_str_plain_set_ocsp_server_callback;
static PyObject *const_str_plain_SSL_CTX_get_timeout;
static PyObject *const_str_plain_get_next_proto_negotiated;
static PyObject *const_str_plain_SSLeay_version;
extern PyObject *const_str_plain_write;
extern PyObject *const_str_plain_WantWriteError;
extern PyObject *const_str_plain_X509Name;
extern PyObject *const_str_plain_DH_free;
static PyObject *const_str_plain__OCSPClientCallbackHelper;
static PyObject *const_str_plain_OP_PKCS1_CHECK_1;
extern PyObject *const_int_neg_1;
static PyObject *const_str_plain_VERIFY_CLIENT_ONCE;
static PyObject *const_str_plain_getwinerror;
static PyObject *const_str_plain__reverse_mapping;
static PyObject *const_tuple_1bf74246b679aacbbc5982cad038a099_tuple;
extern PyObject *const_str_plain_addr;
static PyObject *const_str_plain_set_client_ca_list;
static PyObject *const_str_plain_connect_ex;
extern PyObject *const_str_plain_proto;
static PyObject *const_str_plain_set_info_callback;
extern PyObject *const_int_pos_5;
static PyObject *const_str_digest_8e472bc9049677fa90a9da1a818ea22f;
static PyObject *const_tuple_str_plain_self_str_plain_mode_tuple;
static PyObject *const_str_digest_b02795b9590127f96a3b627129a2fbd2;
static PyObject *const_str_digest_c0087bb531594ec7f6b437fc33f5a397;
static PyObject *const_str_plain_outstr;
static PyObject *const_str_plain_flag;
extern PyObject *const_str_plain_ok;
extern PyObject *const_str_plain_recv;
extern PyObject *const_tuple_str_digest_52773e1185116024389d12c91a4ccf3d_tuple;
extern PyObject *const_str_plain_ciphers;
extern PyObject *const_str_plain_os;
extern PyObject *const_str_plain__text_to_bytes_and_warn;
static PyObject *const_str_plain__npn_advertise_helper;
extern PyObject *const_str_plain_Context;
extern PyObject *const_str_plain_Cryptography_HAS_SSL_ST;
static PyObject *const_str_plain_OP_NO_TLSv1_1;
static PyObject *const_tuple_6f3d7ce791b29c8b2ccceca21130b973_tuple;
static PyObject *const_str_digest_0bb5eb9f5b32c979fadc3e4b702de2f7;
static PyObject *const_str_plain_SSL_CTX_set_mode;
extern PyObject *const_str_plain_out;
extern PyObject *const_str_plain_dh;
static PyObject *const_str_plain_SSL_get_cipher_list;
static PyObject *const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_p_tuple;
extern PyObject *const_str_plain_send;
static PyObject *const_str_plain_SSL_get1_session;
extern PyObject *const_str_plain__from_raw_x509_ptr;
static PyObject *const_str_plain_SSL_CTX_set_verify;
static PyObject *const_str_digest_cbc74855fdd069af46a5197a85921eab;
static PyObject *const_tuple_8f082d20432d2aa73d41a80627094b27_tuple;
static PyObject *const_str_plain__into_ssl;
static PyObject *const_str_plain_BIO_new_file;
static PyObject *const_str_plain__NpnSelectHelper;
extern PyObject *const_str_plain_verify;
static PyObject *const_str_plain_alert;
extern PyObject *const_str_plain_certfile;
static PyObject *const_str_digest_73851dbd1821d646fbb8ad48e937548f;
extern PyObject *const_str_digest_2aaae8e99c54112dad0b0da3957413a9;
static PyObject *const_str_digest_8cc305fc9d9a417a96ba57f2c87b94e9;
extern PyObject *const_tuple_str_plain_self_str_plain_state_tuple;
extern PyObject *const_str_plain___init__;
static PyObject *const_str_plain_SSLEAY_DIR;
static PyObject *const_str_digest_099382aff2f4e6520a621b385fae4992;
static PyObject *const_str_plain_use_privatekey;
static PyObject *const_str_plain_OP_PKCS1_CHECK_2;
extern PyObject *const_str_plain_ascii;
static PyObject *const_str_plain_nbytes;
extern PyObject *const_str_plain_items;
static PyObject *const_str_digest_0bdfe95b50c341a06f9727afb1a762dc;
static PyObject *const_str_plain_SSL_SESS_CACHE_OFF;
extern PyObject *const_str_plain_new;
static PyObject *const_str_plain_SSL_CB_HANDSHAKE_DONE;
static PyObject *const_str_plain_SESS_CACHE_OFF;
static PyObject *const_str_digest_240fed82a102b949d0d53c00df42e330;
static PyObject *const_str_plain_SSL_MODE_ENABLE_PARTIAL_WRITE;
static PyObject *const_str_digest_3957b1b23f06761ef1844caf450dffd3;
extern PyObject *const_str_plain_SSLv3_method;
static PyObject *const_str_plain__VerifyHelper;
static PyObject *const_str_plain_SSL_CIPHER_get_version;
extern PyObject *const_str_plain_store;
static PyObject *const_str_plain_bio_shutdown;
static PyObject *const_str_digest_f45f13437cfffca595693525af90acd6;
extern PyObject *const_str_plain_more_args;
static PyObject *const_str_plain_TLSEXT_NAMETYPE_host_name;
extern PyObject *const_str_angle_genexpr;
extern PyObject *const_str_plain___name__;
static PyObject *const_str_plain_SSL_CB_EXIT;
static PyObject *const_str_plain_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG;
static PyObject *const_dict_c3a065e676a930b8196978eb12fcba71;
extern PyObject *const_str_plain__raise_current_error;
static PyObject *const_str_digest_060a092ce142509580b5fc6c56b149a1;
extern PyObject *const_str_plain_state;
extern PyObject *const_str_plain_where;
static PyObject *const_str_plain__wrap_callback;
static PyObject *const_str_plain_get_app_data;
static PyObject *const_str_plain_SSL_SESS_CACHE_NO_AUTO_CLEAR;
static PyObject *const_str_digest_7ac3fb96e522dea60117802c4a4274df;
static PyObject *const_tuple_62a32d899dc1fe37f6d326f7d9a44911_tuple;
static PyObject *const_str_plain_SSL_OP_NO_TLSv1_2;
extern PyObject *const_str_plain_None;
static PyObject *const_str_plain_SSL_OP_NO_TLSv1_1;
static PyObject *const_str_plain_Cryptography_HAS_NEXTPROTONEG;
static PyObject *const_str_plain_bio_read;
static PyObject *const_str_plain__requires_decorator;
extern PyObject *const_str_plain_res;
static PyObject *const_str_plain_name_stack;
static PyObject *const_str_digest_3d1ad7b2c9fa025afe944eacf471d909;
static PyObject *const_tuple_40c019df00fadc68e051d5153056e038_tuple;
extern PyObject *const_str_plain_SSL_ST_BEFORE;
extern PyObject *const_str_plain_read;
static PyObject *const_str_digest_77c1b668370aaac8571fd41e2e807543;
static PyObject *const_str_plain__asFileDescriptor;
static PyObject *const_str_plain_SESS_CACHE_NO_AUTO_CLEAR;
static PyObject *const_str_plain_add_extra_chain_cert;
static PyObject *const_str_digest_04211c3d50cdc4f69d9c36018d92c12f;
static PyObject *const_str_digest_09af89b9aab79bc5666da647371af25d;
extern PyObject *const_str_plain_Session;
static PyObject *const_str_digest_a824ae6766bf79c53a58510064186c32;
static PyObject *const_str_plain_instr;
static PyObject *const_str_digest_1494ae1301cb98a828389add570df55f;
extern PyObject *const_str_plain_integer_types;
static PyObject *const_str_plain_TLS_CHACHA20_POLY1305_SHA256;
static PyObject *const_str_plain_SSL_CTX_use_certificate;
static PyObject *const_str_plain_SESS_CACHE_BOTH;
extern PyObject *const_str_plain_SSL_CTX_set_alpn_select_cb;
extern PyObject *const_tuple_str_plain_ascii_tuple;
static PyObject *const_str_digest_ee77c76941f8fd58acff5cfda589cc1d;
static PyObject *const_tuple_617fe238ea11ea0890ce2460de3bd68e_tuple;
static PyObject *const_str_digest_f5da7ec1228a5c8d32fa9b786affa014;
static PyObject *const_str_digest_0b1af5d020260df564f1f58f9f88daaa;
static PyObject *const_str_digest_e7ed1590d11cbaaaf17420c6bdc13490;
static PyObject *const_str_digest_83abd167711a9d69f6fb1ba8bbb40fdb;
static PyObject *const_tuple_str_plain_self_str_plain_callback_str_plain_userdata_tuple;
static PyObject *const_str_plain_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG;
extern PyObject *const_str_plain__pkey;
extern PyObject *const_str_plain_x509;
extern PyObject *const_str_plain_label;
static PyObject *const_str_plain_TLS_AES_256_GCM_SHA384;
static PyObject *const_str_plain_OP_EPHEMERAL_RSA;
extern PyObject *const_str_plain_False;
static PyObject *const_str_plain_set_timeout;
extern PyObject *const_str_plain_set_passwd_cb;
static PyObject *const_str_plain_X509_get_default_cert_file;
static PyObject *const_str_plain_protos;
extern PyObject *const_tuple_str_plain_self_str_plain_version_tuple;
static PyObject *const_str_plain_Cryptography_HAS_TLSEXT_HOSTNAME;
extern PyObject *const_str_plain_size;
static PyObject *const_str_plain_SSL_set_bio;
static PyObject *const_tuple_str_plain_self_str_plain_cipher_tuple;
extern PyObject *const_str_digest_c804b213c384a15865e18bf31cfff70e;
static PyObject *const_str_digest_d3a1e78595a066a43885e44a343877f5;
static PyObject *const_str_digest_b7964fdc1d8df81dacc8b4450db712e3;
extern PyObject *const_str_plain_sys;
static PyObject *const_tuple_str_plain_self_str_plain_bio_str_plain_result_tuple;
static PyObject *const_str_digest_ef6e6485863cf611499d4e66d7c8cb32;
static PyObject *const_str_digest_3c214455d63d6846892932f043ae8dab;
static PyObject *const_tuple_str_plain_self_str_plain_options_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_addr_str_plain_connect_ex_tuple;
static PyObject *const_str_digest_ad463a4d3fa3baff68f13aea2d205572;
static PyObject *const_str_plain_get_servername;
static PyObject *const_str_plain_BIO_should_retry;
static PyObject *const_str_plain_set_context;
extern PyObject *const_str_plain_Connection;
static PyObject *const_str_plain_push_result;
extern PyObject *const_str_digest_fa91b370bf4aa8601b20ad022c04c7f5;
static PyObject *const_str_digest_2c98e45dae0eb590d01836d5f4b5f54f;
extern PyObject *const_str_plain_mode;
static PyObject *const_str_digest_b6f7e6068b1690fa00ff377454fad5cf;
static PyObject *const_str_digest_5f09856be161f8b617a90e11db2ed735;
extern PyObject *const_str_plain_wrapper;
static PyObject *const_str_plain_SSL_CB_ACCEPT_EXIT;
static PyObject *const_str_plain_SSL_OP_SSLEAY_080_CLIENT_DH_BUG;
static PyObject *const_str_plain_SSL_peek;
extern PyObject *const_str_plain__native;
extern PyObject *const_str_plain_get_certificate;
static PyObject *const_str_plain__ALPNSelectHelper;
extern PyObject *const_str_plain__ffi;
static PyObject *const_str_plain_bio_write;
static PyObject *const_str_plain_get_session;
static PyObject *const_str_plain_SSL_CTX_set_tlsext_status_cb;
static PyObject *const_str_plain_BIO_should_io_special;
static PyObject *const_str_plain_TLSv1_method;
static PyObject *const_str_plain_export_keying_material;
static PyObject *const_str_plain_in_;
static PyObject *const_str_plain_SSL_get_tlsext_status_ocsp_resp;
static PyObject *const_str_plain_get_session_cache_mode;
static PyObject *const_str_digest_eb75de26d3d89a0b83fc536ac20042b0;
static PyObject *const_str_plain_get_verify_depth;
extern PyObject *const_str_plain_indexbytes;
extern PyObject *const_str_plain_X509_STORE_CTX_get_error;
static PyObject *const_str_plain_SSL_CTX_set_client_CA_list;
static PyObject *const_str_plain__requires_alpn;
static PyObject *const_tuple_str_plain_self_str_plain_cipher_str_plain_name_tuple;
static PyObject *const_str_plain_sk_X509_NAME_value;
static PyObject *const_str_plain_OP_MICROSOFT_SESS_ID_BUG;
static PyObject *const_str_digest_e5bdbccc007b5187d287f36f3c9f8130;
extern PyObject *const_tuple_str_plain_self_str_plain_curve_tuple;
static PyObject *const_str_plain_SSL_CTX_use_certificate_file;
static PyObject *const_tuple_str_plain_obj_str_plain_fd_str_plain_meth_tuple;
static PyObject *const_str_plain_SSL_MODE_RELEASE_BUFFERS;
static PyObject *const_str_digest_b2b544e0252baa92681eeaf8ffa03130;
static PyObject *const_str_plain_ocsp_data_length;
extern PyObject *const_str_plain_args;
static PyObject *const_tuple_str_plain_self_str_plain_cafile_str_plain_ca_list_tuple;
extern PyObject *const_str_plain_X509_NAME_free;
static PyObject *const_str_plain_OP_NETSCAPE_CHALLENGE_BUG;
static PyObject *const_str_digest_62f84685dfb1efe6a65f54b5d84154ad;
extern PyObject *const_str_plain_sk_X509_num;
static PyObject *const_str_plain__ocsp_data;
static PyObject *const_tuple_str_plain_count_str_plain_chain_tuple;
static PyObject *const_str_digest_d84d6f514b61e2d13913a11459387aca;
extern PyObject *const_str_plain_OPENSSL_malloc;
extern PyObject *const_tuple_empty;
static PyObject *const_str_plain_TLS_AES_128_GCM_SHA256;
extern PyObject *const_str_plain___all__;
static PyObject *const_str_plain_protostr;
static PyObject *const_str_plain_SSL_CTX_get_verify_mode;
static PyObject *const_dict_8204a0d80b2c8b5483fe77928e561739;
extern PyObject *const_str_plain__problems;
extern PyObject *const_str_plain_index;
static PyObject *const_tuple_7c3b7701dcc867dc417afc0b7dd18be0_tuple;
static PyObject *const_str_digest_b8ec26ebdab81fb3d5f36275b48d4beb;
static PyObject *const_tuple_78e460fdd8266d432328f4bff5207c29_tuple;
static PyObject *const_str_digest_7540551bed0e4507c2b90cdbe0aa8fb3;
static PyObject *const_tuple_27b415f5f1545c164c69e92aa878cdf0_tuple;
extern PyObject *const_str_plain_kwargs;
static PyObject *const_str_plain_rc;
extern PyObject *const_str_plain___file__;
static PyObject *const_str_digest_61df355efe52f096d5251268bee9ada3;
static PyObject *const_str_plain_SSL_CB_CONNECT_LOOP;
static PyObject *const_str_digest_f85e475b3736c6da8cbd8e92af63eba4;
static PyObject *const_str_plain_SESS_CACHE_NO_INTERNAL_STORE;
static PyObject *const_str_plain_SSL_ERROR_WANT_X509_LOOKUP;
extern PyObject *const_str_plain_path_string;
static PyObject *const_tuple_str_plain_self_str_plain_buf_str_plain_result_tuple;
extern PyObject *const_str_plain_makefile;
extern PyObject *const_str_digest_df9e5608be804d3b3249be3c13b24db8;
extern PyObject *const_str_plain_method;
extern PyObject *const_str_plain___debug__;
static PyObject *const_str_digest_fe0750f479b57ce782e84a9b40cf000b;
static PyObject *const_str_plain_SSL_OP_SINGLE_ECDH_USE;
static PyObject *const_str_plain_certificate_authority;
static PyObject *const_str_plain_use_result;
static PyObject *const_str_plain__requires_npn;
extern PyObject *const_str_plain_gc;
static PyObject *const_str_plain_OPENSSL_VERSION_NUMBER;
static PyObject *const_str_plain_SSL_ERROR_WANT_WRITE;
static PyObject *const_str_plain_X509_up_ref;
extern PyObject *const_str_digest_8b0e1374dcc590bdb16ac8ec2446b5d1;
static PyObject *const_str_digest_bafb2b633667a6bc76266cfd60bf7f9d;
extern PyObject *const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
static PyObject *const_str_plain_profiles;
static PyObject *const_str_digest_fd8757ca246c476601094123086e9a80;
static PyObject *const_str_plain__methods;
static PyObject *const_list_str_digest_746ae0014bb266cffee8b7b1473626af_list;
static PyObject *const_str_plain_SESS_CACHE_NO_INTERNAL_LOOKUP;
extern PyObject *const_str_plain_lib;
static PyObject *const_str_plain_accept;
static PyObject *const_str_plain__path_string;
static PyObject *const_str_plain_SSL_renegotiate;
extern PyObject *const_str_plain__UNSPECIFIED;
static PyObject *const_str_plain_SSL_set_fd;
extern PyObject *const_str_plain_X509_STORE_CTX_get_current_cert;
static PyObject *const_list_6fa8c3d8587ec1659fa28b2f58883e42_list;
static PyObject *const_tuple_7e6126bff16a8a76a713850dcb042242_tuple;
static PyObject *const_str_plain_SSL_OP_CIPHER_SERVER_PREFERENCE;
static PyObject *const_tuple_str_plain_self_str_plain_mode_str_plain_callback_tuple;
static PyObject *const_str_plain_SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER;
static PyObject *const_list_b44af29ad37821285e6b89a520342cf5_list;
extern PyObject *const_str_plain_text_to_bytes_and_warn;
extern PyObject *const_str_plain_str;
extern PyObject *const_str_plain_socket;
static PyObject *const_str_digest_d242bea258df0e7212519aa660c5f53d;
static PyObject *const_str_plain_X509_get_default_cert_dir_env;
static PyObject *const_str_digest_aa8d23211c54bc521e23e53a6e431cd2;
extern PyObject *const_str_plain__make_assert;
extern PyObject *const_str_plain_arg;
static PyObject *const_str_plain_get_cipher_bits;
static PyObject *const_str_plain_SSL_CTX_set_tlsext_status_arg;
extern PyObject *const_str_plain___metaclass__;
static PyObject *const_tuple_a67b1154f8342873401b8122b6389ba8_tuple;
static PyObject *const_str_plain_SSL_get_session;
static PyObject *const_str_plain_SSL_ERROR_SYSCALL;
extern PyObject *const_str_plain_SSL_CTX_set_ecdh_auto;
static PyObject *const_str_plain_SSL_OP_MSIE_SSLV2_RSA_PADDING;
extern PyObject *const_str_plain_errno;
extern PyObject *const_str_plain_userdata;
static PyObject *const_str_plain_ocsp_ptr;
extern PyObject *const_str_plain_X509_NAME_dup;
static PyObject *const_tuple_87f1641fb31961ccfc03a99691482662_tuple;
static PyObject *const_str_plain_SSL_ERROR_WANT_READ;
extern PyObject *const_tuple_none_none_tuple;
static PyObject *const_str_plain_OP_CIPHER_SERVER_PREFERENCE;
static PyObject *const_str_plain_SSL_ST_ACCEPT;
static PyObject *const_str_plain_X509_get_default_cert_dir;
static PyObject *const_str_plain_SSL_CTX_add_extra_chain_cert;
static PyObject *const_str_digest_776556dd9343f57c1cd72ff937153f0f;
extern PyObject *const_int_pos_2147483647;
extern PyObject *const_str_digest_e33a7f733650e687efe98e5491512b82;
static PyObject *const_str_plain_SSL_want_read;
static PyObject *const_tuple_26498c7c65e3c1d61715bb934548919d_tuple;
static PyObject *const_str_plain_inlen;
extern PyObject *const_tuple_str_plain_self_str_plain_buf_tuple;
extern PyObject *const_str_plain___new__;
static PyObject *const_tuple_str_plain_self_str_plain_profiles_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_pystore_str_plain_store_tuple;
static PyObject *const_str_digest_d5ded94dafea47ce6f2b4fa579755177;
static PyObject *const_str_plain_set_alpn_protos;
extern PyObject *const_str_plain_path;
static PyObject *const_str_plain__CallbackExceptionHelper;
extern PyObject *const_str_plain_PEM_read_bio_DHparams;
extern PyObject *const_str_plain_VERIFY_PEER;
static PyObject *const_str_plain_weakref;
static PyObject *const_str_plain_empty;
extern PyObject *const_str_plain__PassphraseHelper;
static PyObject *const_str_plain_sk_X509_NAME_push;
extern PyObject *const_str_plain_name;
static PyObject *const_str_plain_X509_V_OK;
static PyObject *const_str_digest_aa803484dcfcfaec3d1d830a5ef1f026;
static PyObject *const_str_plain_SSLEAY_BUILT_ON;
static PyObject *const_str_plain_total_renegotiations;
extern PyObject *const_str_plain_SSL_get0_alpn_selected;
static PyObject *const_str_plain_TLSv1_1_method;
extern PyObject *const_str_plain_SSL_CTX_set_alpn_protos;
extern PyObject *const_str_plain_from_iterable;
extern PyObject *const_str_plain_VERIFY_NONE;
extern PyObject *const_str_plain_set_tlsext_host_name;
static PyObject *const_str_plain_error_depth;
static PyObject *const_str_digest_47543c17fa95d5ac5c9bf71145417a30;
static PyObject *const_str_digest_ebaec5436a48442094f25464a6eec24c;
static PyObject *const_str_digest_b8ccf81a020f16490de1c8527ea9e4d6;
static PyObject *const_str_digest_d89a36d0b4664ac4178af2071f30652f;
static PyObject *const_str_plain_SSL_CB_CONNECT_EXIT;
static PyObject *const_str_digest_cf5a529c83a60eab9bc87caa3430bc5c;
static PyObject *const_str_digest_3462bf983701fbd7caf2f521f5975fff;
extern PyObject *const_str_plain_SSL_library_init;
static PyObject *const_str_digest_7cf2d06a8643ddce5d0ceedd61c750e1;
static PyObject *const_str_plain_SSL_OP_TLS_BLOCK_PADDING_BUG;
static PyObject *const_str_plain_get_finished;
static PyObject *const_str_digest_794f687944b90121fa261238090835e1;
extern PyObject *const_str_plain_flags;
static PyObject *const_tuple_6740a501bdf22f33fca4ec6a09ab8a62_tuple;
extern PyObject *const_str_chr_0;
extern PyObject *const_str_digest_2c0accc407028fbaba46fefdee9c6c06;
static PyObject *const_str_digest_fded22d63d84a836b130c747fc61664e;
extern PyObject *const_str_plain_sendall;
static PyObject *const_str_plain_get_cipher_name;
static PyObject *const_str_plain_OP_MICROSOFT_BIG_SSLV3_BUFFER;
static PyObject *const_str_digest_ebc06328e68f0dbdd2e23e3f1f581b13;
static PyObject *const_str_plain__fallback_default_verify_paths;
static PyObject *const_str_plain_OP_ALL;
static PyObject *const_str_plain_SSL_total_renegotiations;
static PyObject *const_str_plain_SSL_OP_NETSCAPE_CHALLENGE_BUG;
static PyObject *const_str_plain_SSL_CTX_load_verify_locations;
static PyObject *const_str_plain__requires_sni;
static PyObject *const_tuple_str_plain_type_tuple;
extern PyObject *const_str_plain_Error;
static PyObject *const_str_plain_SSL_set_SSL_CTX;
static PyObject *const_str_plain_OP_NO_TLSv1;
static PyObject *const_str_plain_SSL_ERROR_ZERO_RETURN;
extern PyObject *const_str_plain_get_shutdown;
static PyObject *const_str_plain_SSLv23_method;
static PyObject *const_str_digest_616719c4a0cde3344203a07484a7fb54;
static PyObject *const_tuple_str_plain_WeakValueDictionary_tuple;
static PyObject *const_str_digest_1f723e76cd26cf3162ae94f693472dd5;
static PyObject *const_str_plain_SSL_CTX_get_cert_store;
static PyObject *const_str_plain_new_handle;
extern PyObject *const_str_plain_BIO_free;
static PyObject *const_str_plain_SSLv2_method;
static PyObject *const_str_plain_OP_SINGLE_DH_USE;
static PyObject *const_str_digest_94c36790285a25f5d9268c8333413cf2;
static PyObject *const_str_plain_SSL_CB_ALERT;
static PyObject *const_str_plain_use_certificate_file;
extern PyObject *const_tuple_type_object_tuple;
static PyObject *const_str_plain_SSL_OP_SINGLE_DH_USE;
static PyObject *const_str_plain_SSL_write;
extern PyObject *const_str_plain_meth;
extern PyObject *const_str_plain_ffi;
static PyObject *const_str_plain_SSL_VERIFY_FAIL_IF_NO_PEER_CERT;
extern PyObject *const_str_plain_outlen;
static PyObject *const_str_plain_cert_stack;
static PyObject *const_str_plain_get_alpn_proto_negotiated;
extern PyObject *const_tuple_str_plain_self_str_plain_cert_tuple;
static PyObject *const_str_plain_ca_name;
static PyObject *const_tuple_str_plain_self_str_plain_callback_tuple;
static PyObject *const_str_plain_SSL_CTX_set_tlsext_use_srtp;
extern PyObject *const_str_plain_truncate;
extern PyObject *const_str_plain_SysCallError;
static PyObject *const_str_plain_set_session;
static PyObject *const_tuple_70adcf8f254ece362639433ee96fdafb_tuple;
static PyObject *const_str_plain_SESS_CACHE_SERVER;
extern PyObject *const_str_plain_set_connect_state;
extern PyObject *const_str_plain_pop;
static PyObject *const_tuple_str_plain_self_str_plain_data_len_str_plain_data_tuple;
static PyObject *const_str_plain__no_zero_allocator;
static PyObject *const_str_plain_OP_DONT_INSERT_EMPTY_FRAGMENTS;
extern PyObject *const_str_plain_fileno;
static PyObject *const_str_plain_SSL_CIPHER_get_name;
extern PyObject *const_str_plain_raise_if_problem;
static PyObject *const_str_digest_6e6e0d8d93df9702d9c8795dc2391090;
static PyObject *const_tuple_fdf14ad5fcee8ba941991b04122d5521_tuple;
static PyObject *const_str_plain__alpn_select_helper;
static PyObject *const_str_plain_ocsp_len;
static PyObject *const_str_plain_SSL_set_connect_state;
static PyObject *const_str_digest_b965e7ab82e8e0c92ec2736091bc1c12;
static PyObject *const_str_digest_6f72f23667e4f49591ed4cf6d6205ca5;
extern PyObject *const_str_plain__buffer;
static PyObject *const_str_plain__CERTIFICATE_PATH_LOCATIONS;
static PyObject *const_str_plain__app_data;
static PyObject *const_tuple_c21a4bcc0d9dac830f44bc0c201bf7fd_tuple;
extern PyObject *const_str_plain_partial;
static PyObject *const_str_plain_MSG_PEEK;
static PyObject *const_str_plain_get_cipher_version;
static PyObject *const_str_plain_SSL_ERROR_NONE;
static PyObject *const_tuple_str_plain_self_str_plain_rc_tuple;
extern PyObject *const_str_plain_set_result;
static PyObject *const_str_plain__npn_select_callback_args;
extern PyObject *const_str_plain__exception_from_error_queue;
static PyObject *const_tuple_3ac1ec4ea6ba07372fe57d858ff0148f_tuple;
static PyObject *const_str_digest_053565796c68d049169d0efbeceaaf7d;
static PyObject *const_str_digest_e04d236da419e1b15c5c13532be67a91;
extern PyObject *const_str_plain_type;
static PyObject *const_str_digest_85e95361903fe71cece52bb01216866e;
static PyObject *const_str_plain_SSL_SESS_CACHE_BOTH;
extern PyObject *const_str_plain_decode;
extern PyObject *const_str_plain_X509_free;
static PyObject *const_str_plain_sk_X509_NAME_free;
static PyObject *const_str_plain_get_protocol_version_name;
static PyObject *const_str_plain_identifier;
extern PyObject *const_str_plain___getattr__;
static PyObject *const_str_plain_SSL_CB_HANDSHAKE_START;
static PyObject *const_str_plain_SSLEAY_PLATFORM;
static PyObject *const_str_plain__get_finished_message;
static PyObject *const_str_plain_SSL_version;
static PyObject *const_str_plain_SSL_set_mode;
extern PyObject *const_str_plain_tobytes;
static PyObject *const_str_plain_SSL_CB_WRITE;
static PyObject *const_str_plain_SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG;
static PyObject *const_str_plain__check_env_vars_set;
extern PyObject *const_str_plain_object;
static PyObject *const_str_plain_SSL_CTX_get_verify_depth;
extern PyObject *const_str_plain_set_cipher_list;
static PyObject *const_str_plain_SSL_OP_EPHEMERAL_RSA;
static PyObject *const_str_plain_SSL_SESS_CACHE_CLIENT;
extern PyObject *const_str_plain_curve;
extern PyObject *const_str_plain_set_default_verify_paths;
static PyObject *const_str_digest_1c06dc4166e08805f38a8dca82ce4339;
static PyObject *const_tuple_str_plain_wraps_str_plain_partial_tuple;
extern PyObject *const_str_plain_self;
static PyObject *const_str_digest_ceaeeee7f342339744c9535ada3c62e3;
static PyObject *const_str_plain_SSL_set_tlsext_status_type;
static PyObject *const_str_plain__verify_helper;
extern PyObject *const_str_plain_shutdown;
static PyObject *const_str_digest_38eb25c1dd31f1c93831bc586a51d94a;
static PyObject *const_str_plain__socket;
static PyObject *const_str_digest_afa60644cf27716474a6bbd780185867;
static PyObject *const_str_plain_pysession;
static PyObject *const_str_digest_7cc8f764b42656b144d56bfbd9df2b48;
static PyObject *const_str_plain__make_requires;
static PyObject *const_str_digest_39dd8800b3995a2e161e8739b1bebc01;
static PyObject *const_str_plain__npn_select_helper;
extern PyObject *const_str_plain_cafile;
static PyObject *const_str_plain_BIO_should_read;
static PyObject *const_str_plain_cipher_list;
extern PyObject *const_str_plain_binary_type;
static PyObject *const_str_plain_set_verify_depth;
static PyObject *const_str_digest_bae02e8783abd2cb1ef184c4ddb0f45d;
static PyObject *const_str_digest_0f682ae315fc37e97d14dcc920e8b91d;
extern PyObject *const_str_plain_chain;
static PyObject *const_str_digest_b65860d01f08f87c7391d19b5cfd9850;
static PyObject *const_str_digest_39e6e3efbf37d872dab9cfbddc398ebf;
static PyObject *const_str_plain_use_certificate;
extern PyObject *const_str_plain_store_ctx;
static PyObject *const_str_plain_SSL_CTX_get_session_cache_mode;
extern PyObject *const_tuple_str_plain_deprecated_tuple;
static PyObject *const_str_plain_dir_path;
static PyObject *const_str_digest_f5111f918158679228186076f422f85e;
extern PyObject *const_str_plain_set_verify;
static PyObject *const_str_digest_720dcf8e2be0afcf53b482e84751fd16;
extern PyObject *const_str_plain_deprecated;
extern PyObject *const_str_plain_min;
extern PyObject *const_str_plain_memoryview;
extern PyObject *const_str_plain_DeprecationWarning;
static PyObject *const_str_plain_SSL_CTX_new;
static PyObject *const_str_plain__raise_ssl_error;
static PyObject *const_str_plain_SSL_get_peer_finished;
static PyObject *const_str_plain_SSL_MODE_AUTO_RETRY;
static PyObject *const_str_digest_f64bec1377ff9f22e4ed4c823f6a5647;
static PyObject *const_str_plain_SSL_get_peer_certificate;
static PyObject *const_str_plain_SSL_OP_MICROSOFT_SESS_ID_BUG;
extern PyObject *const_str_plain_capath;
extern PyObject *const_tuple_str_plain_self_tuple;
static PyObject *const_str_plain_load_client_ca;
extern PyObject *const_str_plain_buf;
static PyObject *const_str_plain_SSL_get_server_random;
static PyObject *const_str_plain_dhfile;
extern PyObject *const_str_plain_return_code;
extern PyObject *const_str_plain_error;
static PyObject *const_str_plain_SSL_CB_ACCEPT_LOOP;
static PyObject *const_str_digest_ca7f1c3e5d90e78a07e9f85863c06c8e;
static PyObject *const_tuple_b5f59418c193d572a22cf854b821fa76_tuple;
static PyObject *const_str_plain_ContextType;
extern PyObject *const_str_plain_NULL;
extern PyObject *const_str_plain_OP_NO_COMPRESSION;
static PyObject *const_str_digest_1c1aa9b3fa80807ae10c68cfa1a0b8e6;
static PyObject *const_str_plain_SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG;
static PyObject *const_str_plain_client_random;
static PyObject *const_str_plain_renegotiate_pending;
static PyObject *const_str_plain_SSL_SENT_SHUTDOWN;
static PyObject *const_str_plain__tlsext_servername_callback;
static PyObject *const_str_plain_protolist;
extern PyObject *const_int_pos_6;
extern PyObject *const_int_pos_4;
static PyObject *const_str_plain_BIO_should_write;
extern PyObject *const_int_pos_2;
extern PyObject *const_int_pos_3;
extern PyObject *const_str_plain_RECEIVED_SHUTDOWN;
extern PyObject *const_int_pos_1;
static PyObject *const_str_digest_a971aca8bab65513da2005120ca529f5;
static PyObject *const_str_digest_9c76bfc2ff06864d351211fc5c45c351;
static PyObject *const_str_plain_SSL_SESS_CACHE_NO_INTERNAL_STORE;
static PyObject *const_str_plain_SSL_state_string_long;
static PyObject *const_tuple_20d4fe6eb6129b69f70ca0570507a3f9_tuple;
extern PyObject *const_str_plain_add_result;
static PyObject *const_str_plain_SSL_get_client_CA_list;
static PyObject *const_str_plain_tmpconn;
static PyObject *const_str_plain_SSL_CTX_use_PrivateKey_file;
static PyObject *const_str_plain_SSL_VERIFY_NONE;
static PyObject *const_str_plain_load_result;
static PyObject *const_str_plain_SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG;
static PyObject *const_str_plain_SSLEAY_CFLAGS;
extern PyObject *const_str_plain_set_options;
static PyObject *const_str_plain_SSL_SESS_CACHE_NO_INTERNAL;
extern PyObject *const_str_plain_win32;
static PyObject *const_str_digest_c9c6fa40ef38c8d28b115afb17db4e50;
static PyObject *const_str_plain_SSL_CTX_set_tlsext_servername_callback;
static PyObject *const_str_plain_SSL_CTX_set_options;
static PyObject *const_str_digest_052250489768b32f02c8505795c1c0c7;
static PyObject *const_str_plain_OP_NO_TLSv1_2;
extern PyObject *const_str_digest_c561652c58984ec0e9541542aa405594;
extern PyObject *const_tuple_str_digest_e33a7f733650e687efe98e5491512b82_tuple;
static PyObject *const_str_plain__handle_bio_errors;
extern PyObject *const_str_plain_SSL_ST_INIT;
static PyObject *const_str_plain_WeakValueDictionary;
static PyObject *const_str_digest_1fbb26888e8a93a4fffae5202f2e81a6;
static PyObject *const_str_plain_SSL_CTX_set_tmp_dh;
static PyObject *const_str_digest_0438f8885bf87c226201350e81ca4f79;
static PyObject *const_str_digest_1bd7405e218c8a579c48801956097e27;
extern PyObject *const_tuple_str_plain_self_str_plain_timeout_tuple;
static PyObject *const_str_plain_SSL_read;
extern PyObject *const_str_plain_sk_X509_value;
static PyObject *const_str_plain_SSL_free;
static PyObject *const_str_plain_explode;
extern PyObject *const_str_plain_join;
static PyObject *const_tuple_str_plain_self_str_plain_certfile_str_plain_result_tuple;
extern PyObject *const_str_plain_count;
extern PyObject *const_str_digest_499043b9b2da602637f07b1aa101ddfb;
static PyObject *const_str_digest_723fb164f3e133051d00542dd747fe2d;
static PyObject *const_str_plain_SSL_get0_next_proto_negotiated;
extern PyObject *const_str_plain_functools;
static PyObject *const_str_plain_set_app_data;
static PyObject *const_str_plain__npn_advertise_callback;
static PyObject *const_tuple_e3219c972e1d9320fe91a603e3df8d39_tuple;
static PyObject *const_str_plain_SSL_SESS_CACHE_SERVER;
extern PyObject *const_str_plain_connect;
static PyObject *const_str_plain_SSL_OP_NETSCAPE_CA_DN_BUG;
static PyObject *const_tuple_cf035770f08c8746b05138973d8b64b8_tuple;
extern PyObject *const_str_plain_itertools;
static PyObject *const_str_plain_fd;
static PyObject *const_tuple_str_plain_self_str_plain_addr_tuple;
extern PyObject *const_str_plain_extend;
static PyObject *const_str_plain_SSL_want_write;
static PyObject *const_str_digest_2eac950a8b26412274fa98ea596054c5;
extern PyObject *const_str_plain_result;
extern PyObject *const_str_plain_BIO_new;
static PyObject *const_str_plain__binary_type;
static PyObject *const_str_plain_method_func;
static PyObject *const_str_digest_d71143a9aaaa613b59e0c4c3015a7c4a;
extern PyObject *const_str_plain_client;
static PyObject *const_dict_4a96d2f6310f0842d222254905a83466;
extern PyObject *const_str_plain_cert;
static PyObject *const_str_plain_SSL_CTX_use_certificate_chain_file;
extern PyObject *const_str_plain__openssl_assert;
static PyObject *const_str_digest_c5585513b25f5127855be671a08a1332;
extern PyObject *const_str_plain_int2byte;
static PyObject *const_str_plain_SSLv2_METHOD;
static PyObject *const_str_plain_default_file;
extern PyObject *const_str_plain_buffer;
extern PyObject *const_tuple_str_digest_c075052d723d6707083e869a0e3659bb_tuple;
static PyObject *const_str_digest_5ecd8d00ee49c82aecc9b4312a6eab51;
static PyObject *const_tuple_72afa5cdf95db9f073bb963f13be50a9_tuple;
extern PyObject *const_str_plain_TLSv1_METHOD;
extern PyObject *const_str_plain_p;
static PyObject *const_str_plain_ocsp_data;
extern PyObject *const_str_plain_r;
static PyObject *const_str_plain_load_tmp_dh;
static PyObject *const_str_plain__alpn_select_callback_args;
extern PyObject *const_str_plain__context;
static PyObject *const_tuple_str_plain_self_str_plain_context_tuple;
static PyObject *const_str_plain_valid;
static PyObject *const_str_digest_7f19e81c824604e95ebb1f01b7f5d7a1;
static PyObject *const_str_digest_746ae0014bb266cffee8b7b1473626af;
static PyObject *const_str_plain_SSL_shutdown;
extern PyObject *const_str_plain_X509Store;
static PyObject *const_tuple_70b3e830bf27ee786cecd70f5eebc82a_tuple;
static PyObject *const_str_plain_SSL_get_peer_cert_chain;
static PyObject *const_str_plain__session;
static PyObject *const_str_plain_set_session_cache_mode;
static PyObject *const_str_digest_ce6e46c47189c65d4c33b9ca8d5ba2ad;
static PyObject *const_str_plain__OCSPServerCallbackHelper;
static PyObject *const_str_plain_SSL_new;
static PyObject *const_str_digest_655ba65e888ba33199198c92a8e95d70;
static PyObject *const_str_plain__alpn_select_callback;
extern PyObject *const_str_plain_pending;
extern PyObject *const_str_plain_platform;
static PyObject *const_str_digest_8d1f7ec402c1b452808eeb662977982b;
static PyObject *const_str_plain__passphrase_userdata;
extern PyObject *const_str_plain_FILETYPE_PEM;
extern PyObject *const_str_plain_native;
extern PyObject *const_str_plain_helper;
static PyObject *const_str_plain_SSL_OP_NO_SSLv3;
static PyObject *const_str_plain_SSL_OP_NO_SSLv2;
static PyObject *const_str_plain_SSL_SESSION_free;
extern PyObject *const_str_plain_TLSv1_2_METHOD;
static PyObject *const_str_digest_6d088f969ab84bf3d60ab75faa431e51;
static PyObject *const_str_plain_from_handle;
extern PyObject *const_int_0;
extern PyObject *const_str_plain_six;
static PyObject *const_str_plain_SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS;
extern PyObject *const_str_plain_make_assert;
static PyObject *const_str_plain_SSL_renegotiate_pending;
static PyObject *const_str_plain_pystore;
static PyObject *const_str_plain_SSL_load_client_CA_file;
static PyObject *const_str_plain_SSL_pending;
static PyObject *const_str_plain_SSL_OP_NO_TLSv1;
extern PyObject *const_str_plain_callback;
extern PyObject *const_str_plain_callable;
static PyObject *const_str_digest_4387d84e76f6b2a931cf315cb767f6ce;
static PyObject *const_str_plain_check_privatekey;
static PyObject *const_str_plain_SSL_get_shutdown;
static PyObject *const_str_plain_context_buf;
static PyObject *const_tuple_59ab6bd6bf9c850fdd6c5d8aae933618_tuple;
static PyObject *const_str_digest_b55bbb0df6959d47693f7145ead6828a;
static PyObject *const_tuple_ddbbebd3154d4430c5c187b2eaf912ed_tuple;
extern PyObject *const_str_plain_append;
static PyObject *const_str_plain_dir_env_var;
static PyObject *const_str_digest_3b38b9684d0a691f727a5c25b49127cb;
static PyObject *const_str_plain_request_ocsp;
static PyObject *const_str_plain__info_callback;
extern PyObject *const_str_plain_load_verify_locations;
static PyObject *const_str_plain_OP_TLS_D5_BUG;
static PyObject *const_str_plain_SSL_CTX_set_next_protos_advertised_cb;
static PyObject *const_tuple_str_plain_self_str_plain_dhfile_str_plain_bio_str_plain_dh_tuple;
static PyObject *const_str_digest_df17ae6c88635e3960d7bf94f5e880a4;
extern PyObject *const_str_plain_copy;
static PyObject *const_str_plain_set_npn_select_callback;
static PyObject *const_str_plain_SSL_CTX_set_default_passwd_cb;
static PyObject *const_str_plain_SSL_CTX_set_info_callback;
static PyObject *const_str_plain_OP_TLS_BLOCK_PADDING_BUG;
static PyObject *const_str_plain_SSL_get_error;
static PyObject *const_str_plain_SSL_get_certificate;
static PyObject *const_str_plain_get_timeout;
static PyObject *const_str_digest_f68d1733f2e29d0ad83b903b8f287e14;
extern PyObject *const_str_plain_pycert;
extern PyObject *const_str_plain_func;
static PyObject *const_str_plain_SSL_VERIFY_PEER;
extern PyObject *const_tuple_str_plain_self_str_plain_data_tuple;
extern PyObject *const_str_plain_wraps;
static PyObject *const_tuple_e7183725d38a187a36c7befeae938036_tuple;
static PyObject *const_str_digest_685ba6a7380a18939915178358979194;
static PyObject *const_str_plain_SSL_set_shutdown;
static PyObject *const_tuple_str_digest_c561652c58984ec0e9541542aa405594_int_0_tuple;
static PyObject *const_str_plain_use_context;
static PyObject *const_str_digest_68d768407778bc3b4c8ffc953440b717;
extern PyObject *const_str_plain__verify_callback;
extern PyObject *const_str_plain_version;
static PyObject *const_str_plain_outp;
static PyObject *const_str_digest_fe9d923dffe7ca07e210d76d45bba668;
static PyObject *const_str_plain__npn_select_callback;
static PyObject *const_str_digest_71f502d97e845c89ec13eb6ef271f294;
static PyObject *const_str_plain_get_cipher_list;
static PyObject *const_tuple_str_plain_platform_tuple;
static PyObject *const_str_plain_bufsiz;
static PyObject *const_str_plain_left_to_send;
static PyObject *const_str_digest_75d74458faf9dee1d9b7a20a034cfad7;
extern PyObject *const_str_plain__name;
static PyObject *const_str_plain_file_env_var;
extern PyObject *const_str_plain_keyfile;
extern PyObject *const_str_plain_length;
static PyObject *const_str_plain_set_mode;
static PyObject *const_str_digest_bd36e8cd21056831af843bc4658cec96;
extern PyObject *const_str_plain_do_handshake;
extern PyObject *const_str_plain_SSL_ST_RENEGOTIATE;
static PyObject *const_str_plain_SSL_CB_READ;
static PyObject *const_str_plain_SSL_OP_ALL;
static PyObject *const_tuple_str_plain_self_str_plain_cert_str_plain_use_result_tuple;
static PyObject *const_str_plain__ocsp_callback;
extern PyObject *const_str_plain_X509_dup;
static PyObject *const_str_plain_set_session_id;
static PyObject *const_str_digest_5e63447161ff7f7c21b2ac874cc6500c;
static PyObject *const_str_digest_92d0e5bbbb594d3595c30b16879df5a0;
static PyObject *const_str_digest_1f9e090d5f76db9e818dd53fef9b8465;
static PyObject *const_str_plain_set_ocsp_client_callback;
extern PyObject *const_str_plain_SSL_ST_OK;
extern PyObject *const_str_plain_ERR_peek_error;
static PyObject *const_str_digest_0e87e25b0ab76d44ec1e50f187ee33bd;
static PyObject *const_str_digest_03a9c0f25246f86801453ac49af67056;
static PyObject *const_str_plain_SSL_SESS_CACHE_NO_INTERNAL_LOOKUP;
static PyObject *const_str_plain_X509_get_default_cert_file_env;
extern PyObject *const_str_plain_SSLv3_METHOD;
extern PyObject *const_str_plain__ssl;
static PyObject *const_str_digest_a9a754c6f4c1dd488de35af4ae59537f;
static PyObject *const_str_plain_WantX509LookupError;
static PyObject *const_str_plain_SSLEAY_VERSION;
static PyObject *const_str_plain_set_npn_advertise_callback;
static PyObject *const_str_plain_get_peer_finished;
static PyObject *const_tuple_24e396011cc987e1c1e91fc8d67969c7_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_helper_str_plain_data_str_plain_rc_tuple;
static PyObject *const_str_plain_want_write;
static PyObject *const_str_plain_SSL_OP_COOKIE_EXCHANGE;
static PyObject *const_tuple_5a901cf5390bbd925e09951ee9017d23_tuple;
extern PyObject *const_str_plain_session;
static PyObject *const_str_digest_447836721d7454a13033957e012d7688;
static PyObject *const_tuple_str_plain_self_str_plain_pkey_str_plain_use_result_tuple;
extern PyObject *const_tuple_type_Exception_tuple;
extern PyObject *const_str_plain__store;
static PyObject *const_str_digest_94e7111e03f9422114930bb75dfc492c;
static PyObject *const_str_plain_certobj;
static PyObject *const_str_digest_8d7c284f25a4b19db8bcbef7a9895745;
static PyObject *const_str_plain_SSL_get_version;
static PyObject *const_str_plain_SESS_CACHE_CLIENT;
extern PyObject *const_str_plain_connection;
static PyObject *const_str_plain_get_client_ca_list;
static PyObject *const_str_plain_get_cert_store;
static PyObject *const_tuple_str_plain_self_str_plain_result_tuple;
static PyObject *const_str_plain_SSL_get_current_cipher;
extern PyObject *const_str_digest_b9c4baf879ebd882d40843df3a4dead7;
static PyObject *const_str_digest_e51bcf1ff2d3a73499a1380c77d20ade;
extern PyObject *const_tuple_int_0_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_cipher_list_str_plain_tmpconn_tuple;
static PyObject *const_str_plain_SSL_get_ex_data_X509_STORE_CTX_idx;
extern PyObject *const_tuple_str_plain_self_str_plain_args_str_plain_kwargs_tuple;
extern PyObject *const_str_plain_WantReadError;
extern PyObject *const_str_plain_OP_NO_SSLv3;
static PyObject *const_str_plain__set_ocsp_callback;
extern PyObject *const_str_plain_get_peer_certificate;
static PyObject *const_tuple_a13720a5c6ce612466cecad70ab66e75_tuple;
static PyObject *const_str_plain_set_accept_state;
static PyObject *const_str_digest_a8ac54b3ed8845d56dee411b1beed5c2;
static PyObject *const_str_plain__ocsp_helper;
static PyObject *const_str_plain_SSL_CTX_set_session_id_context;
static PyObject *const_tuple_str_plain_self_str_plain_dir_env_var_str_plain_file_env_var_tuple;
static PyObject *const_str_plain_certificate_authorities;
static PyObject *const_str_plain_file_path;
static PyObject *const_str_plain_SSL_CTX_free;
static PyObject *const_str_plain_context_len;
static PyObject *const_str_digest_215c056443df9aa1456b62fe40673d54;
static PyObject *const_tuple_fb64e812782e9f70f19909e310070a01_tuple;
static PyObject *const_str_plain_SSL_OP_TLS_D5_BUG;
static PyObject *const_str_plain_OP_SSLEAY_080_CLIENT_DH_BUG;
extern PyObject *const_str_digest_52773e1185116024389d12c91a4ccf3d;
extern PyObject *const_str_plain___module__;
extern PyObject *const_str_plain__to_EC_KEY;
extern PyObject *const_str_plain_cipher;
static PyObject *const_str_plain_SSL_get_finished;
static PyObject *const_str_plain_SSL_ST_MASK;
static PyObject *const_tuple_2fe4e23a8c490304baac2b73b87c6ea5_tuple;
static PyObject *const_tuple_0070fc91ecaec455401a06d1a7f4f5e8_tuple;
static PyObject *const_str_digest_159b478f00ae4e4ff337b75b4ff4b73e;
static PyObject *const_str_plain_SSL_set_session;
extern PyObject *const_str_plain_exception_from_error_queue;
static PyObject *const_str_plain_OP_SSLREF2_REUSE_CERT_TYPE_BUG;
static PyObject *const_tuple_09a9274d23abfb5c21510ecab74e4636_tuple;
static PyObject *const_str_digest_428eff9fedd3b449496fa307af56b948;
extern PyObject *const_str_plain__x509;
static PyObject *const_str_plain_SSL_CTX_add_client_CA;
static PyObject *const_str_plain_sk_X509_NAME_new_null;
static PyObject *const_str_plain_SSL_OP_TLS_ROLLBACK_BUG;
extern PyObject *const_str_plain_string;
extern PyObject *const_str_plain_TLSv1_1_METHOD;
static PyObject *const_tuple_str_plain_flag_str_plain_error_str_plain__requires_decorator_tuple;
static PyObject *const_str_plain_SESS_CACHE_NO_INTERNAL;
static PyObject *const_str_plain_get_protocol_version;
static PyObject *const_tuple_12babed94f04a9287de33a0a7ed4bbf2_tuple;
extern PyObject *const_str_plain_ssl;
extern PyObject *const_str_plain_data_ptr;
static PyObject *const_str_plain_SSL_CB_READ_ALERT;
static PyObject *const_str_plain_set_tlsext_use_srtp;
extern PyObject *const_str_plain_no_zero_allocator;
static PyObject *const_str_plain_SSL_OP_NO_COMPRESSION;
extern PyObject *const_tuple_int_neg_1_str_digest_fa91b370bf4aa8601b20ad022c04c7f5_tuple;
static PyObject *const_tuple_f85e0b49580abdb5d9ebc1ace31ffe3d_tuple;
static PyObject *const_str_digest_9e9a42d8484d15cb8253ecb92e0c7121;
static PyObject *const_str_plain_MODE_RELEASE_BUFFERS;
static PyObject *const_tuple_str_plain_self_str_plain_session_str_plain_pysession_tuple;
static PyObject *const_str_plain__passphrase_helper;
static PyObject *const_str_plain_SSL_set_tlsext_status_ocsp_resp;
static PyObject *const_tuple_22496b7900b49af1635f455cd8f3e9ef_tuple;
extern PyObject *const_str_plain_recv_into;
static PyObject *const_str_digest_a068c39f2c9878239ba2a3b47e83e1e0;
static PyObject *const_str_plain_SENT_SHUTDOWN;
static PyObject *const_str_plain__passphrase_callback;
static PyObject *const_str_plain_success;
extern PyObject *const_str_plain_ZeroReturnError;
static PyObject *const_str_plain_SSL_export_keying_material;
static PyObject *const_str_plain_SSL_CTX_set_default_verify_paths;
static PyObject *const_str_plain_get_state_string;
static PyObject *const_str_plain_SSL_CTX_set_cipher_list;
extern PyObject *const_str_plain_conn;
static PyObject *const_str_plain_SSL_OP_NO_TICKET;
static PyObject *const_str_plain_ConnectionType;
static PyObject *const_list_3574eb54ef4ecf6f2c0597b9df34708e_list;
extern PyObject *const_str_plain_get_verify_mode;
static PyObject *const_str_plain_SSL_OP_PKCS1_CHECK_1;
static PyObject *const_str_plain_SSL_OP_PKCS1_CHECK_2;
static PyObject *const_str_plain_set_shutdown;
static PyObject *const_str_plain_isfile;
static PyObject *const_str_plain_get_peer_cert_chain;
extern PyObject *const_str_plain_options;
static PyObject *const_str_plain_OP_NETSCAPE_CA_DN_BUG;
static PyObject *const_str_plain_SSL_CTX_set_tmp_ecdh;
static PyObject *const_str_plain_olen;
static PyObject *const_str_plain_SSL_CTX_set_timeout;
static PyObject *const_str_digest_971aa32305ac0845a4048d72c4cd63c5;
static PyObject *const_str_plain_method_obj;
extern PyObject *const_str_plain_obj;
static PyObject *const_str_plain__npn_advertise_callback_args;
static PyObject *const_str_digest_8cde8912e8f2207155a1addb0752791f;
static PyObject *const_str_plain__raise_passphrase_exception;
static PyObject *const_str_digest_a94ef27b6600318cb26f98532a46ec7d;
extern PyObject *const_str_plain_data_len;
static PyObject *const_str_plain_OP_TLS_ROLLBACK_BUG;
static PyObject *const_str_plain_SSL_CTX_set_verify_depth;
static PyObject *const_str_plain__CRYPTOGRAPHY_MANYLINUX1_CA_DIR;
static PyObject *const_str_plain_SSL_CB_WRITE_ALERT;
static PyObject *const_str_plain_get_context;
extern PyObject *const_str_plain_BIO_s_mem;
static PyObject *const_str_plain_TLSv1_2_method;
static PyObject *const_str_digest_6a85cdfe995e144af7c992d7adff36a9;
static PyObject *const_str_plain_set_tlsext_servername_callback;
extern PyObject *const_str_plain_bio;
static PyObject *const_tuple_str_plain_self_str_plain_callback_str_plain_wrapper_tuple;
static PyObject *const_str_digest_b6ee2740f619fbeb4f2040d74693ca57;
extern PyObject *const_tuple_str_plain_self_str_plain_name_tuple;
static PyObject *const_str_digest_c8e9b5ff5b00d8190ecae28b8a410248;
static PyObject *const_tuple_str_plain_self_str_plain_cipher_str_plain_version_tuple;
extern PyObject *const_str_plain_isdir;
static PyObject *const_str_digest_f6ccda911266ccc3bb4cd038d18beb52;
static PyObject *const_str_plain_SSL_CTX_check_private_key;
static PyObject *const_str_digest_91220ffd97efb14a503e0ecf9d7ff0d1;
static PyObject *const_str_digest_f7bf61568f9564a7aee5354f80d84343;
static PyObject *const_str_plain_SSL_get_client_random;
static PyObject *const_str_plain_SSL_RECEIVED_SHUTDOWN;
static PyObject *const_str_plain_input_str;
static PyObject *const_str_digest_3f54294273e4f6390044ae027b11e5ae;
static PyObject *const_str_plain_SSL_CB_LOOP;
static PyObject *const_str_digest_e0c534afee902e78ce11df02f380dfa7;
static PyObject *const_str_plain_BIO_set_mem_eof_return;
static PyObject *const_str_plain_OP_NO_TICKET;
static PyObject *const_str_plain_set_tmp_ecdh;
static PyObject *const_str_digest_91c07271f44b73503e7c77deea91aef1;
static PyObject *const_str_plain_SSL_SESSION_get_master_key;
static PyObject *const_str_plain_OP_MSIE_SSLV2_RSA_PADDING;
extern PyObject *const_str_plain__lib;
static PyObject *const_str_digest_770cbd653c9b65a44061ec243e0b5fd3;
static PyObject *const_str_digest_3319904791e7df62e14d88cc362facc1;
extern PyObject *const_str_plain_total_sent;
extern PyObject *const_str_plain___doc__;
static PyObject *const_str_digest_a3b259134db00dfd8458bf615870c7e2;
static PyObject *const_str_plain__CERTIFICATE_FILE_LOCATIONS;
static PyObject *const_str_digest_627e1a07a1a60af86ff9e544428f2f09;
extern PyObject *const_str_digest_81f1b0dfcc7a862e6940580ec4cc42d3;
static PyObject *const_str_digest_f4ac5993e0eb53c16d6349308d51d30e;
static PyObject *const_str_digest_1ba1651f4266e42e9b568d28fa131281;
extern PyObject *const_str_plain_PKey;
extern PyObject *const_str_plain_use_certificate_chain_file;
static PyObject *const_str_digest_bcb5a3a78e430302038d88f5e5d88cc5;
static PyObject *const_str_plain_sk_X509_NAME_num;
static PyObject *const_str_plain_set_alpn_select_callback;
static PyObject *const_str_digest_149b7c0937a6a666f182d0520ebdf631;
static PyObject *const_str_digest_eda9ad2d7932cfc1d1f52f27a3ed06a8;
static PyObject *const_tuple_str_plain_args_str_plain_kwargs_str_plain_error_tuple;
static PyObject *const_str_plain_renegotiate;
extern PyObject *const_str_empty;
static PyObject *const_str_digest_9071118ef0006cb5d28d9100761be8e9;
extern PyObject *const_str_plain_context;
static PyObject *const_str_plain_master_key;
static PyObject *const_str_digest_0d994cfb9823ffc5647bea3454d1e646;
static PyObject *const_str_plain_SSL_do_handshake;
extern PyObject *const_str_plain_VERIFY_FAIL_IF_NO_PEER_CERT;
extern PyObject *const_str_plain_timeout;
extern PyObject *const_str_plain_X509_STORE_CTX_get_error_depth;
static PyObject *const_str_plain_server_random;
static PyObject *const_str_plain_SSL_CTX_set_session_cache_mode;
static PyObject *const_str_plain_SSL_set_accept_state;
static PyObject *const_str_plain_sock_shutdown;
static PyObject *const_str_plain_BIO_read;
extern PyObject *const_str_plain_X509;
static PyObject *const_str_digest_592776beca582822ed747da68adba670;
extern PyObject *const_tuple_none_tuple;
static PyObject *const_str_plain_X509_STORE_CTX_set_error;
static PyObject *const_str_plain_TLSEXT_STATUSTYPE_ocsp;
static PyObject *const_str_plain_default_dir;
static PyObject *module_filename_obj;

/* Indicator if this modules private constants were created yet. */
static bool constants_created = false;

/* Function to create module private constants. */
static void createModuleConstants(void) {
    const_str_plain_SSL_CTX_set_next_proto_select_cb = UNSTREAM_STRING(&constant_bin[ 82959 ], 32, 1);
    const_tuple_str_plain_errorcode_tuple = PyTuple_New(1);
    const_str_plain_errorcode = UNSTREAM_STRING(&constant_bin[ 1777 ], 9, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain_errorcode_tuple, 0, const_str_plain_errorcode); Py_INCREF(const_str_plain_errorcode);
    const_str_plain_SSL_CIPHER_get_bits = UNSTREAM_STRING(&constant_bin[ 82991 ], 19, 1);
    const_tuple_str_plain_self_str_plain_session_str_plain_result_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_session_str_plain_result_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_session_str_plain_result_tuple, 1, const_str_plain_session); Py_INCREF(const_str_plain_session);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_session_str_plain_result_tuple, 2, const_str_plain_result); Py_INCREF(const_str_plain_result);
    const_str_plain_SSL_VERIFY_CLIENT_ONCE = UNSTREAM_STRING(&constant_bin[ 83010 ], 22, 1);
    const_str_digest_360fff1f759f48242850b1a03fa368f8 = UNSTREAM_STRING(&constant_bin[ 83032 ], 39, 0);
    const_str_plain_SSL_CTX_use_PrivateKey = UNSTREAM_STRING(&constant_bin[ 83071 ], 22, 1);
    const_str_digest_2db82bf07fbb595fa9b0bb5b41c7d7cb = UNSTREAM_STRING(&constant_bin[ 83093 ], 58, 0);
    const_str_plain_filetype = UNSTREAM_STRING(&constant_bin[ 83151 ], 8, 1);
    const_str_plain_BIO_write = UNSTREAM_STRING(&constant_bin[ 83159 ], 9, 1);
    const_str_digest_60759f97a8e448eec2208bd0c353d705 = UNSTREAM_STRING(&constant_bin[ 83168 ], 405, 0);
    const_list_3507872b18f9d5cd646e67697ec96e56_list = PyMarshal_ReadObjectFromString((char *)&constant_bin[ 83573 ], 1799);
    const_str_plain__NpnAdvertiseHelper = UNSTREAM_STRING(&constant_bin[ 1193 ], 19, 1);
    const_str_plain_ca_list = UNSTREAM_STRING(&constant_bin[ 85372 ], 7, 1);
    const_tuple_str_plain_func_str_plain_explode_str_plain_flag_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_func_str_plain_explode_str_plain_flag_tuple, 0, const_str_plain_func); Py_INCREF(const_str_plain_func);
    const_str_plain_explode = UNSTREAM_STRING(&constant_bin[ 85379 ], 7, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain_func_str_plain_explode_str_plain_flag_tuple, 1, const_str_plain_explode); Py_INCREF(const_str_plain_explode);
    const_str_plain_flag = UNSTREAM_STRING(&constant_bin[ 27321 ], 4, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain_func_str_plain_explode_str_plain_flag_tuple, 2, const_str_plain_flag); Py_INCREF(const_str_plain_flag);
    const_str_digest_92dae1d5c0e993b1b8bd25bfbbae5039 = UNSTREAM_STRING(&constant_bin[ 85386 ], 472, 0);
    const_str_plain_pyname = UNSTREAM_STRING(&constant_bin[ 85858 ], 6, 1);
    const_str_plain_OP_COOKIE_EXCHANGE = UNSTREAM_STRING(&constant_bin[ 84540 ], 18, 1);
    const_str_plain_ca_names = UNSTREAM_STRING(&constant_bin[ 85864 ], 8, 1);
    const_str_plain__CRYPTOGRAPHY_MANYLINUX1_CA_FILE = UNSTREAM_STRING(&constant_bin[ 746 ], 32, 1);
    const_str_plain_OP_SINGLE_ECDH_USE = UNSTREAM_STRING(&constant_bin[ 83979 ], 18, 1);
    const_str_digest_6e6304d3afc4a993b41c01e5af499f6b = UNSTREAM_STRING(&constant_bin[ 85872 ], 154, 0);
    const_str_plain_SSL_set_tlsext_host_name = UNSTREAM_STRING(&constant_bin[ 86026 ], 24, 1);
    const_tuple_str_plain_self_str_plain_depth_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_depth_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    const_str_plain_depth = UNSTREAM_STRING(&constant_bin[ 86050 ], 5, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_depth_tuple, 1, const_str_plain_depth); Py_INCREF(const_str_plain_depth);
    const_str_digest_9575fec1eee4d60c15d3f7c228d8045c = UNSTREAM_STRING(&constant_bin[ 86055 ], 22, 0);
    const_str_plain_SSL_OP_NO_QUERY_MTU = UNSTREAM_STRING(&constant_bin[ 86077 ], 19, 1);
    const_str_digest_ca4a6d4d96b227b5bd17bc5998515ec3 = UNSTREAM_STRING(&constant_bin[ 83168 ], 5, 0);
    const_str_plain_X509_STORE_CTX_get_ex_data = UNSTREAM_STRING(&constant_bin[ 86096 ], 26, 1);
    const_tuple_711d722f51d6d6accf419f2bb9aeb5b5_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_711d722f51d6d6accf419f2bb9aeb5b5_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    const_str_plain_certobj = UNSTREAM_STRING(&constant_bin[ 86122 ], 7, 1);
    PyTuple_SET_ITEM(const_tuple_711d722f51d6d6accf419f2bb9aeb5b5_tuple, 1, const_str_plain_certobj); Py_INCREF(const_str_plain_certobj);
    PyTuple_SET_ITEM(const_tuple_711d722f51d6d6accf419f2bb9aeb5b5_tuple, 2, const_str_plain_copy); Py_INCREF(const_str_plain_copy);
    PyTuple_SET_ITEM(const_tuple_711d722f51d6d6accf419f2bb9aeb5b5_tuple, 3, const_str_plain_add_result); Py_INCREF(const_str_plain_add_result);
    const_str_digest_1491fa532da0499070a77d607dd12a0d = UNSTREAM_STRING(&constant_bin[ 86129 ], 19, 0);
    const_str_plain_SSL_get_servername = UNSTREAM_STRING(&constant_bin[ 86148 ], 18, 1);
    const_str_plain_error_number = UNSTREAM_STRING(&constant_bin[ 86166 ], 12, 1);
    const_str_plain_SSL_ST_CONNECT = UNSTREAM_STRING(&constant_bin[ 84884 ], 14, 1);
    const_str_plain_want_read = UNSTREAM_STRING(&constant_bin[ 86178 ], 9, 1);
    const_str_plain_add_client_ca = UNSTREAM_STRING(&constant_bin[ 86187 ], 13, 1);
    const_str_digest_536ef6d81295f4591dd87bc79e8440e7 = UNSTREAM_STRING(&constant_bin[ 86200 ], 226, 0);
    const_str_plain_OP_NO_QUERY_MTU = UNSTREAM_STRING(&constant_bin[ 84520 ], 15, 1);
    const_str_plain__from_ssl = UNSTREAM_STRING(&constant_bin[ 86426 ], 9, 1);
    const_str_plain_set_ocsp_server_callback = UNSTREAM_STRING(&constant_bin[ 86435 ], 24, 1);
    const_str_plain_SSL_CTX_get_timeout = UNSTREAM_STRING(&constant_bin[ 86459 ], 19, 1);
    const_str_plain_get_next_proto_negotiated = UNSTREAM_STRING(&constant_bin[ 86478 ], 25, 1);
    const_str_plain_SSLeay_version = UNSTREAM_STRING(&constant_bin[ 85319 ], 14, 1);
    const_str_plain__OCSPClientCallbackHelper = UNSTREAM_STRING(&constant_bin[ 1386 ], 25, 1);
    const_str_plain_OP_PKCS1_CHECK_1 = UNSTREAM_STRING(&constant_bin[ 84391 ], 16, 1);
    const_str_plain_VERIFY_CLIENT_ONCE = UNSTREAM_STRING(&constant_bin[ 83014 ], 18, 1);
    const_str_plain_getwinerror = UNSTREAM_STRING(&constant_bin[ 86503 ], 11, 1);
    const_str_plain__reverse_mapping = UNSTREAM_STRING(&constant_bin[ 86514 ], 16, 1);
    const_tuple_1bf74246b679aacbbc5982cad038a099_tuple = PyTuple_New(6);
    PyTuple_SET_ITEM(const_tuple_1bf74246b679aacbbc5982cad038a099_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_1bf74246b679aacbbc5982cad038a099_tuple, 1, const_str_plain_i); Py_INCREF(const_str_plain_i);
    const_str_plain_cert_stack = UNSTREAM_STRING(&constant_bin[ 86530 ], 10, 1);
    PyTuple_SET_ITEM(const_tuple_1bf74246b679aacbbc5982cad038a099_tuple, 2, const_str_plain_cert_stack); Py_INCREF(const_str_plain_cert_stack);
    PyTuple_SET_ITEM(const_tuple_1bf74246b679aacbbc5982cad038a099_tuple, 3, const_str_plain_pycert); Py_INCREF(const_str_plain_pycert);
    PyTuple_SET_ITEM(const_tuple_1bf74246b679aacbbc5982cad038a099_tuple, 4, const_str_plain_cert); Py_INCREF(const_str_plain_cert);
    PyTuple_SET_ITEM(const_tuple_1bf74246b679aacbbc5982cad038a099_tuple, 5, const_str_plain_result); Py_INCREF(const_str_plain_result);
    const_str_plain_set_client_ca_list = UNSTREAM_STRING(&constant_bin[ 86540 ], 18, 1);
    const_str_plain_connect_ex = UNSTREAM_STRING(&constant_bin[ 83193 ], 10, 1);
    const_str_plain_set_info_callback = UNSTREAM_STRING(&constant_bin[ 86558 ], 17, 1);
    const_str_digest_8e472bc9049677fa90a9da1a818ea22f = UNSTREAM_STRING(&constant_bin[ 86575 ], 186, 0);
    const_tuple_str_plain_self_str_plain_mode_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_mode_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_mode_tuple, 1, const_str_plain_mode); Py_INCREF(const_str_plain_mode);
    const_str_digest_b02795b9590127f96a3b627129a2fbd2 = UNSTREAM_STRING(&constant_bin[ 86761 ], 29, 0);
    const_str_digest_c0087bb531594ec7f6b437fc33f5a397 = UNSTREAM_STRING(&constant_bin[ 86790 ], 900, 0);
    const_str_plain_outstr = UNSTREAM_STRING(&constant_bin[ 87690 ], 6, 1);
    const_str_plain__npn_advertise_helper = UNSTREAM_STRING(&constant_bin[ 87696 ], 21, 1);
    const_str_plain_OP_NO_TLSv1_1 = UNSTREAM_STRING(&constant_bin[ 83897 ], 13, 1);
    const_tuple_6f3d7ce791b29c8b2ccceca21130b973_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_6f3d7ce791b29c8b2ccceca21130b973_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_6f3d7ce791b29c8b2ccceca21130b973_tuple, 1, const_str_plain_cafile); Py_INCREF(const_str_plain_cafile);
    PyTuple_SET_ITEM(const_tuple_6f3d7ce791b29c8b2ccceca21130b973_tuple, 2, const_str_plain_capath); Py_INCREF(const_str_plain_capath);
    const_str_plain_load_result = UNSTREAM_STRING(&constant_bin[ 87717 ], 11, 1);
    PyTuple_SET_ITEM(const_tuple_6f3d7ce791b29c8b2ccceca21130b973_tuple, 3, const_str_plain_load_result); Py_INCREF(const_str_plain_load_result);
    const_str_digest_0bb5eb9f5b32c979fadc3e4b702de2f7 = UNSTREAM_STRING(&constant_bin[ 87728 ], 148, 0);
    const_str_plain_SSL_CTX_set_mode = UNSTREAM_STRING(&constant_bin[ 87876 ], 16, 1);
    const_str_plain_SSL_get_cipher_list = UNSTREAM_STRING(&constant_bin[ 87892 ], 19, 1);
    const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_p_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_p_tuple, 0, const_str_digest_b9c4baf879ebd882d40843df3a4dead7); Py_INCREF(const_str_digest_b9c4baf879ebd882d40843df3a4dead7);
    PyTuple_SET_ITEM(const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_p_tuple, 1, const_str_plain_p); Py_INCREF(const_str_plain_p);
    const_str_plain_SSL_get1_session = UNSTREAM_STRING(&constant_bin[ 87911 ], 16, 1);
    const_str_plain_SSL_CTX_set_verify = UNSTREAM_STRING(&constant_bin[ 87636 ], 18, 1);
    const_str_digest_cbc74855fdd069af46a5197a85921eab = UNSTREAM_STRING(&constant_bin[ 87927 ], 328, 0);
    const_tuple_8f082d20432d2aa73d41a80627094b27_tuple = PyTuple_New(15);
    PyTuple_SET_ITEM(const_tuple_8f082d20432d2aa73d41a80627094b27_tuple, 0, const_str_plain_ssl); Py_INCREF(const_str_plain_ssl);
    PyTuple_SET_ITEM(const_tuple_8f082d20432d2aa73d41a80627094b27_tuple, 1, const_str_plain_out); Py_INCREF(const_str_plain_out);
    PyTuple_SET_ITEM(const_tuple_8f082d20432d2aa73d41a80627094b27_tuple, 2, const_str_plain_outlen); Py_INCREF(const_str_plain_outlen);
    const_str_plain_in_ = UNSTREAM_STRING(&constant_bin[ 39953 ], 3, 1);
    PyTuple_SET_ITEM(const_tuple_8f082d20432d2aa73d41a80627094b27_tuple, 3, const_str_plain_in_); Py_INCREF(const_str_plain_in_);
    const_str_plain_inlen = UNSTREAM_STRING(&constant_bin[ 88255 ], 5, 1);
    PyTuple_SET_ITEM(const_tuple_8f082d20432d2aa73d41a80627094b27_tuple, 4, const_str_plain_inlen); Py_INCREF(const_str_plain_inlen);
    PyTuple_SET_ITEM(const_tuple_8f082d20432d2aa73d41a80627094b27_tuple, 5, const_str_plain_arg); Py_INCREF(const_str_plain_arg);
    PyTuple_SET_ITEM(const_tuple_8f082d20432d2aa73d41a80627094b27_tuple, 6, const_str_plain_encoded_len); Py_INCREF(const_str_plain_encoded_len);
    const_str_plain_protolist = UNSTREAM_STRING(&constant_bin[ 88260 ], 9, 1);
    PyTuple_SET_ITEM(const_tuple_8f082d20432d2aa73d41a80627094b27_tuple, 7, const_str_plain_protolist); Py_INCREF(const_str_plain_protolist);
    PyTuple_SET_ITEM(const_tuple_8f082d20432d2aa73d41a80627094b27_tuple, 8, const_str_plain_e); Py_INCREF(const_str_plain_e);
    const_str_plain_instr = UNSTREAM_STRING(&constant_bin[ 88269 ], 5, 1);
    PyTuple_SET_ITEM(const_tuple_8f082d20432d2aa73d41a80627094b27_tuple, 9, const_str_plain_instr); Py_INCREF(const_str_plain_instr);
    PyTuple_SET_ITEM(const_tuple_8f082d20432d2aa73d41a80627094b27_tuple, 10, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_8f082d20432d2aa73d41a80627094b27_tuple, 11, const_str_plain_proto); Py_INCREF(const_str_plain_proto);
    PyTuple_SET_ITEM(const_tuple_8f082d20432d2aa73d41a80627094b27_tuple, 12, const_str_plain_callback); Py_INCREF(const_str_plain_callback);
    PyTuple_SET_ITEM(const_tuple_8f082d20432d2aa73d41a80627094b27_tuple, 13, const_str_plain_outstr); Py_INCREF(const_str_plain_outstr);
    PyTuple_SET_ITEM(const_tuple_8f082d20432d2aa73d41a80627094b27_tuple, 14, const_str_plain_conn); Py_INCREF(const_str_plain_conn);
    const_str_plain__into_ssl = UNSTREAM_STRING(&constant_bin[ 88274 ], 9, 1);
    const_str_plain_BIO_new_file = UNSTREAM_STRING(&constant_bin[ 88283 ], 12, 1);
    const_str_plain__NpnSelectHelper = UNSTREAM_STRING(&constant_bin[ 1241 ], 16, 1);
    const_str_plain_alert = UNSTREAM_STRING(&constant_bin[ 88295 ], 5, 1);
    const_str_digest_73851dbd1821d646fbb8ad48e937548f = UNSTREAM_STRING(&constant_bin[ 88300 ], 135, 0);
    const_str_digest_8cc305fc9d9a417a96ba57f2c87b94e9 = UNSTREAM_STRING(&constant_bin[ 88435 ], 24, 0);
    const_str_plain_SSLEAY_DIR = UNSTREAM_STRING(&constant_bin[ 83667 ], 10, 1);
    const_str_digest_099382aff2f4e6520a621b385fae4992 = UNSTREAM_STRING(&constant_bin[ 88459 ], 220, 0);
    const_str_plain_use_privatekey = UNSTREAM_STRING(&constant_bin[ 88679 ], 14, 1);
    const_str_plain_OP_PKCS1_CHECK_2 = UNSTREAM_STRING(&constant_bin[ 84412 ], 16, 1);
    const_str_plain_nbytes = UNSTREAM_STRING(&constant_bin[ 88693 ], 6, 1);
    const_str_digest_0bdfe95b50c341a06f9727afb1a762dc = UNSTREAM_STRING(&constant_bin[ 88699 ], 158, 0);
    const_str_plain_SSL_SESS_CACHE_OFF = UNSTREAM_STRING(&constant_bin[ 88857 ], 18, 1);
    const_str_plain_SSL_CB_HANDSHAKE_DONE = UNSTREAM_STRING(&constant_bin[ 85185 ], 21, 1);
    const_str_plain_SESS_CACHE_OFF = UNSTREAM_STRING(&constant_bin[ 84678 ], 14, 1);
    const_str_digest_240fed82a102b949d0d53c00df42e330 = UNSTREAM_STRING(&constant_bin[ 88875 ], 103, 0);
    const_str_plain_SSL_MODE_ENABLE_PARTIAL_WRITE = UNSTREAM_STRING(&constant_bin[ 88978 ], 29, 1);
    const_str_digest_3957b1b23f06761ef1844caf450dffd3 = UNSTREAM_STRING(&constant_bin[ 89007 ], 221, 0);
    const_str_plain__VerifyHelper = UNSTREAM_STRING(&constant_bin[ 1076 ], 13, 1);
    const_str_plain_SSL_CIPHER_get_version = UNSTREAM_STRING(&constant_bin[ 89228 ], 22, 1);
    const_str_plain_bio_shutdown = UNSTREAM_STRING(&constant_bin[ 89250 ], 12, 1);
    const_str_digest_f45f13437cfffca595693525af90acd6 = UNSTREAM_STRING(&constant_bin[ 89262 ], 156, 0);
    const_str_plain_TLSEXT_NAMETYPE_host_name = UNSTREAM_STRING(&constant_bin[ 89418 ], 25, 1);
    const_str_plain_SSL_CB_EXIT = UNSTREAM_STRING(&constant_bin[ 84953 ], 11, 1);
    const_str_plain_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG = UNSTREAM_STRING(&constant_bin[ 84082 ], 35, 1);
    const_dict_c3a065e676a930b8196978eb12fcba71 = _PyDict_NewPresized( 2 );
    PyDict_SetItem(const_dict_c3a065e676a930b8196978eb12fcba71, const_str_plain___module__, const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9);
    const_str_digest_720dcf8e2be0afcf53b482e84751fd16 = UNSTREAM_STRING(&constant_bin[ 89443 ], 201, 0);
    PyDict_SetItem(const_dict_c3a065e676a930b8196978eb12fcba71, const_str_plain___doc__, const_str_digest_720dcf8e2be0afcf53b482e84751fd16);
    assert(PyDict_Size(const_dict_c3a065e676a930b8196978eb12fcba71) == 2);
    const_str_digest_060a092ce142509580b5fc6c56b149a1 = UNSTREAM_STRING(&constant_bin[ 89644 ], 308, 0);
    const_str_plain__wrap_callback = UNSTREAM_STRING(&constant_bin[ 89952 ], 14, 1);
    const_str_plain_get_app_data = UNSTREAM_STRING(&constant_bin[ 89966 ], 12, 1);
    const_str_plain_SSL_SESS_CACHE_NO_AUTO_CLEAR = UNSTREAM_STRING(&constant_bin[ 89978 ], 28, 1);
    const_str_digest_7ac3fb96e522dea60117802c4a4274df = UNSTREAM_STRING(&constant_bin[ 90006 ], 26, 0);
    const_tuple_62a32d899dc1fe37f6d326f7d9a44911_tuple = PyTuple_New(6);
    PyTuple_SET_ITEM(const_tuple_62a32d899dc1fe37f6d326f7d9a44911_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_62a32d899dc1fe37f6d326f7d9a44911_tuple, 1, const_str_plain_method); Py_INCREF(const_str_plain_method);
    const_str_plain_method_obj = UNSTREAM_STRING(&constant_bin[ 90032 ], 10, 1);
    PyTuple_SET_ITEM(const_tuple_62a32d899dc1fe37f6d326f7d9a44911_tuple, 2, const_str_plain_method_obj); Py_INCREF(const_str_plain_method_obj);
    PyTuple_SET_ITEM(const_tuple_62a32d899dc1fe37f6d326f7d9a44911_tuple, 3, const_str_plain_res); Py_INCREF(const_str_plain_res);
    PyTuple_SET_ITEM(const_tuple_62a32d899dc1fe37f6d326f7d9a44911_tuple, 4, const_str_plain_context); Py_INCREF(const_str_plain_context);
    const_str_plain_method_func = UNSTREAM_STRING(&constant_bin[ 90042 ], 11, 1);
    PyTuple_SET_ITEM(const_tuple_62a32d899dc1fe37f6d326f7d9a44911_tuple, 5, const_str_plain_method_func); Py_INCREF(const_str_plain_method_func);
    const_str_plain_SSL_OP_NO_TLSv1_2 = UNSTREAM_STRING(&constant_bin[ 90053 ], 17, 1);
    const_str_plain_SSL_OP_NO_TLSv1_1 = UNSTREAM_STRING(&constant_bin[ 90070 ], 17, 1);
    const_str_plain_Cryptography_HAS_NEXTPROTONEG = UNSTREAM_STRING(&constant_bin[ 90087 ], 29, 1);
    const_str_plain_bio_read = UNSTREAM_STRING(&constant_bin[ 90116 ], 8, 1);
    const_str_plain__requires_decorator = UNSTREAM_STRING(&constant_bin[ 90124 ], 19, 1);
    const_str_plain_name_stack = UNSTREAM_STRING(&constant_bin[ 90143 ], 10, 1);
    const_str_digest_3d1ad7b2c9fa025afe944eacf471d909 = UNSTREAM_STRING(&constant_bin[ 90153 ], 137, 0);
    const_tuple_40c019df00fadc68e051d5153056e038_tuple = PyTuple_New(7);
    PyTuple_SET_ITEM(const_tuple_40c019df00fadc68e051d5153056e038_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_40c019df00fadc68e051d5153056e038_tuple, 1, const_str_plain_name); Py_INCREF(const_str_plain_name);
    PyTuple_SET_ITEM(const_tuple_40c019df00fadc68e051d5153056e038_tuple, 2, const_str_plain_pyname); Py_INCREF(const_str_plain_pyname);
    PyTuple_SET_ITEM(const_tuple_40c019df00fadc68e051d5153056e038_tuple, 3, const_str_plain_i); Py_INCREF(const_str_plain_i);
    PyTuple_SET_ITEM(const_tuple_40c019df00fadc68e051d5153056e038_tuple, 4, const_str_plain_ca_names); Py_INCREF(const_str_plain_ca_names);
    PyTuple_SET_ITEM(const_tuple_40c019df00fadc68e051d5153056e038_tuple, 5, const_str_plain_result); Py_INCREF(const_str_plain_result);
    PyTuple_SET_ITEM(const_tuple_40c019df00fadc68e051d5153056e038_tuple, 6, const_str_plain_copy); Py_INCREF(const_str_plain_copy);
    const_str_digest_77c1b668370aaac8571fd41e2e807543 = UNSTREAM_STRING(&constant_bin[ 90290 ], 763, 0);
    const_str_plain__asFileDescriptor = UNSTREAM_STRING(&constant_bin[ 1476 ], 17, 1);
    const_str_plain_SESS_CACHE_NO_AUTO_CLEAR = UNSTREAM_STRING(&constant_bin[ 84761 ], 24, 1);
    const_str_plain_add_extra_chain_cert = UNSTREAM_STRING(&constant_bin[ 91053 ], 20, 1);
    const_str_digest_04211c3d50cdc4f69d9c36018d92c12f = UNSTREAM_STRING(&constant_bin[ 91073 ], 39, 0);
    const_str_digest_09af89b9aab79bc5666da647371af25d = UNSTREAM_STRING(&constant_bin[ 91112 ], 272, 0);
    const_str_digest_a824ae6766bf79c53a58510064186c32 = UNSTREAM_STRING(&constant_bin[ 91384 ], 271, 0);
    const_str_digest_1494ae1301cb98a828389add570df55f = UNSTREAM_STRING(&constant_bin[ 91655 ], 94, 0);
    const_str_plain_TLS_CHACHA20_POLY1305_SHA256 = UNSTREAM_STRING(&constant_bin[ 91749 ], 28, 1);
    const_str_plain_SSL_CTX_use_certificate = UNSTREAM_STRING(&constant_bin[ 91777 ], 23, 1);
    const_str_plain_SESS_CACHE_BOTH = UNSTREAM_STRING(&constant_bin[ 84741 ], 15, 1);
    const_str_digest_ee77c76941f8fd58acff5cfda589cc1d = UNSTREAM_STRING(&constant_bin[ 91800 ], 22, 0);
    const_tuple_617fe238ea11ea0890ce2460de3bd68e_tuple = PyTuple_New(11);
    PyTuple_SET_ITEM(const_tuple_617fe238ea11ea0890ce2460de3bd68e_tuple, 0, const_str_plain_ssl); Py_INCREF(const_str_plain_ssl);
    PyTuple_SET_ITEM(const_tuple_617fe238ea11ea0890ce2460de3bd68e_tuple, 1, const_str_plain_cdata); Py_INCREF(const_str_plain_cdata);
    const_str_plain_ocsp_len = UNSTREAM_STRING(&constant_bin[ 91822 ], 8, 1);
    PyTuple_SET_ITEM(const_tuple_617fe238ea11ea0890ce2460de3bd68e_tuple, 2, const_str_plain_ocsp_len); Py_INCREF(const_str_plain_ocsp_len);
    PyTuple_SET_ITEM(const_tuple_617fe238ea11ea0890ce2460de3bd68e_tuple, 3, const_str_plain_e); Py_INCREF(const_str_plain_e);
    PyTuple_SET_ITEM(const_tuple_617fe238ea11ea0890ce2460de3bd68e_tuple, 4, const_str_plain_callback); Py_INCREF(const_str_plain_callback);
    PyTuple_SET_ITEM(const_tuple_617fe238ea11ea0890ce2460de3bd68e_tuple, 5, const_str_plain_self); Py_INCREF(const_str_plain_self);
    const_str_plain_valid = UNSTREAM_STRING(&constant_bin[ 3774 ], 5, 1);
    PyTuple_SET_ITEM(const_tuple_617fe238ea11ea0890ce2460de3bd68e_tuple, 6, const_str_plain_valid); Py_INCREF(const_str_plain_valid);
    const_str_plain_ocsp_ptr = UNSTREAM_STRING(&constant_bin[ 91830 ], 8, 1);
    PyTuple_SET_ITEM(const_tuple_617fe238ea11ea0890ce2460de3bd68e_tuple, 7, const_str_plain_ocsp_ptr); Py_INCREF(const_str_plain_ocsp_ptr);
    const_str_plain_ocsp_data = UNSTREAM_STRING(&constant_bin[ 91838 ], 9, 1);
    PyTuple_SET_ITEM(const_tuple_617fe238ea11ea0890ce2460de3bd68e_tuple, 8, const_str_plain_ocsp_data); Py_INCREF(const_str_plain_ocsp_data);
    PyTuple_SET_ITEM(const_tuple_617fe238ea11ea0890ce2460de3bd68e_tuple, 9, const_str_plain_data); Py_INCREF(const_str_plain_data);
    PyTuple_SET_ITEM(const_tuple_617fe238ea11ea0890ce2460de3bd68e_tuple, 10, const_str_plain_conn); Py_INCREF(const_str_plain_conn);
    const_str_digest_f5da7ec1228a5c8d32fa9b786affa014 = UNSTREAM_STRING(&constant_bin[ 91847 ], 361, 0);
    const_str_digest_0b1af5d020260df564f1f58f9f88daaa = UNSTREAM_STRING(&constant_bin[ 92208 ], 243, 0);
    const_str_digest_e7ed1590d11cbaaaf17420c6bdc13490 = UNSTREAM_STRING(&constant_bin[ 92451 ], 169, 0);
    const_str_digest_83abd167711a9d69f6fb1ba8bbb40fdb = UNSTREAM_STRING(&constant_bin[ 92620 ], 1010, 0);
    const_tuple_str_plain_self_str_plain_callback_str_plain_userdata_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_callback_str_plain_userdata_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_callback_str_plain_userdata_tuple, 1, const_str_plain_callback); Py_INCREF(const_str_plain_callback);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_callback_str_plain_userdata_tuple, 2, const_str_plain_userdata); Py_INCREF(const_str_plain_userdata);
    const_str_plain_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG = UNSTREAM_STRING(&constant_bin[ 84459 ], 34, 1);
    const_str_plain_TLS_AES_256_GCM_SHA384 = UNSTREAM_STRING(&constant_bin[ 93630 ], 22, 1);
    const_str_plain_OP_EPHEMERAL_RSA = UNSTREAM_STRING(&constant_bin[ 84002 ], 16, 1);
    const_str_plain_set_timeout = UNSTREAM_STRING(&constant_bin[ 87780 ], 11, 1);
    const_str_plain_X509_get_default_cert_file = UNSTREAM_STRING(&constant_bin[ 93652 ], 26, 1);
    const_str_plain_protos = UNSTREAM_STRING(&constant_bin[ 93678 ], 6, 1);
    const_str_plain_Cryptography_HAS_TLSEXT_HOSTNAME = UNSTREAM_STRING(&constant_bin[ 93684 ], 32, 1);
    const_str_plain_SSL_set_bio = UNSTREAM_STRING(&constant_bin[ 93716 ], 11, 1);
    const_tuple_str_plain_self_str_plain_cipher_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_cipher_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_cipher_tuple, 1, const_str_plain_cipher); Py_INCREF(const_str_plain_cipher);
    const_str_digest_d3a1e78595a066a43885e44a343877f5 = UNSTREAM_STRING(&constant_bin[ 93727 ], 14, 0);
    const_str_digest_b7964fdc1d8df81dacc8b4450db712e3 = UNSTREAM_STRING(&constant_bin[ 93741 ], 52, 0);
    const_tuple_str_plain_self_str_plain_bio_str_plain_result_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_bio_str_plain_result_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_bio_str_plain_result_tuple, 1, const_str_plain_bio); Py_INCREF(const_str_plain_bio);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_bio_str_plain_result_tuple, 2, const_str_plain_result); Py_INCREF(const_str_plain_result);
    const_str_digest_ef6e6485863cf611499d4e66d7c8cb32 = UNSTREAM_STRING(&constant_bin[ 93793 ], 196, 0);
    const_str_digest_3c214455d63d6846892932f043ae8dab = UNSTREAM_STRING(&constant_bin[ 93989 ], 362, 0);
    const_tuple_str_plain_self_str_plain_options_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_options_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_options_tuple, 1, const_str_plain_options); Py_INCREF(const_str_plain_options);
    const_tuple_str_plain_self_str_plain_addr_str_plain_connect_ex_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_addr_str_plain_connect_ex_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_addr_str_plain_connect_ex_tuple, 1, const_str_plain_addr); Py_INCREF(const_str_plain_addr);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_addr_str_plain_connect_ex_tuple, 2, const_str_plain_connect_ex); Py_INCREF(const_str_plain_connect_ex);
    const_str_digest_ad463a4d3fa3baff68f13aea2d205572 = UNSTREAM_STRING(&constant_bin[ 94351 ], 129, 0);
    const_str_plain_get_servername = UNSTREAM_STRING(&constant_bin[ 86152 ], 14, 1);
    const_str_plain_BIO_should_retry = UNSTREAM_STRING(&constant_bin[ 94480 ], 16, 1);
    const_str_plain_set_context = UNSTREAM_STRING(&constant_bin[ 94496 ], 11, 1);
    const_str_plain_push_result = UNSTREAM_STRING(&constant_bin[ 94507 ], 11, 1);
    const_str_digest_2c98e45dae0eb590d01836d5f4b5f54f = UNSTREAM_STRING(&constant_bin[ 94518 ], 435, 0);
    const_str_digest_b6f7e6068b1690fa00ff377454fad5cf = UNSTREAM_STRING(&constant_bin[ 94953 ], 62, 0);
    const_str_digest_5f09856be161f8b617a90e11db2ed735 = UNSTREAM_STRING(&constant_bin[ 95015 ], 105, 0);
    const_str_plain_SSL_CB_ACCEPT_EXIT = UNSTREAM_STRING(&constant_bin[ 85087 ], 18, 1);
    const_str_plain_SSL_OP_SSLEAY_080_CLIENT_DH_BUG = UNSTREAM_STRING(&constant_bin[ 95120 ], 31, 1);
    const_str_plain_SSL_peek = UNSTREAM_STRING(&constant_bin[ 95151 ], 8, 1);
    const_str_plain__ALPNSelectHelper = UNSTREAM_STRING(&constant_bin[ 1286 ], 17, 1);
    const_str_plain_bio_write = UNSTREAM_STRING(&constant_bin[ 95159 ], 9, 1);
    const_str_plain_get_session = UNSTREAM_STRING(&constant_bin[ 95168 ], 11, 1);
    const_str_plain_SSL_CTX_set_tlsext_status_cb = UNSTREAM_STRING(&constant_bin[ 95179 ], 28, 1);
    const_str_plain_BIO_should_io_special = UNSTREAM_STRING(&constant_bin[ 95207 ], 21, 1);
    const_str_plain_TLSv1_method = UNSTREAM_STRING(&constant_bin[ 95228 ], 12, 1);
    const_str_plain_export_keying_material = UNSTREAM_STRING(&constant_bin[ 95240 ], 22, 1);
    const_str_plain_SSL_get_tlsext_status_ocsp_resp = UNSTREAM_STRING(&constant_bin[ 95262 ], 31, 1);
    const_str_plain_get_session_cache_mode = UNSTREAM_STRING(&constant_bin[ 95293 ], 22, 1);
    const_str_digest_eb75de26d3d89a0b83fc536ac20042b0 = UNSTREAM_STRING(&constant_bin[ 95315 ], 121, 0);
    const_str_plain_get_verify_depth = UNSTREAM_STRING(&constant_bin[ 95436 ], 16, 1);
    const_str_plain_SSL_CTX_set_client_CA_list = UNSTREAM_STRING(&constant_bin[ 95452 ], 26, 1);
    const_str_plain__requires_alpn = UNSTREAM_STRING(&constant_bin[ 2518 ], 14, 1);
    const_tuple_str_plain_self_str_plain_cipher_str_plain_name_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_cipher_str_plain_name_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_cipher_str_plain_name_tuple, 1, const_str_plain_cipher); Py_INCREF(const_str_plain_cipher);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_cipher_str_plain_name_tuple, 2, const_str_plain_name); Py_INCREF(const_str_plain_name);
    const_str_plain_sk_X509_NAME_value = UNSTREAM_STRING(&constant_bin[ 95478 ], 18, 1);
    const_str_plain_OP_MICROSOFT_SESS_ID_BUG = UNSTREAM_STRING(&constant_bin[ 84023 ], 24, 1);
    const_str_digest_e5bdbccc007b5187d287f36f3c9f8130 = UNSTREAM_STRING(&constant_bin[ 95496 ], 360, 0);
    const_str_plain_SSL_CTX_use_certificate_file = UNSTREAM_STRING(&constant_bin[ 95856 ], 28, 1);
    const_tuple_str_plain_obj_str_plain_fd_str_plain_meth_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_obj_str_plain_fd_str_plain_meth_tuple, 0, const_str_plain_obj); Py_INCREF(const_str_plain_obj);
    const_str_plain_fd = UNSTREAM_STRING(&constant_bin[ 95884 ], 2, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain_obj_str_plain_fd_str_plain_meth_tuple, 1, const_str_plain_fd); Py_INCREF(const_str_plain_fd);
    PyTuple_SET_ITEM(const_tuple_str_plain_obj_str_plain_fd_str_plain_meth_tuple, 2, const_str_plain_meth); Py_INCREF(const_str_plain_meth);
    const_str_plain_SSL_MODE_RELEASE_BUFFERS = UNSTREAM_STRING(&constant_bin[ 95886 ], 24, 1);
    const_str_digest_b2b544e0252baa92681eeaf8ffa03130 = UNSTREAM_STRING(&constant_bin[ 95910 ], 173, 0);
    const_str_plain_ocsp_data_length = UNSTREAM_STRING(&constant_bin[ 96083 ], 16, 1);
    const_tuple_str_plain_self_str_plain_cafile_str_plain_ca_list_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_cafile_str_plain_ca_list_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_cafile_str_plain_ca_list_tuple, 1, const_str_plain_cafile); Py_INCREF(const_str_plain_cafile);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_cafile_str_plain_ca_list_tuple, 2, const_str_plain_ca_list); Py_INCREF(const_str_plain_ca_list);
    const_str_plain_OP_NETSCAPE_CHALLENGE_BUG = UNSTREAM_STRING(&constant_bin[ 84052 ], 25, 1);
    const_str_digest_62f84685dfb1efe6a65f54b5d84154ad = UNSTREAM_STRING(&constant_bin[ 96099 ], 266, 0);
    const_str_plain__ocsp_data = UNSTREAM_STRING(&constant_bin[ 96365 ], 10, 1);
    const_tuple_str_plain_count_str_plain_chain_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_count_str_plain_chain_tuple, 0, const_str_plain_count); Py_INCREF(const_str_plain_count);
    PyTuple_SET_ITEM(const_tuple_str_plain_count_str_plain_chain_tuple, 1, const_str_plain_chain); Py_INCREF(const_str_plain_chain);
    const_str_digest_d84d6f514b61e2d13913a11459387aca = UNSTREAM_STRING(&constant_bin[ 96375 ], 259, 0);
    const_str_plain_TLS_AES_128_GCM_SHA256 = UNSTREAM_STRING(&constant_bin[ 96634 ], 22, 1);
    const_str_plain_protostr = UNSTREAM_STRING(&constant_bin[ 96656 ], 8, 1);
    const_str_plain_SSL_CTX_get_verify_mode = UNSTREAM_STRING(&constant_bin[ 96664 ], 23, 1);
    const_dict_8204a0d80b2c8b5483fe77928e561739 = _PyDict_NewPresized( 2 );
    PyDict_SetItem(const_dict_8204a0d80b2c8b5483fe77928e561739, const_str_plain___module__, const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9);
    const_str_digest_971aa32305ac0845a4048d72c4cd63c5 = UNSTREAM_STRING(&constant_bin[ 96687 ], 52, 0);
    PyDict_SetItem(const_dict_8204a0d80b2c8b5483fe77928e561739, const_str_plain___doc__, const_str_digest_971aa32305ac0845a4048d72c4cd63c5);
    assert(PyDict_Size(const_dict_8204a0d80b2c8b5483fe77928e561739) == 2);
    const_tuple_7c3b7701dcc867dc417afc0b7dd18be0_tuple = PyTuple_New(5);
    PyTuple_SET_ITEM(const_tuple_7c3b7701dcc867dc417afc0b7dd18be0_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_7c3b7701dcc867dc417afc0b7dd18be0_tuple, 1, const_str_plain_context); Py_INCREF(const_str_plain_context);
    PyTuple_SET_ITEM(const_tuple_7c3b7701dcc867dc417afc0b7dd18be0_tuple, 2, const_str_plain_socket); Py_INCREF(const_str_plain_socket);
    PyTuple_SET_ITEM(const_tuple_7c3b7701dcc867dc417afc0b7dd18be0_tuple, 3, const_str_plain_ssl); Py_INCREF(const_str_plain_ssl);
    PyTuple_SET_ITEM(const_tuple_7c3b7701dcc867dc417afc0b7dd18be0_tuple, 4, const_str_plain_set_result); Py_INCREF(const_str_plain_set_result);
    const_str_digest_b8ec26ebdab81fb3d5f36275b48d4beb = UNSTREAM_STRING(&constant_bin[ 96739 ], 404, 0);
    const_tuple_78e460fdd8266d432328f4bff5207c29_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_78e460fdd8266d432328f4bff5207c29_tuple, 0, const_str_plain_ssl); Py_INCREF(const_str_plain_ssl);
    PyTuple_SET_ITEM(const_tuple_78e460fdd8266d432328f4bff5207c29_tuple, 1, const_str_plain_where); Py_INCREF(const_str_plain_where);
    PyTuple_SET_ITEM(const_tuple_78e460fdd8266d432328f4bff5207c29_tuple, 2, const_str_plain_return_code); Py_INCREF(const_str_plain_return_code);
    PyTuple_SET_ITEM(const_tuple_78e460fdd8266d432328f4bff5207c29_tuple, 3, const_str_plain_callback); Py_INCREF(const_str_plain_callback);
    const_str_digest_7540551bed0e4507c2b90cdbe0aa8fb3 = UNSTREAM_STRING(&constant_bin[ 97143 ], 49, 0);
    const_tuple_27b415f5f1545c164c69e92aa878cdf0_tuple = PyTuple_New(7);
    PyTuple_SET_ITEM(const_tuple_27b415f5f1545c164c69e92aa878cdf0_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_27b415f5f1545c164c69e92aa878cdf0_tuple, 1, const_str_plain_buf); Py_INCREF(const_str_plain_buf);
    PyTuple_SET_ITEM(const_tuple_27b415f5f1545c164c69e92aa878cdf0_tuple, 2, const_str_plain_flags); Py_INCREF(const_str_plain_flags);
    const_str_plain_left_to_send = UNSTREAM_STRING(&constant_bin[ 97192 ], 12, 1);
    PyTuple_SET_ITEM(const_tuple_27b415f5f1545c164c69e92aa878cdf0_tuple, 3, const_str_plain_left_to_send); Py_INCREF(const_str_plain_left_to_send);
    PyTuple_SET_ITEM(const_tuple_27b415f5f1545c164c69e92aa878cdf0_tuple, 4, const_str_plain_data); Py_INCREF(const_str_plain_data);
    PyTuple_SET_ITEM(const_tuple_27b415f5f1545c164c69e92aa878cdf0_tuple, 5, const_str_plain_result); Py_INCREF(const_str_plain_result);
    PyTuple_SET_ITEM(const_tuple_27b415f5f1545c164c69e92aa878cdf0_tuple, 6, const_str_plain_total_sent); Py_INCREF(const_str_plain_total_sent);
    const_str_plain_rc = UNSTREAM_STRING(&constant_bin[ 1781 ], 2, 1);
    const_str_digest_61df355efe52f096d5251268bee9ada3 = UNSTREAM_STRING(&constant_bin[ 97204 ], 130, 0);
    const_str_plain_SSL_CB_CONNECT_LOOP = UNSTREAM_STRING(&constant_bin[ 85110 ], 19, 1);
    const_str_digest_f85e475b3736c6da8cbd8e92af63eba4 = UNSTREAM_STRING(&constant_bin[ 97334 ], 258, 0);
    const_str_plain_SESS_CACHE_NO_INTERNAL_STORE = UNSTREAM_STRING(&constant_bin[ 84824 ], 28, 1);
    const_str_plain_SSL_ERROR_WANT_X509_LOOKUP = UNSTREAM_STRING(&constant_bin[ 97592 ], 26, 1);
    const_tuple_str_plain_self_str_plain_buf_str_plain_result_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_buf_str_plain_result_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_buf_str_plain_result_tuple, 1, const_str_plain_buf); Py_INCREF(const_str_plain_buf);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_buf_str_plain_result_tuple, 2, const_str_plain_result); Py_INCREF(const_str_plain_result);
    const_str_digest_fe0750f479b57ce782e84a9b40cf000b = UNSTREAM_STRING(&constant_bin[ 97618 ], 450, 0);
    const_str_plain_SSL_OP_SINGLE_ECDH_USE = UNSTREAM_STRING(&constant_bin[ 98068 ], 22, 1);
    const_str_plain_certificate_authority = UNSTREAM_STRING(&constant_bin[ 92081 ], 21, 1);
    const_str_plain_use_result = UNSTREAM_STRING(&constant_bin[ 98090 ], 10, 1);
    const_str_plain__requires_npn = UNSTREAM_STRING(&constant_bin[ 2483 ], 13, 1);
    const_str_plain_OPENSSL_VERSION_NUMBER = UNSTREAM_STRING(&constant_bin[ 83583 ], 22, 1);
    const_str_plain_SSL_ERROR_WANT_WRITE = UNSTREAM_STRING(&constant_bin[ 98100 ], 20, 1);
    const_str_plain_X509_up_ref = UNSTREAM_STRING(&constant_bin[ 98120 ], 11, 1);
    const_str_digest_bafb2b633667a6bc76266cfd60bf7f9d = UNSTREAM_STRING(&constant_bin[ 98131 ], 84, 0);
    const_str_plain_profiles = UNSTREAM_STRING(&constant_bin[ 98215 ], 8, 1);
    const_str_digest_fd8757ca246c476601094123086e9a80 = UNSTREAM_STRING(&constant_bin[ 98223 ], 1008, 0);
    const_str_plain__methods = UNSTREAM_STRING(&constant_bin[ 2418 ], 8, 1);
    const_list_str_digest_746ae0014bb266cffee8b7b1473626af_list = PyList_New(1);
    const_str_digest_746ae0014bb266cffee8b7b1473626af = UNSTREAM_STRING(&constant_bin[ 99231 ], 14, 0);
    PyList_SET_ITEM(const_list_str_digest_746ae0014bb266cffee8b7b1473626af_list, 0, const_str_digest_746ae0014bb266cffee8b7b1473626af); Py_INCREF(const_str_digest_746ae0014bb266cffee8b7b1473626af);
    const_str_plain_SESS_CACHE_NO_INTERNAL_LOOKUP = UNSTREAM_STRING(&constant_bin[ 84790 ], 29, 1);
    const_str_plain_accept = UNSTREAM_STRING(&constant_bin[ 92809 ], 6, 1);
    const_str_plain__path_string = UNSTREAM_STRING(&constant_bin[ 558 ], 12, 1);
    const_str_plain_SSL_renegotiate = UNSTREAM_STRING(&constant_bin[ 99245 ], 15, 1);
    const_str_plain_SSL_set_fd = UNSTREAM_STRING(&constant_bin[ 99260 ], 10, 1);
    const_list_6fa8c3d8587ec1659fa28b2f58883e42_list = PyList_New(3);
    PyList_SET_ITEM(const_list_6fa8c3d8587ec1659fa28b2f58883e42_list, 0, const_str_plain_TLS_AES_256_GCM_SHA384); Py_INCREF(const_str_plain_TLS_AES_256_GCM_SHA384);
    PyList_SET_ITEM(const_list_6fa8c3d8587ec1659fa28b2f58883e42_list, 1, const_str_plain_TLS_CHACHA20_POLY1305_SHA256); Py_INCREF(const_str_plain_TLS_CHACHA20_POLY1305_SHA256);
    PyList_SET_ITEM(const_list_6fa8c3d8587ec1659fa28b2f58883e42_list, 2, const_str_plain_TLS_AES_128_GCM_SHA256); Py_INCREF(const_str_plain_TLS_AES_128_GCM_SHA256);
    const_tuple_7e6126bff16a8a76a713850dcb042242_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_7e6126bff16a8a76a713850dcb042242_tuple, 0, const_str_plain_ssl); Py_INCREF(const_str_plain_ssl);
    PyTuple_SET_ITEM(const_tuple_7e6126bff16a8a76a713850dcb042242_tuple, 1, const_str_plain_alert); Py_INCREF(const_str_plain_alert);
    PyTuple_SET_ITEM(const_tuple_7e6126bff16a8a76a713850dcb042242_tuple, 2, const_str_plain_arg); Py_INCREF(const_str_plain_arg);
    PyTuple_SET_ITEM(const_tuple_7e6126bff16a8a76a713850dcb042242_tuple, 3, const_str_plain_callback); Py_INCREF(const_str_plain_callback);
    const_str_plain_SSL_OP_CIPHER_SERVER_PREFERENCE = UNSTREAM_STRING(&constant_bin[ 99270 ], 31, 1);
    const_tuple_str_plain_self_str_plain_mode_str_plain_callback_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_mode_str_plain_callback_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_mode_str_plain_callback_tuple, 1, const_str_plain_mode); Py_INCREF(const_str_plain_mode);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_mode_str_plain_callback_tuple, 2, const_str_plain_callback); Py_INCREF(const_str_plain_callback);
    const_str_plain_SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER = UNSTREAM_STRING(&constant_bin[ 99301 ], 33, 1);
    const_list_b44af29ad37821285e6b89a520342cf5_list = PyList_New(5);
    PyList_SET_ITEM(const_list_b44af29ad37821285e6b89a520342cf5_list, 0, const_str_digest_df9e5608be804d3b3249be3c13b24db8); Py_INCREF(const_str_digest_df9e5608be804d3b3249be3c13b24db8);
    const_str_digest_052250489768b32f02c8505795c1c0c7 = UNSTREAM_STRING(&constant_bin[ 99334 ], 32, 0);
    PyList_SET_ITEM(const_list_b44af29ad37821285e6b89a520342cf5_list, 1, const_str_digest_052250489768b32f02c8505795c1c0c7); Py_INCREF(const_str_digest_052250489768b32f02c8505795c1c0c7);
    PyList_SET_ITEM(const_list_b44af29ad37821285e6b89a520342cf5_list, 2, const_str_digest_ee77c76941f8fd58acff5cfda589cc1d); Py_INCREF(const_str_digest_ee77c76941f8fd58acff5cfda589cc1d);
    const_str_digest_053565796c68d049169d0efbeceaaf7d = UNSTREAM_STRING(&constant_bin[ 99366 ], 23, 0);
    PyList_SET_ITEM(const_list_b44af29ad37821285e6b89a520342cf5_list, 3, const_str_digest_053565796c68d049169d0efbeceaaf7d); Py_INCREF(const_str_digest_053565796c68d049169d0efbeceaaf7d);
    const_str_digest_a3b259134db00dfd8458bf615870c7e2 = UNSTREAM_STRING(&constant_bin[ 99389 ], 49, 0);
    PyList_SET_ITEM(const_list_b44af29ad37821285e6b89a520342cf5_list, 4, const_str_digest_a3b259134db00dfd8458bf615870c7e2); Py_INCREF(const_str_digest_a3b259134db00dfd8458bf615870c7e2);
    const_str_digest_d242bea258df0e7212519aa660c5f53d = UNSTREAM_STRING(&constant_bin[ 99438 ], 24, 0);
    const_str_plain_X509_get_default_cert_dir_env = UNSTREAM_STRING(&constant_bin[ 99462 ], 29, 1);
    const_str_digest_aa8d23211c54bc521e23e53a6e431cd2 = UNSTREAM_STRING(&constant_bin[ 99491 ], 30, 0);
    const_str_plain_get_cipher_bits = UNSTREAM_STRING(&constant_bin[ 99521 ], 15, 1);
    const_str_plain_SSL_CTX_set_tlsext_status_arg = UNSTREAM_STRING(&constant_bin[ 99536 ], 29, 1);
    const_tuple_a67b1154f8342873401b8122b6389ba8_tuple = PyTuple_New(6);
    PyTuple_SET_ITEM(const_tuple_a67b1154f8342873401b8122b6389ba8_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_a67b1154f8342873401b8122b6389ba8_tuple, 1, const_str_plain_buffer); Py_INCREF(const_str_plain_buffer);
    PyTuple_SET_ITEM(const_tuple_a67b1154f8342873401b8122b6389ba8_tuple, 2, const_str_plain_nbytes); Py_INCREF(const_str_plain_nbytes);
    PyTuple_SET_ITEM(const_tuple_a67b1154f8342873401b8122b6389ba8_tuple, 3, const_str_plain_flags); Py_INCREF(const_str_plain_flags);
    PyTuple_SET_ITEM(const_tuple_a67b1154f8342873401b8122b6389ba8_tuple, 4, const_str_plain_buf); Py_INCREF(const_str_plain_buf);
    PyTuple_SET_ITEM(const_tuple_a67b1154f8342873401b8122b6389ba8_tuple, 5, const_str_plain_result); Py_INCREF(const_str_plain_result);
    const_str_plain_SSL_get_session = UNSTREAM_STRING(&constant_bin[ 99565 ], 15, 1);
    const_str_plain_SSL_ERROR_SYSCALL = UNSTREAM_STRING(&constant_bin[ 99580 ], 17, 1);
    const_str_plain_SSL_OP_MSIE_SSLV2_RSA_PADDING = UNSTREAM_STRING(&constant_bin[ 99597 ], 29, 1);
    const_tuple_87f1641fb31961ccfc03a99691482662_tuple = PyTuple_New(9);
    PyTuple_SET_ITEM(const_tuple_87f1641fb31961ccfc03a99691482662_tuple, 0, const_str_plain_UNSPECIFIED); Py_INCREF(const_str_plain_UNSPECIFIED);
    PyTuple_SET_ITEM(const_tuple_87f1641fb31961ccfc03a99691482662_tuple, 1, const_str_plain_exception_from_error_queue); Py_INCREF(const_str_plain_exception_from_error_queue);
    PyTuple_SET_ITEM(const_tuple_87f1641fb31961ccfc03a99691482662_tuple, 2, const_str_plain_ffi); Py_INCREF(const_str_plain_ffi);
    PyTuple_SET_ITEM(const_tuple_87f1641fb31961ccfc03a99691482662_tuple, 3, const_str_plain_lib); Py_INCREF(const_str_plain_lib);
    PyTuple_SET_ITEM(const_tuple_87f1641fb31961ccfc03a99691482662_tuple, 4, const_str_plain_make_assert); Py_INCREF(const_str_plain_make_assert);
    PyTuple_SET_ITEM(const_tuple_87f1641fb31961ccfc03a99691482662_tuple, 5, const_str_plain_native); Py_INCREF(const_str_plain_native);
    PyTuple_SET_ITEM(const_tuple_87f1641fb31961ccfc03a99691482662_tuple, 6, const_str_plain_path_string); Py_INCREF(const_str_plain_path_string);
    PyTuple_SET_ITEM(const_tuple_87f1641fb31961ccfc03a99691482662_tuple, 7, const_str_plain_text_to_bytes_and_warn); Py_INCREF(const_str_plain_text_to_bytes_and_warn);
    PyTuple_SET_ITEM(const_tuple_87f1641fb31961ccfc03a99691482662_tuple, 8, const_str_plain_no_zero_allocator); Py_INCREF(const_str_plain_no_zero_allocator);
    const_str_plain_SSL_ERROR_WANT_READ = UNSTREAM_STRING(&constant_bin[ 99626 ], 19, 1);
    const_str_plain_OP_CIPHER_SERVER_PREFERENCE = UNSTREAM_STRING(&constant_bin[ 84335 ], 27, 1);
    const_str_plain_SSL_ST_ACCEPT = UNSTREAM_STRING(&constant_bin[ 84903 ], 13, 1);
    const_str_plain_X509_get_default_cert_dir = UNSTREAM_STRING(&constant_bin[ 99462 ], 25, 1);
    const_str_plain_SSL_CTX_add_extra_chain_cert = UNSTREAM_STRING(&constant_bin[ 99645 ], 28, 1);
    const_str_digest_776556dd9343f57c1cd72ff937153f0f = UNSTREAM_STRING(&constant_bin[ 99673 ], 268, 0);
    const_str_plain_SSL_want_read = UNSTREAM_STRING(&constant_bin[ 99941 ], 13, 1);
    const_tuple_26498c7c65e3c1d61715bb934548919d_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_26498c7c65e3c1d61715bb934548919d_tuple, 0, const_str_plain_binary_type); Py_INCREF(const_str_plain_binary_type);
    PyTuple_SET_ITEM(const_tuple_26498c7c65e3c1d61715bb934548919d_tuple, 1, const_str_plain_integer_types); Py_INCREF(const_str_plain_integer_types);
    PyTuple_SET_ITEM(const_tuple_26498c7c65e3c1d61715bb934548919d_tuple, 2, const_str_plain_int2byte); Py_INCREF(const_str_plain_int2byte);
    PyTuple_SET_ITEM(const_tuple_26498c7c65e3c1d61715bb934548919d_tuple, 3, const_str_plain_indexbytes); Py_INCREF(const_str_plain_indexbytes);
    const_tuple_str_plain_self_str_plain_profiles_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_profiles_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_profiles_tuple, 1, const_str_plain_profiles); Py_INCREF(const_str_plain_profiles);
    const_tuple_str_plain_self_str_plain_pystore_str_plain_store_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_pystore_str_plain_store_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    const_str_plain_pystore = UNSTREAM_STRING(&constant_bin[ 99954 ], 7, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_pystore_str_plain_store_tuple, 1, const_str_plain_pystore); Py_INCREF(const_str_plain_pystore);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_pystore_str_plain_store_tuple, 2, const_str_plain_store); Py_INCREF(const_str_plain_store);
    const_str_digest_d5ded94dafea47ce6f2b4fa579755177 = UNSTREAM_STRING(&constant_bin[ 99961 ], 34, 0);
    const_str_plain_set_alpn_protos = UNSTREAM_STRING(&constant_bin[ 99995 ], 15, 1);
    const_str_plain__CallbackExceptionHelper = UNSTREAM_STRING(&constant_bin[ 96 ], 24, 1);
    const_str_plain_weakref = UNSTREAM_STRING(&constant_bin[ 100010 ], 7, 1);
    const_str_plain_empty = UNSTREAM_STRING(&constant_bin[ 85747 ], 5, 1);
    const_str_plain_sk_X509_NAME_push = UNSTREAM_STRING(&constant_bin[ 100017 ], 17, 1);
    const_str_plain_X509_V_OK = UNSTREAM_STRING(&constant_bin[ 100034 ], 9, 1);
    const_str_digest_aa803484dcfcfaec3d1d830a5ef1f026 = UNSTREAM_STRING(&constant_bin[ 100043 ], 195, 0);
    const_str_plain_SSLEAY_BUILT_ON = UNSTREAM_STRING(&constant_bin[ 83682 ], 15, 1);
    const_str_plain_total_renegotiations = UNSTREAM_STRING(&constant_bin[ 100238 ], 20, 1);
    const_str_plain_TLSv1_1_method = UNSTREAM_STRING(&constant_bin[ 100258 ], 14, 1);
    const_str_plain_error_depth = UNSTREAM_STRING(&constant_bin[ 100272 ], 11, 1);
    const_str_digest_47543c17fa95d5ac5c9bf71145417a30 = UNSTREAM_STRING(&constant_bin[ 100283 ], 17, 0);
    const_str_digest_ebaec5436a48442094f25464a6eec24c = UNSTREAM_STRING(&constant_bin[ 100300 ], 277, 0);
    const_str_digest_b8ccf81a020f16490de1c8527ea9e4d6 = UNSTREAM_STRING(&constant_bin[ 100577 ], 302, 0);
    const_str_digest_d89a36d0b4664ac4178af2071f30652f = UNSTREAM_STRING(&constant_bin[ 100879 ], 26, 0);
    const_str_plain_SSL_CB_CONNECT_EXIT = UNSTREAM_STRING(&constant_bin[ 85134 ], 19, 1);
    const_str_digest_cf5a529c83a60eab9bc87caa3430bc5c = UNSTREAM_STRING(&constant_bin[ 100905 ], 405, 0);
    const_str_digest_3462bf983701fbd7caf2f521f5975fff = UNSTREAM_STRING(&constant_bin[ 101310 ], 25, 0);
    const_str_digest_7cf2d06a8643ddce5d0ceedd61c750e1 = UNSTREAM_STRING(&constant_bin[ 101335 ], 27, 0);
    const_str_plain_SSL_OP_TLS_BLOCK_PADDING_BUG = UNSTREAM_STRING(&constant_bin[ 101362 ], 28, 1);
    const_str_plain_get_finished = UNSTREAM_STRING(&constant_bin[ 101390 ], 12, 1);
    const_str_digest_794f687944b90121fa261238090835e1 = UNSTREAM_STRING(&constant_bin[ 101402 ], 338, 0);
    const_tuple_6740a501bdf22f33fca4ec6a09ab8a62_tuple = PyTuple_New(15);
    PyTuple_SET_ITEM(const_tuple_6740a501bdf22f33fca4ec6a09ab8a62_tuple, 0, const_str_plain_ssl); Py_INCREF(const_str_plain_ssl);
    PyTuple_SET_ITEM(const_tuple_6740a501bdf22f33fca4ec6a09ab8a62_tuple, 1, const_str_plain_out); Py_INCREF(const_str_plain_out);
    PyTuple_SET_ITEM(const_tuple_6740a501bdf22f33fca4ec6a09ab8a62_tuple, 2, const_str_plain_outlen); Py_INCREF(const_str_plain_outlen);
    PyTuple_SET_ITEM(const_tuple_6740a501bdf22f33fca4ec6a09ab8a62_tuple, 3, const_str_plain_in_); Py_INCREF(const_str_plain_in_);
    PyTuple_SET_ITEM(const_tuple_6740a501bdf22f33fca4ec6a09ab8a62_tuple, 4, const_str_plain_inlen); Py_INCREF(const_str_plain_inlen);
    PyTuple_SET_ITEM(const_tuple_6740a501bdf22f33fca4ec6a09ab8a62_tuple, 5, const_str_plain_arg); Py_INCREF(const_str_plain_arg);
    PyTuple_SET_ITEM(const_tuple_6740a501bdf22f33fca4ec6a09ab8a62_tuple, 6, const_str_plain_outstr); Py_INCREF(const_str_plain_outstr);
    PyTuple_SET_ITEM(const_tuple_6740a501bdf22f33fca4ec6a09ab8a62_tuple, 7, const_str_plain_protolist); Py_INCREF(const_str_plain_protolist);
    PyTuple_SET_ITEM(const_tuple_6740a501bdf22f33fca4ec6a09ab8a62_tuple, 8, const_str_plain_e); Py_INCREF(const_str_plain_e);
    PyTuple_SET_ITEM(const_tuple_6740a501bdf22f33fca4ec6a09ab8a62_tuple, 9, const_str_plain_instr); Py_INCREF(const_str_plain_instr);
    PyTuple_SET_ITEM(const_tuple_6740a501bdf22f33fca4ec6a09ab8a62_tuple, 10, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_6740a501bdf22f33fca4ec6a09ab8a62_tuple, 11, const_str_plain_proto); Py_INCREF(const_str_plain_proto);
    PyTuple_SET_ITEM(const_tuple_6740a501bdf22f33fca4ec6a09ab8a62_tuple, 12, const_str_plain_length); Py_INCREF(const_str_plain_length);
    PyTuple_SET_ITEM(const_tuple_6740a501bdf22f33fca4ec6a09ab8a62_tuple, 13, const_str_plain_callback); Py_INCREF(const_str_plain_callback);
    PyTuple_SET_ITEM(const_tuple_6740a501bdf22f33fca4ec6a09ab8a62_tuple, 14, const_str_plain_conn); Py_INCREF(const_str_plain_conn);
    const_str_digest_fded22d63d84a836b130c747fc61664e = UNSTREAM_STRING(&constant_bin[ 101740 ], 80, 0);
    const_str_plain_get_cipher_name = UNSTREAM_STRING(&constant_bin[ 101820 ], 15, 1);
    const_str_plain_OP_MICROSOFT_BIG_SSLV3_BUFFER = UNSTREAM_STRING(&constant_bin[ 84157 ], 29, 1);
    const_str_digest_ebc06328e68f0dbdd2e23e3f1f581b13 = UNSTREAM_STRING(&constant_bin[ 101835 ], 1008, 0);
    const_str_plain__fallback_default_verify_paths = UNSTREAM_STRING(&constant_bin[ 102843 ], 30, 1);
    const_str_plain_OP_ALL = UNSTREAM_STRING(&constant_bin[ 84580 ], 6, 1);
    const_str_plain_SSL_total_renegotiations = UNSTREAM_STRING(&constant_bin[ 102873 ], 24, 1);
    const_str_plain_SSL_OP_NETSCAPE_CHALLENGE_BUG = UNSTREAM_STRING(&constant_bin[ 102897 ], 29, 1);
    const_str_plain_SSL_CTX_load_verify_locations = UNSTREAM_STRING(&constant_bin[ 102926 ], 29, 1);
    const_str_plain__requires_sni = UNSTREAM_STRING(&constant_bin[ 2448 ], 13, 1);
    const_tuple_str_plain_type_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_plain_type_tuple, 0, const_str_plain_type); Py_INCREF(const_str_plain_type);
    const_str_plain_SSL_set_SSL_CTX = UNSTREAM_STRING(&constant_bin[ 102955 ], 15, 1);
    const_str_plain_OP_NO_TLSv1 = UNSTREAM_STRING(&constant_bin[ 83881 ], 11, 1);
    const_str_plain_SSL_ERROR_ZERO_RETURN = UNSTREAM_STRING(&constant_bin[ 102970 ], 21, 1);
    const_str_plain_SSLv23_method = UNSTREAM_STRING(&constant_bin[ 102991 ], 13, 1);
    const_str_digest_616719c4a0cde3344203a07484a7fb54 = UNSTREAM_STRING(&constant_bin[ 103004 ], 18, 0);
    const_tuple_str_plain_WeakValueDictionary_tuple = PyTuple_New(1);
    const_str_plain_WeakValueDictionary = UNSTREAM_STRING(&constant_bin[ 2626 ], 19, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain_WeakValueDictionary_tuple, 0, const_str_plain_WeakValueDictionary); Py_INCREF(const_str_plain_WeakValueDictionary);
    const_str_digest_1f723e76cd26cf3162ae94f693472dd5 = UNSTREAM_STRING(&constant_bin[ 103022 ], 157, 0);
    const_str_plain_SSL_CTX_get_cert_store = UNSTREAM_STRING(&constant_bin[ 103179 ], 22, 1);
    const_str_plain_new_handle = UNSTREAM_STRING(&constant_bin[ 103201 ], 10, 1);
    const_str_plain_SSLv2_method = UNSTREAM_STRING(&constant_bin[ 103211 ], 12, 1);
    const_str_plain_OP_SINGLE_DH_USE = UNSTREAM_STRING(&constant_bin[ 83958 ], 16, 1);
    const_str_digest_94c36790285a25f5d9268c8333413cf2 = UNSTREAM_STRING(&constant_bin[ 103223 ], 17, 0);
    const_str_plain_SSL_CB_ALERT = UNSTREAM_STRING(&constant_bin[ 85002 ], 12, 1);
    const_str_plain_use_certificate_file = UNSTREAM_STRING(&constant_bin[ 95864 ], 20, 1);
    const_str_plain_SSL_OP_SINGLE_DH_USE = UNSTREAM_STRING(&constant_bin[ 103240 ], 20, 1);
    const_str_plain_SSL_write = UNSTREAM_STRING(&constant_bin[ 103260 ], 9, 1);
    const_str_plain_SSL_VERIFY_FAIL_IF_NO_PEER_CERT = UNSTREAM_STRING(&constant_bin[ 103269 ], 31, 1);
    const_str_plain_get_alpn_proto_negotiated = UNSTREAM_STRING(&constant_bin[ 103300 ], 25, 1);
    const_str_plain_ca_name = UNSTREAM_STRING(&constant_bin[ 85864 ], 7, 1);
    const_tuple_str_plain_self_str_plain_callback_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_callback_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_callback_tuple, 1, const_str_plain_callback); Py_INCREF(const_str_plain_callback);
    const_str_plain_SSL_CTX_set_tlsext_use_srtp = UNSTREAM_STRING(&constant_bin[ 103325 ], 27, 1);
    const_str_plain_set_session = UNSTREAM_STRING(&constant_bin[ 103352 ], 11, 1);
    const_tuple_70adcf8f254ece362639433ee96fdafb_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_70adcf8f254ece362639433ee96fdafb_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_70adcf8f254ece362639433ee96fdafb_tuple, 1, const_str_plain_certfile); Py_INCREF(const_str_plain_certfile);
    PyTuple_SET_ITEM(const_tuple_70adcf8f254ece362639433ee96fdafb_tuple, 2, const_str_plain_filetype); Py_INCREF(const_str_plain_filetype);
    PyTuple_SET_ITEM(const_tuple_70adcf8f254ece362639433ee96fdafb_tuple, 3, const_str_plain_use_result); Py_INCREF(const_str_plain_use_result);
    const_str_plain_SESS_CACHE_SERVER = UNSTREAM_STRING(&constant_bin[ 84719 ], 17, 1);
    const_tuple_str_plain_self_str_plain_data_len_str_plain_data_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_data_len_str_plain_data_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_data_len_str_plain_data_tuple, 1, const_str_plain_data_len); Py_INCREF(const_str_plain_data_len);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_data_len_str_plain_data_tuple, 2, const_str_plain_data); Py_INCREF(const_str_plain_data);
    const_str_plain__no_zero_allocator = UNSTREAM_STRING(&constant_bin[ 1851 ], 18, 1);
    const_str_plain_OP_DONT_INSERT_EMPTY_FRAGMENTS = UNSTREAM_STRING(&constant_bin[ 84300 ], 30, 1);
    const_str_plain_SSL_CIPHER_get_name = UNSTREAM_STRING(&constant_bin[ 103363 ], 19, 1);
    const_str_digest_6e6e0d8d93df9702d9c8795dc2391090 = UNSTREAM_STRING(&constant_bin[ 103382 ], 205, 0);
    const_tuple_fdf14ad5fcee8ba941991b04122d5521_tuple = PyTuple_New(5);
    PyTuple_SET_ITEM(const_tuple_fdf14ad5fcee8ba941991b04122d5521_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_fdf14ad5fcee8ba941991b04122d5521_tuple, 1, const_str_plain_function); Py_INCREF(const_str_plain_function);
    PyTuple_SET_ITEM(const_tuple_fdf14ad5fcee8ba941991b04122d5521_tuple, 2, const_str_plain_buf); Py_INCREF(const_str_plain_buf);
    PyTuple_SET_ITEM(const_tuple_fdf14ad5fcee8ba941991b04122d5521_tuple, 3, const_str_plain_empty); Py_INCREF(const_str_plain_empty);
    PyTuple_SET_ITEM(const_tuple_fdf14ad5fcee8ba941991b04122d5521_tuple, 4, const_str_plain_size); Py_INCREF(const_str_plain_size);
    const_str_plain__alpn_select_helper = UNSTREAM_STRING(&constant_bin[ 103587 ], 19, 1);
    const_str_plain_SSL_set_connect_state = UNSTREAM_STRING(&constant_bin[ 103606 ], 21, 1);
    const_str_digest_b965e7ab82e8e0c92ec2736091bc1c12 = UNSTREAM_STRING(&constant_bin[ 103627 ], 30, 0);
    const_str_digest_6f72f23667e4f49591ed4cf6d6205ca5 = UNSTREAM_STRING(&constant_bin[ 103657 ], 613, 0);
    const_str_plain__CERTIFICATE_PATH_LOCATIONS = UNSTREAM_STRING(&constant_bin[ 863 ], 27, 1);
    const_str_plain__app_data = UNSTREAM_STRING(&constant_bin[ 89969 ], 9, 1);
    const_tuple_c21a4bcc0d9dac830f44bc0c201bf7fd_tuple = PyTuple_New(6);
    PyTuple_SET_ITEM(const_tuple_c21a4bcc0d9dac830f44bc0c201bf7fd_tuple, 0, const_str_plain_FILETYPE_PEM); Py_INCREF(const_str_plain_FILETYPE_PEM);
    PyTuple_SET_ITEM(const_tuple_c21a4bcc0d9dac830f44bc0c201bf7fd_tuple, 1, const_str_plain__PassphraseHelper); Py_INCREF(const_str_plain__PassphraseHelper);
    PyTuple_SET_ITEM(const_tuple_c21a4bcc0d9dac830f44bc0c201bf7fd_tuple, 2, const_str_plain_PKey); Py_INCREF(const_str_plain_PKey);
    PyTuple_SET_ITEM(const_tuple_c21a4bcc0d9dac830f44bc0c201bf7fd_tuple, 3, const_str_plain_X509Name); Py_INCREF(const_str_plain_X509Name);
    PyTuple_SET_ITEM(const_tuple_c21a4bcc0d9dac830f44bc0c201bf7fd_tuple, 4, const_str_plain_X509); Py_INCREF(const_str_plain_X509);
    PyTuple_SET_ITEM(const_tuple_c21a4bcc0d9dac830f44bc0c201bf7fd_tuple, 5, const_str_plain_X509Store); Py_INCREF(const_str_plain_X509Store);
    const_str_plain_MSG_PEEK = UNSTREAM_STRING(&constant_bin[ 100463 ], 8, 1);
    const_str_plain_get_cipher_version = UNSTREAM_STRING(&constant_bin[ 104270 ], 18, 1);
    const_str_plain_SSL_ERROR_NONE = UNSTREAM_STRING(&constant_bin[ 104288 ], 14, 1);
    const_tuple_str_plain_self_str_plain_rc_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_rc_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_rc_tuple, 1, const_str_plain_rc); Py_INCREF(const_str_plain_rc);
    const_str_plain__npn_select_callback_args = UNSTREAM_STRING(&constant_bin[ 104302 ], 25, 1);
    const_tuple_3ac1ec4ea6ba07372fe57d858ff0148f_tuple = PyTuple_New(5);
    PyTuple_SET_ITEM(const_tuple_3ac1ec4ea6ba07372fe57d858ff0148f_tuple, 0, const_str_plain_size); Py_INCREF(const_str_plain_size);
    PyTuple_SET_ITEM(const_tuple_3ac1ec4ea6ba07372fe57d858ff0148f_tuple, 1, const_str_plain_verify); Py_INCREF(const_str_plain_verify);
    PyTuple_SET_ITEM(const_tuple_3ac1ec4ea6ba07372fe57d858ff0148f_tuple, 2, const_str_plain_userdata); Py_INCREF(const_str_plain_userdata);
    PyTuple_SET_ITEM(const_tuple_3ac1ec4ea6ba07372fe57d858ff0148f_tuple, 3, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_3ac1ec4ea6ba07372fe57d858ff0148f_tuple, 4, const_str_plain_callback); Py_INCREF(const_str_plain_callback);
    const_str_digest_e04d236da419e1b15c5c13532be67a91 = UNSTREAM_STRING(&constant_bin[ 104327 ], 496, 0);
    const_str_digest_85e95361903fe71cece52bb01216866e = UNSTREAM_STRING(&constant_bin[ 104823 ], 597, 0);
    const_str_plain_SSL_SESS_CACHE_BOTH = UNSTREAM_STRING(&constant_bin[ 105420 ], 19, 1);
    const_str_plain_sk_X509_NAME_free = UNSTREAM_STRING(&constant_bin[ 105439 ], 17, 1);
    const_str_plain_get_protocol_version_name = UNSTREAM_STRING(&constant_bin[ 105456 ], 25, 1);
    const_str_plain_identifier = UNSTREAM_STRING(&constant_bin[ 24295 ], 10, 1);
    const_str_plain_SSL_CB_HANDSHAKE_START = UNSTREAM_STRING(&constant_bin[ 85158 ], 22, 1);
    const_str_plain_SSLEAY_PLATFORM = UNSTREAM_STRING(&constant_bin[ 83647 ], 15, 1);
    const_str_plain__get_finished_message = UNSTREAM_STRING(&constant_bin[ 105481 ], 21, 1);
    const_str_plain_SSL_version = UNSTREAM_STRING(&constant_bin[ 105502 ], 11, 1);
    const_str_plain_SSL_set_mode = UNSTREAM_STRING(&constant_bin[ 105513 ], 12, 1);
    const_str_plain_SSL_CB_WRITE = UNSTREAM_STRING(&constant_bin[ 84985 ], 12, 1);
    const_str_plain_SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG = UNSTREAM_STRING(&constant_bin[ 105525 ], 38, 1);
    const_str_plain__check_env_vars_set = UNSTREAM_STRING(&constant_bin[ 105563 ], 19, 1);
    const_str_plain_SSL_CTX_get_verify_depth = UNSTREAM_STRING(&constant_bin[ 105582 ], 24, 1);
    const_str_plain_SSL_OP_EPHEMERAL_RSA = UNSTREAM_STRING(&constant_bin[ 105606 ], 20, 1);
    const_str_plain_SSL_SESS_CACHE_CLIENT = UNSTREAM_STRING(&constant_bin[ 105626 ], 21, 1);
    const_str_digest_1c06dc4166e08805f38a8dca82ce4339 = UNSTREAM_STRING(&constant_bin[ 105647 ], 147, 0);
    const_tuple_str_plain_wraps_str_plain_partial_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_wraps_str_plain_partial_tuple, 0, const_str_plain_wraps); Py_INCREF(const_str_plain_wraps);
    PyTuple_SET_ITEM(const_tuple_str_plain_wraps_str_plain_partial_tuple, 1, const_str_plain_partial); Py_INCREF(const_str_plain_partial);
    const_str_digest_ceaeeee7f342339744c9535ada3c62e3 = UNSTREAM_STRING(&constant_bin[ 105794 ], 223, 0);
    const_str_plain_SSL_set_tlsext_status_type = UNSTREAM_STRING(&constant_bin[ 106017 ], 26, 1);
    const_str_plain__verify_helper = UNSTREAM_STRING(&constant_bin[ 106043 ], 14, 1);
    const_str_digest_38eb25c1dd31f1c93831bc586a51d94a = UNSTREAM_STRING(&constant_bin[ 106057 ], 386, 0);
    const_str_plain__socket = UNSTREAM_STRING(&constant_bin[ 76401 ], 7, 1);
    const_str_digest_afa60644cf27716474a6bbd780185867 = UNSTREAM_STRING(&constant_bin[ 106443 ], 49, 0);
    const_str_plain_pysession = UNSTREAM_STRING(&constant_bin[ 106492 ], 9, 1);
    const_str_digest_7cc8f764b42656b144d56bfbd9df2b48 = UNSTREAM_STRING(&constant_bin[ 106501 ], 909, 0);
    const_str_plain__make_requires = UNSTREAM_STRING(&constant_bin[ 2173 ], 14, 1);
    const_str_digest_39dd8800b3995a2e161e8739b1bebc01 = UNSTREAM_STRING(&constant_bin[ 107410 ], 337, 0);
    const_str_plain__npn_select_helper = UNSTREAM_STRING(&constant_bin[ 107747 ], 18, 1);
    const_str_plain_BIO_should_read = UNSTREAM_STRING(&constant_bin[ 107765 ], 15, 1);
    const_str_plain_cipher_list = UNSTREAM_STRING(&constant_bin[ 87900 ], 11, 1);
    const_str_plain_set_verify_depth = UNSTREAM_STRING(&constant_bin[ 107780 ], 16, 1);
    const_str_digest_bae02e8783abd2cb1ef184c4ddb0f45d = UNSTREAM_STRING(&constant_bin[ 107796 ], 143, 0);
    const_str_digest_0f682ae315fc37e97d14dcc920e8b91d = UNSTREAM_STRING(&constant_bin[ 107939 ], 112, 0);
    const_str_digest_b65860d01f08f87c7391d19b5cfd9850 = UNSTREAM_STRING(&constant_bin[ 108051 ], 398, 0);
    const_str_digest_39e6e3efbf37d872dab9cfbddc398ebf = UNSTREAM_STRING(&constant_bin[ 108449 ], 318, 0);
    const_str_plain_use_certificate = UNSTREAM_STRING(&constant_bin[ 91785 ], 15, 1);
    const_str_plain_SSL_CTX_get_session_cache_mode = UNSTREAM_STRING(&constant_bin[ 108767 ], 30, 1);
    const_str_plain_dir_path = UNSTREAM_STRING(&constant_bin[ 108797 ], 8, 1);
    const_str_digest_f5111f918158679228186076f422f85e = UNSTREAM_STRING(&constant_bin[ 108805 ], 46, 0);
    const_str_plain_SSL_CTX_new = UNSTREAM_STRING(&constant_bin[ 108851 ], 11, 1);
    const_str_plain__raise_ssl_error = UNSTREAM_STRING(&constant_bin[ 108862 ], 16, 1);
    const_str_plain_SSL_get_peer_finished = UNSTREAM_STRING(&constant_bin[ 106227 ], 21, 1);
    const_str_plain_SSL_MODE_AUTO_RETRY = UNSTREAM_STRING(&constant_bin[ 108878 ], 19, 1);
    const_str_digest_f64bec1377ff9f22e4ed4c823f6a5647 = UNSTREAM_STRING(&constant_bin[ 108897 ], 47, 0);
    const_str_plain_SSL_get_peer_certificate = UNSTREAM_STRING(&constant_bin[ 108944 ], 24, 1);
    const_str_plain_SSL_OP_MICROSOFT_SESS_ID_BUG = UNSTREAM_STRING(&constant_bin[ 108968 ], 28, 1);
    const_str_plain_load_client_ca = UNSTREAM_STRING(&constant_bin[ 108996 ], 14, 1);
    const_str_plain_SSL_get_server_random = UNSTREAM_STRING(&constant_bin[ 109010 ], 21, 1);
    const_str_plain_dhfile = UNSTREAM_STRING(&constant_bin[ 86645 ], 6, 1);
    const_str_plain_SSL_CB_ACCEPT_LOOP = UNSTREAM_STRING(&constant_bin[ 85064 ], 18, 1);
    const_str_digest_ca7f1c3e5d90e78a07e9f85863c06c8e = UNSTREAM_STRING(&constant_bin[ 109031 ], 33, 0);
    const_tuple_b5f59418c193d572a22cf854b821fa76_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_b5f59418c193d572a22cf854b821fa76_tuple, 0, const_str_digest_b9c4baf879ebd882d40843df3a4dead7); Py_INCREF(const_str_digest_b9c4baf879ebd882d40843df3a4dead7);
    PyTuple_SET_ITEM(const_tuple_b5f59418c193d572a22cf854b821fa76_tuple, 1, const_str_plain_identifier); Py_INCREF(const_str_plain_identifier);
    PyTuple_SET_ITEM(const_tuple_b5f59418c193d572a22cf854b821fa76_tuple, 2, const_str_plain_name); Py_INCREF(const_str_plain_name);
    const_str_plain_ContextType = UNSTREAM_STRING(&constant_bin[ 93741 ], 11, 1);
    const_str_digest_1c1aa9b3fa80807ae10c68cfa1a0b8e6 = UNSTREAM_STRING(&constant_bin[ 109064 ], 273, 0);
    const_str_plain_SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG = UNSTREAM_STRING(&constant_bin[ 109337 ], 39, 1);
    const_str_plain_client_random = UNSTREAM_STRING(&constant_bin[ 109376 ], 13, 1);
    const_str_plain_renegotiate_pending = UNSTREAM_STRING(&constant_bin[ 109389 ], 19, 1);
    const_str_plain_SSL_SENT_SHUTDOWN = UNSTREAM_STRING(&constant_bin[ 109408 ], 17, 1);
    const_str_plain__tlsext_servername_callback = UNSTREAM_STRING(&constant_bin[ 109425 ], 27, 1);
    const_str_plain_BIO_should_write = UNSTREAM_STRING(&constant_bin[ 109452 ], 16, 1);
    const_str_digest_a971aca8bab65513da2005120ca529f5 = UNSTREAM_STRING(&constant_bin[ 109468 ], 360, 0);
    const_str_digest_9c76bfc2ff06864d351211fc5c45c351 = UNSTREAM_STRING(&constant_bin[ 109828 ], 418, 0);
    const_str_plain_SSL_SESS_CACHE_NO_INTERNAL_STORE = UNSTREAM_STRING(&constant_bin[ 110246 ], 32, 1);
    const_str_plain_SSL_state_string_long = UNSTREAM_STRING(&constant_bin[ 110278 ], 21, 1);
    const_tuple_20d4fe6eb6129b69f70ca0570507a3f9_tuple = PyTuple_New(6);
    PyTuple_SET_ITEM(const_tuple_20d4fe6eb6129b69f70ca0570507a3f9_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    const_str_plain_default_dir = UNSTREAM_STRING(&constant_bin[ 110299 ], 11, 1);
    PyTuple_SET_ITEM(const_tuple_20d4fe6eb6129b69f70ca0570507a3f9_tuple, 1, const_str_plain_default_dir); Py_INCREF(const_str_plain_default_dir);
    PyTuple_SET_ITEM(const_tuple_20d4fe6eb6129b69f70ca0570507a3f9_tuple, 2, const_str_plain_set_result); Py_INCREF(const_str_plain_set_result);
    const_str_plain_dir_env_var = UNSTREAM_STRING(&constant_bin[ 110310 ], 11, 1);
    PyTuple_SET_ITEM(const_tuple_20d4fe6eb6129b69f70ca0570507a3f9_tuple, 3, const_str_plain_dir_env_var); Py_INCREF(const_str_plain_dir_env_var);
    const_str_plain_file_env_var = UNSTREAM_STRING(&constant_bin[ 110321 ], 12, 1);
    PyTuple_SET_ITEM(const_tuple_20d4fe6eb6129b69f70ca0570507a3f9_tuple, 4, const_str_plain_file_env_var); Py_INCREF(const_str_plain_file_env_var);
    const_str_plain_default_file = UNSTREAM_STRING(&constant_bin[ 110333 ], 12, 1);
    PyTuple_SET_ITEM(const_tuple_20d4fe6eb6129b69f70ca0570507a3f9_tuple, 5, const_str_plain_default_file); Py_INCREF(const_str_plain_default_file);
    const_str_plain_SSL_get_client_CA_list = UNSTREAM_STRING(&constant_bin[ 110345 ], 22, 1);
    const_str_plain_tmpconn = UNSTREAM_STRING(&constant_bin[ 110367 ], 7, 1);
    const_str_plain_SSL_CTX_use_PrivateKey_file = UNSTREAM_STRING(&constant_bin[ 110374 ], 27, 1);
    const_str_plain_SSL_VERIFY_NONE = UNSTREAM_STRING(&constant_bin[ 110401 ], 15, 1);
    const_str_plain_SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG = UNSTREAM_STRING(&constant_bin[ 110416 ], 34, 1);
    const_str_plain_SSLEAY_CFLAGS = UNSTREAM_STRING(&constant_bin[ 83629 ], 13, 1);
    const_str_plain_SSL_SESS_CACHE_NO_INTERNAL = UNSTREAM_STRING(&constant_bin[ 110246 ], 26, 1);
    const_str_digest_c9c6fa40ef38c8d28b115afb17db4e50 = UNSTREAM_STRING(&constant_bin[ 110450 ], 343, 0);
    const_str_plain_SSL_CTX_set_tlsext_servername_callback = UNSTREAM_STRING(&constant_bin[ 110793 ], 38, 1);
    const_str_plain_SSL_CTX_set_options = UNSTREAM_STRING(&constant_bin[ 110831 ], 19, 1);
    const_str_plain_OP_NO_TLSv1_2 = UNSTREAM_STRING(&constant_bin[ 83915 ], 13, 1);
    const_str_plain__handle_bio_errors = UNSTREAM_STRING(&constant_bin[ 110850 ], 18, 1);
    const_str_digest_1fbb26888e8a93a4fffae5202f2e81a6 = UNSTREAM_STRING(&constant_bin[ 110868 ], 28, 0);
    const_str_plain_SSL_CTX_set_tmp_dh = UNSTREAM_STRING(&constant_bin[ 110896 ], 18, 1);
    const_str_digest_0438f8885bf87c226201350e81ca4f79 = UNSTREAM_STRING(&constant_bin[ 110914 ], 129, 0);
    const_str_digest_1bd7405e218c8a579c48801956097e27 = UNSTREAM_STRING(&constant_bin[ 111043 ], 94, 0);
    const_str_plain_SSL_read = UNSTREAM_STRING(&constant_bin[ 111137 ], 8, 1);
    const_str_plain_SSL_free = UNSTREAM_STRING(&constant_bin[ 111145 ], 8, 1);
    const_tuple_str_plain_self_str_plain_certfile_str_plain_result_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_certfile_str_plain_result_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_certfile_str_plain_result_tuple, 1, const_str_plain_certfile); Py_INCREF(const_str_plain_certfile);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_certfile_str_plain_result_tuple, 2, const_str_plain_result); Py_INCREF(const_str_plain_result);
    const_str_digest_723fb164f3e133051d00542dd747fe2d = UNSTREAM_STRING(&constant_bin[ 111153 ], 140, 0);
    const_str_plain_SSL_get0_next_proto_negotiated = UNSTREAM_STRING(&constant_bin[ 111293 ], 30, 1);
    const_str_plain_set_app_data = UNSTREAM_STRING(&constant_bin[ 111323 ], 12, 1);
    const_str_plain__npn_advertise_callback = UNSTREAM_STRING(&constant_bin[ 111335 ], 23, 1);
    const_tuple_e3219c972e1d9320fe91a603e3df8d39_tuple = PyTuple_New(5);
    PyTuple_SET_ITEM(const_tuple_e3219c972e1d9320fe91a603e3df8d39_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    const_str_plain_file_path = UNSTREAM_STRING(&constant_bin[ 111358 ], 9, 1);
    PyTuple_SET_ITEM(const_tuple_e3219c972e1d9320fe91a603e3df8d39_tuple, 1, const_str_plain_file_path); Py_INCREF(const_str_plain_file_path);
    PyTuple_SET_ITEM(const_tuple_e3219c972e1d9320fe91a603e3df8d39_tuple, 2, const_str_plain_dir_path); Py_INCREF(const_str_plain_dir_path);
    PyTuple_SET_ITEM(const_tuple_e3219c972e1d9320fe91a603e3df8d39_tuple, 3, const_str_plain_capath); Py_INCREF(const_str_plain_capath);
    PyTuple_SET_ITEM(const_tuple_e3219c972e1d9320fe91a603e3df8d39_tuple, 4, const_str_plain_cafile); Py_INCREF(const_str_plain_cafile);
    const_str_plain_SSL_SESS_CACHE_SERVER = UNSTREAM_STRING(&constant_bin[ 111367 ], 21, 1);
    const_str_plain_SSL_OP_NETSCAPE_CA_DN_BUG = UNSTREAM_STRING(&constant_bin[ 111388 ], 25, 1);
    const_tuple_cf035770f08c8746b05138973d8b64b8_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_cf035770f08c8746b05138973d8b64b8_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_cf035770f08c8746b05138973d8b64b8_tuple, 1, const_str_plain_protos); Py_INCREF(const_str_plain_protos);
    PyTuple_SET_ITEM(const_tuple_cf035770f08c8746b05138973d8b64b8_tuple, 2, const_str_plain_protostr); Py_INCREF(const_str_plain_protostr);
    const_str_plain_input_str = UNSTREAM_STRING(&constant_bin[ 111413 ], 9, 1);
    PyTuple_SET_ITEM(const_tuple_cf035770f08c8746b05138973d8b64b8_tuple, 3, const_str_plain_input_str); Py_INCREF(const_str_plain_input_str);
    const_tuple_str_plain_self_str_plain_addr_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_addr_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_addr_tuple, 1, const_str_plain_addr); Py_INCREF(const_str_plain_addr);
    const_str_plain_SSL_want_write = UNSTREAM_STRING(&constant_bin[ 111422 ], 14, 1);
    const_str_digest_2eac950a8b26412274fa98ea596054c5 = UNSTREAM_STRING(&constant_bin[ 111436 ], 425, 0);
    const_str_plain__binary_type = UNSTREAM_STRING(&constant_bin[ 431 ], 12, 1);
    const_str_digest_d71143a9aaaa613b59e0c4c3015a7c4a = UNSTREAM_STRING(&constant_bin[ 111861 ], 104, 0);
    const_dict_4a96d2f6310f0842d222254905a83466 = _PyDict_NewPresized( 2 );
    PyDict_SetItem(const_dict_4a96d2f6310f0842d222254905a83466, const_str_plain_more_args, Py_True);
    PyDict_SetItem(const_dict_4a96d2f6310f0842d222254905a83466, const_str_plain_truncate, Py_True);
    assert(PyDict_Size(const_dict_4a96d2f6310f0842d222254905a83466) == 2);
    const_str_plain_SSL_CTX_use_certificate_chain_file = UNSTREAM_STRING(&constant_bin[ 111965 ], 34, 1);
    const_str_digest_c5585513b25f5127855be671a08a1332 = UNSTREAM_STRING(&constant_bin[ 111999 ], 217, 0);
    const_str_plain_SSLv2_METHOD = UNSTREAM_STRING(&constant_bin[ 2209 ], 12, 1);
    const_str_digest_5ecd8d00ee49c82aecc9b4312a6eab51 = UNSTREAM_STRING(&constant_bin[ 112216 ], 213, 0);
    const_tuple_72afa5cdf95db9f073bb963f13be50a9_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_72afa5cdf95db9f073bb963f13be50a9_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_72afa5cdf95db9f073bb963f13be50a9_tuple, 1, const_str_plain_client); Py_INCREF(const_str_plain_client);
    PyTuple_SET_ITEM(const_tuple_72afa5cdf95db9f073bb963f13be50a9_tuple, 2, const_str_plain_addr); Py_INCREF(const_str_plain_addr);
    PyTuple_SET_ITEM(const_tuple_72afa5cdf95db9f073bb963f13be50a9_tuple, 3, const_str_plain_conn); Py_INCREF(const_str_plain_conn);
    const_str_plain_load_tmp_dh = UNSTREAM_STRING(&constant_bin[ 112429 ], 11, 1);
    const_str_plain__alpn_select_callback_args = UNSTREAM_STRING(&constant_bin[ 112440 ], 26, 1);
    const_tuple_str_plain_self_str_plain_context_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_context_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_context_tuple, 1, const_str_plain_context); Py_INCREF(const_str_plain_context);
    const_str_digest_7f19e81c824604e95ebb1f01b7f5d7a1 = UNSTREAM_STRING(&constant_bin[ 112466 ], 729, 0);
    const_str_plain_SSL_shutdown = UNSTREAM_STRING(&constant_bin[ 113195 ], 12, 1);
    const_tuple_70b3e830bf27ee786cecd70f5eebc82a_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_70b3e830bf27ee786cecd70f5eebc82a_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_70b3e830bf27ee786cecd70f5eebc82a_tuple, 1, const_str_plain_keyfile); Py_INCREF(const_str_plain_keyfile);
    PyTuple_SET_ITEM(const_tuple_70b3e830bf27ee786cecd70f5eebc82a_tuple, 2, const_str_plain_filetype); Py_INCREF(const_str_plain_filetype);
    PyTuple_SET_ITEM(const_tuple_70b3e830bf27ee786cecd70f5eebc82a_tuple, 3, const_str_plain_use_result); Py_INCREF(const_str_plain_use_result);
    const_str_plain_SSL_get_peer_cert_chain = UNSTREAM_STRING(&constant_bin[ 113207 ], 23, 1);
    const_str_plain__session = UNSTREAM_STRING(&constant_bin[ 87919 ], 8, 1);
    const_str_plain_set_session_cache_mode = UNSTREAM_STRING(&constant_bin[ 113230 ], 22, 1);
    const_str_digest_ce6e46c47189c65d4c33b9ca8d5ba2ad = UNSTREAM_STRING(&constant_bin[ 113252 ], 129, 0);
    const_str_plain__OCSPServerCallbackHelper = UNSTREAM_STRING(&constant_bin[ 1332 ], 25, 1);
    const_str_plain_SSL_new = UNSTREAM_STRING(&constant_bin[ 113381 ], 7, 1);
    const_str_digest_655ba65e888ba33199198c92a8e95d70 = UNSTREAM_STRING(&constant_bin[ 113388 ], 151, 0);
    const_str_plain__alpn_select_callback = UNSTREAM_STRING(&constant_bin[ 112440 ], 21, 1);
    const_str_digest_8d1f7ec402c1b452808eeb662977982b = UNSTREAM_STRING(&constant_bin[ 113539 ], 224, 0);
    const_str_plain__passphrase_userdata = UNSTREAM_STRING(&constant_bin[ 113763 ], 20, 1);
    const_str_plain_SSL_OP_NO_SSLv3 = UNSTREAM_STRING(&constant_bin[ 113783 ], 15, 1);
    const_str_plain_SSL_OP_NO_SSLv2 = UNSTREAM_STRING(&constant_bin[ 113798 ], 15, 1);
    const_str_plain_SSL_SESSION_free = UNSTREAM_STRING(&constant_bin[ 113813 ], 16, 1);
    const_str_digest_6d088f969ab84bf3d60ab75faa431e51 = UNSTREAM_STRING(&constant_bin[ 113829 ], 132, 0);
    const_str_plain_from_handle = UNSTREAM_STRING(&constant_bin[ 113961 ], 11, 1);
    const_str_plain_SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS = UNSTREAM_STRING(&constant_bin[ 113972 ], 34, 1);
    const_str_plain_SSL_renegotiate_pending = UNSTREAM_STRING(&constant_bin[ 114006 ], 23, 1);
    const_str_plain_SSL_load_client_CA_file = UNSTREAM_STRING(&constant_bin[ 114029 ], 23, 1);
    const_str_plain_SSL_pending = UNSTREAM_STRING(&constant_bin[ 114052 ], 11, 1);
    const_str_plain_SSL_OP_NO_TLSv1 = UNSTREAM_STRING(&constant_bin[ 90053 ], 15, 1);
    const_str_digest_4387d84e76f6b2a931cf315cb767f6ce = UNSTREAM_STRING(&constant_bin[ 114063 ], 51, 0);
    const_str_plain_check_privatekey = UNSTREAM_STRING(&constant_bin[ 114114 ], 16, 1);
    const_str_plain_SSL_get_shutdown = UNSTREAM_STRING(&constant_bin[ 114130 ], 16, 1);
    const_str_plain_context_buf = UNSTREAM_STRING(&constant_bin[ 114146 ], 11, 1);
    const_tuple_59ab6bd6bf9c850fdd6c5d8aae933618_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_59ab6bd6bf9c850fdd6c5d8aae933618_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_59ab6bd6bf9c850fdd6c5d8aae933618_tuple, 1, const_str_plain_buf); Py_INCREF(const_str_plain_buf);
    PyTuple_SET_ITEM(const_tuple_59ab6bd6bf9c850fdd6c5d8aae933618_tuple, 2, const_str_plain_flags); Py_INCREF(const_str_plain_flags);
    PyTuple_SET_ITEM(const_tuple_59ab6bd6bf9c850fdd6c5d8aae933618_tuple, 3, const_str_plain_result); Py_INCREF(const_str_plain_result);
    const_str_digest_b55bbb0df6959d47693f7145ead6828a = UNSTREAM_STRING(&constant_bin[ 114157 ], 250, 0);
    const_tuple_ddbbebd3154d4430c5c187b2eaf912ed_tuple = PyTuple_New(5);
    PyTuple_SET_ITEM(const_tuple_ddbbebd3154d4430c5c187b2eaf912ed_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    const_str_plain_bufsiz = UNSTREAM_STRING(&constant_bin[ 100357 ], 6, 1);
    PyTuple_SET_ITEM(const_tuple_ddbbebd3154d4430c5c187b2eaf912ed_tuple, 1, const_str_plain_bufsiz); Py_INCREF(const_str_plain_bufsiz);
    PyTuple_SET_ITEM(const_tuple_ddbbebd3154d4430c5c187b2eaf912ed_tuple, 2, const_str_plain_flags); Py_INCREF(const_str_plain_flags);
    PyTuple_SET_ITEM(const_tuple_ddbbebd3154d4430c5c187b2eaf912ed_tuple, 3, const_str_plain_buf); Py_INCREF(const_str_plain_buf);
    PyTuple_SET_ITEM(const_tuple_ddbbebd3154d4430c5c187b2eaf912ed_tuple, 4, const_str_plain_result); Py_INCREF(const_str_plain_result);
    const_str_digest_3b38b9684d0a691f727a5c25b49127cb = UNSTREAM_STRING(&constant_bin[ 114407 ], 36, 0);
    const_str_plain_request_ocsp = UNSTREAM_STRING(&constant_bin[ 114443 ], 12, 1);
    const_str_plain__info_callback = UNSTREAM_STRING(&constant_bin[ 86561 ], 14, 1);
    const_str_plain_OP_TLS_D5_BUG = UNSTREAM_STRING(&constant_bin[ 84253 ], 13, 1);
    const_str_plain_SSL_CTX_set_next_protos_advertised_cb = UNSTREAM_STRING(&constant_bin[ 114455 ], 37, 1);
    const_tuple_str_plain_self_str_plain_dhfile_str_plain_bio_str_plain_dh_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_dhfile_str_plain_bio_str_plain_dh_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_dhfile_str_plain_bio_str_plain_dh_tuple, 1, const_str_plain_dhfile); Py_INCREF(const_str_plain_dhfile);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_dhfile_str_plain_bio_str_plain_dh_tuple, 2, const_str_plain_bio); Py_INCREF(const_str_plain_bio);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_dhfile_str_plain_bio_str_plain_dh_tuple, 3, const_str_plain_dh); Py_INCREF(const_str_plain_dh);
    const_str_digest_df17ae6c88635e3960d7bf94f5e880a4 = UNSTREAM_STRING(&constant_bin[ 114492 ], 342, 0);
    const_str_plain_set_npn_select_callback = UNSTREAM_STRING(&constant_bin[ 114834 ], 23, 1);
    const_str_plain_SSL_CTX_set_default_passwd_cb = UNSTREAM_STRING(&constant_bin[ 114857 ], 29, 1);
    const_str_plain_SSL_CTX_set_info_callback = UNSTREAM_STRING(&constant_bin[ 114886 ], 25, 1);
    const_str_plain_OP_TLS_BLOCK_PADDING_BUG = UNSTREAM_STRING(&constant_bin[ 84271 ], 24, 1);
    const_str_plain_SSL_get_error = UNSTREAM_STRING(&constant_bin[ 114911 ], 13, 1);
    const_str_plain_SSL_get_certificate = UNSTREAM_STRING(&constant_bin[ 114924 ], 19, 1);
    const_str_plain_get_timeout = UNSTREAM_STRING(&constant_bin[ 86467 ], 11, 1);
    const_str_digest_f68d1733f2e29d0ad83b903b8f287e14 = UNSTREAM_STRING(&constant_bin[ 114943 ], 441, 0);
    const_str_plain_SSL_VERIFY_PEER = UNSTREAM_STRING(&constant_bin[ 115384 ], 15, 1);
    const_tuple_e7183725d38a187a36c7befeae938036_tuple = PyTuple_New(5);
    PyTuple_SET_ITEM(const_tuple_e7183725d38a187a36c7befeae938036_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_e7183725d38a187a36c7befeae938036_tuple, 1, const_str_plain_ssl); Py_INCREF(const_str_plain_ssl);
    PyTuple_SET_ITEM(const_tuple_e7183725d38a187a36c7befeae938036_tuple, 2, const_str_plain_result); Py_INCREF(const_str_plain_result);
    PyTuple_SET_ITEM(const_tuple_e7183725d38a187a36c7befeae938036_tuple, 3, const_str_plain_errno); Py_INCREF(const_str_plain_errno);
    PyTuple_SET_ITEM(const_tuple_e7183725d38a187a36c7befeae938036_tuple, 4, const_str_plain_error); Py_INCREF(const_str_plain_error);
    const_str_digest_685ba6a7380a18939915178358979194 = UNSTREAM_STRING(&constant_bin[ 115399 ], 16, 0);
    const_str_plain_SSL_set_shutdown = UNSTREAM_STRING(&constant_bin[ 115415 ], 16, 1);
    const_tuple_str_digest_c561652c58984ec0e9541542aa405594_int_0_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_digest_c561652c58984ec0e9541542aa405594_int_0_tuple, 0, const_str_digest_c561652c58984ec0e9541542aa405594); Py_INCREF(const_str_digest_c561652c58984ec0e9541542aa405594);
    PyTuple_SET_ITEM(const_tuple_str_digest_c561652c58984ec0e9541542aa405594_int_0_tuple, 1, const_int_0); Py_INCREF(const_int_0);
    const_str_plain_use_context = UNSTREAM_STRING(&constant_bin[ 115431 ], 11, 1);
    const_str_digest_68d768407778bc3b4c8ffc953440b717 = UNSTREAM_STRING(&constant_bin[ 115442 ], 293, 0);
    const_str_plain_outp = UNSTREAM_STRING(&constant_bin[ 52116 ], 4, 1);
    const_str_digest_fe9d923dffe7ca07e210d76d45bba668 = UNSTREAM_STRING(&constant_bin[ 115735 ], 170, 0);
    const_str_plain__npn_select_callback = UNSTREAM_STRING(&constant_bin[ 104302 ], 20, 1);
    const_str_digest_71f502d97e845c89ec13eb6ef271f294 = UNSTREAM_STRING(&constant_bin[ 115905 ], 23, 0);
    const_str_plain_get_cipher_list = UNSTREAM_STRING(&constant_bin[ 87896 ], 15, 1);
    const_tuple_str_plain_platform_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_plain_platform_tuple, 0, const_str_plain_platform); Py_INCREF(const_str_plain_platform);
    const_str_digest_75d74458faf9dee1d9b7a20a034cfad7 = UNSTREAM_STRING(&constant_bin[ 115928 ], 31, 0);
    const_str_plain_set_mode = UNSTREAM_STRING(&constant_bin[ 87884 ], 8, 1);
    const_str_digest_bd36e8cd21056831af843bc4658cec96 = UNSTREAM_STRING(&constant_bin[ 115959 ], 209, 0);
    const_str_plain_SSL_CB_READ = UNSTREAM_STRING(&constant_bin[ 84969 ], 11, 1);
    const_str_plain_SSL_OP_ALL = UNSTREAM_STRING(&constant_bin[ 116168 ], 10, 1);
    const_tuple_str_plain_self_str_plain_cert_str_plain_use_result_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_cert_str_plain_use_result_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_cert_str_plain_use_result_tuple, 1, const_str_plain_cert); Py_INCREF(const_str_plain_cert);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_cert_str_plain_use_result_tuple, 2, const_str_plain_use_result); Py_INCREF(const_str_plain_use_result);
    const_str_plain__ocsp_callback = UNSTREAM_STRING(&constant_bin[ 116178 ], 14, 1);
    const_str_plain_set_session_id = UNSTREAM_STRING(&constant_bin[ 116192 ], 14, 1);
    const_str_digest_5e63447161ff7f7c21b2ac874cc6500c = UNSTREAM_STRING(&constant_bin[ 116206 ], 498, 0);
    const_str_digest_92d0e5bbbb594d3595c30b16879df5a0 = UNSTREAM_STRING(&constant_bin[ 116704 ], 128, 0);
    const_str_digest_1f9e090d5f76db9e818dd53fef9b8465 = UNSTREAM_STRING(&constant_bin[ 116832 ], 115, 0);
    const_str_plain_set_ocsp_client_callback = UNSTREAM_STRING(&constant_bin[ 92549 ], 24, 1);
    const_str_digest_0e87e25b0ab76d44ec1e50f187ee33bd = UNSTREAM_STRING(&constant_bin[ 116947 ], 293, 0);
    const_str_digest_03a9c0f25246f86801453ac49af67056 = UNSTREAM_STRING(&constant_bin[ 117240 ], 453, 0);
    const_str_plain_SSL_SESS_CACHE_NO_INTERNAL_LOOKUP = UNSTREAM_STRING(&constant_bin[ 117693 ], 33, 1);
    const_str_plain_X509_get_default_cert_file_env = UNSTREAM_STRING(&constant_bin[ 117726 ], 30, 1);
    const_str_digest_a9a754c6f4c1dd488de35af4ae59537f = UNSTREAM_STRING(&constant_bin[ 117756 ], 81, 0);
    const_str_plain_WantX509LookupError = UNSTREAM_STRING(&constant_bin[ 1651 ], 19, 1);
    const_str_plain_SSLEAY_VERSION = UNSTREAM_STRING(&constant_bin[ 83610 ], 14, 1);
    const_str_plain_set_npn_advertise_callback = UNSTREAM_STRING(&constant_bin[ 117837 ], 26, 1);
    const_str_plain_get_peer_finished = UNSTREAM_STRING(&constant_bin[ 106126 ], 17, 1);
    const_tuple_24e396011cc987e1c1e91fc8d67969c7_tuple = PyTuple_New(9);
    PyTuple_SET_ITEM(const_tuple_24e396011cc987e1c1e91fc8d67969c7_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_24e396011cc987e1c1e91fc8d67969c7_tuple, 1, const_str_plain_label); Py_INCREF(const_str_plain_label);
    const_str_plain_olen = UNSTREAM_STRING(&constant_bin[ 88076 ], 4, 1);
    PyTuple_SET_ITEM(const_tuple_24e396011cc987e1c1e91fc8d67969c7_tuple, 2, const_str_plain_olen); Py_INCREF(const_str_plain_olen);
    PyTuple_SET_ITEM(const_tuple_24e396011cc987e1c1e91fc8d67969c7_tuple, 3, const_str_plain_context); Py_INCREF(const_str_plain_context);
    PyTuple_SET_ITEM(const_tuple_24e396011cc987e1c1e91fc8d67969c7_tuple, 4, const_str_plain_outp); Py_INCREF(const_str_plain_outp);
    PyTuple_SET_ITEM(const_tuple_24e396011cc987e1c1e91fc8d67969c7_tuple, 5, const_str_plain_use_context); Py_INCREF(const_str_plain_use_context);
    const_str_plain_success = UNSTREAM_STRING(&constant_bin[ 29332 ], 7, 1);
    PyTuple_SET_ITEM(const_tuple_24e396011cc987e1c1e91fc8d67969c7_tuple, 6, const_str_plain_success); Py_INCREF(const_str_plain_success);
    PyTuple_SET_ITEM(const_tuple_24e396011cc987e1c1e91fc8d67969c7_tuple, 7, const_str_plain_context_buf); Py_INCREF(const_str_plain_context_buf);
    const_str_plain_context_len = UNSTREAM_STRING(&constant_bin[ 117863 ], 11, 1);
    PyTuple_SET_ITEM(const_tuple_24e396011cc987e1c1e91fc8d67969c7_tuple, 8, const_str_plain_context_len); Py_INCREF(const_str_plain_context_len);
    const_tuple_str_plain_self_str_plain_helper_str_plain_data_str_plain_rc_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_helper_str_plain_data_str_plain_rc_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_helper_str_plain_data_str_plain_rc_tuple, 1, const_str_plain_helper); Py_INCREF(const_str_plain_helper);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_helper_str_plain_data_str_plain_rc_tuple, 2, const_str_plain_data); Py_INCREF(const_str_plain_data);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_helper_str_plain_data_str_plain_rc_tuple, 3, const_str_plain_rc); Py_INCREF(const_str_plain_rc);
    const_str_plain_want_write = UNSTREAM_STRING(&constant_bin[ 111426 ], 10, 1);
    const_str_plain_SSL_OP_COOKIE_EXCHANGE = UNSTREAM_STRING(&constant_bin[ 117874 ], 22, 1);
    const_tuple_5a901cf5390bbd925e09951ee9017d23_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_5a901cf5390bbd925e09951ee9017d23_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_5a901cf5390bbd925e09951ee9017d23_tuple, 1, const_str_plain_outp); Py_INCREF(const_str_plain_outp);
    PyTuple_SET_ITEM(const_tuple_5a901cf5390bbd925e09951ee9017d23_tuple, 2, const_str_plain_session); Py_INCREF(const_str_plain_session);
    PyTuple_SET_ITEM(const_tuple_5a901cf5390bbd925e09951ee9017d23_tuple, 3, const_str_plain_length); Py_INCREF(const_str_plain_length);
    const_str_digest_447836721d7454a13033957e012d7688 = UNSTREAM_STRING(&constant_bin[ 117896 ], 247, 0);
    const_tuple_str_plain_self_str_plain_pkey_str_plain_use_result_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_pkey_str_plain_use_result_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_pkey_str_plain_use_result_tuple, 1, const_str_plain_pkey); Py_INCREF(const_str_plain_pkey);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_pkey_str_plain_use_result_tuple, 2, const_str_plain_use_result); Py_INCREF(const_str_plain_use_result);
    const_str_digest_94e7111e03f9422114930bb75dfc492c = UNSTREAM_STRING(&constant_bin[ 118143 ], 239, 0);
    const_str_digest_8d7c284f25a4b19db8bcbef7a9895745 = UNSTREAM_STRING(&constant_bin[ 118382 ], 114, 0);
    const_str_plain_SSL_get_version = UNSTREAM_STRING(&constant_bin[ 118496 ], 15, 1);
    const_str_plain_SESS_CACHE_CLIENT = UNSTREAM_STRING(&constant_bin[ 84697 ], 17, 1);
    const_str_plain_get_client_ca_list = UNSTREAM_STRING(&constant_bin[ 118511 ], 18, 1);
    const_str_plain_get_cert_store = UNSTREAM_STRING(&constant_bin[ 103187 ], 14, 1);
    const_tuple_str_plain_self_str_plain_result_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_result_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_result_tuple, 1, const_str_plain_result); Py_INCREF(const_str_plain_result);
    const_str_plain_SSL_get_current_cipher = UNSTREAM_STRING(&constant_bin[ 118529 ], 22, 1);
    const_str_digest_e51bcf1ff2d3a73499a1380c77d20ade = UNSTREAM_STRING(&constant_bin[ 118551 ], 32, 0);
    const_tuple_str_plain_self_str_plain_cipher_list_str_plain_tmpconn_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_cipher_list_str_plain_tmpconn_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_cipher_list_str_plain_tmpconn_tuple, 1, const_str_plain_cipher_list); Py_INCREF(const_str_plain_cipher_list);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_cipher_list_str_plain_tmpconn_tuple, 2, const_str_plain_tmpconn); Py_INCREF(const_str_plain_tmpconn);
    const_str_plain_SSL_get_ex_data_X509_STORE_CTX_idx = UNSTREAM_STRING(&constant_bin[ 118583 ], 34, 1);
    const_str_plain__set_ocsp_callback = UNSTREAM_STRING(&constant_bin[ 118617 ], 18, 1);
    const_tuple_a13720a5c6ce612466cecad70ab66e75_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_a13720a5c6ce612466cecad70ab66e75_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_a13720a5c6ce612466cecad70ab66e75_tuple, 1, const_str_plain_certificate_authority); Py_INCREF(const_str_plain_certificate_authority);
    PyTuple_SET_ITEM(const_tuple_a13720a5c6ce612466cecad70ab66e75_tuple, 2, const_str_plain_add_result); Py_INCREF(const_str_plain_add_result);
    const_str_plain_set_accept_state = UNSTREAM_STRING(&constant_bin[ 97435 ], 16, 1);
    const_str_digest_a8ac54b3ed8845d56dee411b1beed5c2 = UNSTREAM_STRING(&constant_bin[ 118635 ], 20, 0);
    const_str_plain__ocsp_helper = UNSTREAM_STRING(&constant_bin[ 118655 ], 12, 1);
    const_str_plain_SSL_CTX_set_session_id_context = UNSTREAM_STRING(&constant_bin[ 118667 ], 30, 1);
    const_tuple_str_plain_self_str_plain_dir_env_var_str_plain_file_env_var_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_dir_env_var_str_plain_file_env_var_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_dir_env_var_str_plain_file_env_var_tuple, 1, const_str_plain_dir_env_var); Py_INCREF(const_str_plain_dir_env_var);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_dir_env_var_str_plain_file_env_var_tuple, 2, const_str_plain_file_env_var); Py_INCREF(const_str_plain_file_env_var);
    const_str_plain_certificate_authorities = UNSTREAM_STRING(&constant_bin[ 118697 ], 23, 1);
    const_str_plain_SSL_CTX_free = UNSTREAM_STRING(&constant_bin[ 118720 ], 12, 1);
    const_str_digest_215c056443df9aa1456b62fe40673d54 = UNSTREAM_STRING(&constant_bin[ 118732 ], 31, 0);
    const_tuple_fb64e812782e9f70f19909e310070a01_tuple = PyTuple_New(13);
    PyTuple_SET_ITEM(const_tuple_fb64e812782e9f70f19909e310070a01_tuple, 0, const_str_plain_ok); Py_INCREF(const_str_plain_ok);
    PyTuple_SET_ITEM(const_tuple_fb64e812782e9f70f19909e310070a01_tuple, 1, const_str_plain_store_ctx); Py_INCREF(const_str_plain_store_ctx);
    PyTuple_SET_ITEM(const_tuple_fb64e812782e9f70f19909e310070a01_tuple, 2, const_str_plain_index); Py_INCREF(const_str_plain_index);
    PyTuple_SET_ITEM(const_tuple_fb64e812782e9f70f19909e310070a01_tuple, 3, const_str_plain_error_number); Py_INCREF(const_str_plain_error_number);
    PyTuple_SET_ITEM(const_tuple_fb64e812782e9f70f19909e310070a01_tuple, 4, const_str_plain_callback); Py_INCREF(const_str_plain_callback);
    PyTuple_SET_ITEM(const_tuple_fb64e812782e9f70f19909e310070a01_tuple, 5, const_str_plain_x509); Py_INCREF(const_str_plain_x509);
    PyTuple_SET_ITEM(const_tuple_fb64e812782e9f70f19909e310070a01_tuple, 6, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_fb64e812782e9f70f19909e310070a01_tuple, 7, const_str_plain_connection); Py_INCREF(const_str_plain_connection);
    PyTuple_SET_ITEM(const_tuple_fb64e812782e9f70f19909e310070a01_tuple, 8, const_str_plain_ssl); Py_INCREF(const_str_plain_ssl);
    PyTuple_SET_ITEM(const_tuple_fb64e812782e9f70f19909e310070a01_tuple, 9, const_str_plain_cert); Py_INCREF(const_str_plain_cert);
    PyTuple_SET_ITEM(const_tuple_fb64e812782e9f70f19909e310070a01_tuple, 10, const_str_plain_result); Py_INCREF(const_str_plain_result);
    PyTuple_SET_ITEM(const_tuple_fb64e812782e9f70f19909e310070a01_tuple, 11, const_str_plain_error_depth); Py_INCREF(const_str_plain_error_depth);
    PyTuple_SET_ITEM(const_tuple_fb64e812782e9f70f19909e310070a01_tuple, 12, const_str_plain_e); Py_INCREF(const_str_plain_e);
    const_str_plain_SSL_OP_TLS_D5_BUG = UNSTREAM_STRING(&constant_bin[ 118763 ], 17, 1);
    const_str_plain_OP_SSLEAY_080_CLIENT_DH_BUG = UNSTREAM_STRING(&constant_bin[ 84221 ], 27, 1);
    const_str_plain_SSL_get_finished = UNSTREAM_STRING(&constant_bin[ 106186 ], 16, 1);
    const_str_plain_SSL_ST_MASK = UNSTREAM_STRING(&constant_bin[ 84921 ], 11, 1);
    const_tuple_2fe4e23a8c490304baac2b73b87c6ea5_tuple = PyTuple_New(6);
    PyTuple_SET_ITEM(const_tuple_2fe4e23a8c490304baac2b73b87c6ea5_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_2fe4e23a8c490304baac2b73b87c6ea5_tuple, 1, const_str_plain_certificate_authorities); Py_INCREF(const_str_plain_certificate_authorities);
    PyTuple_SET_ITEM(const_tuple_2fe4e23a8c490304baac2b73b87c6ea5_tuple, 2, const_str_plain_copy); Py_INCREF(const_str_plain_copy);
    PyTuple_SET_ITEM(const_tuple_2fe4e23a8c490304baac2b73b87c6ea5_tuple, 3, const_str_plain_name_stack); Py_INCREF(const_str_plain_name_stack);
    PyTuple_SET_ITEM(const_tuple_2fe4e23a8c490304baac2b73b87c6ea5_tuple, 4, const_str_plain_ca_name); Py_INCREF(const_str_plain_ca_name);
    PyTuple_SET_ITEM(const_tuple_2fe4e23a8c490304baac2b73b87c6ea5_tuple, 5, const_str_plain_push_result); Py_INCREF(const_str_plain_push_result);
    const_tuple_0070fc91ecaec455401a06d1a7f4f5e8_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_0070fc91ecaec455401a06d1a7f4f5e8_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_0070fc91ecaec455401a06d1a7f4f5e8_tuple, 1, const_str_plain_bufsiz); Py_INCREF(const_str_plain_bufsiz);
    PyTuple_SET_ITEM(const_tuple_0070fc91ecaec455401a06d1a7f4f5e8_tuple, 2, const_str_plain_buf); Py_INCREF(const_str_plain_buf);
    PyTuple_SET_ITEM(const_tuple_0070fc91ecaec455401a06d1a7f4f5e8_tuple, 3, const_str_plain_result); Py_INCREF(const_str_plain_result);
    const_str_digest_159b478f00ae4e4ff337b75b4ff4b73e = UNSTREAM_STRING(&constant_bin[ 118780 ], 174, 0);
    const_str_plain_SSL_set_session = UNSTREAM_STRING(&constant_bin[ 118954 ], 15, 1);
    const_str_plain_OP_SSLREF2_REUSE_CERT_TYPE_BUG = UNSTREAM_STRING(&constant_bin[ 84122 ], 30, 1);
    const_tuple_09a9274d23abfb5c21510ecab74e4636_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_09a9274d23abfb5c21510ecab74e4636_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_09a9274d23abfb5c21510ecab74e4636_tuple, 1, const_str_plain_callback); Py_INCREF(const_str_plain_callback);
    PyTuple_SET_ITEM(const_tuple_09a9274d23abfb5c21510ecab74e4636_tuple, 2, const_str_plain_data); Py_INCREF(const_str_plain_data);
    PyTuple_SET_ITEM(const_tuple_09a9274d23abfb5c21510ecab74e4636_tuple, 3, const_str_plain_helper); Py_INCREF(const_str_plain_helper);
    const_str_digest_428eff9fedd3b449496fa307af56b948 = UNSTREAM_STRING(&constant_bin[ 118969 ], 34, 0);
    const_str_plain_SSL_CTX_add_client_CA = UNSTREAM_STRING(&constant_bin[ 119003 ], 21, 1);
    const_str_plain_sk_X509_NAME_new_null = UNSTREAM_STRING(&constant_bin[ 119024 ], 21, 1);
    const_str_plain_SSL_OP_TLS_ROLLBACK_BUG = UNSTREAM_STRING(&constant_bin[ 119045 ], 23, 1);
    const_tuple_str_plain_flag_str_plain_error_str_plain__requires_decorator_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_flag_str_plain_error_str_plain__requires_decorator_tuple, 0, const_str_plain_flag); Py_INCREF(const_str_plain_flag);
    PyTuple_SET_ITEM(const_tuple_str_plain_flag_str_plain_error_str_plain__requires_decorator_tuple, 1, const_str_plain_error); Py_INCREF(const_str_plain_error);
    PyTuple_SET_ITEM(const_tuple_str_plain_flag_str_plain_error_str_plain__requires_decorator_tuple, 2, const_str_plain__requires_decorator); Py_INCREF(const_str_plain__requires_decorator);
    const_str_plain_SESS_CACHE_NO_INTERNAL = UNSTREAM_STRING(&constant_bin[ 84790 ], 22, 1);
    const_str_plain_get_protocol_version = UNSTREAM_STRING(&constant_bin[ 105456 ], 20, 1);
    const_tuple_12babed94f04a9287de33a0a7ed4bbf2_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_12babed94f04a9287de33a0a7ed4bbf2_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_12babed94f04a9287de33a0a7ed4bbf2_tuple, 1, const_str_plain_i); Py_INCREF(const_str_plain_i);
    PyTuple_SET_ITEM(const_tuple_12babed94f04a9287de33a0a7ed4bbf2_tuple, 2, const_str_plain_ciphers); Py_INCREF(const_str_plain_ciphers);
    PyTuple_SET_ITEM(const_tuple_12babed94f04a9287de33a0a7ed4bbf2_tuple, 3, const_str_plain_result); Py_INCREF(const_str_plain_result);
    const_str_plain_SSL_CB_READ_ALERT = UNSTREAM_STRING(&constant_bin[ 85019 ], 17, 1);
    const_str_plain_set_tlsext_use_srtp = UNSTREAM_STRING(&constant_bin[ 103333 ], 19, 1);
    const_str_plain_SSL_OP_NO_COMPRESSION = UNSTREAM_STRING(&constant_bin[ 119068 ], 21, 1);
    const_tuple_f85e0b49580abdb5d9ebc1ace31ffe3d_tuple = PyTuple_New(10);
    PyTuple_SET_ITEM(const_tuple_f85e0b49580abdb5d9ebc1ace31ffe3d_tuple, 0, const_str_plain_ssl); Py_INCREF(const_str_plain_ssl);
    PyTuple_SET_ITEM(const_tuple_f85e0b49580abdb5d9ebc1ace31ffe3d_tuple, 1, const_str_plain_cdata); Py_INCREF(const_str_plain_cdata);
    PyTuple_SET_ITEM(const_tuple_f85e0b49580abdb5d9ebc1ace31ffe3d_tuple, 2, const_str_plain_e); Py_INCREF(const_str_plain_e);
    PyTuple_SET_ITEM(const_tuple_f85e0b49580abdb5d9ebc1ace31ffe3d_tuple, 3, const_str_plain_ocsp_data_length); Py_INCREF(const_str_plain_ocsp_data_length);
    PyTuple_SET_ITEM(const_tuple_f85e0b49580abdb5d9ebc1ace31ffe3d_tuple, 4, const_str_plain_callback); Py_INCREF(const_str_plain_callback);
    PyTuple_SET_ITEM(const_tuple_f85e0b49580abdb5d9ebc1ace31ffe3d_tuple, 5, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_f85e0b49580abdb5d9ebc1ace31ffe3d_tuple, 6, const_str_plain_ocsp_data); Py_INCREF(const_str_plain_ocsp_data);
    PyTuple_SET_ITEM(const_tuple_f85e0b49580abdb5d9ebc1ace31ffe3d_tuple, 7, const_str_plain_data_ptr); Py_INCREF(const_str_plain_data_ptr);
    PyTuple_SET_ITEM(const_tuple_f85e0b49580abdb5d9ebc1ace31ffe3d_tuple, 8, const_str_plain_data); Py_INCREF(const_str_plain_data);
    PyTuple_SET_ITEM(const_tuple_f85e0b49580abdb5d9ebc1ace31ffe3d_tuple, 9, const_str_plain_conn); Py_INCREF(const_str_plain_conn);
    const_str_digest_9e9a42d8484d15cb8253ecb92e0c7121 = UNSTREAM_STRING(&constant_bin[ 119089 ], 51, 0);
    const_str_plain_MODE_RELEASE_BUFFERS = UNSTREAM_STRING(&constant_bin[ 83933 ], 20, 1);
    const_tuple_str_plain_self_str_plain_session_str_plain_pysession_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_session_str_plain_pysession_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_session_str_plain_pysession_tuple, 1, const_str_plain_session); Py_INCREF(const_str_plain_session);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_session_str_plain_pysession_tuple, 2, const_str_plain_pysession); Py_INCREF(const_str_plain_pysession);
    const_str_plain__passphrase_helper = UNSTREAM_STRING(&constant_bin[ 119140 ], 18, 1);
    const_str_plain_SSL_set_tlsext_status_ocsp_resp = UNSTREAM_STRING(&constant_bin[ 119158 ], 31, 1);
    const_tuple_22496b7900b49af1635f455cd8f3e9ef_tuple = PyTuple_New(10);
    PyTuple_SET_ITEM(const_tuple_22496b7900b49af1635f455cd8f3e9ef_tuple, 0, const_str_plain_ssl); Py_INCREF(const_str_plain_ssl);
    PyTuple_SET_ITEM(const_tuple_22496b7900b49af1635f455cd8f3e9ef_tuple, 1, const_str_plain_out); Py_INCREF(const_str_plain_out);
    PyTuple_SET_ITEM(const_tuple_22496b7900b49af1635f455cd8f3e9ef_tuple, 2, const_str_plain_outlen); Py_INCREF(const_str_plain_outlen);
    PyTuple_SET_ITEM(const_tuple_22496b7900b49af1635f455cd8f3e9ef_tuple, 3, const_str_plain_arg); Py_INCREF(const_str_plain_arg);
    PyTuple_SET_ITEM(const_tuple_22496b7900b49af1635f455cd8f3e9ef_tuple, 4, const_str_plain_e); Py_INCREF(const_str_plain_e);
    PyTuple_SET_ITEM(const_tuple_22496b7900b49af1635f455cd8f3e9ef_tuple, 5, const_str_plain_callback); Py_INCREF(const_str_plain_callback);
    PyTuple_SET_ITEM(const_tuple_22496b7900b49af1635f455cd8f3e9ef_tuple, 6, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_22496b7900b49af1635f455cd8f3e9ef_tuple, 7, const_str_plain_protos); Py_INCREF(const_str_plain_protos);
    PyTuple_SET_ITEM(const_tuple_22496b7900b49af1635f455cd8f3e9ef_tuple, 8, const_str_plain_protostr); Py_INCREF(const_str_plain_protostr);
    PyTuple_SET_ITEM(const_tuple_22496b7900b49af1635f455cd8f3e9ef_tuple, 9, const_str_plain_conn); Py_INCREF(const_str_plain_conn);
    const_str_digest_a068c39f2c9878239ba2a3b47e83e1e0 = UNSTREAM_STRING(&constant_bin[ 119189 ], 26, 0);
    const_str_plain_SENT_SHUTDOWN = UNSTREAM_STRING(&constant_bin[ 83702 ], 13, 1);
    const_str_plain__passphrase_callback = UNSTREAM_STRING(&constant_bin[ 119215 ], 20, 1);
    const_str_plain_SSL_export_keying_material = UNSTREAM_STRING(&constant_bin[ 119235 ], 26, 1);
    const_str_plain_SSL_CTX_set_default_verify_paths = UNSTREAM_STRING(&constant_bin[ 119261 ], 32, 1);
    const_str_plain_get_state_string = UNSTREAM_STRING(&constant_bin[ 119293 ], 16, 1);
    const_str_plain_SSL_CTX_set_cipher_list = UNSTREAM_STRING(&constant_bin[ 119309 ], 23, 1);
    const_str_plain_SSL_OP_NO_TICKET = UNSTREAM_STRING(&constant_bin[ 119332 ], 16, 1);
    const_str_plain_ConnectionType = UNSTREAM_STRING(&constant_bin[ 83093 ], 14, 1);
    const_list_3574eb54ef4ecf6f2c0597b9df34708e_list = PyList_New(4);
    PyList_SET_ITEM(const_list_3574eb54ef4ecf6f2c0597b9df34708e_list, 0, const_str_plain_SSL_ST_INIT); Py_INCREF(const_str_plain_SSL_ST_INIT);
    PyList_SET_ITEM(const_list_3574eb54ef4ecf6f2c0597b9df34708e_list, 1, const_str_plain_SSL_ST_BEFORE); Py_INCREF(const_str_plain_SSL_ST_BEFORE);
    PyList_SET_ITEM(const_list_3574eb54ef4ecf6f2c0597b9df34708e_list, 2, const_str_plain_SSL_ST_OK); Py_INCREF(const_str_plain_SSL_ST_OK);
    PyList_SET_ITEM(const_list_3574eb54ef4ecf6f2c0597b9df34708e_list, 3, const_str_plain_SSL_ST_RENEGOTIATE); Py_INCREF(const_str_plain_SSL_ST_RENEGOTIATE);
    const_str_plain_SSL_OP_PKCS1_CHECK_1 = UNSTREAM_STRING(&constant_bin[ 119348 ], 20, 1);
    const_str_plain_SSL_OP_PKCS1_CHECK_2 = UNSTREAM_STRING(&constant_bin[ 119368 ], 20, 1);
    const_str_plain_set_shutdown = UNSTREAM_STRING(&constant_bin[ 115419 ], 12, 1);
    const_str_plain_isfile = UNSTREAM_STRING(&constant_bin[ 119388 ], 6, 1);
    const_str_plain_get_peer_cert_chain = UNSTREAM_STRING(&constant_bin[ 113211 ], 19, 1);
    const_str_plain_OP_NETSCAPE_CA_DN_BUG = UNSTREAM_STRING(&constant_bin[ 84433 ], 21, 1);
    const_str_plain_SSL_CTX_set_tmp_ecdh = UNSTREAM_STRING(&constant_bin[ 119394 ], 20, 1);
    const_str_plain_SSL_CTX_set_timeout = UNSTREAM_STRING(&constant_bin[ 107611 ], 19, 1);
    const_str_plain__npn_advertise_callback_args = UNSTREAM_STRING(&constant_bin[ 119414 ], 28, 1);
    const_str_digest_8cde8912e8f2207155a1addb0752791f = UNSTREAM_STRING(&constant_bin[ 119442 ], 44, 0);
    const_str_plain__raise_passphrase_exception = UNSTREAM_STRING(&constant_bin[ 119486 ], 27, 1);
    const_str_digest_a94ef27b6600318cb26f98532a46ec7d = UNSTREAM_STRING(&constant_bin[ 119513 ], 122, 0);
    const_str_plain_OP_TLS_ROLLBACK_BUG = UNSTREAM_STRING(&constant_bin[ 84367 ], 19, 1);
    const_str_plain_SSL_CTX_set_verify_depth = UNSTREAM_STRING(&constant_bin[ 119635 ], 24, 1);
    const_str_plain__CRYPTOGRAPHY_MANYLINUX1_CA_DIR = UNSTREAM_STRING(&constant_bin[ 686 ], 31, 1);
    const_str_plain_SSL_CB_WRITE_ALERT = UNSTREAM_STRING(&constant_bin[ 85041 ], 18, 1);
    const_str_plain_get_context = UNSTREAM_STRING(&constant_bin[ 119659 ], 11, 1);
    const_str_plain_TLSv1_2_method = UNSTREAM_STRING(&constant_bin[ 119670 ], 14, 1);
    const_str_digest_6a85cdfe995e144af7c992d7adff36a9 = UNSTREAM_STRING(&constant_bin[ 119684 ], 289, 0);
    const_str_plain_set_tlsext_servername_callback = UNSTREAM_STRING(&constant_bin[ 110801 ], 30, 1);
    const_tuple_str_plain_self_str_plain_callback_str_plain_wrapper_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_callback_str_plain_wrapper_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_callback_str_plain_wrapper_tuple, 1, const_str_plain_callback); Py_INCREF(const_str_plain_callback);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_callback_str_plain_wrapper_tuple, 2, const_str_plain_wrapper); Py_INCREF(const_str_plain_wrapper);
    const_str_digest_b6ee2740f619fbeb4f2040d74693ca57 = UNSTREAM_STRING(&constant_bin[ 119973 ], 194, 0);
    const_str_digest_c8e9b5ff5b00d8190ecae28b8a410248 = UNSTREAM_STRING(&constant_bin[ 120167 ], 25, 0);
    const_tuple_str_plain_self_str_plain_cipher_str_plain_version_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_cipher_str_plain_version_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_cipher_str_plain_version_tuple, 1, const_str_plain_cipher); Py_INCREF(const_str_plain_cipher);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_cipher_str_plain_version_tuple, 2, const_str_plain_version); Py_INCREF(const_str_plain_version);
    const_str_digest_f6ccda911266ccc3bb4cd038d18beb52 = UNSTREAM_STRING(&constant_bin[ 120192 ], 25, 0);
    const_str_plain_SSL_CTX_check_private_key = UNSTREAM_STRING(&constant_bin[ 120217 ], 25, 1);
    const_str_digest_91220ffd97efb14a503e0ecf9d7ff0d1 = UNSTREAM_STRING(&constant_bin[ 120242 ], 205, 0);
    const_str_digest_f7bf61568f9564a7aee5354f80d84343 = UNSTREAM_STRING(&constant_bin[ 120447 ], 351, 0);
    const_str_plain_SSL_get_client_random = UNSTREAM_STRING(&constant_bin[ 120798 ], 21, 1);
    const_str_plain_SSL_RECEIVED_SHUTDOWN = UNSTREAM_STRING(&constant_bin[ 120819 ], 21, 1);
    const_str_digest_3f54294273e4f6390044ae027b11e5ae = UNSTREAM_STRING(&constant_bin[ 120840 ], 150, 0);
    const_str_plain_SSL_CB_LOOP = UNSTREAM_STRING(&constant_bin[ 84937 ], 11, 1);
    const_str_digest_e0c534afee902e78ce11df02f380dfa7 = UNSTREAM_STRING(&constant_bin[ 120990 ], 48, 0);
    const_str_plain_BIO_set_mem_eof_return = UNSTREAM_STRING(&constant_bin[ 121038 ], 22, 1);
    const_str_plain_OP_NO_TICKET = UNSTREAM_STRING(&constant_bin[ 84563 ], 12, 1);
    const_str_plain_set_tmp_ecdh = UNSTREAM_STRING(&constant_bin[ 119402 ], 12, 1);
    const_str_digest_91c07271f44b73503e7c77deea91aef1 = UNSTREAM_STRING(&constant_bin[ 121060 ], 139, 0);
    const_str_plain_SSL_SESSION_get_master_key = UNSTREAM_STRING(&constant_bin[ 121199 ], 26, 1);
    const_str_plain_OP_MSIE_SSLV2_RSA_PADDING = UNSTREAM_STRING(&constant_bin[ 84191 ], 25, 1);
    const_str_digest_770cbd653c9b65a44061ec243e0b5fd3 = UNSTREAM_STRING(&constant_bin[ 121225 ], 97, 0);
    const_str_digest_3319904791e7df62e14d88cc362facc1 = UNSTREAM_STRING(&constant_bin[ 121322 ], 150, 0);
    const_str_plain__CERTIFICATE_FILE_LOCATIONS = UNSTREAM_STRING(&constant_bin[ 807 ], 27, 1);
    const_str_digest_627e1a07a1a60af86ff9e544428f2f09 = UNSTREAM_STRING(&constant_bin[ 121472 ], 34, 0);
    const_str_digest_f4ac5993e0eb53c16d6349308d51d30e = UNSTREAM_STRING(&constant_bin[ 121506 ], 39, 0);
    const_str_digest_1ba1651f4266e42e9b568d28fa131281 = UNSTREAM_STRING(&constant_bin[ 121545 ], 207, 0);
    const_str_digest_bcb5a3a78e430302038d88f5e5d88cc5 = UNSTREAM_STRING(&constant_bin[ 121752 ], 163, 0);
    const_str_plain_sk_X509_NAME_num = UNSTREAM_STRING(&constant_bin[ 121915 ], 16, 1);
    const_str_plain_set_alpn_select_callback = UNSTREAM_STRING(&constant_bin[ 121931 ], 24, 1);
    const_str_digest_149b7c0937a6a666f182d0520ebdf631 = UNSTREAM_STRING(&constant_bin[ 121955 ], 242, 0);
    const_str_digest_eda9ad2d7932cfc1d1f52f27a3ed06a8 = UNSTREAM_STRING(&constant_bin[ 122197 ], 115, 0);
    const_tuple_str_plain_args_str_plain_kwargs_str_plain_error_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_args_str_plain_kwargs_str_plain_error_tuple, 0, const_str_plain_args); Py_INCREF(const_str_plain_args);
    PyTuple_SET_ITEM(const_tuple_str_plain_args_str_plain_kwargs_str_plain_error_tuple, 1, const_str_plain_kwargs); Py_INCREF(const_str_plain_kwargs);
    PyTuple_SET_ITEM(const_tuple_str_plain_args_str_plain_kwargs_str_plain_error_tuple, 2, const_str_plain_error); Py_INCREF(const_str_plain_error);
    const_str_plain_renegotiate = UNSTREAM_STRING(&constant_bin[ 97397 ], 11, 1);
    const_str_digest_9071118ef0006cb5d28d9100761be8e9 = UNSTREAM_STRING(&constant_bin[ 122312 ], 337, 0);
    const_str_plain_master_key = UNSTREAM_STRING(&constant_bin[ 121215 ], 10, 1);
    const_str_digest_0d994cfb9823ffc5647bea3454d1e646 = UNSTREAM_STRING(&constant_bin[ 122649 ], 119, 0);
    const_str_plain_SSL_do_handshake = UNSTREAM_STRING(&constant_bin[ 122768 ], 16, 1);
    const_str_plain_server_random = UNSTREAM_STRING(&constant_bin[ 109018 ], 13, 1);
    const_str_plain_SSL_CTX_set_session_cache_mode = UNSTREAM_STRING(&constant_bin[ 122784 ], 30, 1);
    const_str_plain_SSL_set_accept_state = UNSTREAM_STRING(&constant_bin[ 122814 ], 20, 1);
    const_str_plain_sock_shutdown = UNSTREAM_STRING(&constant_bin[ 122834 ], 13, 1);
    const_str_plain_BIO_read = UNSTREAM_STRING(&constant_bin[ 122847 ], 8, 1);
    const_str_digest_592776beca582822ed747da68adba670 = UNSTREAM_STRING(&constant_bin[ 122855 ], 395, 0);
    const_str_plain_X509_STORE_CTX_set_error = UNSTREAM_STRING(&constant_bin[ 123250 ], 24, 1);
    const_str_plain_TLSEXT_STATUSTYPE_ocsp = UNSTREAM_STRING(&constant_bin[ 123274 ], 22, 1);

    constants_created = true;
}

/* Function to verify module private constants for non-corruption. */
#ifndef __NUITKA_NO_ASSERT__
void checkModuleConstants_OpenSSL$SSL(void) {
    // The module may not have been used at all, then ignore this.
    if (constants_created == false) return;


}
#endif

// The module code objects.
static PyCodeObject *codeobj_aa161ac185e75726cd10cc9d22ea8046;
static PyCodeObject *codeobj_dec16e966d6274a18c38ad18c936c314;
static PyCodeObject *codeobj_187ce20cb779135c6ac49e57137cf08a;
static PyCodeObject *codeobj_d3b60764eff38474732964f96db6ec32;
static PyCodeObject *codeobj_9bf9e3fa2edc4bf3ebd1e712b4e8714e;
static PyCodeObject *codeobj_b51be28c00cf0bfc19c54f6f95b9174b;
static PyCodeObject *codeobj_d641b83c6dc81d8049e076a80fd0abcb;
static PyCodeObject *codeobj_afa02031ee1fbc3d4b779093fdfb585c;
static PyCodeObject *codeobj_9ff72b44efcfb2d4a96a40edcf67b8cf;
static PyCodeObject *codeobj_0ab1750369bb8d45abc70b759d692236;
static PyCodeObject *codeobj_4708bc94e7cf08ee5e04fb7dbacf1bd1;
static PyCodeObject *codeobj_0eb02023a95d73c29a7d3de33ad75951;
static PyCodeObject *codeobj_3beab920a481007f8daf7a784334bc50;
static PyCodeObject *codeobj_6eecb9f929296113b11b777ecdee380a;
static PyCodeObject *codeobj_31b7ea660237ae3ad6904b3b553dbb0b;
static PyCodeObject *codeobj_5b498c42a86529628b46de5b97e617d3;
static PyCodeObject *codeobj_c93d963cdd7d7cda8b597989582cd847;
static PyCodeObject *codeobj_187fe5b9a88e33cc73e9ffc0bee13a36;
static PyCodeObject *codeobj_36419b8e55b17a9cf1f1164d41ec30e1;
static PyCodeObject *codeobj_a34ae73d8f795897cbc3555bccd4619d;
static PyCodeObject *codeobj_567d4caf802af0a89115f921ed8e28e3;
static PyCodeObject *codeobj_22ca8433889a93275ebb1b4e80b3b8e9;
static PyCodeObject *codeobj_8e1387e41345949ee09c7bd644ab240f;
static PyCodeObject *codeobj_c32e3eca92a8fda3af3c267c3ed289ab;
static PyCodeObject *codeobj_ff33e982614e50cd77cbd818f47a7a68;
static PyCodeObject *codeobj_ecbdc66f85a0b113e83a292b998563db;
static PyCodeObject *codeobj_d5e6e0f6e9a353e330b36c530b5b4bb0;
static PyCodeObject *codeobj_638f4df5700a78f0b7a07a86c27fb3a2;
static PyCodeObject *codeobj_c566f460e49d418f64d8ae5bff045f3b;
static PyCodeObject *codeobj_2f4c7f3e7e619c283f90e008af92ff2c;
static PyCodeObject *codeobj_13d36b1bd050046a04a5eb1214a2c430;
static PyCodeObject *codeobj_822962a03b3cbac836e47fa1e36419fa;
static PyCodeObject *codeobj_b7ca808cc5c4c80d7918d0eed15dff75;
static PyCodeObject *codeobj_e6af520114787689a5f9cf0c5c00fde7;
static PyCodeObject *codeobj_d5ed49f302d78d068853f841ba5561d8;
static PyCodeObject *codeobj_c1f5ffac0bddcd92b9fd18b1877284a7;
static PyCodeObject *codeobj_4ad7fb1c164aa08c3de4745ff8bb3abb;
static PyCodeObject *codeobj_054eab96f8b2836c51e087bd4de8388e;
static PyCodeObject *codeobj_79150ce062e76c9de8df0c58996d97fe;
static PyCodeObject *codeobj_3a54cffed41af1aede27c16b10131e97;
static PyCodeObject *codeobj_7a0155ee18f90fe4fffc56c025b25370;
static PyCodeObject *codeobj_26dc7c955eece9f3eeb0e341a1ceda0b;
static PyCodeObject *codeobj_776624edcfa35f9ea528996d05e133ee;
static PyCodeObject *codeobj_9d4bbd15181b53f3bd7f364d6e6e4145;
static PyCodeObject *codeobj_c7e9dcab9b20e02fc8fa7057fd275f11;
static PyCodeObject *codeobj_15a969cf6b2c91b8e511081a7c0a39b6;
static PyCodeObject *codeobj_3946b9a412811e47d3779a1e62a72e4b;
static PyCodeObject *codeobj_eb4e822fd78a70f279bd9df4a597324d;
static PyCodeObject *codeobj_dfa471f51052025d0f268f8ce73b5948;
static PyCodeObject *codeobj_5a46eefcdd3d235d3fe799c45ec3726a;
static PyCodeObject *codeobj_6fb08a01e4ea72bc52096d7018179add;
static PyCodeObject *codeobj_c7007220b0b459514c7b12300a002dc2;
static PyCodeObject *codeobj_85b9d973a13dac4e475a6908180fcbd0;
static PyCodeObject *codeobj_729d8bc5b3418129828900f018d231cc;
static PyCodeObject *codeobj_2d525410d7ab181761b0e480a04ac3bb;
static PyCodeObject *codeobj_b0089d377af5c5ab7b6943168bf04c70;
static PyCodeObject *codeobj_3f6bd2362b83f8e85f091e7fc006c6ad;
static PyCodeObject *codeobj_a54ef0e991ddc5127543496476fffdc2;
static PyCodeObject *codeobj_190fc2095a8f804515eb5f410b637f5e;
static PyCodeObject *codeobj_8a31a568865bc9c9ed09c31a31d8134a;
static PyCodeObject *codeobj_4b891c2de54665c165f85dce04cb4cb8;
static PyCodeObject *codeobj_52829c318867d59743de899b39d5abac;
static PyCodeObject *codeobj_5817b5e321e605b5e5aa93bf0883e885;
static PyCodeObject *codeobj_290e9c85751ef278e20a65deeb074f76;
static PyCodeObject *codeobj_096b136f4a3b30d606655f40a0fcb7eb;
static PyCodeObject *codeobj_01a9999db18bff60965b0449882ec682;
static PyCodeObject *codeobj_db4c7bea0bf7206725d167d502c6eba5;
static PyCodeObject *codeobj_a8347686a3eb5f3ebe1515762b155d4a;
static PyCodeObject *codeobj_2d489c67d8f0900c68ccd131eb39b31e;
static PyCodeObject *codeobj_30235f217fa5586477415a9239a3581a;
static PyCodeObject *codeobj_346033c0896bad93f6cf605df224d7cb;
static PyCodeObject *codeobj_433dfad8408328fc74fc1215c9a5f8eb;
static PyCodeObject *codeobj_bb87c94112fe99283e7d060ed1328b6e;
static PyCodeObject *codeobj_b6d73ec0251ecf129f902466d7d1010b;
static PyCodeObject *codeobj_10a2c3fa06ddc8ce7babebf4ab2a34ed;
static PyCodeObject *codeobj_97860a8503a242ea2870dd155ed6cf25;
static PyCodeObject *codeobj_be94e691bb77258f38f88be8b8aadc60;
static PyCodeObject *codeobj_7028d427820f53c4d1e8a41a379a1710;
static PyCodeObject *codeobj_d6f61d72394bd98660c5c42254770e72;
static PyCodeObject *codeobj_cef9c931fd2f28c31ff360c1fa396b8e;
static PyCodeObject *codeobj_c3dfbb3b28d031b8f3e3ccaa5745dfa1;
static PyCodeObject *codeobj_b9ad0ac22cd13b3cff0f4d819d0dee45;
static PyCodeObject *codeobj_cbb40621241b7978549d445047800574;
static PyCodeObject *codeobj_201bf75d84b5bdea5cfec00b8b8c8ba7;
static PyCodeObject *codeobj_ce17632235d529b0e086bbba8d5f4d69;
static PyCodeObject *codeobj_c5a3b890d44f3c8acdb96b874e67ae24;
static PyCodeObject *codeobj_42236c687cf1136b7c7bf18f19fec11f;
static PyCodeObject *codeobj_0a6cc7d4157b03d199984fd3c032b609;
static PyCodeObject *codeobj_a30e6c3082d13f64248246c7b439f499;
static PyCodeObject *codeobj_2b3317a29293d550661be41a8c0a9de2;
static PyCodeObject *codeobj_08c15e906deacdd0080dc5380f603678;
static PyCodeObject *codeobj_d43339cac2a23168c71e48b85d7e240f;
static PyCodeObject *codeobj_b2045a22f86b32602807c3a9b9a1b9a9;
static PyCodeObject *codeobj_1eb3a30ea8ff5bbf704361f349f12a12;
static PyCodeObject *codeobj_8789032a2a2c430ee61b2a9a442b588d;
static PyCodeObject *codeobj_de42447e718b11e0e561f2def518a1f5;
static PyCodeObject *codeobj_c82e8c12b8026efc371154571f833311;
static PyCodeObject *codeobj_7e20264abef33d5c372261962149019f;
static PyCodeObject *codeobj_d67706623e0b60e72dc27ab285eeed79;
static PyCodeObject *codeobj_03577ba5881bc60859c4e27b32960700;
static PyCodeObject *codeobj_0632cad59439bdd081092e8e08dbc92d;
static PyCodeObject *codeobj_8f7fd200c22a912bb8feee9fea391456;
static PyCodeObject *codeobj_486bd2bad33e063a2af794bab2239dd3;
static PyCodeObject *codeobj_c427551e2adf1aa767652146eebdf018;
static PyCodeObject *codeobj_bd9f3e8d092c4130e2f017c3c9cd2b5e;
static PyCodeObject *codeobj_a79065ffeacdb0a47f1382db19c35f3d;
static PyCodeObject *codeobj_a709177b545996fdc26d1f69a26d148a;
static PyCodeObject *codeobj_e3c8ae13ac9eb0f32a9b6fc044804d84;
static PyCodeObject *codeobj_bfea99648ca6c20c83b6bfd2c85611c5;
static PyCodeObject *codeobj_d8df85ffb933c241e379fed2d072ff49;
static PyCodeObject *codeobj_4617788626982375adc8761ce194469c;
static PyCodeObject *codeobj_c067e3d1636e863e171637342c310c8c;
static PyCodeObject *codeobj_df923127bdb888edf2c0aee9d730721d;
static PyCodeObject *codeobj_6f36c0fa3d59052efa6a916f18f6c1e1;
static PyCodeObject *codeobj_0a0cad4a67aba10eabe93e57ee235747;
static PyCodeObject *codeobj_0fadfadb8bb4516eed76800a79e9a7f7;
static PyCodeObject *codeobj_1a8dfef65194129bda154b5d5d19c988;
static PyCodeObject *codeobj_1dc98b765f924dc15a85607868c9dcc9;
static PyCodeObject *codeobj_29af76d76b7406a6693f5b340243209e;
static PyCodeObject *codeobj_5e575d8ecc92ab2025e10ae05258d327;
static PyCodeObject *codeobj_c9eaa039e52a2d0cfe9a9fd0371f8a5f;
static PyCodeObject *codeobj_c34dc8d8e69e96a1fdc1da393173e7eb;
static PyCodeObject *codeobj_f69b17c8965a6426ab8e389546eeab2c;
static PyCodeObject *codeobj_3ca30ec9f4bb68c7995e4dc075f1f8aa;
static PyCodeObject *codeobj_a9047c1bce52ef36545c3c95123c1a6f;
static PyCodeObject *codeobj_ce0f4a68c73e09b427efa61d82289d07;
static PyCodeObject *codeobj_cd50f2607dc6e8cfc0715ef171ecbc55;
static PyCodeObject *codeobj_6dbabe0cc3fa56b737c573ecdbbbc1cc;
static PyCodeObject *codeobj_8b48c52cd2db4623bd0576fa41e4cfa3;
static PyCodeObject *codeobj_1f66bae567fc069e7269625d4e4a775a;
static PyCodeObject *codeobj_0228e96ca7a03ca447fc3f1bfe3f2f29;
static PyCodeObject *codeobj_a732a29d3f3e6b4a55e2a24a6a2d57ce;

static void createModuleCodeObjects(void) {
    module_filename_obj = MAKE_RELATIVE_PATH(const_str_digest_d3a1e78595a066a43885e44a343877f5);
    codeobj_aa161ac185e75726cd10cc9d22ea8046 = MAKE_CODEOBJECT(module_filename_obj, 696, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_angle_genexpr, const_tuple_b5f59418c193d572a22cf854b821fa76_tuple, 1, 0, 0);
    codeobj_dec16e966d6274a18c38ad18c936c314 = MAKE_CODEOBJECT(module_filename_obj, 353, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS, const_str_angle_genexpr, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_p_tuple, 1, 0, 0);
    codeobj_187ce20cb779135c6ac49e57137cf08a = MAKE_CODEOBJECT(module_filename_obj, 1448, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_angle_genexpr, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_p_tuple, 1, 0, 0);
    codeobj_d3b60764eff38474732964f96db6ec32 = MAKE_CODEOBJECT(module_filename_obj, 2460, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_angle_genexpr, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_p_tuple, 1, 0, 0);
    codeobj_9bf9e3fa2edc4bf3ebd1e712b4e8714e = MAKE_CODEOBJECT(module_filename_obj, 1, CO_NOFREE, const_str_digest_a8ac54b3ed8845d56dee411b1beed5c2, const_tuple_empty, 0, 0, 0);
    codeobj_b51be28c00cf0bfc19c54f6f95b9174b = MAKE_CODEOBJECT(module_filename_obj, 1537, CO_NEWLOCALS | CO_NOFREE, const_str_plain_Connection, const_tuple_empty, 0, 0, 0);
    codeobj_d641b83c6dc81d8049e076a80fd0abcb = MAKE_CODEOBJECT(module_filename_obj, 679, CO_NEWLOCALS | CO_NOFREE, const_str_plain_Context, const_tuple_empty, 0, 0, 0);
    codeobj_afa02031ee1fbc3d4b779093fdfb585c = MAKE_CODEOBJECT(module_filename_obj, 622, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_SSLeay_version, const_tuple_str_plain_type_tuple, 1, 0, 0);
    codeobj_9ff72b44efcfb2d4a96a40edcf67b8cf = MAKE_CODEOBJECT(module_filename_obj, 1596, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain___getattr__, const_tuple_str_plain_self_str_plain_name_tuple, 2, 0, 0);
    codeobj_0ab1750369bb8d45abc70b759d692236 = MAKE_CODEOBJECT(module_filename_obj, 281, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain___init__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_4708bc94e7cf08ee5e04fb7dbacf1bd1 = MAKE_CODEOBJECT(module_filename_obj, 303, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain___init__, const_tuple_str_plain_self_str_plain_callback_str_plain_wrapper_tuple, 2, 0, 0);
    codeobj_0eb02023a95d73c29a7d3de33ad75951 = MAKE_CODEOBJECT(module_filename_obj, 341, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain___init__, const_tuple_str_plain_self_str_plain_callback_str_plain_wrapper_tuple, 2, 0, 0);
    codeobj_3beab920a481007f8daf7a784334bc50 = MAKE_CODEOBJECT(module_filename_obj, 382, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain___init__, const_tuple_str_plain_self_str_plain_callback_str_plain_wrapper_tuple, 2, 0, 0);
    codeobj_6eecb9f929296113b11b777ecdee380a = MAKE_CODEOBJECT(module_filename_obj, 431, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain___init__, const_tuple_str_plain_self_str_plain_callback_str_plain_wrapper_tuple, 2, 0, 0);
    codeobj_31b7ea660237ae3ad6904b3b553dbb0b = MAKE_CODEOBJECT(module_filename_obj, 499, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain___init__, const_tuple_str_plain_self_str_plain_callback_str_plain_wrapper_tuple, 2, 0, 0);
    codeobj_5b498c42a86529628b46de5b97e617d3 = MAKE_CODEOBJECT(module_filename_obj, 566, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain___init__, const_tuple_str_plain_self_str_plain_callback_str_plain_wrapper_tuple, 2, 0, 0);
    codeobj_c93d963cdd7d7cda8b597989582cd847 = MAKE_CODEOBJECT(module_filename_obj, 1542, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain___init__, const_tuple_7c3b7701dcc867dc417afc0b7dd18be0_tuple, 3, 0, 0);
    codeobj_187fe5b9a88e33cc73e9ffc0bee13a36 = MAKE_CODEOBJECT(module_filename_obj, 700, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain___init__, const_tuple_62a32d899dc1fe37f6d326f7d9a44911_tuple, 2, 0, 0);
    codeobj_36419b8e55b17a9cf1f1164d41ec30e1 = MAKE_CODEOBJECT(module_filename_obj, 603, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain__asFileDescriptor, const_tuple_str_plain_obj_str_plain_fd_str_plain_meth_tuple, 1, 0, 0);
    codeobj_a34ae73d8f795897cbc3555bccd4619d = MAKE_CODEOBJECT(module_filename_obj, 862, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain__check_env_vars_set, const_tuple_str_plain_self_str_plain_dir_env_var_str_plain_file_env_var_tuple, 3, 0, 0);
    codeobj_567d4caf802af0a89115f921ed8e28e3 = MAKE_CODEOBJECT(module_filename_obj, 873, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain__fallback_default_verify_paths, const_tuple_e3219c972e1d9320fe91a603e3df8d39_tuple, 3, 0, 0);
    codeobj_22ca8433889a93275ebb1b4e80b3b8e9 = MAKE_CODEOBJECT(module_filename_obj, 2298, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain__get_finished_message, const_tuple_fdf14ad5fcee8ba941991b04122d5521_tuple, 2, 0, 0);
    codeobj_8e1387e41345949ee09c7bd644ab240f = MAKE_CODEOBJECT(module_filename_obj, 1832, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain__handle_bio_errors, const_tuple_str_plain_self_str_plain_bio_str_plain_result_tuple, 3, 0, 0);
    codeobj_c32e3eca92a8fda3af3c267c3ed289ab = MAKE_CODEOBJECT(module_filename_obj, 631, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain__make_requires, const_tuple_str_plain_flag_str_plain_error_str_plain__requires_decorator_tuple, 2, 0, 0);
    codeobj_ff33e982614e50cd77cbd818f47a7a68 = MAKE_CODEOBJECT(module_filename_obj, 963, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain__raise_passphrase_exception, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_ecbdc66f85a0b113e83a292b998563db = MAKE_CODEOBJECT(module_filename_obj, 1608, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain__raise_ssl_error, const_tuple_e7183725d38a187a36c7befeae938036_tuple, 3, 0, 0);
    codeobj_d5e6e0f6e9a353e330b36c530b5b4bb0 = MAKE_CODEOBJECT(module_filename_obj, 641, CO_OPTIMIZED | CO_NEWLOCALS, const_str_plain__requires_decorator, const_tuple_str_plain_func_str_plain_explode_str_plain_flag_tuple, 1, 0, 0);
    codeobj_638f4df5700a78f0b7a07a86c27fb3a2 = MAKE_CODEOBJECT(module_filename_obj, 1472, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain__set_ocsp_callback, const_tuple_str_plain_self_str_plain_helper_str_plain_data_str_plain_rc_tuple, 3, 0, 0);
    codeobj_c566f460e49d418f64d8ae5bff045f3b = MAKE_CODEOBJECT(module_filename_obj, 778, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain__wrap_callback, const_tuple_str_plain_self_str_plain_callback_str_plain_wrapper_tuple, 2, 0, 0);
    codeobj_2f4c7f3e7e619c283f90e008af92ff2c = MAKE_CODEOBJECT(module_filename_obj, 1962, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_accept, const_tuple_72afa5cdf95db9f073bb963f13be50a9_tuple, 1, 0, 0);
    codeobj_13d36b1bd050046a04a5eb1214a2c430 = MAKE_CODEOBJECT(module_filename_obj, 1239, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_add_client_ca, const_tuple_a13720a5c6ce612466cecad70ab66e75_tuple, 2, 0, 0);
    codeobj_822962a03b3cbac836e47fa1e36419fa = MAKE_CODEOBJECT(module_filename_obj, 946, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_add_extra_chain_cert, const_tuple_711d722f51d6d6accf419f2bb9aeb5b5_tuple, 2, 0, 0);
    codeobj_b7ca808cc5c4c80d7918d0eed15dff75 = MAKE_CODEOBJECT(module_filename_obj, 1850, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_bio_read, const_tuple_0070fc91ecaec455401a06d1a7f4f5e8_tuple, 2, 0, 0);
    codeobj_e6af520114787689a5f9cf0c5c00fde7 = MAKE_CODEOBJECT(module_filename_obj, 1977, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_bio_shutdown, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_d5ed49f302d78d068853f841ba5561d8 = MAKE_CODEOBJECT(module_filename_obj, 1874, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_bio_write, const_tuple_str_plain_self_str_plain_buf_str_plain_result_tuple, 2, 0, 0);
    codeobj_c1f5ffac0bddcd92b9fd18b1877284a7 = MAKE_CODEOBJECT(module_filename_obj, 1006, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_check_privatekey, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_4ad7fb1c164aa08c3de4745ff8bb3abb = MAKE_CODEOBJECT(module_filename_obj, 2122, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_client_random, const_tuple_5a901cf5390bbd925e09951ee9017d23_tuple, 1, 0, 0);
    codeobj_054eab96f8b2836c51e087bd4de8388e = MAKE_CODEOBJECT(module_filename_obj, 1936, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_connect, const_tuple_str_plain_self_str_plain_addr_tuple, 2, 0, 0);
    codeobj_79150ce062e76c9de8df0c58996d97fe = MAKE_CODEOBJECT(module_filename_obj, 1948, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_connect_ex, const_tuple_str_plain_self_str_plain_addr_str_plain_connect_ex_tuple, 2, 0, 0);
    codeobj_3a54cffed41af1aede27c16b10131e97 = MAKE_CODEOBJECT(module_filename_obj, 1906, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_do_handshake, const_tuple_str_plain_self_str_plain_result_tuple, 1, 0, 0);
    codeobj_7a0155ee18f90fe4fffc56c025b25370 = MAKE_CODEOBJECT(module_filename_obj, 643, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS, const_str_plain_explode, const_tuple_str_plain_args_str_plain_kwargs_str_plain_error_tuple, 0, 0, 0);
    codeobj_26dc7c955eece9f3eeb0e341a1ceda0b = MAKE_CODEOBJECT(module_filename_obj, 2154, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_export_keying_material, const_tuple_24e396011cc987e1c1e91fc8d67969c7_tuple, 4, 0, 0);
    codeobj_776624edcfa35f9ea528996d05e133ee = MAKE_CODEOBJECT(module_filename_obj, 2468, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_alpn_proto_negotiated, const_tuple_str_plain_self_str_plain_data_len_str_plain_data_tuple, 1, 0, 0);
    codeobj_9d4bbd15181b53f3bd7f364d6e6e4145 = MAKE_CODEOBJECT(module_filename_obj, 1301, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_app_data, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_c7e9dcab9b20e02fc8fa7057fd275f11 = MAKE_CODEOBJECT(module_filename_obj, 2060, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_app_data, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_15a969cf6b2c91b8e511081a7c0a39b6 = MAKE_CODEOBJECT(module_filename_obj, 1318, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_cert_store, const_tuple_str_plain_self_str_plain_pystore_str_plain_store_tuple, 1, 0, 0);
    codeobj_3946b9a412811e47d3779a1e62a72e4b = MAKE_CODEOBJECT(module_filename_obj, 2187, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_certificate, const_tuple_str_plain_self_str_plain_cert_tuple, 1, 0, 0);
    codeobj_eb4e822fd78a70f279bd9df4a597324d = MAKE_CODEOBJECT(module_filename_obj, 2373, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_cipher_bits, const_tuple_str_plain_self_str_plain_cipher_tuple, 1, 0, 0);
    codeobj_dfa471f51052025d0f268f8ce73b5948 = MAKE_CODEOBJECT(module_filename_obj, 2007, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_cipher_list, const_tuple_12babed94f04a9287de33a0a7ed4bbf2_tuple, 1, 0, 0);
    codeobj_5a46eefcdd3d235d3fe799c45ec3726a = MAKE_CODEOBJECT(module_filename_obj, 2356, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_cipher_name, const_tuple_str_plain_self_str_plain_cipher_str_plain_name_tuple, 1, 0, 0);
    codeobj_6fb08a01e4ea72bc52096d7018179add = MAKE_CODEOBJECT(module_filename_obj, 2389, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_cipher_version, const_tuple_str_plain_self_str_plain_cipher_str_plain_version_tuple, 1, 0, 0);
    codeobj_c7007220b0b459514c7b12300a002dc2 = MAKE_CODEOBJECT(module_filename_obj, 2021, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_client_ca_list, const_tuple_40c019df00fadc68e051d5153056e038_tuple, 1, 0, 0);
    codeobj_85b9d973a13dac4e475a6908180fcbd0 = MAKE_CODEOBJECT(module_filename_obj, 1649, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_context, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_729d8bc5b3418129828900f018d231cc = MAKE_CODEOBJECT(module_filename_obj, 2332, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_finished, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_2d525410d7ab181761b0e480a04ac3bb = MAKE_CODEOBJECT(module_filename_obj, 2429, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_next_proto_negotiated, const_tuple_str_plain_self_str_plain_data_len_str_plain_data_tuple, 1, 0, 0);
    codeobj_b0089d377af5c5ab7b6943168bf04c70 = MAKE_CODEOBJECT(module_filename_obj, 2210, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_peer_cert_chain, const_tuple_1bf74246b679aacbbc5982cad038a099_tuple, 1, 0, 0);
    codeobj_3f6bd2362b83f8e85f091e7fc006c6ad = MAKE_CODEOBJECT(module_filename_obj, 2199, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_peer_certificate, const_tuple_str_plain_self_str_plain_cert_tuple, 1, 0, 0);
    codeobj_a54ef0e991ddc5127543496476fffdc2 = MAKE_CODEOBJECT(module_filename_obj, 2344, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_peer_finished, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_190fc2095a8f804515eb5f410b637f5e = MAKE_CODEOBJECT(module_filename_obj, 2418, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_protocol_version, const_tuple_str_plain_self_str_plain_version_tuple, 1, 0, 0);
    codeobj_8a31a568865bc9c9ed09c31a31d8134a = MAKE_CODEOBJECT(module_filename_obj, 2406, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_protocol_version_name, const_tuple_str_plain_self_str_plain_version_tuple, 1, 0, 0);
    codeobj_4b891c2de54665c165f85dce04cb4cb8 = MAKE_CODEOBJECT(module_filename_obj, 1669, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_servername, const_tuple_str_plain_self_str_plain_name_tuple, 1, 0, 0);
    codeobj_52829c318867d59743de899b39d5abac = MAKE_CODEOBJECT(module_filename_obj, 2265, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_session, const_tuple_str_plain_self_str_plain_session_str_plain_pysession_tuple, 1, 0, 0);
    codeobj_5817b5e321e605b5e5aa93bf0883e885 = MAKE_CODEOBJECT(module_filename_obj, 1068, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_session_cache_mode, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_290e9c85751ef278e20a65deeb074f76 = MAKE_CODEOBJECT(module_filename_obj, 2077, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_shutdown, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_096b136f4a3b30d606655f40a0fcb7eb = MAKE_CODEOBJECT(module_filename_obj, 2098, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_state_string, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_01a9999db18bff60965b0449882ec682 = MAKE_CODEOBJECT(module_filename_obj, 1273, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_timeout, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_db4c7bea0bf7206725d167d502c6eba5 = MAKE_CODEOBJECT(module_filename_obj, 1129, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_verify_depth, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_a8347686a3eb5f3ebe1515762b155d4a = MAKE_CODEOBJECT(module_filename_obj, 1120, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_get_verify_mode, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_2d489c67d8f0900c68ccd131eb39b31e = MAKE_CODEOBJECT(module_filename_obj, 1016, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_load_client_ca, const_tuple_str_plain_self_str_plain_cafile_str_plain_ca_list_tuple, 2, 0, 0);
    codeobj_30235f217fa5586477415a9239a3581a = MAKE_CODEOBJECT(module_filename_obj, 1138, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_load_tmp_dh, const_tuple_str_plain_self_str_plain_dhfile_str_plain_bio_str_plain_dh_tuple, 2, 0, 0);
    codeobj_346033c0896bad93f6cf605df224d7cb = MAKE_CODEOBJECT(module_filename_obj, 746, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_load_verify_locations, const_tuple_6f3d7ce791b29c8b2ccceca21130b973_tuple, 3, 0, 0);
    codeobj_433dfad8408328fc74fc1215c9a5f8eb = MAKE_CODEOBJECT(module_filename_obj, 2050, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_NOFREE, const_str_plain_makefile, const_tuple_str_plain_self_str_plain_args_str_plain_kwargs_tuple, 1, 0, 0);
    codeobj_bb87c94112fe99283e7d060ed1328b6e = MAKE_CODEOBJECT(module_filename_obj, 2138, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_master_key, const_tuple_5a901cf5390bbd925e09951ee9017d23_tuple, 1, 0, 0);
    codeobj_b6d73ec0251ecf129f902466d7d1010b = MAKE_CODEOBJECT(module_filename_obj, 1704, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_pending, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_10a2c3fa06ddc8ce7babebf4ab2a34ed = MAKE_CODEOBJECT(module_filename_obj, 284, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_raise_if_problem, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_97860a8503a242ea2870dd155ed6cf25 = MAKE_CODEOBJECT(module_filename_obj, 1777, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_recv, const_tuple_ddbbebd3154d4430c5c187b2eaf912ed_tuple, 3, 0, 0);
    codeobj_be94e691bb77258f38f88be8b8aadc60 = MAKE_CODEOBJECT(module_filename_obj, 1795, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_recv_into, const_tuple_a67b1154f8342873401b8122b6389ba8_tuple, 4, 0, 0);
    codeobj_7028d427820f53c4d1e8a41a379a1710 = MAKE_CODEOBJECT(module_filename_obj, 1894, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_renegotiate, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_d6f61d72394bd98660c5c42254770e72 = MAKE_CODEOBJECT(module_filename_obj, 1917, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_renegotiate_pending, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_cef9c931fd2f28c31ff360c1fa396b8e = MAKE_CODEOBJECT(module_filename_obj, 2486, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_request_ocsp, const_tuple_str_plain_self_str_plain_rc_tuple, 1, 0, 0);
    codeobj_c3dfbb3b28d031b8f3e3ccaa5745dfa1 = MAKE_CODEOBJECT(module_filename_obj, 1713, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_send, const_tuple_59ab6bd6bf9c850fdd6c5d8aae933618_tuple, 3, 0, 0);
    codeobj_b9ad0ac22cd13b3cff0f4d819d0dee45 = MAKE_CODEOBJECT(module_filename_obj, 1741, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_sendall, const_tuple_27b415f5f1545c164c69e92aa878cdf0_tuple, 3, 0, 0);
    codeobj_cbb40621241b7978549d445047800574 = MAKE_CODEOBJECT(module_filename_obj, 2107, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_server_random, const_tuple_5a901cf5390bbd925e09951ee9017d23_tuple, 1, 0, 0);
    codeobj_201bf75d84b5bdea5cfec00b8b8c8ba7 = MAKE_CODEOBJECT(module_filename_obj, 2247, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_accept_state, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_ce17632235d529b0e086bbba8d5f4d69 = MAKE_CODEOBJECT(module_filename_obj, 1434, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_alpn_protos, const_tuple_cf035770f08c8746b05138973d8b64b8_tuple, 2, 0, 0);
    codeobj_c5a3b890d44f3c8acdb96b874e67ae24 = MAKE_CODEOBJECT(module_filename_obj, 2446, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_alpn_protos, const_tuple_cf035770f08c8746b05138973d8b64b8_tuple, 2, 0, 0);
    codeobj_42236c687cf1136b7c7bf18f19fec11f = MAKE_CODEOBJECT(module_filename_obj, 1456, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_alpn_select_callback, const_tuple_str_plain_self_str_plain_callback_tuple, 2, 0, 0);
    codeobj_0a6cc7d4157b03d199984fd3c032b609 = MAKE_CODEOBJECT(module_filename_obj, 1309, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_app_data, const_tuple_str_plain_self_str_plain_data_tuple, 2, 0, 0);
    codeobj_a30e6c3082d13f64248246c7b439f499 = MAKE_CODEOBJECT(module_filename_obj, 2068, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_app_data, const_tuple_str_plain_self_str_plain_data_tuple, 2, 0, 0);
    codeobj_2b3317a29293d550661be41a8c0a9de2 = MAKE_CODEOBJECT(module_filename_obj, 1170, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_cipher_list, const_tuple_str_plain_self_str_plain_cipher_list_str_plain_tmpconn_tuple, 2, 0, 0);
    codeobj_08c15e906deacdd0080dc5380f603678 = MAKE_CODEOBJECT(module_filename_obj, 1202, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_client_ca_list, const_tuple_2fe4e23a8c490304baac2b73b87c6ea5_tuple, 2, 0, 0);
    codeobj_d43339cac2a23168c71e48b85d7e240f = MAKE_CODEOBJECT(module_filename_obj, 2256, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_connect_state, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_b2045a22f86b32602807c3a9b9a1b9a9 = MAKE_CODEOBJECT(module_filename_obj, 1656, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_context, const_tuple_str_plain_self_str_plain_context_tuple, 2, 0, 0);
    codeobj_1eb3a30ea8ff5bbf704361f349f12a12 = MAKE_CODEOBJECT(module_filename_obj, 813, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_default_verify_paths, const_tuple_20d4fe6eb6129b69f70ca0570507a3f9_tuple, 1, 0, 0);
    codeobj_8789032a2a2c430ee61b2a9a442b588d = MAKE_CODEOBJECT(module_filename_obj, 1282, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_info_callback, const_tuple_str_plain_self_str_plain_callback_str_plain_wrapper_tuple, 2, 0, 0);
    codeobj_de42447e718b11e0e561f2def518a1f5 = MAKE_CODEOBJECT(module_filename_obj, 1348, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_mode, const_tuple_str_plain_self_str_plain_mode_tuple, 2, 0, 0);
    codeobj_c82e8c12b8026efc371154571f833311 = MAKE_CODEOBJECT(module_filename_obj, 1397, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_npn_advertise_callback, const_tuple_str_plain_self_str_plain_callback_tuple, 2, 0, 0);
    codeobj_7e20264abef33d5c372261962149019f = MAKE_CODEOBJECT(module_filename_obj, 1416, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_npn_select_callback, const_tuple_str_plain_self_str_plain_callback_tuple, 2, 0, 0);
    codeobj_d67706623e0b60e72dc27ab285eeed79 = MAKE_CODEOBJECT(module_filename_obj, 1510, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_ocsp_client_callback, const_tuple_09a9274d23abfb5c21510ecab74e4636_tuple, 3, 0, 0);
    codeobj_03577ba5881bc60859c4e27b32960700 = MAKE_CODEOBJECT(module_filename_obj, 1492, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_ocsp_server_callback, const_tuple_09a9274d23abfb5c21510ecab74e4636_tuple, 3, 0, 0);
    codeobj_0632cad59439bdd081092e8e08dbc92d = MAKE_CODEOBJECT(module_filename_obj, 1335, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_options, const_tuple_str_plain_self_str_plain_options_tuple, 2, 0, 0);
    codeobj_8f7fd200c22a912bb8feee9fea391456 = MAKE_CODEOBJECT(module_filename_obj, 785, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_passwd_cb, const_tuple_str_plain_self_str_plain_callback_str_plain_userdata_tuple, 3, 0, 0);
    codeobj_486bd2bad33e063a2af794bab2239dd3 = MAKE_CODEOBJECT(module_filename_obj, 2282, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_session, const_tuple_str_plain_self_str_plain_session_str_plain_result_tuple, 2, 0, 0);
    codeobj_c427551e2adf1aa767652146eebdf018 = MAKE_CODEOBJECT(module_filename_obj, 1051, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_session_cache_mode, const_tuple_str_plain_self_str_plain_mode_tuple, 2, 0, 0);
    codeobj_bd9f3e8d092c4130e2f017c3c9cd2b5e = MAKE_CODEOBJECT(module_filename_obj, 1031, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_session_id, const_tuple_str_plain_self_str_plain_buf_tuple, 2, 0, 0);
    codeobj_a79065ffeacdb0a47f1382db19c35f3d = MAKE_CODEOBJECT(module_filename_obj, 2086, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_shutdown, const_tuple_str_plain_self_str_plain_state_tuple, 2, 0, 0);
    codeobj_a709177b545996fdc26d1f69a26d148a = MAKE_CODEOBJECT(module_filename_obj, 1259, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_timeout, const_tuple_str_plain_self_str_plain_timeout_tuple, 2, 0, 0);
    codeobj_e3c8ae13ac9eb0f32a9b6fc044804d84 = MAKE_CODEOBJECT(module_filename_obj, 1687, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_tlsext_host_name, const_tuple_str_plain_self_str_plain_name_tuple, 2, 0, 0);
    codeobj_bfea99648ca6c20c83b6bfd2c85611c5 = MAKE_CODEOBJECT(module_filename_obj, 1361, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_tlsext_servername_callback, const_tuple_str_plain_self_str_plain_callback_str_plain_wrapper_tuple, 2, 0, 0);
    codeobj_d8df85ffb933c241e379fed2d072ff49 = MAKE_CODEOBJECT(module_filename_obj, 1382, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_tlsext_use_srtp, const_tuple_str_plain_self_str_plain_profiles_tuple, 2, 0, 0);
    codeobj_4617788626982375adc8761ce194469c = MAKE_CODEOBJECT(module_filename_obj, 1158, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_tmp_ecdh, const_tuple_str_plain_self_str_plain_curve_tuple, 2, 0, 0);
    codeobj_c067e3d1636e863e171637342c310c8c = MAKE_CODEOBJECT(module_filename_obj, 1078, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_verify, const_tuple_str_plain_self_str_plain_mode_str_plain_callback_tuple, 3, 0, 0);
    codeobj_df923127bdb888edf2c0aee9d730721d = MAKE_CODEOBJECT(module_filename_obj, 1107, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_verify_depth, const_tuple_str_plain_self_str_plain_depth_tuple, 2, 0, 0);
    codeobj_6f36c0fa3d59052efa6a916f18f6c1e1 = MAKE_CODEOBJECT(module_filename_obj, 1990, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_shutdown, const_tuple_str_plain_self_str_plain_result_tuple, 1, 0, 0);
    codeobj_0a0cad4a67aba10eabe93e57ee235747 = MAKE_CODEOBJECT(module_filename_obj, 2178, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_NOFREE, const_str_plain_sock_shutdown, const_tuple_str_plain_self_str_plain_args_str_plain_kwargs_tuple, 1, 0, 0);
    codeobj_0fadfadb8bb4516eed76800a79e9a7f7 = MAKE_CODEOBJECT(module_filename_obj, 1927, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_total_renegotiations, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_1a8dfef65194129bda154b5d5d19c988 = MAKE_CODEOBJECT(module_filename_obj, 932, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_use_certificate, const_tuple_str_plain_self_str_plain_cert_str_plain_use_result_tuple, 2, 0, 0);
    codeobj_1dc98b765f924dc15a85607868c9dcc9 = MAKE_CODEOBJECT(module_filename_obj, 893, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_use_certificate_chain_file, const_tuple_str_plain_self_str_plain_certfile_str_plain_result_tuple, 2, 0, 0);
    codeobj_29af76d76b7406a6693f5b340243209e = MAKE_CODEOBJECT(module_filename_obj, 910, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_use_certificate_file, const_tuple_70adcf8f254ece362639433ee96fdafb_tuple, 3, 0, 0);
    codeobj_5e575d8ecc92ab2025e10ae05258d327 = MAKE_CODEOBJECT(module_filename_obj, 992, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_use_privatekey, const_tuple_str_plain_self_str_plain_pkey_str_plain_use_result_tuple, 2, 0, 0);
    codeobj_c9eaa039e52a2d0cfe9a9fd0371f8a5f = MAKE_CODEOBJECT(module_filename_obj, 969, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_use_privatekey_file, const_tuple_70b3e830bf27ee786cecd70f5eebc82a_tuple, 3, 0, 0);
    codeobj_c34dc8d8e69e96a1fdc1da393173e7eb = MAKE_CODEOBJECT(module_filename_obj, 2229, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_want_read, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_f69b17c8965a6426ab8e389546eeab2c = MAKE_CODEOBJECT(module_filename_obj, 2238, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_want_write, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_3ca30ec9f4bb68c7995e4dc075f1f8aa = MAKE_CODEOBJECT(module_filename_obj, 306, CO_OPTIMIZED | CO_NEWLOCALS, const_str_plain_wrapper, const_tuple_fb64e812782e9f70f19909e310070a01_tuple, 2, 0, 0);
    codeobj_a9047c1bce52ef36545c3c95123c1a6f = MAKE_CODEOBJECT(module_filename_obj, 779, CO_OPTIMIZED | CO_NEWLOCALS, const_str_plain_wrapper, const_tuple_3ac1ec4ea6ba07372fe57d858ff0148f_tuple, 3, 0, 0);
    codeobj_ce0f4a68c73e09b427efa61d82289d07 = MAKE_CODEOBJECT(module_filename_obj, 1372, CO_OPTIMIZED | CO_NEWLOCALS, const_str_plain_wrapper, const_tuple_7e6126bff16a8a76a713850dcb042242_tuple, 3, 0, 0);
    codeobj_cd50f2607dc6e8cfc0715ef171ecbc55 = MAKE_CODEOBJECT(module_filename_obj, 502, CO_OPTIMIZED | CO_NEWLOCALS, const_str_plain_wrapper, const_tuple_f85e0b49580abdb5d9ebc1ace31ffe3d_tuple, 2, 0, 0);
    codeobj_6dbabe0cc3fa56b737c573ecdbbbc1cc = MAKE_CODEOBJECT(module_filename_obj, 569, CO_OPTIMIZED | CO_NEWLOCALS, const_str_plain_wrapper, const_tuple_617fe238ea11ea0890ce2460de3bd68e_tuple, 2, 0, 0);
    codeobj_8b48c52cd2db4623bd0576fa41e4cfa3 = MAKE_CODEOBJECT(module_filename_obj, 344, CO_OPTIMIZED | CO_NEWLOCALS, const_str_plain_wrapper, const_tuple_22496b7900b49af1635f455cd8f3e9ef_tuple, 4, 0, 0);
    codeobj_1f66bae567fc069e7269625d4e4a775a = MAKE_CODEOBJECT(module_filename_obj, 434, CO_OPTIMIZED | CO_NEWLOCALS, const_str_plain_wrapper, const_tuple_8f082d20432d2aa73d41a80627094b27_tuple, 6, 0, 0);
    codeobj_0228e96ca7a03ca447fc3f1bfe3f2f29 = MAKE_CODEOBJECT(module_filename_obj, 385, CO_OPTIMIZED | CO_NEWLOCALS, const_str_plain_wrapper, const_tuple_6740a501bdf22f33fca4ec6a09ab8a62_tuple, 6, 0, 0);
    codeobj_a732a29d3f3e6b4a55e2a24a6a2d57ce = MAKE_CODEOBJECT(module_filename_obj, 1294, CO_OPTIMIZED | CO_NEWLOCALS, const_str_plain_wrapper, const_tuple_78e460fdd8266d432328f4bff5207c29_tuple, 3, 0, 0);
}

// The module function declarations.
static PyObject *OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper$$$genexpr_1_genexpr_maker(void);


static PyObject *OpenSSL$SSL$$$genexpr_1_genexpr_maker(void);


static PyObject *OpenSSL$SSL$$$function_52_set_alpn_protos$$$genexpr_1_genexpr_maker(void);


static PyObject *OpenSSL$SSL$$$function_112_set_alpn_protos$$$genexpr_1_genexpr_maker(void);


NUITKA_CROSS_MODULE PyObject *impl___internal__$$$function_1_complex_call_helper_star_list_star_dict(PyObject **python_pars);


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_100_set_connect_state();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_101_get_session();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_102_set_session();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_103__get_finished_message();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_104_get_finished();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_105_get_peer_finished();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_106_get_cipher_name();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_107_get_cipher_bits();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_108_get_cipher_version();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_109_get_protocol_version_name();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_10_SSLeay_version();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_110_get_protocol_version();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_111_get_next_proto_negotiated();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_112_set_alpn_protos();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_113_get_alpn_proto_negotiated();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_114_request_ocsp();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_11__make_requires();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_11__make_requires$$$function_1__requires_decorator();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_11__make_requires$$$function_1__requires_decorator$$$function_1_explode();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_12___init__();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_13_load_verify_locations(PyObject *defaults);


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_14__wrap_callback();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_14__wrap_callback$$$function_1_wrapper();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_15_set_passwd_cb(PyObject *defaults);


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_16_set_default_verify_paths();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_17__check_env_vars_set();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_18__fallback_default_verify_paths();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_19_use_certificate_chain_file();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_1___init__();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_20_use_certificate_file(PyObject *defaults);


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_21_use_certificate();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_22_add_extra_chain_cert();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_23__raise_passphrase_exception();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_24_use_privatekey_file(PyObject *defaults);


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_25_use_privatekey();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_26_check_privatekey();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_27_load_client_ca();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_28_set_session_id();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_29_set_session_cache_mode();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_2_raise_if_problem();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_30_get_session_cache_mode();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_31_set_verify();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_32_set_verify_depth();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_33_get_verify_mode();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_34_get_verify_depth();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_35_load_tmp_dh();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_36_set_tmp_ecdh();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_37_set_cipher_list();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_38_set_client_ca_list();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_39_add_client_ca();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_3___init__();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_3___init__$$$function_1_wrapper();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_40_set_timeout();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_41_get_timeout();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_42_set_info_callback();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_42_set_info_callback$$$function_1_wrapper();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_43_get_app_data();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_44_set_app_data();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_45_get_cert_store();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_46_set_options();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_47_set_mode();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_48_set_tlsext_servername_callback();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_48_set_tlsext_servername_callback$$$function_1_wrapper();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_49_set_tlsext_use_srtp();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_4___init__();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_50_set_npn_advertise_callback();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_51_set_npn_select_callback();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_52_set_alpn_protos();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_53_set_alpn_select_callback();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_54__set_ocsp_callback();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_55_set_ocsp_server_callback(PyObject *defaults);


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_56_set_ocsp_client_callback(PyObject *defaults);


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_57___init__(PyObject *defaults);


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_58___getattr__();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_59__raise_ssl_error();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_5___init__();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_5___init__$$$function_1_wrapper();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_60_get_context();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_61_set_context();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_62_get_servername();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_63_set_tlsext_host_name();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_64_pending();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_65_send(PyObject *defaults);


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_66_sendall(PyObject *defaults);


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_67_recv(PyObject *defaults);


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_68_recv_into(PyObject *defaults);


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_69__handle_bio_errors();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_6___init__();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_6___init__$$$function_1_wrapper();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_70_bio_read();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_71_bio_write();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_72_renegotiate();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_73_do_handshake();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_74_renegotiate_pending();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_75_total_renegotiations();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_76_connect();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_77_connect_ex();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_78_accept();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_79_bio_shutdown();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_7___init__();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_7___init__$$$function_1_wrapper();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_80_shutdown();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_81_get_cipher_list();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_82_get_client_ca_list();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_83_makefile();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_84_get_app_data();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_85_set_app_data();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_86_get_shutdown();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_87_set_shutdown();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_88_get_state_string();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_89_server_random();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_8___init__();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_8___init__$$$function_1_wrapper();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_90_client_random();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_91_master_key();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_92_export_keying_material(PyObject *defaults);


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_93_sock_shutdown();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_94_get_certificate();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_95_get_peer_certificate();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_96_get_peer_cert_chain();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_97_want_read();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_98_want_write();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_99_set_accept_state();


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_9__asFileDescriptor();


// The module function definitions.
static PyObject *impl_OpenSSL$SSL$$$function_1___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_0ab1750369bb8d45abc70b759d692236;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_0ab1750369bb8d45abc70b759d692236 = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_0ab1750369bb8d45abc70b759d692236, codeobj_0ab1750369bb8d45abc70b759d692236, module_OpenSSL$SSL, sizeof(void *));
    frame_0ab1750369bb8d45abc70b759d692236 = cache_frame_0ab1750369bb8d45abc70b759d692236;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_0ab1750369bb8d45abc70b759d692236);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_0ab1750369bb8d45abc70b759d692236) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        tmp_assattr_name_1 = PyList_New(0);
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__problems, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 282;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0ab1750369bb8d45abc70b759d692236);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0ab1750369bb8d45abc70b759d692236);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_0ab1750369bb8d45abc70b759d692236, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_0ab1750369bb8d45abc70b759d692236->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_0ab1750369bb8d45abc70b759d692236, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0ab1750369bb8d45abc70b759d692236,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_0ab1750369bb8d45abc70b759d692236 == cache_frame_0ab1750369bb8d45abc70b759d692236) {
        Py_DECREF(frame_0ab1750369bb8d45abc70b759d692236);
    }
    cache_frame_0ab1750369bb8d45abc70b759d692236 = NULL;

    assertFrameObject(frame_0ab1750369bb8d45abc70b759d692236);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_1___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_2_raise_if_problem(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_10a2c3fa06ddc8ce7babebf4ab2a34ed;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_10a2c3fa06ddc8ce7babebf4ab2a34ed = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_10a2c3fa06ddc8ce7babebf4ab2a34ed, codeobj_10a2c3fa06ddc8ce7babebf4ab2a34ed, module_OpenSSL$SSL, sizeof(void *));
    frame_10a2c3fa06ddc8ce7babebf4ab2a34ed = cache_frame_10a2c3fa06ddc8ce7babebf4ab2a34ed;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_10a2c3fa06ddc8ce7babebf4ab2a34ed);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_10a2c3fa06ddc8ce7babebf4ab2a34ed) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_attribute_value_1;
        int tmp_truth_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_attribute_value_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__problems);
        if (tmp_attribute_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 289;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE(tmp_attribute_value_1);
        if (tmp_truth_name_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_attribute_value_1);

            exception_lineno = 289;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_attribute_value_1);
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        // Tried code:
        {
            PyObject *tmp_called_name_1;
            PyObject *tmp_mvar_value_1;
            PyObject *tmp_call_result_1;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error);

            if (unlikely(tmp_mvar_value_1 == NULL)) {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error);
            }

            if (tmp_mvar_value_1 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 0 ], 49, 0);
                exception_tb = NULL;

                exception_lineno = 291;
                type_description_1 = "o";
                goto try_except_handler_1;
            }

            tmp_called_name_1 = tmp_mvar_value_1;
            frame_10a2c3fa06ddc8ce7babebf4ab2a34ed->m_frame.f_lineno = 291;
            tmp_call_result_1 = CALL_FUNCTION_NO_ARGS(tmp_called_name_1);
            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 291;
                type_description_1 = "o";
                goto try_except_handler_1;
            }
            Py_DECREF(tmp_call_result_1);
        }
        goto try_end_1;
        // Exception handler code:
        try_except_handler_1:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Preserve existing published exception.
        PRESERVE_FRAME_EXCEPTION(frame_10a2c3fa06ddc8ce7babebf4ab2a34ed);
        if (exception_keeper_tb_1 == NULL) {
            exception_keeper_tb_1 = MAKE_TRACEBACK(frame_10a2c3fa06ddc8ce7babebf4ab2a34ed, exception_keeper_lineno_1);
        } else if (exception_keeper_lineno_1 != 0) {
            exception_keeper_tb_1 = ADD_TRACEBACK(exception_keeper_tb_1, frame_10a2c3fa06ddc8ce7babebf4ab2a34ed, exception_keeper_lineno_1);
        }

        NORMALIZE_EXCEPTION(&exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1);
        PUBLISH_EXCEPTION(&exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1);
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_operand_name_1;
            PyObject *tmp_compexpr_left_1;
            PyObject *tmp_compexpr_right_1;
            PyObject *tmp_mvar_value_2;
            tmp_compexpr_left_1 = EXC_TYPE(PyThreadState_GET());
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Error);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_Error);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 49 ], 34, 0);
                exception_tb = NULL;

                exception_lineno = 292;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_1 = tmp_mvar_value_2;
            tmp_res = EXCEPTION_MATCH_BOOL(tmp_compexpr_left_1, tmp_compexpr_right_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 292;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 292;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
                goto branch_yes_2;
            } else {
                goto branch_no_2;
            }
            branch_yes_2:;
            tmp_result = RERAISE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            if (unlikely(tmp_result == false)) {
                exception_lineno = 290;
            }

            if (exception_tb && exception_tb->tb_frame == &frame_10a2c3fa06ddc8ce7babebf4ab2a34ed->m_frame) frame_10a2c3fa06ddc8ce7babebf4ab2a34ed->m_frame.f_lineno = exception_tb->tb_lineno;
            type_description_1 = "o";
            goto frame_exception_exit_1;
            branch_no_2:;
        }
        goto try_end_1;
        // exception handler codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_2_raise_if_problem);
        return NULL;
        // End of try:
        try_end_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_source_name_2;
            CHECK_OBJECT(par_self);
            tmp_source_name_2 = par_self;
            tmp_called_instance_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__problems);
            if (tmp_called_instance_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 294;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            frame_10a2c3fa06ddc8ce7babebf4ab2a34ed->m_frame.f_lineno = 294;
            tmp_raise_type_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_pop, &PyTuple_GET_ITEM(const_tuple_int_0_tuple, 0));

            Py_DECREF(tmp_called_instance_1);
            if (tmp_raise_type_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 294;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            exception_type = tmp_raise_type_1;
            exception_lineno = 294;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }

#if 1
    RESTORE_FRAME_EXCEPTION(frame_10a2c3fa06ddc8ce7babebf4ab2a34ed);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION(frame_10a2c3fa06ddc8ce7babebf4ab2a34ed);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_10a2c3fa06ddc8ce7babebf4ab2a34ed, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_10a2c3fa06ddc8ce7babebf4ab2a34ed->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_10a2c3fa06ddc8ce7babebf4ab2a34ed, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_10a2c3fa06ddc8ce7babebf4ab2a34ed,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_10a2c3fa06ddc8ce7babebf4ab2a34ed == cache_frame_10a2c3fa06ddc8ce7babebf4ab2a34ed) {
        Py_DECREF(frame_10a2c3fa06ddc8ce7babebf4ab2a34ed);
    }
    cache_frame_10a2c3fa06ddc8ce7babebf4ab2a34ed = NULL;

    assertFrameObject(frame_10a2c3fa06ddc8ce7babebf4ab2a34ed);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_2_raise_if_problem);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_3___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1(python_pars[0]);
    struct Nuitka_CellObject *par_callback = PyCell_NEW1(python_pars[1]);
    PyObject *var_wrapper = NULL;
    struct Nuitka_FrameObject *frame_4708bc94e7cf08ee5e04fb7dbacf1bd1;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_4708bc94e7cf08ee5e04fb7dbacf1bd1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_4708bc94e7cf08ee5e04fb7dbacf1bd1, codeobj_4708bc94e7cf08ee5e04fb7dbacf1bd1, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_4708bc94e7cf08ee5e04fb7dbacf1bd1 = cache_frame_4708bc94e7cf08ee5e04fb7dbacf1bd1;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_4708bc94e7cf08ee5e04fb7dbacf1bd1);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_4708bc94e7cf08ee5e04fb7dbacf1bd1) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 83 ], 53, 0);
            exception_tb = NULL;

            exception_lineno = 304;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT(PyCell_GET(par_self));
        tmp_args_element_name_1 = PyCell_GET(par_self);
        frame_4708bc94e7cf08ee5e04fb7dbacf1bd1->m_frame.f_lineno = 304;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain___init__, call_args);
        }

        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 304;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_wraps);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_wraps);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 136 ], 34, 0);
            exception_tb = NULL;

            exception_lineno = 306;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT(PyCell_GET(par_callback));
        tmp_args_element_name_2 = PyCell_GET(par_callback);
        frame_4708bc94e7cf08ee5e04fb7dbacf1bd1->m_frame.f_lineno = 306;
        tmp_called_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_2);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 306;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = MAKE_FUNCTION_OpenSSL$SSL$$$function_3___init__$$$function_1_wrapper();

        ((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[0] = par_callback;
        Py_INCREF(((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[0]);
        ((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[1] = par_self;
        Py_INCREF(((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[1]);


        frame_4708bc94e7cf08ee5e04fb7dbacf1bd1->m_frame.f_lineno = 306;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_3);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 306;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        assert(var_wrapper == NULL);
        var_wrapper = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 332;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_3;
        tmp_args_element_name_4 = const_str_digest_aa8d23211c54bc521e23e53a6e431cd2;
        CHECK_OBJECT(var_wrapper);
        tmp_args_element_name_5 = var_wrapper;
        frame_4708bc94e7cf08ee5e04fb7dbacf1bd1->m_frame.f_lineno = 332;
        {
            PyObject *call_args[] = {tmp_args_element_name_4, tmp_args_element_name_5};
            tmp_assattr_name_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_2, const_str_plain_callback, call_args);
        }

        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 332;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(PyCell_GET(par_self));
        tmp_assattr_target_1 = PyCell_GET(par_self);
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain_callback, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 332;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_4708bc94e7cf08ee5e04fb7dbacf1bd1);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_4708bc94e7cf08ee5e04fb7dbacf1bd1);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_4708bc94e7cf08ee5e04fb7dbacf1bd1, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_4708bc94e7cf08ee5e04fb7dbacf1bd1->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_4708bc94e7cf08ee5e04fb7dbacf1bd1, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4708bc94e7cf08ee5e04fb7dbacf1bd1,
        type_description_1,
        par_self,
        par_callback,
        var_wrapper
    );


    // Release cached frame.
    if (frame_4708bc94e7cf08ee5e04fb7dbacf1bd1 == cache_frame_4708bc94e7cf08ee5e04fb7dbacf1bd1) {
        Py_DECREF(frame_4708bc94e7cf08ee5e04fb7dbacf1bd1);
    }
    cache_frame_4708bc94e7cf08ee5e04fb7dbacf1bd1 = NULL;

    assertFrameObject(frame_4708bc94e7cf08ee5e04fb7dbacf1bd1);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_3___init__);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_wrapper);
    Py_DECREF(var_wrapper);
    var_wrapper = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_wrapper);
    var_wrapper = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_3___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_callback);
    Py_DECREF(par_callback);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_callback);
    Py_DECREF(par_callback);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_3___init__$$$function_1_wrapper(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_ok = python_pars[0];
    PyObject *par_store_ctx = python_pars[1];
    PyObject *var_index = NULL;
    PyObject *var_error_number = NULL;
    PyObject *var_x509 = NULL;
    PyObject *var_connection = NULL;
    PyObject *var_ssl = NULL;
    PyObject *var_cert = NULL;
    PyObject *var_result = NULL;
    PyObject *var_error_depth = NULL;
    PyObject *var_e = NULL;
    struct Nuitka_FrameObject *frame_3ca30ec9f4bb68c7995e4dc075f1f8aa;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_3ca30ec9f4bb68c7995e4dc075f1f8aa = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_3ca30ec9f4bb68c7995e4dc075f1f8aa, codeobj_3ca30ec9f4bb68c7995e4dc075f1f8aa, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_3ca30ec9f4bb68c7995e4dc075f1f8aa = cache_frame_3ca30ec9f4bb68c7995e4dc075f1f8aa;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_3ca30ec9f4bb68c7995e4dc075f1f8aa);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_3ca30ec9f4bb68c7995e4dc075f1f8aa) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 308;
            type_description_1 = "oooococoooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT(par_store_ctx);
        tmp_args_element_name_1 = par_store_ctx;
        frame_3ca30ec9f4bb68c7995e4dc075f1f8aa->m_frame.f_lineno = 308;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_X509_STORE_CTX_get_current_cert, call_args);
        }

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 308;
            type_description_1 = "oooococoooooo";
            goto frame_exception_exit_1;
        }
        assert(var_x509 == NULL);
        var_x509 = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 309;
            type_description_1 = "oooococoooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_2;
        CHECK_OBJECT(var_x509);
        tmp_args_element_name_2 = var_x509;
        frame_3ca30ec9f4bb68c7995e4dc075f1f8aa->m_frame.f_lineno = 309;
        {
            PyObject *call_args[] = {tmp_args_element_name_2};
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_X509_up_ref, call_args);
        }

        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 309;
            type_description_1 = "oooococoooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 236 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 310;
            type_description_1 = "oooococoooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_3 = tmp_mvar_value_3;
        CHECK_OBJECT(var_x509);
        tmp_args_element_name_3 = var_x509;
        frame_3ca30ec9f4bb68c7995e4dc075f1f8aa->m_frame.f_lineno = 310;
        {
            PyObject *call_args[] = {tmp_args_element_name_3};
            tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_3, const_str_plain__from_raw_x509_ptr, call_args);
        }

        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 310;
            type_description_1 = "oooococoooooo";
            goto frame_exception_exit_1;
        }
        assert(var_cert == NULL);
        var_cert = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_instance_4;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 311;
            type_description_1 = "oooococoooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_4 = tmp_mvar_value_4;
        CHECK_OBJECT(par_store_ctx);
        tmp_args_element_name_4 = par_store_ctx;
        frame_3ca30ec9f4bb68c7995e4dc075f1f8aa->m_frame.f_lineno = 311;
        {
            PyObject *call_args[] = {tmp_args_element_name_4};
            tmp_assign_source_3 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_4, const_str_plain_X509_STORE_CTX_get_error, call_args);
        }

        if (tmp_assign_source_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 311;
            type_description_1 = "oooococoooooo";
            goto frame_exception_exit_1;
        }
        assert(var_error_number == NULL);
        var_error_number = tmp_assign_source_3;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_instance_5;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_5;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 312;
            type_description_1 = "oooococoooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_5 = tmp_mvar_value_5;
        CHECK_OBJECT(par_store_ctx);
        tmp_args_element_name_5 = par_store_ctx;
        frame_3ca30ec9f4bb68c7995e4dc075f1f8aa->m_frame.f_lineno = 312;
        {
            PyObject *call_args[] = {tmp_args_element_name_5};
            tmp_assign_source_4 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_5, const_str_plain_X509_STORE_CTX_get_error_depth, call_args);
        }

        if (tmp_assign_source_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 312;
            type_description_1 = "oooococoooooo";
            goto frame_exception_exit_1;
        }
        assert(var_error_depth == NULL);
        var_error_depth = tmp_assign_source_4;
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_called_instance_6;
        PyObject *tmp_mvar_value_6;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_6 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 314;
            type_description_1 = "oooococoooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_6 = tmp_mvar_value_6;
        frame_3ca30ec9f4bb68c7995e4dc075f1f8aa->m_frame.f_lineno = 314;
        tmp_assign_source_5 = CALL_METHOD_NO_ARGS(tmp_called_instance_6, const_str_plain_SSL_get_ex_data_X509_STORE_CTX_idx);
        if (tmp_assign_source_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 314;
            type_description_1 = "oooococoooooo";
            goto frame_exception_exit_1;
        }
        assert(var_index == NULL);
        var_index = tmp_assign_source_5;
    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_called_instance_7;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_args_element_name_7;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_7 == NULL)) {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_7 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 315;
            type_description_1 = "oooococoooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_7 = tmp_mvar_value_7;
        CHECK_OBJECT(par_store_ctx);
        tmp_args_element_name_6 = par_store_ctx;
        CHECK_OBJECT(var_index);
        tmp_args_element_name_7 = var_index;
        frame_3ca30ec9f4bb68c7995e4dc075f1f8aa->m_frame.f_lineno = 315;
        {
            PyObject *call_args[] = {tmp_args_element_name_6, tmp_args_element_name_7};
            tmp_assign_source_6 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_7, const_str_plain_X509_STORE_CTX_get_ex_data, call_args);
        }

        if (tmp_assign_source_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 315;
            type_description_1 = "oooococoooooo";
            goto frame_exception_exit_1;
        }
        assert(var_ssl == NULL);
        var_ssl = tmp_assign_source_6;
    }
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_subscript_name_1;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Connection);

        if (unlikely(tmp_mvar_value_8 == NULL)) {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_Connection);
        }

        if (tmp_mvar_value_8 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 269 ], 39, 0);
            exception_tb = NULL;

            exception_lineno = 316;
            type_description_1 = "oooococoooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_8;
        tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__reverse_mapping);
        if (tmp_subscribed_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 316;
            type_description_1 = "oooococoooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_ssl);
        tmp_subscript_name_1 = var_ssl;
        tmp_assign_source_7 = LOOKUP_SUBSCRIPT(tmp_subscribed_name_1, tmp_subscript_name_1);
        Py_DECREF(tmp_subscribed_name_1);
        if (tmp_assign_source_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 316;
            type_description_1 = "oooococoooooo";
            goto frame_exception_exit_1;
        }
        assert(var_connection == NULL);
        var_connection = tmp_assign_source_7;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_8;
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_args_element_name_11;
        PyObject *tmp_args_element_name_12;
        if (PyCell_GET(self->m_closure[0]) == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "callback");
            exception_tb = NULL;

            exception_lineno = 319;
            type_description_1 = "oooococoooooo";
            goto try_except_handler_2;
        }

        tmp_called_name_1 = PyCell_GET(self->m_closure[0]);
        CHECK_OBJECT(var_connection);
        tmp_args_element_name_8 = var_connection;
        CHECK_OBJECT(var_cert);
        tmp_args_element_name_9 = var_cert;
        CHECK_OBJECT(var_error_number);
        tmp_args_element_name_10 = var_error_number;
        CHECK_OBJECT(var_error_depth);
        tmp_args_element_name_11 = var_error_depth;
        CHECK_OBJECT(par_ok);
        tmp_args_element_name_12 = par_ok;
        frame_3ca30ec9f4bb68c7995e4dc075f1f8aa->m_frame.f_lineno = 319;
        {
            PyObject *call_args[] = {tmp_args_element_name_8, tmp_args_element_name_9, tmp_args_element_name_10, tmp_args_element_name_11, tmp_args_element_name_12};
            tmp_assign_source_8 = CALL_FUNCTION_WITH_ARGS5(tmp_called_name_1, call_args);
        }

        if (tmp_assign_source_8 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 319;
            type_description_1 = "oooococoooooo";
            goto try_except_handler_2;
        }
        assert(var_result == NULL);
        var_result = tmp_assign_source_8;
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION(frame_3ca30ec9f4bb68c7995e4dc075f1f8aa);
    if (exception_keeper_tb_1 == NULL) {
        exception_keeper_tb_1 = MAKE_TRACEBACK(frame_3ca30ec9f4bb68c7995e4dc075f1f8aa, exception_keeper_lineno_1);
    } else if (exception_keeper_lineno_1 != 0) {
        exception_keeper_tb_1 = ADD_TRACEBACK(exception_keeper_tb_1, frame_3ca30ec9f4bb68c7995e4dc075f1f8aa, exception_keeper_lineno_1);
    }

    NORMALIZE_EXCEPTION(&exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1);
    PUBLISH_EXCEPTION(&exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1);
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_compexpr_left_1 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_1 = PyExc_Exception;
        tmp_res = EXCEPTION_MATCH_BOOL(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 322;
            type_description_1 = "oooococoooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_9;
            tmp_assign_source_9 = EXC_VALUE(PyThreadState_GET());
            assert(var_e == NULL);
            Py_INCREF(tmp_assign_source_9);
            var_e = tmp_assign_source_9;
        }
        {
            PyObject *tmp_called_instance_8;
            PyObject *tmp_source_name_2;
            PyObject *tmp_call_result_2;
            PyObject *tmp_args_element_name_13;
            if (PyCell_GET(self->m_closure[1]) == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = PyString_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "self");
                exception_tb = NULL;

                exception_lineno = 323;
                type_description_1 = "oooococoooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_2 = PyCell_GET(self->m_closure[1]);
            tmp_called_instance_8 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__problems);
            if (tmp_called_instance_8 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 323;
                type_description_1 = "oooococoooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_e);
            tmp_args_element_name_13 = var_e;
            frame_3ca30ec9f4bb68c7995e4dc075f1f8aa->m_frame.f_lineno = 323;
            {
                PyObject *call_args[] = {tmp_args_element_name_13};
                tmp_call_result_2 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_8, const_str_plain_append, call_args);
            }

            Py_DECREF(tmp_called_instance_8);
            if (tmp_call_result_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 323;
                type_description_1 = "oooococoooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_2);
        }
        tmp_return_value = const_int_0;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        goto branch_end_1;
        branch_no_1:;
        tmp_result = RERAISE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
        if (unlikely(tmp_result == false)) {
            exception_lineno = 318;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_3ca30ec9f4bb68c7995e4dc075f1f8aa->m_frame) frame_3ca30ec9f4bb68c7995e4dc075f1f8aa->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "oooococoooooo";
        goto frame_exception_exit_1;
        branch_end_1:;
    }
    // End of try:
    try_end_1:;
    {
        nuitka_bool tmp_condition_result_2;
        int tmp_truth_name_1;
        CHECK_OBJECT(var_result);
        tmp_truth_name_1 = CHECK_IF_TRUE(var_result);
        if (tmp_truth_name_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 326;
            type_description_1 = "oooococoooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_3;
            PyObject *tmp_mvar_value_9;
            PyObject *tmp_call_result_3;
            PyObject *tmp_args_element_name_14;
            PyObject *tmp_args_element_name_15;
            PyObject *tmp_source_name_4;
            PyObject *tmp_mvar_value_10;
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_9 == NULL)) {
                tmp_mvar_value_9 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_9 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 327;
                type_description_1 = "oooococoooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_3 = tmp_mvar_value_9;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_X509_STORE_CTX_set_error);
            if (tmp_called_name_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 327;
                type_description_1 = "oooococoooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(par_store_ctx);
            tmp_args_element_name_14 = par_store_ctx;
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_10 == NULL)) {
                tmp_mvar_value_10 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_10 == NULL) {
                Py_DECREF(tmp_called_name_2);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 327;
                type_description_1 = "oooococoooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_4 = tmp_mvar_value_10;
            tmp_args_element_name_15 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_X509_V_OK);
            if (tmp_args_element_name_15 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_2);

                exception_lineno = 327;
                type_description_1 = "oooococoooooo";
                goto frame_exception_exit_1;
            }
            frame_3ca30ec9f4bb68c7995e4dc075f1f8aa->m_frame.f_lineno = 327;
            {
                PyObject *call_args[] = {tmp_args_element_name_14, tmp_args_element_name_15};
                tmp_call_result_3 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
            }

            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_15);
            if (tmp_call_result_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 327;
                type_description_1 = "oooococoooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_3);
        }
        tmp_return_value = const_int_pos_1;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        goto branch_end_2;
        branch_no_2:;
        tmp_return_value = const_int_0;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_end_2:;
    }

#if 1
    RESTORE_FRAME_EXCEPTION(frame_3ca30ec9f4bb68c7995e4dc075f1f8aa);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION(frame_3ca30ec9f4bb68c7995e4dc075f1f8aa);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION(frame_3ca30ec9f4bb68c7995e4dc075f1f8aa);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_3ca30ec9f4bb68c7995e4dc075f1f8aa, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_3ca30ec9f4bb68c7995e4dc075f1f8aa->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_3ca30ec9f4bb68c7995e4dc075f1f8aa, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3ca30ec9f4bb68c7995e4dc075f1f8aa,
        type_description_1,
        par_ok,
        par_store_ctx,
        var_index,
        var_error_number,
        self->m_closure[0],
        var_x509,
        self->m_closure[1],
        var_connection,
        var_ssl,
        var_cert,
        var_result,
        var_error_depth,
        var_e
    );


    // Release cached frame.
    if (frame_3ca30ec9f4bb68c7995e4dc075f1f8aa == cache_frame_3ca30ec9f4bb68c7995e4dc075f1f8aa) {
        Py_DECREF(frame_3ca30ec9f4bb68c7995e4dc075f1f8aa);
    }
    cache_frame_3ca30ec9f4bb68c7995e4dc075f1f8aa = NULL;

    assertFrameObject(frame_3ca30ec9f4bb68c7995e4dc075f1f8aa);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_3___init__$$$function_1_wrapper);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_index);
    Py_DECREF(var_index);
    var_index = NULL;

    CHECK_OBJECT((PyObject *)var_error_number);
    Py_DECREF(var_error_number);
    var_error_number = NULL;

    CHECK_OBJECT((PyObject *)var_x509);
    Py_DECREF(var_x509);
    var_x509 = NULL;

    CHECK_OBJECT((PyObject *)var_connection);
    Py_DECREF(var_connection);
    var_connection = NULL;

    CHECK_OBJECT((PyObject *)var_ssl);
    Py_DECREF(var_ssl);
    var_ssl = NULL;

    CHECK_OBJECT((PyObject *)var_cert);
    Py_DECREF(var_cert);
    var_cert = NULL;

    Py_XDECREF(var_result);
    var_result = NULL;

    CHECK_OBJECT((PyObject *)var_error_depth);
    Py_DECREF(var_error_depth);
    var_error_depth = NULL;

    Py_XDECREF(var_e);
    var_e = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_index);
    var_index = NULL;

    Py_XDECREF(var_error_number);
    var_error_number = NULL;

    Py_XDECREF(var_x509);
    var_x509 = NULL;

    Py_XDECREF(var_connection);
    var_connection = NULL;

    Py_XDECREF(var_ssl);
    var_ssl = NULL;

    Py_XDECREF(var_cert);
    var_cert = NULL;

    Py_XDECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_error_depth);
    var_error_depth = NULL;

    Py_XDECREF(var_e);
    var_e = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_3___init__$$$function_1_wrapper);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_ok);
    Py_DECREF(par_ok);
    CHECK_OBJECT(par_store_ctx);
    Py_DECREF(par_store_ctx);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_ok);
    Py_DECREF(par_ok);
    CHECK_OBJECT(par_store_ctx);
    Py_DECREF(par_store_ctx);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_4___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1(python_pars[0]);
    struct Nuitka_CellObject *par_callback = PyCell_NEW1(python_pars[1]);
    PyObject *var_wrapper = NULL;
    struct Nuitka_FrameObject *frame_0eb02023a95d73c29a7d3de33ad75951;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_0eb02023a95d73c29a7d3de33ad75951 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_0eb02023a95d73c29a7d3de33ad75951, codeobj_0eb02023a95d73c29a7d3de33ad75951, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_0eb02023a95d73c29a7d3de33ad75951 = cache_frame_0eb02023a95d73c29a7d3de33ad75951;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_0eb02023a95d73c29a7d3de33ad75951);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_0eb02023a95d73c29a7d3de33ad75951) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 83 ], 53, 0);
            exception_tb = NULL;

            exception_lineno = 342;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT(PyCell_GET(par_self));
        tmp_args_element_name_1 = PyCell_GET(par_self);
        frame_0eb02023a95d73c29a7d3de33ad75951->m_frame.f_lineno = 342;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain___init__, call_args);
        }

        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 342;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_wraps);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_wraps);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 136 ], 34, 0);
            exception_tb = NULL;

            exception_lineno = 344;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT(PyCell_GET(par_callback));
        tmp_args_element_name_2 = PyCell_GET(par_callback);
        frame_0eb02023a95d73c29a7d3de33ad75951->m_frame.f_lineno = 344;
        tmp_called_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_2);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 344;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = MAKE_FUNCTION_OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper();

        ((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[0] = par_callback;
        Py_INCREF(((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[0]);
        ((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[1] = par_self;
        Py_INCREF(((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[1]);


        frame_0eb02023a95d73c29a7d3de33ad75951->m_frame.f_lineno = 344;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_3);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 344;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        assert(var_wrapper == NULL);
        var_wrapper = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 371;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_3;
        tmp_args_element_name_4 = const_str_digest_b6f7e6068b1690fa00ff377454fad5cf;
        CHECK_OBJECT(var_wrapper);
        tmp_args_element_name_5 = var_wrapper;
        frame_0eb02023a95d73c29a7d3de33ad75951->m_frame.f_lineno = 371;
        {
            PyObject *call_args[] = {tmp_args_element_name_4, tmp_args_element_name_5};
            tmp_assattr_name_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_2, const_str_plain_callback, call_args);
        }

        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 371;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(PyCell_GET(par_self));
        tmp_assattr_target_1 = PyCell_GET(par_self);
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain_callback, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 371;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0eb02023a95d73c29a7d3de33ad75951);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0eb02023a95d73c29a7d3de33ad75951);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_0eb02023a95d73c29a7d3de33ad75951, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_0eb02023a95d73c29a7d3de33ad75951->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_0eb02023a95d73c29a7d3de33ad75951, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0eb02023a95d73c29a7d3de33ad75951,
        type_description_1,
        par_self,
        par_callback,
        var_wrapper
    );


    // Release cached frame.
    if (frame_0eb02023a95d73c29a7d3de33ad75951 == cache_frame_0eb02023a95d73c29a7d3de33ad75951) {
        Py_DECREF(frame_0eb02023a95d73c29a7d3de33ad75951);
    }
    cache_frame_0eb02023a95d73c29a7d3de33ad75951 = NULL;

    assertFrameObject(frame_0eb02023a95d73c29a7d3de33ad75951);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_4___init__);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_wrapper);
    Py_DECREF(var_wrapper);
    var_wrapper = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_wrapper);
    var_wrapper = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_4___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_callback);
    Py_DECREF(par_callback);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_callback);
    Py_DECREF(par_callback);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_ssl = python_pars[0];
    PyObject *par_out = python_pars[1];
    PyObject *par_outlen = python_pars[2];
    PyObject *par_arg = python_pars[3];
    PyObject *var_e = NULL;
    PyObject *var_protos = NULL;
    PyObject *var_protostr = NULL;
    PyObject *var_conn = NULL;
    PyObject *tmp_genexpr_1__$0 = NULL;
    struct Nuitka_FrameObject *frame_8b48c52cd2db4623bd0576fa41e4cfa3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_8b48c52cd2db4623bd0576fa41e4cfa3 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_8b48c52cd2db4623bd0576fa41e4cfa3, codeobj_8b48c52cd2db4623bd0576fa41e4cfa3, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_8b48c52cd2db4623bd0576fa41e4cfa3 = cache_frame_8b48c52cd2db4623bd0576fa41e4cfa3;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_8b48c52cd2db4623bd0576fa41e4cfa3);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_8b48c52cd2db4623bd0576fa41e4cfa3) == 2); // Frame stack

    // Framed code:
    // Tried code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_subscript_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Connection);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_Connection);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 269 ], 39, 0);
            exception_tb = NULL;

            exception_lineno = 347;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__reverse_mapping);
        if (tmp_subscribed_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 347;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT(par_ssl);
        tmp_subscript_name_1 = par_ssl;
        tmp_assign_source_1 = LOOKUP_SUBSCRIPT(tmp_subscribed_name_1, tmp_subscript_name_1);
        Py_DECREF(tmp_subscribed_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 347;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }
        assert(var_conn == NULL);
        var_conn = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_1;
        if (PyCell_GET(self->m_closure[0]) == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "callback");
            exception_tb = NULL;

            exception_lineno = 348;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }

        tmp_called_name_1 = PyCell_GET(self->m_closure[0]);
        CHECK_OBJECT(var_conn);
        tmp_args_element_name_1 = var_conn;
        frame_8b48c52cd2db4623bd0576fa41e4cfa3->m_frame.f_lineno = 348;
        tmp_assign_source_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 348;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }
        assert(var_protos == NULL);
        var_protos = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_3;
        tmp_source_name_2 = const_str_empty;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_join);
        assert(!(tmp_called_name_2 == NULL));
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_chain);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_chain);
        }

        if (tmp_mvar_value_2 == NULL) {
            Py_DECREF(tmp_called_name_2);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 308 ], 34, 0);
            exception_tb = NULL;

            exception_lineno = 353;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_from_iterable);
        if (tmp_called_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 353;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }
        {
            PyObject *tmp_assign_source_4;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT(var_protos);
            tmp_iter_arg_1 = var_protos;
            tmp_assign_source_4 = MAKE_ITERATOR(tmp_iter_arg_1);
            if (tmp_assign_source_4 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 353;
                type_description_1 = "oooooccooo";
                goto try_except_handler_2;
            }
            assert(tmp_genexpr_1__$0 == NULL);
            tmp_genexpr_1__$0 = tmp_assign_source_4;
        }
        // Tried code:
        tmp_args_element_name_3 = OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper$$$genexpr_1_genexpr_maker();

        ((struct Nuitka_GeneratorObject *)tmp_args_element_name_3)->m_closure[0] = PyCell_NEW0(tmp_genexpr_1__$0);


        goto try_return_handler_3;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper);
        return NULL;
        // Return handler code:
        try_return_handler_3:;
        CHECK_OBJECT((PyObject *)tmp_genexpr_1__$0);
        Py_DECREF(tmp_genexpr_1__$0);
        tmp_genexpr_1__$0 = NULL;

        goto outline_result_1;
        // End of try:
        CHECK_OBJECT((PyObject *)tmp_genexpr_1__$0);
        Py_DECREF(tmp_genexpr_1__$0);
        tmp_genexpr_1__$0 = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper);
        return NULL;
        outline_result_1:;
        frame_8b48c52cd2db4623bd0576fa41e4cfa3->m_frame.f_lineno = 353;
        tmp_args_element_name_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_3, tmp_args_element_name_3);
        Py_DECREF(tmp_called_name_3);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 353;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }
        frame_8b48c52cd2db4623bd0576fa41e4cfa3->m_frame.f_lineno = 352;
        tmp_assign_source_3 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_2);
        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assign_source_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 352;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }
        assert(var_protostr == NULL);
        var_protostr = tmp_assign_source_3;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_list_element_1;
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_len_arg_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 361;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }

        tmp_source_name_4 = tmp_mvar_value_3;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_new);
        if (tmp_called_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 361;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }
        tmp_args_element_name_4 = const_str_digest_e33a7f733650e687efe98e5491512b82;
        CHECK_OBJECT(var_protostr);
        tmp_len_arg_1 = var_protostr;
        tmp_args_element_name_5 = BUILTIN_LEN(tmp_len_arg_1);
        if (tmp_args_element_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_4);

            exception_lineno = 361;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }
        frame_8b48c52cd2db4623bd0576fa41e4cfa3->m_frame.f_lineno = 361;
        {
            PyObject *call_args[] = {tmp_args_element_name_4, tmp_args_element_name_5};
            tmp_list_element_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_4, call_args);
        }

        Py_DECREF(tmp_called_name_4);
        Py_DECREF(tmp_args_element_name_5);
        if (tmp_list_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 361;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }
        tmp_assattr_name_1 = PyList_New(2);
        PyList_SET_ITEM(tmp_assattr_name_1, 0, tmp_list_element_1);
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_4 == NULL) {
            Py_DECREF(tmp_assattr_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 362;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_1 = tmp_mvar_value_4;
        tmp_args_element_name_6 = const_str_digest_81f1b0dfcc7a862e6940580ec4cc42d3;
        CHECK_OBJECT(var_protostr);
        tmp_args_element_name_7 = var_protostr;
        frame_8b48c52cd2db4623bd0576fa41e4cfa3->m_frame.f_lineno = 362;
        {
            PyObject *call_args[] = {tmp_args_element_name_6, tmp_args_element_name_7};
            tmp_list_element_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain_new, call_args);
        }

        if (tmp_list_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_assattr_name_1);

            exception_lineno = 362;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }
        PyList_SET_ITEM(tmp_assattr_name_1, 1, tmp_list_element_1);
        CHECK_OBJECT(var_conn);
        tmp_assattr_target_1 = var_conn;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__npn_advertise_callback_args, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 360;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }
    }
    {
        PyObject *tmp_ass_subvalue_1;
        PyObject *tmp_subscribed_name_2;
        PyObject *tmp_subscribed_name_3;
        PyObject *tmp_source_name_5;
        PyObject *tmp_subscript_name_2;
        PyObject *tmp_subscript_name_3;
        PyObject *tmp_ass_subscribed_1;
        PyObject *tmp_ass_subscript_1;
        int tmp_ass_subscript_res_1;
        CHECK_OBJECT(var_conn);
        tmp_source_name_5 = var_conn;
        tmp_subscribed_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain__npn_advertise_callback_args);
        if (tmp_subscribed_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 364;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }
        tmp_subscript_name_2 = const_int_0;
        tmp_subscribed_name_2 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_3, tmp_subscript_name_2, 0);
        Py_DECREF(tmp_subscribed_name_3);
        if (tmp_subscribed_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 364;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }
        tmp_subscript_name_3 = const_int_0;
        tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_2, tmp_subscript_name_3, 0);
        Py_DECREF(tmp_subscribed_name_2);
        if (tmp_ass_subvalue_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 364;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT(par_outlen);
        tmp_ass_subscribed_1 = par_outlen;
        tmp_ass_subscript_1 = const_int_0;
        tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST(tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1);
        Py_DECREF(tmp_ass_subvalue_1);
        if (tmp_ass_subscript_res_1 == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 364;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }
    }
    {
        PyObject *tmp_ass_subvalue_2;
        PyObject *tmp_subscribed_name_4;
        PyObject *tmp_source_name_6;
        PyObject *tmp_subscript_name_4;
        PyObject *tmp_ass_subscribed_2;
        PyObject *tmp_ass_subscript_2;
        int tmp_ass_subscript_res_2;
        CHECK_OBJECT(var_conn);
        tmp_source_name_6 = var_conn;
        tmp_subscribed_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain__npn_advertise_callback_args);
        if (tmp_subscribed_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 365;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }
        tmp_subscript_name_4 = const_int_pos_1;
        tmp_ass_subvalue_2 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_4, tmp_subscript_name_4, 1);
        Py_DECREF(tmp_subscribed_name_4);
        if (tmp_ass_subvalue_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 365;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT(par_out);
        tmp_ass_subscribed_2 = par_out;
        tmp_ass_subscript_2 = const_int_0;
        tmp_ass_subscript_res_2 = SET_SUBSCRIPT_CONST(tmp_ass_subscribed_2, tmp_ass_subscript_2, 0, tmp_ass_subvalue_2);
        Py_DECREF(tmp_ass_subvalue_2);
        if (tmp_ass_subscript_res_2 == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 365;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION(frame_8b48c52cd2db4623bd0576fa41e4cfa3);
    if (exception_keeper_tb_1 == NULL) {
        exception_keeper_tb_1 = MAKE_TRACEBACK(frame_8b48c52cd2db4623bd0576fa41e4cfa3, exception_keeper_lineno_1);
    } else if (exception_keeper_lineno_1 != 0) {
        exception_keeper_tb_1 = ADD_TRACEBACK(exception_keeper_tb_1, frame_8b48c52cd2db4623bd0576fa41e4cfa3, exception_keeper_lineno_1);
    }

    NORMALIZE_EXCEPTION(&exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1);
    PUBLISH_EXCEPTION(&exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1);
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_compexpr_left_1 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_1 = PyExc_Exception;
        tmp_res = EXCEPTION_MATCH_BOOL(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 367;
            type_description_1 = "oooooccooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_5;
            tmp_assign_source_5 = EXC_VALUE(PyThreadState_GET());
            assert(var_e == NULL);
            Py_INCREF(tmp_assign_source_5);
            var_e = tmp_assign_source_5;
        }
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_source_name_7;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_8;
            if (PyCell_GET(self->m_closure[1]) == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = PyString_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "self");
                exception_tb = NULL;

                exception_lineno = 368;
                type_description_1 = "oooooccooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_7 = PyCell_GET(self->m_closure[1]);
            tmp_called_instance_2 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain__problems);
            if (tmp_called_instance_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 368;
                type_description_1 = "oooooccooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_e);
            tmp_args_element_name_8 = var_e;
            frame_8b48c52cd2db4623bd0576fa41e4cfa3->m_frame.f_lineno = 368;
            {
                PyObject *call_args[] = {tmp_args_element_name_8};
                tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_append, call_args);
            }

            Py_DECREF(tmp_called_instance_2);
            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 368;
                type_description_1 = "oooooccooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_1);
        }
        tmp_return_value = const_int_pos_2;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        goto branch_end_1;
        branch_no_1:;
        tmp_result = RERAISE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
        if (unlikely(tmp_result == false)) {
            exception_lineno = 346;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_8b48c52cd2db4623bd0576fa41e4cfa3->m_frame) frame_8b48c52cd2db4623bd0576fa41e4cfa3->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "oooooccooo";
        goto frame_exception_exit_1;
        branch_end_1:;
    }
    // End of try:
    try_end_1:;

#if 1
    RESTORE_FRAME_EXCEPTION(frame_8b48c52cd2db4623bd0576fa41e4cfa3);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION(frame_8b48c52cd2db4623bd0576fa41e4cfa3);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION(frame_8b48c52cd2db4623bd0576fa41e4cfa3);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_8b48c52cd2db4623bd0576fa41e4cfa3, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_8b48c52cd2db4623bd0576fa41e4cfa3->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_8b48c52cd2db4623bd0576fa41e4cfa3, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8b48c52cd2db4623bd0576fa41e4cfa3,
        type_description_1,
        par_ssl,
        par_out,
        par_outlen,
        par_arg,
        var_e,
        self->m_closure[0],
        self->m_closure[1],
        var_protos,
        var_protostr,
        var_conn
    );


    // Release cached frame.
    if (frame_8b48c52cd2db4623bd0576fa41e4cfa3 == cache_frame_8b48c52cd2db4623bd0576fa41e4cfa3) {
        Py_DECREF(frame_8b48c52cd2db4623bd0576fa41e4cfa3);
    }
    cache_frame_8b48c52cd2db4623bd0576fa41e4cfa3 = NULL;

    assertFrameObject(frame_8b48c52cd2db4623bd0576fa41e4cfa3);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = const_int_0;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_e);
    var_e = NULL;

    Py_XDECREF(var_protos);
    var_protos = NULL;

    Py_XDECREF(var_protostr);
    var_protostr = NULL;

    Py_XDECREF(var_conn);
    var_conn = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_e);
    var_e = NULL;

    Py_XDECREF(var_protos);
    var_protos = NULL;

    Py_XDECREF(var_protostr);
    var_protostr = NULL;

    Py_XDECREF(var_conn);
    var_conn = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_outlen);
    Py_DECREF(par_outlen);
    CHECK_OBJECT(par_ssl);
    Py_DECREF(par_ssl);
    CHECK_OBJECT(par_arg);
    Py_DECREF(par_arg);
    CHECK_OBJECT(par_out);
    Py_DECREF(par_out);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_outlen);
    Py_DECREF(par_outlen);
    CHECK_OBJECT(par_ssl);
    Py_DECREF(par_ssl);
    CHECK_OBJECT(par_arg);
    Py_DECREF(par_arg);
    CHECK_OBJECT(par_out);
    Py_DECREF(par_out);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}



struct OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper$$$genexpr_1_genexpr_locals {
    PyObject *var_p;
    PyObject *tmp_iter_value_0;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value ) {
    CHECK_OBJECT((PyObject *)generator);
    assert(Nuitka_Generator_Check( (PyObject *)generator ));

    // Heap access if used.
    struct OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper$$$genexpr_1_genexpr_locals *generator_heap = (struct OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper$$$genexpr_1_genexpr_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_p = NULL;
    generator_heap->tmp_iter_value_0 = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_m_frame, codeobj_dec16e966d6274a18c38ad18c936c314, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *));
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF(generator->m_frame);
    assert(Py_REFCNT(generator->m_frame) == 2); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR(generator->m_frame->m_frame.f_back);

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF(generator->m_frame->m_frame.f_back);

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF(generator->m_frame);

    Nuitka_Frame_MarkAsExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

        EXC_TYPE_F(generator) = EXC_TYPE(thread_state);
        if (EXC_TYPE_F(generator) == Py_None) EXC_TYPE_F(generator) = NULL;
        Py_XINCREF(EXC_TYPE_F(generator));
        EXC_VALUE_F(generator) = EXC_VALUE(thread_state);
        Py_XINCREF(EXC_VALUE_F(generator));
        EXC_TRACEBACK_F(generator) = EXC_TRACEBACK(thread_state);
        Py_XINCREF(EXC_TRACEBACK_F(generator));
    }

#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_1;
        CHECK_OBJECT(PyCell_GET(generator->m_closure[0]));
        tmp_next_source_1 = PyCell_GET(generator->m_closure[0]);
        tmp_assign_source_1 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_1 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);
                generator_heap->type_description_1 = "No";
                generator_heap->exception_lineno = 353;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_iter_value_0;
            generator_heap->tmp_iter_value_0 = tmp_assign_source_1;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT(generator_heap->tmp_iter_value_0);
        tmp_assign_source_2 = generator_heap->tmp_iter_value_0;
        {
            PyObject *old = generator_heap->var_p;
            generator_heap->var_p = tmp_assign_source_2;
            Py_INCREF(generator_heap->var_p);
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_expression_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_len_arg_1;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_int2byte);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_int2byte);
        }

        if (tmp_mvar_value_1 == NULL) {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF(generator_heap->exception_type);
            generator_heap->exception_value = UNSTREAM_STRING(&constant_bin[ 342 ], 37, 0);
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 353;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT(generator_heap->var_p);
        tmp_len_arg_1 = generator_heap->var_p;
        tmp_args_element_name_1 = BUILTIN_LEN(tmp_len_arg_1);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 353;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        generator->m_frame->m_frame.f_lineno = 353;
        tmp_tuple_element_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 353;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_expression_name_1 = PyTuple_New(2);
        PyTuple_SET_ITEM(tmp_expression_name_1, 0, tmp_tuple_element_1);
        CHECK_OBJECT(generator_heap->var_p);
        tmp_tuple_element_1 = generator_heap->var_p;
        Py_INCREF(tmp_tuple_element_1);
        PyTuple_SET_ITEM(tmp_expression_name_1, 1, tmp_tuple_element_1);
        Nuitka_PreserveHeap(generator_heap->yield_tmps, &tmp_tuple_element_1, sizeof(PyObject *), &tmp_called_name_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), &tmp_args_element_name_1, sizeof(PyObject *), &tmp_len_arg_1, sizeof(PyObject *), NULL);
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        Nuitka_RestoreHeap(generator_heap->yield_tmps, &tmp_tuple_element_1, sizeof(PyObject *), &tmp_called_name_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), &tmp_args_element_name_1, sizeof(PyObject *), &tmp_len_arg_1, sizeof(PyObject *), NULL);
        if (yield_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 353;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


        generator_heap->exception_lineno = 353;
        generator_heap->type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    // Allow re-use of the frame again.
    Py_DECREF(generator->m_frame);
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if (!EXCEPTION_MATCH_GENERATOR(generator_heap->exception_type)) {
        if (generator_heap->exception_tb == NULL) {
            generator_heap->exception_tb = MAKE_TRACEBACK(generator->m_frame, generator_heap->exception_lineno);
        } else if (generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame) {
            generator_heap->exception_tb = ADD_TRACEBACK(generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno);
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            NULL,
            generator_heap->var_p
        );


        // Release cached frame.
        if (generator->m_frame == cache_m_frame) {
            Py_DECREF(generator->m_frame);
        }
        cache_m_frame = NULL;

        assertFrameObject(generator->m_frame);
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    Py_DECREF(generator->m_frame);

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->var_p);
    generator_heap->var_p = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    Py_XDECREF(generator_heap->var_p);
    generator_heap->var_p = NULL;



    return NULL;

    function_exception_exit:
    assert(generator_heap->exception_type);
    RESTORE_ERROR_OCCURRED(generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb);

    return NULL;

}

static PyObject *OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper$$$genexpr_1_genexpr_maker(void) {
    return Nuitka_Generator_New(
        OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper$$$genexpr_1_genexpr_context,
        module_OpenSSL$SSL,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_dec16e966d6274a18c38ad18c936c314,
        1,
        sizeof(struct OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper$$$genexpr_1_genexpr_locals)
    );
}


static PyObject *impl_OpenSSL$SSL$$$function_5___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1(python_pars[0]);
    struct Nuitka_CellObject *par_callback = PyCell_NEW1(python_pars[1]);
    PyObject *var_wrapper = NULL;
    struct Nuitka_FrameObject *frame_3beab920a481007f8daf7a784334bc50;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_3beab920a481007f8daf7a784334bc50 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_3beab920a481007f8daf7a784334bc50, codeobj_3beab920a481007f8daf7a784334bc50, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_3beab920a481007f8daf7a784334bc50 = cache_frame_3beab920a481007f8daf7a784334bc50;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_3beab920a481007f8daf7a784334bc50);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_3beab920a481007f8daf7a784334bc50) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 83 ], 53, 0);
            exception_tb = NULL;

            exception_lineno = 383;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT(PyCell_GET(par_self));
        tmp_args_element_name_1 = PyCell_GET(par_self);
        frame_3beab920a481007f8daf7a784334bc50->m_frame.f_lineno = 383;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain___init__, call_args);
        }

        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 383;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_wraps);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_wraps);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 136 ], 34, 0);
            exception_tb = NULL;

            exception_lineno = 385;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT(PyCell_GET(par_callback));
        tmp_args_element_name_2 = PyCell_GET(par_callback);
        frame_3beab920a481007f8daf7a784334bc50->m_frame.f_lineno = 385;
        tmp_called_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_2);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 385;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = MAKE_FUNCTION_OpenSSL$SSL$$$function_5___init__$$$function_1_wrapper();

        ((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[0] = par_callback;
        Py_INCREF(((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[0]);
        ((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[1] = par_self;
        Py_INCREF(((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[1]);


        frame_3beab920a481007f8daf7a784334bc50->m_frame.f_lineno = 385;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_3);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 385;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        assert(var_wrapper == NULL);
        var_wrapper = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 419;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_3;
        tmp_args_element_name_4 = const_str_digest_1bd7405e218c8a579c48801956097e27;
        CHECK_OBJECT(var_wrapper);
        tmp_args_element_name_5 = var_wrapper;
        frame_3beab920a481007f8daf7a784334bc50->m_frame.f_lineno = 419;
        {
            PyObject *call_args[] = {tmp_args_element_name_4, tmp_args_element_name_5};
            tmp_assattr_name_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_2, const_str_plain_callback, call_args);
        }

        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 419;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(PyCell_GET(par_self));
        tmp_assattr_target_1 = PyCell_GET(par_self);
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain_callback, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 419;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3beab920a481007f8daf7a784334bc50);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3beab920a481007f8daf7a784334bc50);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_3beab920a481007f8daf7a784334bc50, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_3beab920a481007f8daf7a784334bc50->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_3beab920a481007f8daf7a784334bc50, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3beab920a481007f8daf7a784334bc50,
        type_description_1,
        par_self,
        par_callback,
        var_wrapper
    );


    // Release cached frame.
    if (frame_3beab920a481007f8daf7a784334bc50 == cache_frame_3beab920a481007f8daf7a784334bc50) {
        Py_DECREF(frame_3beab920a481007f8daf7a784334bc50);
    }
    cache_frame_3beab920a481007f8daf7a784334bc50 = NULL;

    assertFrameObject(frame_3beab920a481007f8daf7a784334bc50);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_5___init__);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_wrapper);
    Py_DECREF(var_wrapper);
    var_wrapper = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_wrapper);
    var_wrapper = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_5___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_callback);
    Py_DECREF(par_callback);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_callback);
    Py_DECREF(par_callback);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_5___init__$$$function_1_wrapper(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_ssl = python_pars[0];
    PyObject *par_out = python_pars[1];
    PyObject *par_outlen = python_pars[2];
    PyObject *par_in_ = python_pars[3];
    PyObject *par_inlen = python_pars[4];
    PyObject *par_arg = python_pars[5];
    PyObject *var_outstr = NULL;
    PyObject *var_protolist = NULL;
    PyObject *var_e = NULL;
    PyObject *var_instr = NULL;
    PyObject *var_proto = NULL;
    PyObject *var_length = NULL;
    PyObject *var_conn = NULL;
    struct Nuitka_FrameObject *frame_0228e96ca7a03ca447fc3f1bfe3f2f29;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_0228e96ca7a03ca447fc3f1bfe3f2f29 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_0228e96ca7a03ca447fc3f1bfe3f2f29, codeobj_0228e96ca7a03ca447fc3f1bfe3f2f29, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_0228e96ca7a03ca447fc3f1bfe3f2f29 = cache_frame_0228e96ca7a03ca447fc3f1bfe3f2f29;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_0228e96ca7a03ca447fc3f1bfe3f2f29);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_0228e96ca7a03ca447fc3f1bfe3f2f29) == 2); // Frame stack

    // Framed code:
    // Tried code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_subscript_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Connection);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_Connection);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 269 ], 39, 0);
            exception_tb = NULL;

            exception_lineno = 388;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__reverse_mapping);
        if (tmp_subscribed_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 388;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
        CHECK_OBJECT(par_ssl);
        tmp_subscript_name_1 = par_ssl;
        tmp_assign_source_1 = LOOKUP_SUBSCRIPT(tmp_subscribed_name_1, tmp_subscript_name_1);
        Py_DECREF(tmp_subscribed_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 388;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
        assert(var_conn == NULL);
        var_conn = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        Py_ssize_t tmp_sliceslicedel_index_lower_1;
        Py_ssize_t tmp_slice_index_upper_1;
        PyObject *tmp_slice_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_sliceslicedel_index_lower_1 = 0;
        tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 393;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }

        tmp_called_instance_1 = tmp_mvar_value_2;
        CHECK_OBJECT(par_in_);
        tmp_args_element_name_1 = par_in_;
        CHECK_OBJECT(par_inlen);
        tmp_args_element_name_2 = par_inlen;
        frame_0228e96ca7a03ca447fc3f1bfe3f2f29->m_frame.f_lineno = 393;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_slice_source_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain_buffer, call_args);
        }

        if (tmp_slice_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 393;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
        tmp_assign_source_2 = LOOKUP_INDEX_SLICE(tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1);
        Py_DECREF(tmp_slice_source_1);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 393;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
        assert(var_instr == NULL);
        var_instr = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        tmp_assign_source_3 = PyList_New(0);
        assert(var_protolist == NULL);
        var_protolist = tmp_assign_source_3;
    }
    loop_start_1:;
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        CHECK_OBJECT(var_instr);
        tmp_operand_name_1 = var_instr;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 395;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        goto loop_end_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_indexbytes);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_indexbytes);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 379 ], 39, 0);
            exception_tb = NULL;

            exception_lineno = 396;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }

        tmp_called_name_1 = tmp_mvar_value_3;
        CHECK_OBJECT(var_instr);
        tmp_args_element_name_3 = var_instr;
        tmp_args_element_name_4 = const_int_0;
        frame_0228e96ca7a03ca447fc3f1bfe3f2f29->m_frame.f_lineno = 396;
        {
            PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4};
            tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        if (tmp_assign_source_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 396;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_length;
            var_length = tmp_assign_source_4;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_slice_source_2;
        PyObject *tmp_slice_lower_1;
        PyObject *tmp_slice_upper_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        CHECK_OBJECT(var_instr);
        tmp_slice_source_2 = var_instr;
        tmp_slice_lower_1 = const_int_pos_1;
        CHECK_OBJECT(var_length);
        tmp_left_name_1 = var_length;
        tmp_right_name_1 = const_int_pos_1;
        tmp_slice_upper_1 = BINARY_OPERATION_ADD_OBJECT_INT(tmp_left_name_1, tmp_right_name_1);
        if (tmp_slice_upper_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 397;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
        tmp_assign_source_5 = LOOKUP_SLICE(tmp_slice_source_2, tmp_slice_lower_1, tmp_slice_upper_1);
        Py_DECREF(tmp_slice_upper_1);
        if (tmp_assign_source_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 397;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_proto;
            var_proto = tmp_assign_source_5;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_5;
        CHECK_OBJECT(var_protolist);
        tmp_called_instance_2 = var_protolist;
        CHECK_OBJECT(var_proto);
        tmp_args_element_name_5 = var_proto;
        frame_0228e96ca7a03ca447fc3f1bfe3f2f29->m_frame.f_lineno = 398;
        {
            PyObject *call_args[] = {tmp_args_element_name_5};
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_append, call_args);
        }

        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 398;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_slice_source_3;
        PyObject *tmp_slice_lower_2;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_2;
        CHECK_OBJECT(var_instr);
        tmp_slice_source_3 = var_instr;
        CHECK_OBJECT(var_length);
        tmp_left_name_2 = var_length;
        tmp_right_name_2 = const_int_pos_1;
        tmp_slice_lower_2 = BINARY_OPERATION_ADD_OBJECT_INT(tmp_left_name_2, tmp_right_name_2);
        if (tmp_slice_lower_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 399;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
        tmp_assign_source_6 = LOOKUP_SLICE(tmp_slice_source_3, tmp_slice_lower_2, Py_None);
        Py_DECREF(tmp_slice_lower_2);
        if (tmp_assign_source_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 399;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_instr;
            assert(old != NULL);
            var_instr = tmp_assign_source_6;
            Py_DECREF(old);
        }

    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


        exception_lineno = 395;
        type_description_1 = "oooooooooocooco";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_called_name_2;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_args_element_name_7;
        if (PyCell_GET(self->m_closure[0]) == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "callback");
            exception_tb = NULL;

            exception_lineno = 402;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }

        tmp_called_name_2 = PyCell_GET(self->m_closure[0]);
        CHECK_OBJECT(var_conn);
        tmp_args_element_name_6 = var_conn;
        CHECK_OBJECT(var_protolist);
        tmp_args_element_name_7 = var_protolist;
        frame_0228e96ca7a03ca447fc3f1bfe3f2f29->m_frame.f_lineno = 402;
        {
            PyObject *call_args[] = {tmp_args_element_name_6, tmp_args_element_name_7};
            tmp_assign_source_7 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        if (tmp_assign_source_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 402;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
        assert(var_outstr == NULL);
        var_outstr = tmp_assign_source_7;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_list_element_1;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_len_arg_1;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_args_element_name_11;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 409;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }

        tmp_source_name_2 = tmp_mvar_value_4;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_new);
        if (tmp_called_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 409;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
        tmp_args_element_name_8 = const_str_digest_2aaae8e99c54112dad0b0da3957413a9;
        CHECK_OBJECT(var_outstr);
        tmp_len_arg_1 = var_outstr;
        tmp_args_element_name_9 = BUILTIN_LEN(tmp_len_arg_1);
        if (tmp_args_element_name_9 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);

            exception_lineno = 409;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
        frame_0228e96ca7a03ca447fc3f1bfe3f2f29->m_frame.f_lineno = 409;
        {
            PyObject *call_args[] = {tmp_args_element_name_8, tmp_args_element_name_9};
            tmp_list_element_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_3, call_args);
        }

        Py_DECREF(tmp_called_name_3);
        Py_DECREF(tmp_args_element_name_9);
        if (tmp_list_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 409;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
        tmp_assattr_name_1 = PyList_New(2);
        PyList_SET_ITEM(tmp_assattr_name_1, 0, tmp_list_element_1);
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_5 == NULL) {
            Py_DECREF(tmp_assattr_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 410;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }

        tmp_called_instance_3 = tmp_mvar_value_5;
        tmp_args_element_name_10 = const_str_digest_81f1b0dfcc7a862e6940580ec4cc42d3;
        CHECK_OBJECT(var_outstr);
        tmp_args_element_name_11 = var_outstr;
        frame_0228e96ca7a03ca447fc3f1bfe3f2f29->m_frame.f_lineno = 410;
        {
            PyObject *call_args[] = {tmp_args_element_name_10, tmp_args_element_name_11};
            tmp_list_element_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_3, const_str_plain_new, call_args);
        }

        if (tmp_list_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_assattr_name_1);

            exception_lineno = 410;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
        PyList_SET_ITEM(tmp_assattr_name_1, 1, tmp_list_element_1);
        CHECK_OBJECT(var_conn);
        tmp_assattr_target_1 = var_conn;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__npn_select_callback_args, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 408;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
    }
    {
        PyObject *tmp_ass_subvalue_1;
        PyObject *tmp_subscribed_name_2;
        PyObject *tmp_subscribed_name_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_subscript_name_2;
        PyObject *tmp_subscript_name_3;
        PyObject *tmp_ass_subscribed_1;
        PyObject *tmp_ass_subscript_1;
        int tmp_ass_subscript_res_1;
        CHECK_OBJECT(var_conn);
        tmp_source_name_3 = var_conn;
        tmp_subscribed_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__npn_select_callback_args);
        if (tmp_subscribed_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 412;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
        tmp_subscript_name_2 = const_int_0;
        tmp_subscribed_name_2 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_3, tmp_subscript_name_2, 0);
        Py_DECREF(tmp_subscribed_name_3);
        if (tmp_subscribed_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 412;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
        tmp_subscript_name_3 = const_int_0;
        tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_2, tmp_subscript_name_3, 0);
        Py_DECREF(tmp_subscribed_name_2);
        if (tmp_ass_subvalue_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 412;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
        CHECK_OBJECT(par_outlen);
        tmp_ass_subscribed_1 = par_outlen;
        tmp_ass_subscript_1 = const_int_0;
        tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST(tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1);
        Py_DECREF(tmp_ass_subvalue_1);
        if (tmp_ass_subscript_res_1 == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 412;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
    }
    {
        PyObject *tmp_ass_subvalue_2;
        PyObject *tmp_subscribed_name_4;
        PyObject *tmp_source_name_4;
        PyObject *tmp_subscript_name_4;
        PyObject *tmp_ass_subscribed_2;
        PyObject *tmp_ass_subscript_2;
        int tmp_ass_subscript_res_2;
        CHECK_OBJECT(var_conn);
        tmp_source_name_4 = var_conn;
        tmp_subscribed_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain__npn_select_callback_args);
        if (tmp_subscribed_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 413;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
        tmp_subscript_name_4 = const_int_pos_1;
        tmp_ass_subvalue_2 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_4, tmp_subscript_name_4, 1);
        Py_DECREF(tmp_subscribed_name_4);
        if (tmp_ass_subvalue_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 413;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
        CHECK_OBJECT(par_out);
        tmp_ass_subscribed_2 = par_out;
        tmp_ass_subscript_2 = const_int_0;
        tmp_ass_subscript_res_2 = SET_SUBSCRIPT_CONST(tmp_ass_subscribed_2, tmp_ass_subscript_2, 0, tmp_ass_subvalue_2);
        Py_DECREF(tmp_ass_subvalue_2);
        if (tmp_ass_subscript_res_2 == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 413;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION(frame_0228e96ca7a03ca447fc3f1bfe3f2f29);
    if (exception_keeper_tb_1 == NULL) {
        exception_keeper_tb_1 = MAKE_TRACEBACK(frame_0228e96ca7a03ca447fc3f1bfe3f2f29, exception_keeper_lineno_1);
    } else if (exception_keeper_lineno_1 != 0) {
        exception_keeper_tb_1 = ADD_TRACEBACK(exception_keeper_tb_1, frame_0228e96ca7a03ca447fc3f1bfe3f2f29, exception_keeper_lineno_1);
    }

    NORMALIZE_EXCEPTION(&exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1);
    PUBLISH_EXCEPTION(&exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1);
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_compexpr_left_1 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_1 = PyExc_Exception;
        tmp_res = EXCEPTION_MATCH_BOOL(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 415;
            type_description_1 = "oooooooooocooco";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_8;
            tmp_assign_source_8 = EXC_VALUE(PyThreadState_GET());
            assert(var_e == NULL);
            Py_INCREF(tmp_assign_source_8);
            var_e = tmp_assign_source_8;
        }
        {
            PyObject *tmp_called_instance_4;
            PyObject *tmp_source_name_5;
            PyObject *tmp_call_result_2;
            PyObject *tmp_args_element_name_12;
            if (PyCell_GET(self->m_closure[1]) == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = PyString_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "self");
                exception_tb = NULL;

                exception_lineno = 416;
                type_description_1 = "oooooooooocooco";
                goto frame_exception_exit_1;
            }

            tmp_source_name_5 = PyCell_GET(self->m_closure[1]);
            tmp_called_instance_4 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain__problems);
            if (tmp_called_instance_4 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 416;
                type_description_1 = "oooooooooocooco";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_e);
            tmp_args_element_name_12 = var_e;
            frame_0228e96ca7a03ca447fc3f1bfe3f2f29->m_frame.f_lineno = 416;
            {
                PyObject *call_args[] = {tmp_args_element_name_12};
                tmp_call_result_2 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_4, const_str_plain_append, call_args);
            }

            Py_DECREF(tmp_called_instance_4);
            if (tmp_call_result_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 416;
                type_description_1 = "oooooooooocooco";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_2);
        }
        tmp_return_value = const_int_pos_2;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        goto branch_end_2;
        branch_no_2:;
        tmp_result = RERAISE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
        if (unlikely(tmp_result == false)) {
            exception_lineno = 387;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_0228e96ca7a03ca447fc3f1bfe3f2f29->m_frame) frame_0228e96ca7a03ca447fc3f1bfe3f2f29->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "oooooooooocooco";
        goto frame_exception_exit_1;
        branch_end_2:;
    }
    // End of try:
    try_end_1:;

#if 1
    RESTORE_FRAME_EXCEPTION(frame_0228e96ca7a03ca447fc3f1bfe3f2f29);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION(frame_0228e96ca7a03ca447fc3f1bfe3f2f29);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION(frame_0228e96ca7a03ca447fc3f1bfe3f2f29);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_0228e96ca7a03ca447fc3f1bfe3f2f29, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_0228e96ca7a03ca447fc3f1bfe3f2f29->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_0228e96ca7a03ca447fc3f1bfe3f2f29, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0228e96ca7a03ca447fc3f1bfe3f2f29,
        type_description_1,
        par_ssl,
        par_out,
        par_outlen,
        par_in_,
        par_inlen,
        par_arg,
        var_outstr,
        var_protolist,
        var_e,
        var_instr,
        self->m_closure[1],
        var_proto,
        var_length,
        self->m_closure[0],
        var_conn
    );


    // Release cached frame.
    if (frame_0228e96ca7a03ca447fc3f1bfe3f2f29 == cache_frame_0228e96ca7a03ca447fc3f1bfe3f2f29) {
        Py_DECREF(frame_0228e96ca7a03ca447fc3f1bfe3f2f29);
    }
    cache_frame_0228e96ca7a03ca447fc3f1bfe3f2f29 = NULL;

    assertFrameObject(frame_0228e96ca7a03ca447fc3f1bfe3f2f29);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = const_int_0;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_5___init__$$$function_1_wrapper);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_outstr);
    var_outstr = NULL;

    Py_XDECREF(var_protolist);
    var_protolist = NULL;

    Py_XDECREF(var_e);
    var_e = NULL;

    Py_XDECREF(var_instr);
    var_instr = NULL;

    Py_XDECREF(var_proto);
    var_proto = NULL;

    Py_XDECREF(var_length);
    var_length = NULL;

    Py_XDECREF(var_conn);
    var_conn = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_outstr);
    var_outstr = NULL;

    Py_XDECREF(var_protolist);
    var_protolist = NULL;

    Py_XDECREF(var_e);
    var_e = NULL;

    Py_XDECREF(var_instr);
    var_instr = NULL;

    Py_XDECREF(var_proto);
    var_proto = NULL;

    Py_XDECREF(var_length);
    var_length = NULL;

    Py_XDECREF(var_conn);
    var_conn = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_5___init__$$$function_1_wrapper);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_in_);
    Py_DECREF(par_in_);
    CHECK_OBJECT(par_outlen);
    Py_DECREF(par_outlen);
    CHECK_OBJECT(par_ssl);
    Py_DECREF(par_ssl);
    CHECK_OBJECT(par_arg);
    Py_DECREF(par_arg);
    CHECK_OBJECT(par_out);
    Py_DECREF(par_out);
    CHECK_OBJECT(par_inlen);
    Py_DECREF(par_inlen);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_in_);
    Py_DECREF(par_in_);
    CHECK_OBJECT(par_outlen);
    Py_DECREF(par_outlen);
    CHECK_OBJECT(par_ssl);
    Py_DECREF(par_ssl);
    CHECK_OBJECT(par_arg);
    Py_DECREF(par_arg);
    CHECK_OBJECT(par_out);
    Py_DECREF(par_out);
    CHECK_OBJECT(par_inlen);
    Py_DECREF(par_inlen);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_6___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1(python_pars[0]);
    struct Nuitka_CellObject *par_callback = PyCell_NEW1(python_pars[1]);
    PyObject *var_wrapper = NULL;
    struct Nuitka_FrameObject *frame_6eecb9f929296113b11b777ecdee380a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_6eecb9f929296113b11b777ecdee380a = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_6eecb9f929296113b11b777ecdee380a, codeobj_6eecb9f929296113b11b777ecdee380a, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_6eecb9f929296113b11b777ecdee380a = cache_frame_6eecb9f929296113b11b777ecdee380a;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_6eecb9f929296113b11b777ecdee380a);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_6eecb9f929296113b11b777ecdee380a) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 83 ], 53, 0);
            exception_tb = NULL;

            exception_lineno = 432;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT(PyCell_GET(par_self));
        tmp_args_element_name_1 = PyCell_GET(par_self);
        frame_6eecb9f929296113b11b777ecdee380a->m_frame.f_lineno = 432;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain___init__, call_args);
        }

        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 432;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_wraps);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_wraps);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 136 ], 34, 0);
            exception_tb = NULL;

            exception_lineno = 434;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT(PyCell_GET(par_callback));
        tmp_args_element_name_2 = PyCell_GET(par_callback);
        frame_6eecb9f929296113b11b777ecdee380a->m_frame.f_lineno = 434;
        tmp_called_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_2);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 434;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = MAKE_FUNCTION_OpenSSL$SSL$$$function_6___init__$$$function_1_wrapper();

        ((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[0] = par_callback;
        Py_INCREF(((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[0]);
        ((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[1] = par_self;
        Py_INCREF(((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[1]);


        frame_6eecb9f929296113b11b777ecdee380a->m_frame.f_lineno = 434;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_3);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 434;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        assert(var_wrapper == NULL);
        var_wrapper = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 470;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_3;
        tmp_args_element_name_4 = const_str_digest_1bd7405e218c8a579c48801956097e27;
        CHECK_OBJECT(var_wrapper);
        tmp_args_element_name_5 = var_wrapper;
        frame_6eecb9f929296113b11b777ecdee380a->m_frame.f_lineno = 470;
        {
            PyObject *call_args[] = {tmp_args_element_name_4, tmp_args_element_name_5};
            tmp_assattr_name_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_2, const_str_plain_callback, call_args);
        }

        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 470;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(PyCell_GET(par_self));
        tmp_assattr_target_1 = PyCell_GET(par_self);
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain_callback, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 470;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_6eecb9f929296113b11b777ecdee380a);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_6eecb9f929296113b11b777ecdee380a);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_6eecb9f929296113b11b777ecdee380a, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_6eecb9f929296113b11b777ecdee380a->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_6eecb9f929296113b11b777ecdee380a, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6eecb9f929296113b11b777ecdee380a,
        type_description_1,
        par_self,
        par_callback,
        var_wrapper
    );


    // Release cached frame.
    if (frame_6eecb9f929296113b11b777ecdee380a == cache_frame_6eecb9f929296113b11b777ecdee380a) {
        Py_DECREF(frame_6eecb9f929296113b11b777ecdee380a);
    }
    cache_frame_6eecb9f929296113b11b777ecdee380a = NULL;

    assertFrameObject(frame_6eecb9f929296113b11b777ecdee380a);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_6___init__);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_wrapper);
    Py_DECREF(var_wrapper);
    var_wrapper = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_wrapper);
    var_wrapper = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_6___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_callback);
    Py_DECREF(par_callback);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_callback);
    Py_DECREF(par_callback);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_6___init__$$$function_1_wrapper(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_ssl = python_pars[0];
    PyObject *par_out = python_pars[1];
    PyObject *par_outlen = python_pars[2];
    PyObject *par_in_ = python_pars[3];
    PyObject *par_inlen = python_pars[4];
    PyObject *par_arg = python_pars[5];
    PyObject *var_encoded_len = NULL;
    PyObject *var_protolist = NULL;
    PyObject *var_e = NULL;
    PyObject *var_instr = NULL;
    PyObject *var_proto = NULL;
    PyObject *var_outstr = NULL;
    PyObject *var_conn = NULL;
    struct Nuitka_FrameObject *frame_1f66bae567fc069e7269625d4e4a775a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_1f66bae567fc069e7269625d4e4a775a = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_1f66bae567fc069e7269625d4e4a775a, codeobj_1f66bae567fc069e7269625d4e4a775a, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_1f66bae567fc069e7269625d4e4a775a = cache_frame_1f66bae567fc069e7269625d4e4a775a;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_1f66bae567fc069e7269625d4e4a775a);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_1f66bae567fc069e7269625d4e4a775a) == 2); // Frame stack

    // Framed code:
    // Tried code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_subscript_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Connection);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_Connection);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 269 ], 39, 0);
            exception_tb = NULL;

            exception_lineno = 437;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__reverse_mapping);
        if (tmp_subscribed_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 437;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT(par_ssl);
        tmp_subscript_name_1 = par_ssl;
        tmp_assign_source_1 = LOOKUP_SUBSCRIPT(tmp_subscribed_name_1, tmp_subscript_name_1);
        Py_DECREF(tmp_subscribed_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 437;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        assert(var_conn == NULL);
        var_conn = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        Py_ssize_t tmp_sliceslicedel_index_lower_1;
        Py_ssize_t tmp_slice_index_upper_1;
        PyObject *tmp_slice_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_sliceslicedel_index_lower_1 = 0;
        tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 442;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }

        tmp_called_instance_1 = tmp_mvar_value_2;
        CHECK_OBJECT(par_in_);
        tmp_args_element_name_1 = par_in_;
        CHECK_OBJECT(par_inlen);
        tmp_args_element_name_2 = par_inlen;
        frame_1f66bae567fc069e7269625d4e4a775a->m_frame.f_lineno = 442;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_slice_source_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain_buffer, call_args);
        }

        if (tmp_slice_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 442;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        tmp_assign_source_2 = LOOKUP_INDEX_SLICE(tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1);
        Py_DECREF(tmp_slice_source_1);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 442;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        assert(var_instr == NULL);
        var_instr = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        tmp_assign_source_3 = PyList_New(0);
        assert(var_protolist == NULL);
        var_protolist = tmp_assign_source_3;
    }
    loop_start_1:;
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        CHECK_OBJECT(var_instr);
        tmp_operand_name_1 = var_instr;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 444;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        goto loop_end_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_indexbytes);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_indexbytes);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 379 ], 39, 0);
            exception_tb = NULL;

            exception_lineno = 445;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }

        tmp_called_name_1 = tmp_mvar_value_3;
        CHECK_OBJECT(var_instr);
        tmp_args_element_name_3 = var_instr;
        tmp_args_element_name_4 = const_int_0;
        frame_1f66bae567fc069e7269625d4e4a775a->m_frame.f_lineno = 445;
        {
            PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4};
            tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        if (tmp_assign_source_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 445;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_encoded_len;
            var_encoded_len = tmp_assign_source_4;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_slice_source_2;
        PyObject *tmp_slice_lower_1;
        PyObject *tmp_slice_upper_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        CHECK_OBJECT(var_instr);
        tmp_slice_source_2 = var_instr;
        tmp_slice_lower_1 = const_int_pos_1;
        CHECK_OBJECT(var_encoded_len);
        tmp_left_name_1 = var_encoded_len;
        tmp_right_name_1 = const_int_pos_1;
        tmp_slice_upper_1 = BINARY_OPERATION_ADD_OBJECT_INT(tmp_left_name_1, tmp_right_name_1);
        if (tmp_slice_upper_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 446;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        tmp_assign_source_5 = LOOKUP_SLICE(tmp_slice_source_2, tmp_slice_lower_1, tmp_slice_upper_1);
        Py_DECREF(tmp_slice_upper_1);
        if (tmp_assign_source_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 446;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_proto;
            var_proto = tmp_assign_source_5;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_5;
        CHECK_OBJECT(var_protolist);
        tmp_called_instance_2 = var_protolist;
        CHECK_OBJECT(var_proto);
        tmp_args_element_name_5 = var_proto;
        frame_1f66bae567fc069e7269625d4e4a775a->m_frame.f_lineno = 447;
        {
            PyObject *call_args[] = {tmp_args_element_name_5};
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_append, call_args);
        }

        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 447;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_slice_source_3;
        PyObject *tmp_slice_lower_2;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_2;
        CHECK_OBJECT(var_instr);
        tmp_slice_source_3 = var_instr;
        CHECK_OBJECT(var_encoded_len);
        tmp_left_name_2 = var_encoded_len;
        tmp_right_name_2 = const_int_pos_1;
        tmp_slice_lower_2 = BINARY_OPERATION_ADD_OBJECT_INT(tmp_left_name_2, tmp_right_name_2);
        if (tmp_slice_lower_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 448;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        tmp_assign_source_6 = LOOKUP_SLICE(tmp_slice_source_3, tmp_slice_lower_2, Py_None);
        Py_DECREF(tmp_slice_lower_2);
        if (tmp_assign_source_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 448;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_instr;
            assert(old != NULL);
            var_instr = tmp_assign_source_6;
            Py_DECREF(old);
        }

    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


        exception_lineno = 444;
        type_description_1 = "oooooooooococoo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_called_name_2;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_args_element_name_7;
        if (PyCell_GET(self->m_closure[0]) == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "callback");
            exception_tb = NULL;

            exception_lineno = 451;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }

        tmp_called_name_2 = PyCell_GET(self->m_closure[0]);
        CHECK_OBJECT(var_conn);
        tmp_args_element_name_6 = var_conn;
        CHECK_OBJECT(var_protolist);
        tmp_args_element_name_7 = var_protolist;
        frame_1f66bae567fc069e7269625d4e4a775a->m_frame.f_lineno = 451;
        {
            PyObject *call_args[] = {tmp_args_element_name_6, tmp_args_element_name_7};
            tmp_assign_source_7 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        if (tmp_assign_source_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 451;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        assert(var_outstr == NULL);
        var_outstr = tmp_assign_source_7;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_2;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_4;
        CHECK_OBJECT(var_outstr);
        tmp_isinstance_inst_1 = var_outstr;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__binary_type);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__binary_type);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 418 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 453;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_4;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 453;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        tmp_operand_name_2 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 453;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        tmp_condition_result_2 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_360fff1f759f48242850b1a03fa368f8;
            frame_1f66bae567fc069e7269625d4e4a775a->m_frame.f_lineno = 454;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 454;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        branch_no_2:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_list_element_1;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_len_arg_1;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_args_element_name_11;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 460;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }

        tmp_source_name_2 = tmp_mvar_value_5;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_new);
        if (tmp_called_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 460;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        tmp_args_element_name_8 = const_str_digest_2aaae8e99c54112dad0b0da3957413a9;
        CHECK_OBJECT(var_outstr);
        tmp_len_arg_1 = var_outstr;
        tmp_args_element_name_9 = BUILTIN_LEN(tmp_len_arg_1);
        if (tmp_args_element_name_9 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);

            exception_lineno = 460;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        frame_1f66bae567fc069e7269625d4e4a775a->m_frame.f_lineno = 460;
        {
            PyObject *call_args[] = {tmp_args_element_name_8, tmp_args_element_name_9};
            tmp_list_element_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_3, call_args);
        }

        Py_DECREF(tmp_called_name_3);
        Py_DECREF(tmp_args_element_name_9);
        if (tmp_list_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 460;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        tmp_assattr_name_1 = PyList_New(2);
        PyList_SET_ITEM(tmp_assattr_name_1, 0, tmp_list_element_1);
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_6 == NULL) {
            Py_DECREF(tmp_assattr_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 461;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }

        tmp_called_instance_3 = tmp_mvar_value_6;
        tmp_args_element_name_10 = const_str_digest_81f1b0dfcc7a862e6940580ec4cc42d3;
        CHECK_OBJECT(var_outstr);
        tmp_args_element_name_11 = var_outstr;
        frame_1f66bae567fc069e7269625d4e4a775a->m_frame.f_lineno = 461;
        {
            PyObject *call_args[] = {tmp_args_element_name_10, tmp_args_element_name_11};
            tmp_list_element_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_3, const_str_plain_new, call_args);
        }

        if (tmp_list_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_assattr_name_1);

            exception_lineno = 461;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        PyList_SET_ITEM(tmp_assattr_name_1, 1, tmp_list_element_1);
        CHECK_OBJECT(var_conn);
        tmp_assattr_target_1 = var_conn;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__alpn_select_callback_args, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 459;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
    }
    {
        PyObject *tmp_ass_subvalue_1;
        PyObject *tmp_subscribed_name_2;
        PyObject *tmp_subscribed_name_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_subscript_name_2;
        PyObject *tmp_subscript_name_3;
        PyObject *tmp_ass_subscribed_1;
        PyObject *tmp_ass_subscript_1;
        int tmp_ass_subscript_res_1;
        CHECK_OBJECT(var_conn);
        tmp_source_name_3 = var_conn;
        tmp_subscribed_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__alpn_select_callback_args);
        if (tmp_subscribed_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 463;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        tmp_subscript_name_2 = const_int_0;
        tmp_subscribed_name_2 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_3, tmp_subscript_name_2, 0);
        Py_DECREF(tmp_subscribed_name_3);
        if (tmp_subscribed_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 463;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        tmp_subscript_name_3 = const_int_0;
        tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_2, tmp_subscript_name_3, 0);
        Py_DECREF(tmp_subscribed_name_2);
        if (tmp_ass_subvalue_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 463;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT(par_outlen);
        tmp_ass_subscribed_1 = par_outlen;
        tmp_ass_subscript_1 = const_int_0;
        tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST(tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1);
        Py_DECREF(tmp_ass_subvalue_1);
        if (tmp_ass_subscript_res_1 == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 463;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
    }
    {
        PyObject *tmp_ass_subvalue_2;
        PyObject *tmp_subscribed_name_4;
        PyObject *tmp_source_name_4;
        PyObject *tmp_subscript_name_4;
        PyObject *tmp_ass_subscribed_2;
        PyObject *tmp_ass_subscript_2;
        int tmp_ass_subscript_res_2;
        CHECK_OBJECT(var_conn);
        tmp_source_name_4 = var_conn;
        tmp_subscribed_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain__alpn_select_callback_args);
        if (tmp_subscribed_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 464;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        tmp_subscript_name_4 = const_int_pos_1;
        tmp_ass_subvalue_2 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_4, tmp_subscript_name_4, 1);
        Py_DECREF(tmp_subscribed_name_4);
        if (tmp_ass_subvalue_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 464;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT(par_out);
        tmp_ass_subscribed_2 = par_out;
        tmp_ass_subscript_2 = const_int_0;
        tmp_ass_subscript_res_2 = SET_SUBSCRIPT_CONST(tmp_ass_subscribed_2, tmp_ass_subscript_2, 0, tmp_ass_subvalue_2);
        Py_DECREF(tmp_ass_subvalue_2);
        if (tmp_ass_subscript_res_2 == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 464;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION(frame_1f66bae567fc069e7269625d4e4a775a);
    if (exception_keeper_tb_1 == NULL) {
        exception_keeper_tb_1 = MAKE_TRACEBACK(frame_1f66bae567fc069e7269625d4e4a775a, exception_keeper_lineno_1);
    } else if (exception_keeper_lineno_1 != 0) {
        exception_keeper_tb_1 = ADD_TRACEBACK(exception_keeper_tb_1, frame_1f66bae567fc069e7269625d4e4a775a, exception_keeper_lineno_1);
    }

    NORMALIZE_EXCEPTION(&exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1);
    PUBLISH_EXCEPTION(&exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1);
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_compexpr_left_1 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_1 = PyExc_Exception;
        tmp_res = EXCEPTION_MATCH_BOOL(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 466;
            type_description_1 = "oooooooooococoo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
            goto branch_yes_3;
        } else {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_assign_source_8;
            tmp_assign_source_8 = EXC_VALUE(PyThreadState_GET());
            assert(var_e == NULL);
            Py_INCREF(tmp_assign_source_8);
            var_e = tmp_assign_source_8;
        }
        {
            PyObject *tmp_called_instance_4;
            PyObject *tmp_source_name_5;
            PyObject *tmp_call_result_2;
            PyObject *tmp_args_element_name_12;
            if (PyCell_GET(self->m_closure[1]) == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = PyString_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "self");
                exception_tb = NULL;

                exception_lineno = 467;
                type_description_1 = "oooooooooococoo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_5 = PyCell_GET(self->m_closure[1]);
            tmp_called_instance_4 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain__problems);
            if (tmp_called_instance_4 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 467;
                type_description_1 = "oooooooooococoo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_e);
            tmp_args_element_name_12 = var_e;
            frame_1f66bae567fc069e7269625d4e4a775a->m_frame.f_lineno = 467;
            {
                PyObject *call_args[] = {tmp_args_element_name_12};
                tmp_call_result_2 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_4, const_str_plain_append, call_args);
            }

            Py_DECREF(tmp_called_instance_4);
            if (tmp_call_result_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 467;
                type_description_1 = "oooooooooococoo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_2);
        }
        tmp_return_value = const_int_pos_2;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        goto branch_end_3;
        branch_no_3:;
        tmp_result = RERAISE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
        if (unlikely(tmp_result == false)) {
            exception_lineno = 436;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_1f66bae567fc069e7269625d4e4a775a->m_frame) frame_1f66bae567fc069e7269625d4e4a775a->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "oooooooooococoo";
        goto frame_exception_exit_1;
        branch_end_3:;
    }
    // End of try:
    try_end_1:;

#if 1
    RESTORE_FRAME_EXCEPTION(frame_1f66bae567fc069e7269625d4e4a775a);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION(frame_1f66bae567fc069e7269625d4e4a775a);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION(frame_1f66bae567fc069e7269625d4e4a775a);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_1f66bae567fc069e7269625d4e4a775a, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_1f66bae567fc069e7269625d4e4a775a->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_1f66bae567fc069e7269625d4e4a775a, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1f66bae567fc069e7269625d4e4a775a,
        type_description_1,
        par_ssl,
        par_out,
        par_outlen,
        par_in_,
        par_inlen,
        par_arg,
        var_encoded_len,
        var_protolist,
        var_e,
        var_instr,
        self->m_closure[1],
        var_proto,
        self->m_closure[0],
        var_outstr,
        var_conn
    );


    // Release cached frame.
    if (frame_1f66bae567fc069e7269625d4e4a775a == cache_frame_1f66bae567fc069e7269625d4e4a775a) {
        Py_DECREF(frame_1f66bae567fc069e7269625d4e4a775a);
    }
    cache_frame_1f66bae567fc069e7269625d4e4a775a = NULL;

    assertFrameObject(frame_1f66bae567fc069e7269625d4e4a775a);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = const_int_0;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_6___init__$$$function_1_wrapper);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_encoded_len);
    var_encoded_len = NULL;

    Py_XDECREF(var_protolist);
    var_protolist = NULL;

    Py_XDECREF(var_e);
    var_e = NULL;

    Py_XDECREF(var_instr);
    var_instr = NULL;

    Py_XDECREF(var_proto);
    var_proto = NULL;

    Py_XDECREF(var_outstr);
    var_outstr = NULL;

    Py_XDECREF(var_conn);
    var_conn = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_encoded_len);
    var_encoded_len = NULL;

    Py_XDECREF(var_protolist);
    var_protolist = NULL;

    Py_XDECREF(var_e);
    var_e = NULL;

    Py_XDECREF(var_instr);
    var_instr = NULL;

    Py_XDECREF(var_proto);
    var_proto = NULL;

    Py_XDECREF(var_outstr);
    var_outstr = NULL;

    Py_XDECREF(var_conn);
    var_conn = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_6___init__$$$function_1_wrapper);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_in_);
    Py_DECREF(par_in_);
    CHECK_OBJECT(par_outlen);
    Py_DECREF(par_outlen);
    CHECK_OBJECT(par_ssl);
    Py_DECREF(par_ssl);
    CHECK_OBJECT(par_arg);
    Py_DECREF(par_arg);
    CHECK_OBJECT(par_out);
    Py_DECREF(par_out);
    CHECK_OBJECT(par_inlen);
    Py_DECREF(par_inlen);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_in_);
    Py_DECREF(par_in_);
    CHECK_OBJECT(par_outlen);
    Py_DECREF(par_outlen);
    CHECK_OBJECT(par_ssl);
    Py_DECREF(par_ssl);
    CHECK_OBJECT(par_arg);
    Py_DECREF(par_arg);
    CHECK_OBJECT(par_out);
    Py_DECREF(par_out);
    CHECK_OBJECT(par_inlen);
    Py_DECREF(par_inlen);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_7___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1(python_pars[0]);
    struct Nuitka_CellObject *par_callback = PyCell_NEW1(python_pars[1]);
    PyObject *var_wrapper = NULL;
    struct Nuitka_FrameObject *frame_31b7ea660237ae3ad6904b3b553dbb0b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_31b7ea660237ae3ad6904b3b553dbb0b = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_31b7ea660237ae3ad6904b3b553dbb0b, codeobj_31b7ea660237ae3ad6904b3b553dbb0b, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_31b7ea660237ae3ad6904b3b553dbb0b = cache_frame_31b7ea660237ae3ad6904b3b553dbb0b;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_31b7ea660237ae3ad6904b3b553dbb0b);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_31b7ea660237ae3ad6904b3b553dbb0b) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 83 ], 53, 0);
            exception_tb = NULL;

            exception_lineno = 500;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT(PyCell_GET(par_self));
        tmp_args_element_name_1 = PyCell_GET(par_self);
        frame_31b7ea660237ae3ad6904b3b553dbb0b->m_frame.f_lineno = 500;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain___init__, call_args);
        }

        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 500;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_wraps);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_wraps);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 136 ], 34, 0);
            exception_tb = NULL;

            exception_lineno = 502;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT(PyCell_GET(par_callback));
        tmp_args_element_name_2 = PyCell_GET(par_callback);
        frame_31b7ea660237ae3ad6904b3b553dbb0b->m_frame.f_lineno = 502;
        tmp_called_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_2);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 502;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = MAKE_FUNCTION_OpenSSL$SSL$$$function_7___init__$$$function_1_wrapper();

        ((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[0] = par_callback;
        Py_INCREF(((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[0]);
        ((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[1] = par_self;
        Py_INCREF(((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[1]);


        frame_31b7ea660237ae3ad6904b3b553dbb0b->m_frame.f_lineno = 502;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_3);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 502;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        assert(var_wrapper == NULL);
        var_wrapper = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 541;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_3;
        tmp_args_element_name_4 = const_str_digest_9575fec1eee4d60c15d3f7c228d8045c;
        CHECK_OBJECT(var_wrapper);
        tmp_args_element_name_5 = var_wrapper;
        frame_31b7ea660237ae3ad6904b3b553dbb0b->m_frame.f_lineno = 541;
        {
            PyObject *call_args[] = {tmp_args_element_name_4, tmp_args_element_name_5};
            tmp_assattr_name_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_2, const_str_plain_callback, call_args);
        }

        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 541;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(PyCell_GET(par_self));
        tmp_assattr_target_1 = PyCell_GET(par_self);
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain_callback, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 541;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_31b7ea660237ae3ad6904b3b553dbb0b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_31b7ea660237ae3ad6904b3b553dbb0b);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_31b7ea660237ae3ad6904b3b553dbb0b, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_31b7ea660237ae3ad6904b3b553dbb0b->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_31b7ea660237ae3ad6904b3b553dbb0b, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_31b7ea660237ae3ad6904b3b553dbb0b,
        type_description_1,
        par_self,
        par_callback,
        var_wrapper
    );


    // Release cached frame.
    if (frame_31b7ea660237ae3ad6904b3b553dbb0b == cache_frame_31b7ea660237ae3ad6904b3b553dbb0b) {
        Py_DECREF(frame_31b7ea660237ae3ad6904b3b553dbb0b);
    }
    cache_frame_31b7ea660237ae3ad6904b3b553dbb0b = NULL;

    assertFrameObject(frame_31b7ea660237ae3ad6904b3b553dbb0b);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_7___init__);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_wrapper);
    Py_DECREF(var_wrapper);
    var_wrapper = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_wrapper);
    var_wrapper = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_7___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_callback);
    Py_DECREF(par_callback);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_callback);
    Py_DECREF(par_callback);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_7___init__$$$function_1_wrapper(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_ssl = python_pars[0];
    PyObject *par_cdata = python_pars[1];
    PyObject *var_e = NULL;
    PyObject *var_ocsp_data_length = NULL;
    PyObject *var_ocsp_data = NULL;
    PyObject *var_data_ptr = NULL;
    PyObject *var_data = NULL;
    PyObject *var_conn = NULL;
    struct Nuitka_FrameObject *frame_cd50f2607dc6e8cfc0715ef171ecbc55;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    bool tmp_result;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_cd50f2607dc6e8cfc0715ef171ecbc55 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_cd50f2607dc6e8cfc0715ef171ecbc55, codeobj_cd50f2607dc6e8cfc0715ef171ecbc55, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_cd50f2607dc6e8cfc0715ef171ecbc55 = cache_frame_cd50f2607dc6e8cfc0715ef171ecbc55;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_cd50f2607dc6e8cfc0715ef171ecbc55);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_cd50f2607dc6e8cfc0715ef171ecbc55) == 2); // Frame stack

    // Framed code:
    // Tried code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_subscript_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Connection);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_Connection);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 269 ], 39, 0);
            exception_tb = NULL;

            exception_lineno = 505;
            type_description_1 = "ooooccoooo";
            goto try_except_handler_2;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__reverse_mapping);
        if (tmp_subscribed_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 505;
            type_description_1 = "ooooccoooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT(par_ssl);
        tmp_subscript_name_1 = par_ssl;
        tmp_assign_source_1 = LOOKUP_SUBSCRIPT(tmp_subscribed_name_1, tmp_subscript_name_1);
        Py_DECREF(tmp_subscribed_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 505;
            type_description_1 = "ooooccoooo";
            goto try_except_handler_2;
        }
        assert(var_conn == NULL);
        var_conn = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT(par_cdata);
        tmp_compexpr_left_1 = par_cdata;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 508;
            type_description_1 = "ooooccoooo";
            goto try_except_handler_2;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_NULL);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 508;
            type_description_1 = "ooooccoooo";
            goto try_except_handler_2;
        }
        tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 508;
            type_description_1 = "ooooccoooo";
            goto try_except_handler_2;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_args_element_name_1;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_3 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 509;
                type_description_1 = "ooooccoooo";
                goto try_except_handler_2;
            }

            tmp_called_instance_1 = tmp_mvar_value_3;
            CHECK_OBJECT(par_cdata);
            tmp_args_element_name_1 = par_cdata;
            frame_cd50f2607dc6e8cfc0715ef171ecbc55->m_frame.f_lineno = 509;
            {
                PyObject *call_args[] = {tmp_args_element_name_1};
                tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_from_handle, call_args);
            }

            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 509;
                type_description_1 = "ooooccoooo";
                goto try_except_handler_2;
            }
            assert(var_data == NULL);
            var_data = tmp_assign_source_2;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_3;
            tmp_assign_source_3 = Py_None;
            assert(var_data == NULL);
            Py_INCREF(tmp_assign_source_3);
            var_data = tmp_assign_source_3;
        }
        branch_end_1:;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        if (PyCell_GET(self->m_closure[0]) == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "callback");
            exception_tb = NULL;

            exception_lineno = 514;
            type_description_1 = "ooooccoooo";
            goto try_except_handler_2;
        }

        tmp_called_name_1 = PyCell_GET(self->m_closure[0]);
        CHECK_OBJECT(var_conn);
        tmp_args_element_name_2 = var_conn;
        CHECK_OBJECT(var_data);
        tmp_args_element_name_3 = var_data;
        frame_cd50f2607dc6e8cfc0715ef171ecbc55->m_frame.f_lineno = 514;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        if (tmp_assign_source_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 514;
            type_description_1 = "ooooccoooo";
            goto try_except_handler_2;
        }
        assert(var_ocsp_data == NULL);
        var_ocsp_data = tmp_assign_source_4;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_4;
        CHECK_OBJECT(var_ocsp_data);
        tmp_isinstance_inst_1 = var_ocsp_data;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__binary_type);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__binary_type);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 418 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 516;
            type_description_1 = "ooooccoooo";
            goto try_except_handler_2;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_4;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 516;
            type_description_1 = "ooooccoooo";
            goto try_except_handler_2;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 516;
            type_description_1 = "ooooccoooo";
            goto try_except_handler_2;
        }
        tmp_condition_result_2 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_f4ac5993e0eb53c16d6349308d51d30e;
            frame_cd50f2607dc6e8cfc0715ef171ecbc55->m_frame.f_lineno = 517;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 517;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooooccoooo";
            goto try_except_handler_2;
        }
        branch_no_2:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_operand_name_2;
        CHECK_OBJECT(var_ocsp_data);
        tmp_operand_name_2 = var_ocsp_data;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 523;
            type_description_1 = "ooooccoooo";
            goto try_except_handler_2;
        }
        tmp_condition_result_3 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
            goto branch_yes_3;
        } else {
            goto branch_no_3;
        }
        branch_yes_3:;
        tmp_return_value = const_int_pos_3;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_3:;
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_len_arg_1;
        CHECK_OBJECT(var_ocsp_data);
        tmp_len_arg_1 = var_ocsp_data;
        tmp_assign_source_5 = BUILTIN_LEN(tmp_len_arg_1);
        if (tmp_assign_source_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 528;
            type_description_1 = "ooooccoooo";
            goto try_except_handler_2;
        }
        assert(var_ocsp_data_length == NULL);
        var_ocsp_data_length = tmp_assign_source_5;
    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 529;
            type_description_1 = "ooooccoooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_2 = tmp_mvar_value_5;
        CHECK_OBJECT(var_ocsp_data_length);
        tmp_args_element_name_4 = var_ocsp_data_length;
        frame_cd50f2607dc6e8cfc0715ef171ecbc55->m_frame.f_lineno = 529;
        {
            PyObject *call_args[] = {tmp_args_element_name_4};
            tmp_assign_source_6 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_OPENSSL_malloc, call_args);
        }

        if (tmp_assign_source_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 529;
            type_description_1 = "ooooccoooo";
            goto try_except_handler_2;
        }
        assert(var_data_ptr == NULL);
        var_data_ptr = tmp_assign_source_6;
    }
    {
        PyObject *tmp_sliceass_value_1;
        PyObject *tmp_sliceass_target_1;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_args_element_name_6;
        Py_ssize_t tmp_sliceassslicedel_index_lower_1;
        Py_ssize_t tmp_sliceass_index_upper_1;
        CHECK_OBJECT(var_ocsp_data);
        tmp_sliceass_value_1 = var_ocsp_data;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_6 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 530;
            type_description_1 = "ooooccoooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_3 = tmp_mvar_value_6;
        CHECK_OBJECT(var_data_ptr);
        tmp_args_element_name_5 = var_data_ptr;
        CHECK_OBJECT(var_ocsp_data_length);
        tmp_args_element_name_6 = var_ocsp_data_length;
        frame_cd50f2607dc6e8cfc0715ef171ecbc55->m_frame.f_lineno = 530;
        {
            PyObject *call_args[] = {tmp_args_element_name_5, tmp_args_element_name_6};
            tmp_sliceass_target_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_3, const_str_plain_buffer, call_args);
        }

        if (tmp_sliceass_target_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 530;
            type_description_1 = "ooooccoooo";
            goto try_except_handler_2;
        }
        tmp_sliceassslicedel_index_lower_1 = 0;
        tmp_sliceass_index_upper_1 = PY_SSIZE_T_MAX;
        tmp_result = SET_INDEX_SLICE(tmp_sliceass_target_1, tmp_sliceassslicedel_index_lower_1, tmp_sliceass_index_upper_1, tmp_sliceass_value_1);
        Py_DECREF(tmp_sliceass_target_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 530;
            type_description_1 = "ooooccoooo";
            goto try_except_handler_2;
        }
    }
    {
        PyObject *tmp_called_instance_4;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_args_element_name_9;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_7 == NULL)) {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_7 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 532;
            type_description_1 = "ooooccoooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_4 = tmp_mvar_value_7;
        CHECK_OBJECT(par_ssl);
        tmp_args_element_name_7 = par_ssl;
        CHECK_OBJECT(var_data_ptr);
        tmp_args_element_name_8 = var_data_ptr;
        CHECK_OBJECT(var_ocsp_data_length);
        tmp_args_element_name_9 = var_ocsp_data_length;
        frame_cd50f2607dc6e8cfc0715ef171ecbc55->m_frame.f_lineno = 532;
        {
            PyObject *call_args[] = {tmp_args_element_name_7, tmp_args_element_name_8, tmp_args_element_name_9};
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS3(tmp_called_instance_4, const_str_plain_SSL_set_tlsext_status_ocsp_resp, call_args);
        }

        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 532;
            type_description_1 = "ooooccoooo";
            goto try_except_handler_2;
        }
        Py_DECREF(tmp_call_result_1);
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION(frame_cd50f2607dc6e8cfc0715ef171ecbc55);
    if (exception_keeper_tb_1 == NULL) {
        exception_keeper_tb_1 = MAKE_TRACEBACK(frame_cd50f2607dc6e8cfc0715ef171ecbc55, exception_keeper_lineno_1);
    } else if (exception_keeper_lineno_1 != 0) {
        exception_keeper_tb_1 = ADD_TRACEBACK(exception_keeper_tb_1, frame_cd50f2607dc6e8cfc0715ef171ecbc55, exception_keeper_lineno_1);
    }

    NORMALIZE_EXCEPTION(&exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1);
    PUBLISH_EXCEPTION(&exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1);
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        tmp_compexpr_left_2 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_2 = PyExc_Exception;
        tmp_res = EXCEPTION_MATCH_BOOL(tmp_compexpr_left_2, tmp_compexpr_right_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 537;
            type_description_1 = "ooooccoooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_4 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_4 == NUITKA_BOOL_TRUE) {
            goto branch_yes_4;
        } else {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_assign_source_7;
            tmp_assign_source_7 = EXC_VALUE(PyThreadState_GET());
            assert(var_e == NULL);
            Py_INCREF(tmp_assign_source_7);
            var_e = tmp_assign_source_7;
        }
        {
            PyObject *tmp_called_instance_5;
            PyObject *tmp_source_name_3;
            PyObject *tmp_call_result_2;
            PyObject *tmp_args_element_name_10;
            if (PyCell_GET(self->m_closure[1]) == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = PyString_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "self");
                exception_tb = NULL;

                exception_lineno = 538;
                type_description_1 = "ooooccoooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_3 = PyCell_GET(self->m_closure[1]);
            tmp_called_instance_5 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__problems);
            if (tmp_called_instance_5 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 538;
                type_description_1 = "ooooccoooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_e);
            tmp_args_element_name_10 = var_e;
            frame_cd50f2607dc6e8cfc0715ef171ecbc55->m_frame.f_lineno = 538;
            {
                PyObject *call_args[] = {tmp_args_element_name_10};
                tmp_call_result_2 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_5, const_str_plain_append, call_args);
            }

            Py_DECREF(tmp_called_instance_5);
            if (tmp_call_result_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 538;
                type_description_1 = "ooooccoooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_2);
        }
        tmp_return_value = const_int_pos_2;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        goto branch_end_4;
        branch_no_4:;
        tmp_result = RERAISE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
        if (unlikely(tmp_result == false)) {
            exception_lineno = 504;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_cd50f2607dc6e8cfc0715ef171ecbc55->m_frame) frame_cd50f2607dc6e8cfc0715ef171ecbc55->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "ooooccoooo";
        goto frame_exception_exit_1;
        branch_end_4:;
    }
    // End of try:
    try_end_1:;

#if 1
    RESTORE_FRAME_EXCEPTION(frame_cd50f2607dc6e8cfc0715ef171ecbc55);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION(frame_cd50f2607dc6e8cfc0715ef171ecbc55);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION(frame_cd50f2607dc6e8cfc0715ef171ecbc55);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_cd50f2607dc6e8cfc0715ef171ecbc55, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_cd50f2607dc6e8cfc0715ef171ecbc55->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_cd50f2607dc6e8cfc0715ef171ecbc55, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_cd50f2607dc6e8cfc0715ef171ecbc55,
        type_description_1,
        par_ssl,
        par_cdata,
        var_e,
        var_ocsp_data_length,
        self->m_closure[0],
        self->m_closure[1],
        var_ocsp_data,
        var_data_ptr,
        var_data,
        var_conn
    );


    // Release cached frame.
    if (frame_cd50f2607dc6e8cfc0715ef171ecbc55 == cache_frame_cd50f2607dc6e8cfc0715ef171ecbc55) {
        Py_DECREF(frame_cd50f2607dc6e8cfc0715ef171ecbc55);
    }
    cache_frame_cd50f2607dc6e8cfc0715ef171ecbc55 = NULL;

    assertFrameObject(frame_cd50f2607dc6e8cfc0715ef171ecbc55);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = const_int_0;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_7___init__$$$function_1_wrapper);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_e);
    var_e = NULL;

    Py_XDECREF(var_ocsp_data_length);
    var_ocsp_data_length = NULL;

    Py_XDECREF(var_ocsp_data);
    var_ocsp_data = NULL;

    Py_XDECREF(var_data_ptr);
    var_data_ptr = NULL;

    Py_XDECREF(var_data);
    var_data = NULL;

    Py_XDECREF(var_conn);
    var_conn = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_e);
    var_e = NULL;

    Py_XDECREF(var_ocsp_data_length);
    var_ocsp_data_length = NULL;

    Py_XDECREF(var_ocsp_data);
    var_ocsp_data = NULL;

    Py_XDECREF(var_data_ptr);
    var_data_ptr = NULL;

    Py_XDECREF(var_data);
    var_data = NULL;

    Py_XDECREF(var_conn);
    var_conn = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_7___init__$$$function_1_wrapper);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_ssl);
    Py_DECREF(par_ssl);
    CHECK_OBJECT(par_cdata);
    Py_DECREF(par_cdata);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_ssl);
    Py_DECREF(par_ssl);
    CHECK_OBJECT(par_cdata);
    Py_DECREF(par_cdata);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_8___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1(python_pars[0]);
    struct Nuitka_CellObject *par_callback = PyCell_NEW1(python_pars[1]);
    PyObject *var_wrapper = NULL;
    struct Nuitka_FrameObject *frame_5b498c42a86529628b46de5b97e617d3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_5b498c42a86529628b46de5b97e617d3 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_5b498c42a86529628b46de5b97e617d3, codeobj_5b498c42a86529628b46de5b97e617d3, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_5b498c42a86529628b46de5b97e617d3 = cache_frame_5b498c42a86529628b46de5b97e617d3;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_5b498c42a86529628b46de5b97e617d3);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_5b498c42a86529628b46de5b97e617d3) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 83 ], 53, 0);
            exception_tb = NULL;

            exception_lineno = 567;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT(PyCell_GET(par_self));
        tmp_args_element_name_1 = PyCell_GET(par_self);
        frame_5b498c42a86529628b46de5b97e617d3->m_frame.f_lineno = 567;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain___init__, call_args);
        }

        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 567;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_wraps);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_wraps);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 136 ], 34, 0);
            exception_tb = NULL;

            exception_lineno = 569;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT(PyCell_GET(par_callback));
        tmp_args_element_name_2 = PyCell_GET(par_callback);
        frame_5b498c42a86529628b46de5b97e617d3->m_frame.f_lineno = 569;
        tmp_called_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_2);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 569;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = MAKE_FUNCTION_OpenSSL$SSL$$$function_8___init__$$$function_1_wrapper();

        ((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[0] = par_callback;
        Py_INCREF(((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[0]);
        ((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[1] = par_self;
        Py_INCREF(((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[1]);


        frame_5b498c42a86529628b46de5b97e617d3->m_frame.f_lineno = 569;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_3);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 569;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        assert(var_wrapper == NULL);
        var_wrapper = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 600;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_3;
        tmp_args_element_name_4 = const_str_digest_9575fec1eee4d60c15d3f7c228d8045c;
        CHECK_OBJECT(var_wrapper);
        tmp_args_element_name_5 = var_wrapper;
        frame_5b498c42a86529628b46de5b97e617d3->m_frame.f_lineno = 600;
        {
            PyObject *call_args[] = {tmp_args_element_name_4, tmp_args_element_name_5};
            tmp_assattr_name_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_2, const_str_plain_callback, call_args);
        }

        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 600;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(PyCell_GET(par_self));
        tmp_assattr_target_1 = PyCell_GET(par_self);
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain_callback, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 600;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5b498c42a86529628b46de5b97e617d3);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5b498c42a86529628b46de5b97e617d3);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_5b498c42a86529628b46de5b97e617d3, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_5b498c42a86529628b46de5b97e617d3->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_5b498c42a86529628b46de5b97e617d3, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5b498c42a86529628b46de5b97e617d3,
        type_description_1,
        par_self,
        par_callback,
        var_wrapper
    );


    // Release cached frame.
    if (frame_5b498c42a86529628b46de5b97e617d3 == cache_frame_5b498c42a86529628b46de5b97e617d3) {
        Py_DECREF(frame_5b498c42a86529628b46de5b97e617d3);
    }
    cache_frame_5b498c42a86529628b46de5b97e617d3 = NULL;

    assertFrameObject(frame_5b498c42a86529628b46de5b97e617d3);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_8___init__);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_wrapper);
    Py_DECREF(var_wrapper);
    var_wrapper = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_wrapper);
    var_wrapper = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_8___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_callback);
    Py_DECREF(par_callback);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_callback);
    Py_DECREF(par_callback);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_8___init__$$$function_1_wrapper(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_ssl = python_pars[0];
    PyObject *par_cdata = python_pars[1];
    PyObject *var_ocsp_len = NULL;
    PyObject *var_e = NULL;
    PyObject *var_valid = NULL;
    PyObject *var_ocsp_ptr = NULL;
    PyObject *var_ocsp_data = NULL;
    PyObject *var_data = NULL;
    PyObject *var_conn = NULL;
    struct Nuitka_FrameObject *frame_6dbabe0cc3fa56b737c573ecdbbbc1cc;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_6dbabe0cc3fa56b737c573ecdbbbc1cc = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_6dbabe0cc3fa56b737c573ecdbbbc1cc, codeobj_6dbabe0cc3fa56b737c573ecdbbbc1cc, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_6dbabe0cc3fa56b737c573ecdbbbc1cc = cache_frame_6dbabe0cc3fa56b737c573ecdbbbc1cc;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_6dbabe0cc3fa56b737c573ecdbbbc1cc);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_6dbabe0cc3fa56b737c573ecdbbbc1cc) == 2); // Frame stack

    // Framed code:
    // Tried code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_subscript_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Connection);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_Connection);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 269 ], 39, 0);
            exception_tb = NULL;

            exception_lineno = 572;
            type_description_1 = "ooooccooooo";
            goto try_except_handler_2;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__reverse_mapping);
        if (tmp_subscribed_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 572;
            type_description_1 = "ooooccooooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT(par_ssl);
        tmp_subscript_name_1 = par_ssl;
        tmp_assign_source_1 = LOOKUP_SUBSCRIPT(tmp_subscribed_name_1, tmp_subscript_name_1);
        Py_DECREF(tmp_subscribed_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 572;
            type_description_1 = "ooooccooooo";
            goto try_except_handler_2;
        }
        assert(var_conn == NULL);
        var_conn = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT(par_cdata);
        tmp_compexpr_left_1 = par_cdata;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 575;
            type_description_1 = "ooooccooooo";
            goto try_except_handler_2;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_NULL);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 575;
            type_description_1 = "ooooccooooo";
            goto try_except_handler_2;
        }
        tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 575;
            type_description_1 = "ooooccooooo";
            goto try_except_handler_2;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_args_element_name_1;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_3 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 576;
                type_description_1 = "ooooccooooo";
                goto try_except_handler_2;
            }

            tmp_called_instance_1 = tmp_mvar_value_3;
            CHECK_OBJECT(par_cdata);
            tmp_args_element_name_1 = par_cdata;
            frame_6dbabe0cc3fa56b737c573ecdbbbc1cc->m_frame.f_lineno = 576;
            {
                PyObject *call_args[] = {tmp_args_element_name_1};
                tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_from_handle, call_args);
            }

            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 576;
                type_description_1 = "ooooccooooo";
                goto try_except_handler_2;
            }
            assert(var_data == NULL);
            var_data = tmp_assign_source_2;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_3;
            tmp_assign_source_3 = Py_None;
            assert(var_data == NULL);
            Py_INCREF(tmp_assign_source_3);
            var_data = tmp_assign_source_3;
        }
        branch_end_1:;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_4;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 581;
            type_description_1 = "ooooccooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_2 = tmp_mvar_value_4;
        frame_6dbabe0cc3fa56b737c573ecdbbbc1cc->m_frame.f_lineno = 581;
        tmp_assign_source_4 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_new, &PyTuple_GET_ITEM(const_tuple_str_digest_52773e1185116024389d12c91a4ccf3d_tuple, 0));

        if (tmp_assign_source_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 581;
            type_description_1 = "ooooccooooo";
            goto try_except_handler_2;
        }
        assert(var_ocsp_ptr == NULL);
        var_ocsp_ptr = tmp_assign_source_4;
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 582;
            type_description_1 = "ooooccooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_3 = tmp_mvar_value_5;
        CHECK_OBJECT(par_ssl);
        tmp_args_element_name_2 = par_ssl;
        CHECK_OBJECT(var_ocsp_ptr);
        tmp_args_element_name_3 = var_ocsp_ptr;
        frame_6dbabe0cc3fa56b737c573ecdbbbc1cc->m_frame.f_lineno = 582;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_assign_source_5 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_3, const_str_plain_SSL_get_tlsext_status_ocsp_resp, call_args);
        }

        if (tmp_assign_source_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 582;
            type_description_1 = "ooooccooooo";
            goto try_except_handler_2;
        }
        assert(var_ocsp_len == NULL);
        var_ocsp_len = tmp_assign_source_5;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        CHECK_OBJECT(var_ocsp_len);
        tmp_compexpr_left_2 = var_ocsp_len;
        tmp_compexpr_right_2 = const_int_0;
        tmp_res = RICH_COMPARE_BOOL_LT_OBJECT_INT(tmp_compexpr_left_2, tmp_compexpr_right_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 583;
            type_description_1 = "ooooccooooo";
            goto try_except_handler_2;
        }
        tmp_condition_result_2 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_6;
            tmp_assign_source_6 = const_str_empty;
            assert(var_ocsp_data == NULL);
            Py_INCREF(tmp_assign_source_6);
            var_ocsp_data = tmp_assign_source_6;
        }
        goto branch_end_2;
        branch_no_2:;
        {
            PyObject *tmp_assign_source_7;
            Py_ssize_t tmp_sliceslicedel_index_lower_1;
            Py_ssize_t tmp_slice_index_upper_1;
            PyObject *tmp_slice_source_1;
            PyObject *tmp_called_name_1;
            PyObject *tmp_source_name_3;
            PyObject *tmp_mvar_value_6;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_subscribed_name_2;
            PyObject *tmp_subscript_name_2;
            PyObject *tmp_args_element_name_5;
            tmp_sliceslicedel_index_lower_1 = 0;
            tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_6 == NULL)) {
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_6 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 588;
                type_description_1 = "ooooccooooo";
                goto try_except_handler_2;
            }

            tmp_source_name_3 = tmp_mvar_value_6;
            tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_buffer);
            if (tmp_called_name_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 588;
                type_description_1 = "ooooccooooo";
                goto try_except_handler_2;
            }
            CHECK_OBJECT(var_ocsp_ptr);
            tmp_subscribed_name_2 = var_ocsp_ptr;
            tmp_subscript_name_2 = const_int_0;
            tmp_args_element_name_4 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_2, tmp_subscript_name_2, 0);
            if (tmp_args_element_name_4 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_1);

                exception_lineno = 588;
                type_description_1 = "ooooccooooo";
                goto try_except_handler_2;
            }
            CHECK_OBJECT(var_ocsp_len);
            tmp_args_element_name_5 = var_ocsp_len;
            frame_6dbabe0cc3fa56b737c573ecdbbbc1cc->m_frame.f_lineno = 588;
            {
                PyObject *call_args[] = {tmp_args_element_name_4, tmp_args_element_name_5};
                tmp_slice_source_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
            }

            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_element_name_4);
            if (tmp_slice_source_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 588;
                type_description_1 = "ooooccooooo";
                goto try_except_handler_2;
            }
            tmp_assign_source_7 = LOOKUP_INDEX_SLICE(tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1);
            Py_DECREF(tmp_slice_source_1);
            if (tmp_assign_source_7 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 588;
                type_description_1 = "ooooccooooo";
                goto try_except_handler_2;
            }
            assert(var_ocsp_data == NULL);
            var_ocsp_data = tmp_assign_source_7;
        }
        branch_end_2:;
    }
    {
        PyObject *tmp_assign_source_8;
        PyObject *tmp_called_name_2;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_args_element_name_8;
        if (PyCell_GET(self->m_closure[0]) == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "callback");
            exception_tb = NULL;

            exception_lineno = 590;
            type_description_1 = "ooooccooooo";
            goto try_except_handler_2;
        }

        tmp_called_name_2 = PyCell_GET(self->m_closure[0]);
        CHECK_OBJECT(var_conn);
        tmp_args_element_name_6 = var_conn;
        CHECK_OBJECT(var_ocsp_data);
        tmp_args_element_name_7 = var_ocsp_data;
        CHECK_OBJECT(var_data);
        tmp_args_element_name_8 = var_data;
        frame_6dbabe0cc3fa56b737c573ecdbbbc1cc->m_frame.f_lineno = 590;
        {
            PyObject *call_args[] = {tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8};
            tmp_assign_source_8 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_2, call_args);
        }

        if (tmp_assign_source_8 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 590;
            type_description_1 = "ooooccooooo";
            goto try_except_handler_2;
        }
        assert(var_valid == NULL);
        var_valid = tmp_assign_source_8;
    }
    {
        PyObject *tmp_int_arg_1;
        PyObject *tmp_value_name_1;
        CHECK_OBJECT(var_valid);
        tmp_value_name_1 = var_valid;
        tmp_res = CHECK_IF_TRUE(tmp_value_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 593;
            type_description_1 = "ooooccooooo";
            goto try_except_handler_2;
        }
        tmp_int_arg_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_return_value = PyNumber_Int(tmp_int_arg_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 593;
            type_description_1 = "ooooccooooo";
            goto try_except_handler_2;
        }
        goto frame_return_exit_1;
    }
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_8___init__$$$function_1_wrapper);
    return NULL;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION(frame_6dbabe0cc3fa56b737c573ecdbbbc1cc);
    if (exception_keeper_tb_1 == NULL) {
        exception_keeper_tb_1 = MAKE_TRACEBACK(frame_6dbabe0cc3fa56b737c573ecdbbbc1cc, exception_keeper_lineno_1);
    } else if (exception_keeper_lineno_1 != 0) {
        exception_keeper_tb_1 = ADD_TRACEBACK(exception_keeper_tb_1, frame_6dbabe0cc3fa56b737c573ecdbbbc1cc, exception_keeper_lineno_1);
    }

    NORMALIZE_EXCEPTION(&exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1);
    PUBLISH_EXCEPTION(&exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1);
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        tmp_compexpr_left_3 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_3 = PyExc_Exception;
        tmp_res = EXCEPTION_MATCH_BOOL(tmp_compexpr_left_3, tmp_compexpr_right_3);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 595;
            type_description_1 = "ooooccooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
            goto branch_yes_3;
        } else {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_assign_source_9;
            tmp_assign_source_9 = EXC_VALUE(PyThreadState_GET());
            assert(var_e == NULL);
            Py_INCREF(tmp_assign_source_9);
            var_e = tmp_assign_source_9;
        }
        {
            PyObject *tmp_called_instance_4;
            PyObject *tmp_source_name_4;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_9;
            if (PyCell_GET(self->m_closure[1]) == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = PyString_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "self");
                exception_tb = NULL;

                exception_lineno = 596;
                type_description_1 = "ooooccooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_4 = PyCell_GET(self->m_closure[1]);
            tmp_called_instance_4 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain__problems);
            if (tmp_called_instance_4 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 596;
                type_description_1 = "ooooccooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_e);
            tmp_args_element_name_9 = var_e;
            frame_6dbabe0cc3fa56b737c573ecdbbbc1cc->m_frame.f_lineno = 596;
            {
                PyObject *call_args[] = {tmp_args_element_name_9};
                tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_4, const_str_plain_append, call_args);
            }

            Py_DECREF(tmp_called_instance_4);
            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 596;
                type_description_1 = "ooooccooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_1);
        }
        tmp_return_value = const_int_neg_1;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        goto branch_end_3;
        branch_no_3:;
        tmp_result = RERAISE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
        if (unlikely(tmp_result == false)) {
            exception_lineno = 571;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_6dbabe0cc3fa56b737c573ecdbbbc1cc->m_frame) frame_6dbabe0cc3fa56b737c573ecdbbbc1cc->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "ooooccooooo";
        goto frame_exception_exit_1;
        branch_end_3:;
    }
    // End of try:

#if 1
    RESTORE_FRAME_EXCEPTION(frame_6dbabe0cc3fa56b737c573ecdbbbc1cc);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION(frame_6dbabe0cc3fa56b737c573ecdbbbc1cc);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION(frame_6dbabe0cc3fa56b737c573ecdbbbc1cc);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_6dbabe0cc3fa56b737c573ecdbbbc1cc, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_6dbabe0cc3fa56b737c573ecdbbbc1cc->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_6dbabe0cc3fa56b737c573ecdbbbc1cc, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6dbabe0cc3fa56b737c573ecdbbbc1cc,
        type_description_1,
        par_ssl,
        par_cdata,
        var_ocsp_len,
        var_e,
        self->m_closure[0],
        self->m_closure[1],
        var_valid,
        var_ocsp_ptr,
        var_ocsp_data,
        var_data,
        var_conn
    );


    // Release cached frame.
    if (frame_6dbabe0cc3fa56b737c573ecdbbbc1cc == cache_frame_6dbabe0cc3fa56b737c573ecdbbbc1cc) {
        Py_DECREF(frame_6dbabe0cc3fa56b737c573ecdbbbc1cc);
    }
    cache_frame_6dbabe0cc3fa56b737c573ecdbbbc1cc = NULL;

    assertFrameObject(frame_6dbabe0cc3fa56b737c573ecdbbbc1cc);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_8___init__$$$function_1_wrapper);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_ocsp_len);
    var_ocsp_len = NULL;

    Py_XDECREF(var_e);
    var_e = NULL;

    Py_XDECREF(var_valid);
    var_valid = NULL;

    Py_XDECREF(var_ocsp_ptr);
    var_ocsp_ptr = NULL;

    Py_XDECREF(var_ocsp_data);
    var_ocsp_data = NULL;

    Py_XDECREF(var_data);
    var_data = NULL;

    Py_XDECREF(var_conn);
    var_conn = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_ocsp_len);
    var_ocsp_len = NULL;

    Py_XDECREF(var_e);
    var_e = NULL;

    Py_XDECREF(var_valid);
    var_valid = NULL;

    Py_XDECREF(var_ocsp_ptr);
    var_ocsp_ptr = NULL;

    Py_XDECREF(var_ocsp_data);
    var_ocsp_data = NULL;

    Py_XDECREF(var_data);
    var_data = NULL;

    Py_XDECREF(var_conn);
    var_conn = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_8___init__$$$function_1_wrapper);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_ssl);
    Py_DECREF(par_ssl);
    CHECK_OBJECT(par_cdata);
    Py_DECREF(par_cdata);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_ssl);
    Py_DECREF(par_ssl);
    CHECK_OBJECT(par_cdata);
    Py_DECREF(par_cdata);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_9__asFileDescriptor(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_obj = python_pars[0];
    PyObject *var_fd = NULL;
    PyObject *var_meth = NULL;
    struct Nuitka_FrameObject *frame_36419b8e55b17a9cf1f1164d41ec30e1;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_36419b8e55b17a9cf1f1164d41ec30e1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = Py_None;
        assert(var_fd == NULL);
        Py_INCREF(tmp_assign_source_1);
        var_fd = tmp_assign_source_1;
    }
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_36419b8e55b17a9cf1f1164d41ec30e1, codeobj_36419b8e55b17a9cf1f1164d41ec30e1, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_36419b8e55b17a9cf1f1164d41ec30e1 = cache_frame_36419b8e55b17a9cf1f1164d41ec30e1;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_36419b8e55b17a9cf1f1164d41ec30e1);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_36419b8e55b17a9cf1f1164d41ec30e1) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_obj);
        tmp_isinstance_inst_1 = par_obj;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_types);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 459 ], 42, 0);
            exception_tb = NULL;

            exception_lineno = 605;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 605;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 605;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_getattr_target_1;
            PyObject *tmp_getattr_attr_1;
            PyObject *tmp_getattr_default_1;
            CHECK_OBJECT(par_obj);
            tmp_getattr_target_1 = par_obj;
            tmp_getattr_attr_1 = const_str_plain_fileno;
            tmp_getattr_default_1 = Py_None;
            tmp_assign_source_2 = BUILTIN_GETATTR(tmp_getattr_target_1, tmp_getattr_attr_1, tmp_getattr_default_1);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 606;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            assert(var_meth == NULL);
            var_meth = tmp_assign_source_2;
        }
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_1;
            PyObject *tmp_compexpr_right_1;
            CHECK_OBJECT(var_meth);
            tmp_compexpr_left_1 = var_meth;
            tmp_compexpr_right_1 = Py_None;
            tmp_condition_result_2 = (tmp_compexpr_left_1 != tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
                goto branch_yes_2;
            } else {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_assign_source_3;
                PyObject *tmp_called_name_1;
                CHECK_OBJECT(var_meth);
                tmp_called_name_1 = var_meth;
                frame_36419b8e55b17a9cf1f1164d41ec30e1->m_frame.f_lineno = 608;
                tmp_assign_source_3 = CALL_FUNCTION_NO_ARGS(tmp_called_name_1);
                if (tmp_assign_source_3 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 608;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                {
                    PyObject *old = par_obj;
                    assert(old != NULL);
                    par_obj = tmp_assign_source_3;
                    Py_DECREF(old);
                }

            }
            branch_no_2:;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_isinstance_inst_2;
        PyObject *tmp_isinstance_cls_2;
        PyObject *tmp_mvar_value_2;
        if (par_obj == NULL) {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("local variable '%s' referenced before assignment", "obj");
            exception_tb = NULL;

            exception_lineno = 610;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_inst_2 = par_obj;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_types);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 459 ], 42, 0);
            exception_tb = NULL;

            exception_lineno = 610;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_2 = tmp_mvar_value_2;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_2, tmp_isinstance_cls_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 610;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
            goto branch_yes_3;
        } else {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_assign_source_4;
            if (par_obj == NULL) {

                exception_type = PyExc_UnboundLocalError;
                Py_INCREF(exception_type);
                exception_value = PyString_FromFormat("local variable '%s' referenced before assignment", "obj");
                exception_tb = NULL;

                exception_lineno = 611;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }

            tmp_assign_source_4 = par_obj;
            {
                PyObject *old = var_fd;
                assert(old != NULL);
                var_fd = tmp_assign_source_4;
                Py_INCREF(var_fd);
                Py_DECREF(old);
            }

        }
        branch_no_3:;
    }
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_operand_name_2;
        PyObject *tmp_isinstance_inst_3;
        PyObject *tmp_isinstance_cls_3;
        PyObject *tmp_mvar_value_3;
        CHECK_OBJECT(var_fd);
        tmp_isinstance_inst_3 = var_fd;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_types);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 459 ], 42, 0);
            exception_tb = NULL;

            exception_lineno = 613;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_3 = tmp_mvar_value_3;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_3, tmp_isinstance_cls_3);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 613;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_2 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 613;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_4 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_4 == NUITKA_BOOL_TRUE) {
            goto branch_yes_4;
        } else {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_9e9a42d8484d15cb8253ecb92e0c7121;
            frame_36419b8e55b17a9cf1f1164d41ec30e1->m_frame.f_lineno = 614;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 614;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto branch_end_4;
        branch_no_4:;
        {
            nuitka_bool tmp_condition_result_5;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            CHECK_OBJECT(var_fd);
            tmp_compexpr_left_2 = var_fd;
            tmp_compexpr_right_2 = const_int_0;
            tmp_res = RICH_COMPARE_BOOL_LT_OBJECT_INT(tmp_compexpr_left_2, tmp_compexpr_right_2);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 615;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_5 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_5 == NUITKA_BOOL_TRUE) {
                goto branch_yes_5;
            } else {
                goto branch_no_5;
            }
            branch_yes_5:;
            {
                PyObject *tmp_raise_type_2;
                PyObject *tmp_make_exception_arg_2;
                PyObject *tmp_left_name_1;
                PyObject *tmp_right_name_1;
                PyObject *tmp_tuple_element_1;
                tmp_left_name_1 = const_str_digest_afa60644cf27716474a6bbd780185867;
                CHECK_OBJECT(var_fd);
                tmp_tuple_element_1 = var_fd;
                tmp_right_name_1 = PyTuple_New(1);
                Py_INCREF(tmp_tuple_element_1);
                PyTuple_SET_ITEM(tmp_right_name_1, 0, tmp_tuple_element_1);
                tmp_make_exception_arg_2 = BINARY_OPERATION_MOD_STR_TUPLE(tmp_left_name_1, tmp_right_name_1);
                Py_DECREF(tmp_right_name_1);
                if (tmp_make_exception_arg_2 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 617;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                frame_36419b8e55b17a9cf1f1164d41ec30e1->m_frame.f_lineno = 616;
                tmp_raise_type_2 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_2);
                Py_DECREF(tmp_make_exception_arg_2);
                assert(!(tmp_raise_type_2 == NULL));
                exception_type = tmp_raise_type_2;
                exception_lineno = 616;
                RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            branch_no_5:;
        }
        branch_end_4:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_36419b8e55b17a9cf1f1164d41ec30e1);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_36419b8e55b17a9cf1f1164d41ec30e1);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_36419b8e55b17a9cf1f1164d41ec30e1, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_36419b8e55b17a9cf1f1164d41ec30e1->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_36419b8e55b17a9cf1f1164d41ec30e1, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_36419b8e55b17a9cf1f1164d41ec30e1,
        type_description_1,
        par_obj,
        var_fd,
        var_meth
    );


    // Release cached frame.
    if (frame_36419b8e55b17a9cf1f1164d41ec30e1 == cache_frame_36419b8e55b17a9cf1f1164d41ec30e1) {
        Py_DECREF(frame_36419b8e55b17a9cf1f1164d41ec30e1);
    }
    cache_frame_36419b8e55b17a9cf1f1164d41ec30e1 = NULL;

    assertFrameObject(frame_36419b8e55b17a9cf1f1164d41ec30e1);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT(var_fd);
    tmp_return_value = var_fd;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_9__asFileDescriptor);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_fd);
    Py_DECREF(var_fd);
    var_fd = NULL;

    Py_XDECREF(var_meth);
    var_meth = NULL;

    Py_XDECREF(par_obj);
    par_obj = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_fd);
    var_fd = NULL;

    Py_XDECREF(var_meth);
    var_meth = NULL;

    Py_XDECREF(par_obj);
    par_obj = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_9__asFileDescriptor);
    return NULL;

function_exception_exit:
    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_10_SSLeay_version(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_type = python_pars[0];
    struct Nuitka_FrameObject *frame_afa02031ee1fbc3d4b779093fdfb585c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_afa02031ee1fbc3d4b779093fdfb585c = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_afa02031ee1fbc3d4b779093fdfb585c, codeobj_afa02031ee1fbc3d4b779093fdfb585c, module_OpenSSL$SSL, sizeof(void *));
    frame_afa02031ee1fbc3d4b779093fdfb585c = cache_frame_afa02031ee1fbc3d4b779093fdfb585c;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_afa02031ee1fbc3d4b779093fdfb585c);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_afa02031ee1fbc3d4b779093fdfb585c) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 628;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_string);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 628;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 628;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_2;
        CHECK_OBJECT(par_type);
        tmp_args_element_name_2 = par_type;
        frame_afa02031ee1fbc3d4b779093fdfb585c->m_frame.f_lineno = 628;
        {
            PyObject *call_args[] = {tmp_args_element_name_2};
            tmp_args_element_name_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_SSLeay_version, call_args);
        }

        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 628;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_afa02031ee1fbc3d4b779093fdfb585c->m_frame.f_lineno = 628;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 628;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_afa02031ee1fbc3d4b779093fdfb585c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_afa02031ee1fbc3d4b779093fdfb585c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_afa02031ee1fbc3d4b779093fdfb585c);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_afa02031ee1fbc3d4b779093fdfb585c, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_afa02031ee1fbc3d4b779093fdfb585c->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_afa02031ee1fbc3d4b779093fdfb585c, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_afa02031ee1fbc3d4b779093fdfb585c,
        type_description_1,
        par_type
    );


    // Release cached frame.
    if (frame_afa02031ee1fbc3d4b779093fdfb585c == cache_frame_afa02031ee1fbc3d4b779093fdfb585c) {
        Py_DECREF(frame_afa02031ee1fbc3d4b779093fdfb585c);
    }
    cache_frame_afa02031ee1fbc3d4b779093fdfb585c = NULL;

    assertFrameObject(frame_afa02031ee1fbc3d4b779093fdfb585c);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_10_SSLeay_version);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_11__make_requires(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_flag = PyCell_NEW1(python_pars[0]);
    struct Nuitka_CellObject *par_error = PyCell_NEW1(python_pars[1]);
    PyObject *var__requires_decorator = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = MAKE_FUNCTION_OpenSSL$SSL$$$function_11__make_requires$$$function_1__requires_decorator();

        ((struct Nuitka_FunctionObject *)tmp_assign_source_1)->m_closure[0] = par_error;
        Py_INCREF(((struct Nuitka_FunctionObject *)tmp_assign_source_1)->m_closure[0]);
        ((struct Nuitka_FunctionObject *)tmp_assign_source_1)->m_closure[1] = par_flag;
        Py_INCREF(((struct Nuitka_FunctionObject *)tmp_assign_source_1)->m_closure[1]);


        assert(var__requires_decorator == NULL);
        var__requires_decorator = tmp_assign_source_1;
    }
    // Tried code:
    CHECK_OBJECT(var__requires_decorator);
    tmp_return_value = var__requires_decorator;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_11__make_requires);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var__requires_decorator);
    Py_DECREF(var__requires_decorator);
    var__requires_decorator = NULL;

    goto function_return_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_11__make_requires);
    return NULL;


function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_flag);
    Py_DECREF(par_flag);
    CHECK_OBJECT(par_error);
    Py_DECREF(par_error);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_11__make_requires$$$function_1__requires_decorator(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_func = python_pars[0];
    PyObject *var_explode = NULL;
    struct Nuitka_FrameObject *frame_d5e6e0f6e9a353e330b36c530b5b4bb0;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_d5e6e0f6e9a353e330b36c530b5b4bb0 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_d5e6e0f6e9a353e330b36c530b5b4bb0, codeobj_d5e6e0f6e9a353e330b36c530b5b4bb0, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_d5e6e0f6e9a353e330b36c530b5b4bb0 = cache_frame_d5e6e0f6e9a353e330b36c530b5b4bb0;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_d5e6e0f6e9a353e330b36c530b5b4bb0);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_d5e6e0f6e9a353e330b36c530b5b4bb0) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        if (PyCell_GET(self->m_closure[1]) == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "flag");
            exception_tb = NULL;

            exception_lineno = 642;
            type_description_1 = "ooc";
            goto frame_exception_exit_1;
        }

        tmp_operand_name_1 = PyCell_GET(self->m_closure[1]);
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 642;
            type_description_1 = "ooc";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_called_name_1;
            PyObject *tmp_called_name_2;
            PyObject *tmp_mvar_value_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_wraps);

            if (unlikely(tmp_mvar_value_1 == NULL)) {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_wraps);
            }

            if (tmp_mvar_value_1 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 136 ], 34, 0);
                exception_tb = NULL;

                exception_lineno = 643;
                type_description_1 = "ooc";
                goto frame_exception_exit_1;
            }

            tmp_called_name_2 = tmp_mvar_value_1;
            CHECK_OBJECT(par_func);
            tmp_args_element_name_1 = par_func;
            frame_d5e6e0f6e9a353e330b36c530b5b4bb0->m_frame.f_lineno = 643;
            tmp_called_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_1);
            if (tmp_called_name_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 643;
                type_description_1 = "ooc";
                goto frame_exception_exit_1;
            }
            tmp_args_element_name_2 = MAKE_FUNCTION_OpenSSL$SSL$$$function_11__make_requires$$$function_1__requires_decorator$$$function_1_explode();

            ((struct Nuitka_FunctionObject *)tmp_args_element_name_2)->m_closure[0] = self->m_closure[0];
            Py_INCREF(((struct Nuitka_FunctionObject *)tmp_args_element_name_2)->m_closure[0]);


            frame_d5e6e0f6e9a353e330b36c530b5b4bb0->m_frame.f_lineno = 643;
            tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_2);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_element_name_2);
            if (tmp_assign_source_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 643;
                type_description_1 = "ooc";
                goto frame_exception_exit_1;
            }
            assert(var_explode == NULL);
            var_explode = tmp_assign_source_1;
        }
        CHECK_OBJECT(var_explode);
        tmp_return_value = var_explode;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        goto branch_end_1;
        branch_no_1:;
        CHECK_OBJECT(par_func);
        tmp_return_value = par_func;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_d5e6e0f6e9a353e330b36c530b5b4bb0);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_d5e6e0f6e9a353e330b36c530b5b4bb0);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_d5e6e0f6e9a353e330b36c530b5b4bb0);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_d5e6e0f6e9a353e330b36c530b5b4bb0, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_d5e6e0f6e9a353e330b36c530b5b4bb0->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_d5e6e0f6e9a353e330b36c530b5b4bb0, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d5e6e0f6e9a353e330b36c530b5b4bb0,
        type_description_1,
        par_func,
        var_explode,
        self->m_closure[1]
    );


    // Release cached frame.
    if (frame_d5e6e0f6e9a353e330b36c530b5b4bb0 == cache_frame_d5e6e0f6e9a353e330b36c530b5b4bb0) {
        Py_DECREF(frame_d5e6e0f6e9a353e330b36c530b5b4bb0);
    }
    cache_frame_d5e6e0f6e9a353e330b36c530b5b4bb0 = NULL;

    assertFrameObject(frame_d5e6e0f6e9a353e330b36c530b5b4bb0);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_11__make_requires$$$function_1__requires_decorator);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_explode);
    var_explode = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_11__make_requires$$$function_1__requires_decorator);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_func);
    Py_DECREF(par_func);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_func);
    Py_DECREF(par_func);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_11__make_requires$$$function_1__requires_decorator$$$function_1_explode(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_args = python_pars[0];
    PyObject *par_kwargs = python_pars[1];
    struct Nuitka_FrameObject *frame_7a0155ee18f90fe4fffc56c025b25370;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_7a0155ee18f90fe4fffc56c025b25370 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_7a0155ee18f90fe4fffc56c025b25370, codeobj_7a0155ee18f90fe4fffc56c025b25370, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_7a0155ee18f90fe4fffc56c025b25370 = cache_frame_7a0155ee18f90fe4fffc56c025b25370;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_7a0155ee18f90fe4fffc56c025b25370);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_7a0155ee18f90fe4fffc56c025b25370) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_raise_type_1;
        PyObject *tmp_make_exception_arg_1;
        if (PyCell_GET(self->m_closure[0]) == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "error");
            exception_tb = NULL;

            exception_lineno = 645;
            type_description_1 = "ooc";
            goto frame_exception_exit_1;
        }

        tmp_make_exception_arg_1 = PyCell_GET(self->m_closure[0]);
        frame_7a0155ee18f90fe4fffc56c025b25370->m_frame.f_lineno = 645;
        tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_NotImplementedError, tmp_make_exception_arg_1);
        assert(!(tmp_raise_type_1 == NULL));
        exception_type = tmp_raise_type_1;
        exception_lineno = 645;
        RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
        type_description_1 = "ooc";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_7a0155ee18f90fe4fffc56c025b25370);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_7a0155ee18f90fe4fffc56c025b25370);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_7a0155ee18f90fe4fffc56c025b25370, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_7a0155ee18f90fe4fffc56c025b25370->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_7a0155ee18f90fe4fffc56c025b25370, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7a0155ee18f90fe4fffc56c025b25370,
        type_description_1,
        par_args,
        par_kwargs,
        self->m_closure[0]
    );


    // Release cached frame.
    if (frame_7a0155ee18f90fe4fffc56c025b25370 == cache_frame_7a0155ee18f90fe4fffc56c025b25370) {
        Py_DECREF(frame_7a0155ee18f90fe4fffc56c025b25370);
    }
    cache_frame_7a0155ee18f90fe4fffc56c025b25370 = NULL;

    assertFrameObject(frame_7a0155ee18f90fe4fffc56c025b25370);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_11__make_requires$$$function_1__requires_decorator$$$function_1_explode);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_args);
    Py_DECREF(par_args);
    CHECK_OBJECT(par_kwargs);
    Py_DECREF(par_kwargs);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

}



struct OpenSSL$SSL$$$genexpr_1_genexpr_locals {
    PyObject *var_identifier;
    PyObject *var_name;
    PyObject *tmp_iter_value_0;
    PyObject *tmp_tuple_unpack_1__element_1;
    PyObject *tmp_tuple_unpack_1__element_2;
    PyObject *tmp_tuple_unpack_1__source_iter;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    PyObject *tmp_iterator_attempt;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    int exception_keeper_lineno_4;
};

static PyObject *OpenSSL$SSL$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value ) {
    CHECK_OBJECT((PyObject *)generator);
    assert(Nuitka_Generator_Check( (PyObject *)generator ));

    // Heap access if used.
    struct OpenSSL$SSL$$$genexpr_1_genexpr_locals *generator_heap = (struct OpenSSL$SSL$$$genexpr_1_genexpr_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_identifier = NULL;
    generator_heap->var_name = NULL;
    generator_heap->tmp_iter_value_0 = NULL;
    generator_heap->tmp_tuple_unpack_1__element_1 = NULL;
    generator_heap->tmp_tuple_unpack_1__element_2 = NULL;
    generator_heap->tmp_tuple_unpack_1__source_iter = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_m_frame, codeobj_aa161ac185e75726cd10cc9d22ea8046, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *));
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF(generator->m_frame);
    assert(Py_REFCNT(generator->m_frame) == 2); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR(generator->m_frame->m_frame.f_back);

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF(generator->m_frame->m_frame.f_back);

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF(generator->m_frame);

    Nuitka_Frame_MarkAsExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

        EXC_TYPE_F(generator) = EXC_TYPE(thread_state);
        if (EXC_TYPE_F(generator) == Py_None) EXC_TYPE_F(generator) = NULL;
        Py_XINCREF(EXC_TYPE_F(generator));
        EXC_VALUE_F(generator) = EXC_VALUE(thread_state);
        Py_XINCREF(EXC_VALUE_F(generator));
        EXC_TRACEBACK_F(generator) = EXC_TRACEBACK(thread_state);
        Py_XINCREF(EXC_TRACEBACK_F(generator));
    }

#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_1;
        CHECK_OBJECT(PyCell_GET(generator->m_closure[0]));
        tmp_next_source_1 = PyCell_GET(generator->m_closure[0]);
        tmp_assign_source_1 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_1 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);
                generator_heap->type_description_1 = "Noo";
                generator_heap->exception_lineno = 696;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_iter_value_0;
            generator_heap->tmp_iter_value_0 = tmp_assign_source_1;
            Py_XDECREF(old);
        }

    }
    // Tried code:
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_iter_arg_1;
        CHECK_OBJECT(generator_heap->tmp_iter_value_0);
        tmp_iter_arg_1 = generator_heap->tmp_iter_value_0;
        tmp_assign_source_2 = MAKE_ITERATOR(tmp_iter_arg_1);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 696;
            generator_heap->type_description_1 = "Noo";
            goto try_except_handler_3;
        }
        {
            PyObject *old = generator_heap->tmp_tuple_unpack_1__source_iter;
            generator_heap->tmp_tuple_unpack_1__source_iter = tmp_assign_source_2;
            Py_XDECREF(old);
        }

    }
    // Tried code:
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_unpack_1;
        CHECK_OBJECT(generator_heap->tmp_tuple_unpack_1__source_iter);
        tmp_unpack_1 = generator_heap->tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_3 = UNPACK_NEXT(tmp_unpack_1, 0);
        if (tmp_assign_source_3 == NULL) {
            if (!ERROR_OCCURRED()) {
                generator_heap->exception_type = PyExc_StopIteration;
                Py_INCREF(generator_heap->exception_type);
                generator_heap->exception_value = NULL;
                generator_heap->exception_tb = NULL;
            } else {
                FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);
            }


            generator_heap->type_description_1 = "Noo";
            generator_heap->exception_lineno = 696;
            goto try_except_handler_4;
        }
        {
            PyObject *old = generator_heap->tmp_tuple_unpack_1__element_1;
            generator_heap->tmp_tuple_unpack_1__element_1 = tmp_assign_source_3;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_unpack_2;
        CHECK_OBJECT(generator_heap->tmp_tuple_unpack_1__source_iter);
        tmp_unpack_2 = generator_heap->tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_4 = UNPACK_NEXT(tmp_unpack_2, 1);
        if (tmp_assign_source_4 == NULL) {
            if (!ERROR_OCCURRED()) {
                generator_heap->exception_type = PyExc_StopIteration;
                Py_INCREF(generator_heap->exception_type);
                generator_heap->exception_value = NULL;
                generator_heap->exception_tb = NULL;
            } else {
                FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);
            }


            generator_heap->type_description_1 = "Noo";
            generator_heap->exception_lineno = 696;
            goto try_except_handler_4;
        }
        {
            PyObject *old = generator_heap->tmp_tuple_unpack_1__element_2;
            generator_heap->tmp_tuple_unpack_1__element_2 = tmp_assign_source_4;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_iterator_name_1;
        CHECK_OBJECT(generator_heap->tmp_tuple_unpack_1__source_iter);
        tmp_iterator_name_1 = generator_heap->tmp_tuple_unpack_1__source_iter;
        // Check if iterator has left-over elements.
        CHECK_OBJECT(tmp_iterator_name_1); assert(HAS_ITERNEXT(tmp_iterator_name_1));

        generator_heap->tmp_iterator_attempt = (*Py_TYPE(tmp_iterator_name_1)->tp_iternext)(tmp_iterator_name_1);

        if (likely(generator_heap->tmp_iterator_attempt == NULL))
        {
            PyObject *error = GET_ERROR_OCCURRED();

            if (error != NULL)
            {
                if (EXCEPTION_MATCH_BOOL_SINGLE(error, PyExc_StopIteration))
                {
                    CLEAR_ERROR_OCCURRED();
                } else {
                    FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);

                    generator_heap->type_description_1 = "Noo";
                    generator_heap->exception_lineno = 696;
                    goto try_except_handler_4;
                }
            }
        } else {
            Py_DECREF(generator_heap->tmp_iterator_attempt);

            // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
            PyErr_Format(PyExc_ValueError, "too many values to unpack");
#else
            PyErr_Format(PyExc_ValueError, "too many values to unpack (expected 2)");
#endif
            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);

            generator_heap->type_description_1 = "Noo";
            generator_heap->exception_lineno = 696;
            goto try_except_handler_4;
        }
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_4:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    CHECK_OBJECT((PyObject *)generator_heap->tmp_tuple_unpack_1__source_iter);
    Py_DECREF(generator_heap->tmp_tuple_unpack_1__source_iter);
    generator_heap->tmp_tuple_unpack_1__source_iter = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto try_except_handler_3;
    // End of try:
    try_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_3:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->tmp_tuple_unpack_1__element_1);
    generator_heap->tmp_tuple_unpack_1__element_1 = NULL;

    Py_XDECREF(generator_heap->tmp_tuple_unpack_1__element_2);
    generator_heap->tmp_tuple_unpack_1__element_2 = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto try_except_handler_2;
    // End of try:
    try_end_2:;
    CHECK_OBJECT((PyObject *)generator_heap->tmp_tuple_unpack_1__source_iter);
    Py_DECREF(generator_heap->tmp_tuple_unpack_1__source_iter);
    generator_heap->tmp_tuple_unpack_1__source_iter = NULL;

    {
        PyObject *tmp_assign_source_5;
        CHECK_OBJECT(generator_heap->tmp_tuple_unpack_1__element_1);
        tmp_assign_source_5 = generator_heap->tmp_tuple_unpack_1__element_1;
        {
            PyObject *old = generator_heap->var_identifier;
            generator_heap->var_identifier = tmp_assign_source_5;
            Py_INCREF(generator_heap->var_identifier);
            Py_XDECREF(old);
        }

    }
    Py_XDECREF(generator_heap->tmp_tuple_unpack_1__element_1);
    generator_heap->tmp_tuple_unpack_1__element_1 = NULL;

    {
        PyObject *tmp_assign_source_6;
        CHECK_OBJECT(generator_heap->tmp_tuple_unpack_1__element_2);
        tmp_assign_source_6 = generator_heap->tmp_tuple_unpack_1__element_2;
        {
            PyObject *old = generator_heap->var_name;
            generator_heap->var_name = tmp_assign_source_6;
            Py_INCREF(generator_heap->var_name);
            Py_XDECREF(old);
        }

    }
    Py_XDECREF(generator_heap->tmp_tuple_unpack_1__element_2);
    generator_heap->tmp_tuple_unpack_1__element_2 = NULL;

    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_getattr_target_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_getattr_attr_1;
        PyObject *tmp_getattr_default_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF(generator_heap->exception_type);
            generator_heap->exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 698;
            generator_heap->type_description_1 = "Noo";
            goto try_except_handler_2;
        }

        tmp_getattr_target_1 = tmp_mvar_value_1;
        CHECK_OBJECT(generator_heap->var_name);
        tmp_getattr_attr_1 = generator_heap->var_name;
        tmp_getattr_default_1 = Py_None;
        tmp_compexpr_left_1 = BUILTIN_GETATTR(tmp_getattr_target_1, tmp_getattr_attr_1, tmp_getattr_default_1);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 698;
            generator_heap->type_description_1 = "Noo";
            goto try_except_handler_2;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 != tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_compexpr_left_1);
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_expression_name_1;
            PyObject *tmp_tuple_element_1;
            PyObject *tmp_getattr_target_2;
            PyObject *tmp_mvar_value_2;
            PyObject *tmp_getattr_attr_2;
            NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
            CHECK_OBJECT(generator_heap->var_identifier);
            tmp_tuple_element_1 = generator_heap->var_identifier;
            tmp_expression_name_1 = PyTuple_New(2);
            Py_INCREF(tmp_tuple_element_1);
            PyTuple_SET_ITEM(tmp_expression_name_1, 0, tmp_tuple_element_1);
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_2 == NULL) {
                Py_DECREF(tmp_expression_name_1);
                generator_heap->exception_type = PyExc_NameError;
                Py_INCREF(generator_heap->exception_type);
                generator_heap->exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                generator_heap->exception_tb = NULL;

                generator_heap->exception_lineno = 696;
                generator_heap->type_description_1 = "Noo";
                goto try_except_handler_2;
            }

            tmp_getattr_target_2 = tmp_mvar_value_2;
            CHECK_OBJECT(generator_heap->var_name);
            tmp_getattr_attr_2 = generator_heap->var_name;
            tmp_tuple_element_1 = BUILTIN_GETATTR(tmp_getattr_target_2, tmp_getattr_attr_2, NULL);
            if (tmp_tuple_element_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);
                Py_DECREF(tmp_expression_name_1);

                generator_heap->exception_lineno = 696;
                generator_heap->type_description_1 = "Noo";
                goto try_except_handler_2;
            }
            PyTuple_SET_ITEM(tmp_expression_name_1, 1, tmp_tuple_element_1);
            Nuitka_PreserveHeap(generator_heap->yield_tmps, &tmp_condition_result_1, sizeof(nuitka_bool), &tmp_compexpr_left_1, sizeof(PyObject *), &tmp_compexpr_right_1, sizeof(PyObject *), &tmp_getattr_target_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), &tmp_getattr_attr_1, sizeof(PyObject *), &tmp_getattr_default_1, sizeof(PyObject *), &tmp_tuple_element_1, sizeof(PyObject *), &tmp_getattr_target_2, sizeof(PyObject *), &tmp_mvar_value_2, sizeof(PyObject *), &tmp_getattr_attr_2, sizeof(PyObject *), NULL);
            generator->m_yield_return_index = 1;
            return tmp_expression_name_1;
            yield_return_1:
            Nuitka_RestoreHeap(generator_heap->yield_tmps, &tmp_condition_result_1, sizeof(nuitka_bool), &tmp_compexpr_left_1, sizeof(PyObject *), &tmp_compexpr_right_1, sizeof(PyObject *), &tmp_getattr_target_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), &tmp_getattr_attr_1, sizeof(PyObject *), &tmp_getattr_default_1, sizeof(PyObject *), &tmp_tuple_element_1, sizeof(PyObject *), &tmp_getattr_target_2, sizeof(PyObject *), &tmp_mvar_value_2, sizeof(PyObject *), &tmp_getattr_attr_2, sizeof(PyObject *), NULL);
            if (yield_return_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


                generator_heap->exception_lineno = 696;
                generator_heap->type_description_1 = "Noo";
                goto try_except_handler_2;
            }
            tmp_yield_result_1 = yield_return_value;
        }
        branch_no_1:;
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


        generator_heap->exception_lineno = 696;
        generator_heap->type_description_1 = "Noo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_3;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_3 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_3 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_3 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_3 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_3;
    generator_heap->exception_value = generator_heap->exception_keeper_value_3;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_3;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;

    Nuitka_Frame_MarkAsNotExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    // Allow re-use of the frame again.
    Py_DECREF(generator->m_frame);
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if (!EXCEPTION_MATCH_GENERATOR(generator_heap->exception_type)) {
        if (generator_heap->exception_tb == NULL) {
            generator_heap->exception_tb = MAKE_TRACEBACK(generator->m_frame, generator_heap->exception_lineno);
        } else if (generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame) {
            generator_heap->exception_tb = ADD_TRACEBACK(generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno);
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            NULL,
            generator_heap->var_identifier,
            generator_heap->var_name
        );


        // Release cached frame.
        if (generator->m_frame == cache_m_frame) {
            Py_DECREF(generator->m_frame);
        }
        cache_m_frame = NULL;

        assertFrameObject(generator->m_frame);
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    Py_DECREF(generator->m_frame);

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_4;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_4 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_4 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_4 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_4 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->var_identifier);
    generator_heap->var_identifier = NULL;

    Py_XDECREF(generator_heap->var_name);
    generator_heap->var_name = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_4;
    generator_heap->exception_value = generator_heap->exception_keeper_value_4;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_4;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_4;

    goto function_exception_exit;
    // End of try:
    try_end_4:;
    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    Py_XDECREF(generator_heap->var_identifier);
    generator_heap->var_identifier = NULL;

    Py_XDECREF(generator_heap->var_name);
    generator_heap->var_name = NULL;



    return NULL;

    function_exception_exit:
    assert(generator_heap->exception_type);
    RESTORE_ERROR_OCCURRED(generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb);

    return NULL;

}

static PyObject *OpenSSL$SSL$$$genexpr_1_genexpr_maker(void) {
    return Nuitka_Generator_New(
        OpenSSL$SSL$$$genexpr_1_genexpr_context,
        module_OpenSSL$SSL,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_aa161ac185e75726cd10cc9d22ea8046,
        1,
        sizeof(struct OpenSSL$SSL$$$genexpr_1_genexpr_locals)
    );
}


static PyObject *impl_OpenSSL$SSL$$$function_12___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_method = python_pars[1];
    PyObject *var_method_obj = NULL;
    PyObject *var_res = NULL;
    PyObject *var_context = NULL;
    PyObject *var_method_func = NULL;
    struct Nuitka_FrameObject *frame_187fe5b9a88e33cc73e9ffc0bee13a36;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    bool tmp_result;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    static struct Nuitka_FrameObject *cache_frame_187fe5b9a88e33cc73e9ffc0bee13a36 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_187fe5b9a88e33cc73e9ffc0bee13a36, codeobj_187fe5b9a88e33cc73e9ffc0bee13a36, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_187fe5b9a88e33cc73e9ffc0bee13a36 = cache_frame_187fe5b9a88e33cc73e9ffc0bee13a36;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_187fe5b9a88e33cc73e9ffc0bee13a36);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_187fe5b9a88e33cc73e9ffc0bee13a36) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_method);
        tmp_isinstance_inst_1 = par_method;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_types);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 459 ], 42, 0);
            exception_tb = NULL;

            exception_lineno = 701;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 701;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 701;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_c8e9b5ff5b00d8190ecae28b8a410248;
            frame_187fe5b9a88e33cc73e9ffc0bee13a36->m_frame.f_lineno = 702;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 702;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_subscript_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__methods);
        if (tmp_subscribed_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 705;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT(par_method);
        tmp_subscript_name_1 = par_method;
        tmp_assign_source_1 = LOOKUP_SUBSCRIPT(tmp_subscribed_name_1, tmp_subscript_name_1);
        Py_DECREF(tmp_subscribed_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 705;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }
        assert(var_method_func == NULL);
        var_method_func = tmp_assign_source_1;
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION(frame_187fe5b9a88e33cc73e9ffc0bee13a36);
    if (exception_keeper_tb_1 == NULL) {
        exception_keeper_tb_1 = MAKE_TRACEBACK(frame_187fe5b9a88e33cc73e9ffc0bee13a36, exception_keeper_lineno_1);
    } else if (exception_keeper_lineno_1 != 0) {
        exception_keeper_tb_1 = ADD_TRACEBACK(exception_keeper_tb_1, frame_187fe5b9a88e33cc73e9ffc0bee13a36, exception_keeper_lineno_1);
    }

    NORMALIZE_EXCEPTION(&exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1);
    PUBLISH_EXCEPTION(&exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1);
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_compexpr_left_1 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_1 = PyExc_KeyError;
        tmp_res = EXCEPTION_MATCH_BOOL(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 706;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            tmp_make_exception_arg_2 = const_str_digest_685ba6a7380a18939915178358979194;
            frame_187fe5b9a88e33cc73e9ffc0bee13a36->m_frame.f_lineno = 707;
            tmp_raise_type_2 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_2);
            assert(!(tmp_raise_type_2 == NULL));
            exception_type = tmp_raise_type_2;
            exception_lineno = 707;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        goto branch_end_2;
        branch_no_2:;
        tmp_result = RERAISE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
        if (unlikely(tmp_result == false)) {
            exception_lineno = 704;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_187fe5b9a88e33cc73e9ffc0bee13a36->m_frame) frame_187fe5b9a88e33cc73e9ffc0bee13a36->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
        branch_end_2:;
    }
    // End of try:
    try_end_1:;
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_1;
        CHECK_OBJECT(var_method_func);
        tmp_called_name_1 = var_method_func;
        frame_187fe5b9a88e33cc73e9ffc0bee13a36->m_frame.f_lineno = 709;
        tmp_assign_source_2 = CALL_FUNCTION_NO_ARGS(tmp_called_name_1);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 709;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert(var_method_obj == NULL);
        var_method_obj = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 710;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT(var_method_obj);
        tmp_compexpr_left_2 = var_method_obj;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 710;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_NULL);
        if (tmp_compexpr_right_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 710;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_1 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
        Py_DECREF(tmp_compexpr_right_2);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 710;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_187fe5b9a88e33cc73e9ffc0bee13a36->m_frame.f_lineno = 710;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 710;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 712;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_4;
        CHECK_OBJECT(var_method_obj);
        tmp_args_element_name_2 = var_method_obj;
        frame_187fe5b9a88e33cc73e9ffc0bee13a36->m_frame.f_lineno = 712;
        {
            PyObject *call_args[] = {tmp_args_element_name_2};
            tmp_assign_source_3 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_SSL_CTX_new, call_args);
        }

        if (tmp_assign_source_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 712;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert(var_context == NULL);
        var_context = tmp_assign_source_3;
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_6;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 713;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_5;
        CHECK_OBJECT(var_context);
        tmp_compexpr_left_3 = var_context;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_6 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 713;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_6;
        tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_NULL);
        if (tmp_compexpr_right_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 713;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_3, tmp_compexpr_right_3);
        Py_DECREF(tmp_compexpr_right_3);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 713;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_187fe5b9a88e33cc73e9ffc0bee13a36->m_frame.f_lineno = 713;
        tmp_call_result_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_3, tmp_args_element_name_3);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_call_result_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 713;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_2);
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_8;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_7 == NULL)) {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_7 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 714;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_7;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_gc);
        if (tmp_called_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 714;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_context);
        tmp_args_element_name_4 = var_context;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_8 == NULL)) {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_8 == NULL) {
            Py_DECREF(tmp_called_name_4);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 714;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_8;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_SSL_CTX_free);
        if (tmp_args_element_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_4);

            exception_lineno = 714;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_187fe5b9a88e33cc73e9ffc0bee13a36->m_frame.f_lineno = 714;
        {
            PyObject *call_args[] = {tmp_args_element_name_4, tmp_args_element_name_5};
            tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_4, call_args);
        }

        Py_DECREF(tmp_called_name_4);
        Py_DECREF(tmp_args_element_name_5);
        if (tmp_assign_source_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 714;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var_context;
            assert(old != NULL);
            var_context = tmp_assign_source_4;
            Py_DECREF(old);
        }

    }
    // Tried code:
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_9;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_args_element_name_7;
        tmp_mvar_value_9 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_9 == NULL)) {
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_9 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 720;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }

        tmp_called_instance_2 = tmp_mvar_value_9;
        CHECK_OBJECT(var_context);
        tmp_args_element_name_6 = var_context;
        tmp_args_element_name_7 = const_int_pos_1;
        frame_187fe5b9a88e33cc73e9ffc0bee13a36->m_frame.f_lineno = 720;
        {
            PyObject *call_args[] = {tmp_args_element_name_6, tmp_args_element_name_7};
            tmp_assign_source_5 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_2, const_str_plain_SSL_CTX_set_ecdh_auto, call_args);
        }

        if (tmp_assign_source_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 720;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }
        assert(var_res == NULL);
        var_res = tmp_assign_source_5;
    }
    {
        PyObject *tmp_called_name_5;
        PyObject *tmp_mvar_value_10;
        PyObject *tmp_call_result_3;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        tmp_mvar_value_10 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_10 == NULL)) {
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_10 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 721;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }

        tmp_called_name_5 = tmp_mvar_value_10;
        CHECK_OBJECT(var_res);
        tmp_compexpr_left_4 = var_res;
        tmp_compexpr_right_4 = const_int_pos_1;
        tmp_args_element_name_8 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_4, tmp_compexpr_right_4);
        if (tmp_args_element_name_8 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 721;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }
        frame_187fe5b9a88e33cc73e9ffc0bee13a36->m_frame.f_lineno = 721;
        tmp_call_result_3 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_5, tmp_args_element_name_8);
        Py_DECREF(tmp_args_element_name_8);
        if (tmp_call_result_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 721;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }
        Py_DECREF(tmp_call_result_3);
    }
    goto try_end_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION(frame_187fe5b9a88e33cc73e9ffc0bee13a36);
    if (exception_keeper_tb_2 == NULL) {
        exception_keeper_tb_2 = MAKE_TRACEBACK(frame_187fe5b9a88e33cc73e9ffc0bee13a36, exception_keeper_lineno_2);
    } else if (exception_keeper_lineno_2 != 0) {
        exception_keeper_tb_2 = ADD_TRACEBACK(exception_keeper_tb_2, frame_187fe5b9a88e33cc73e9ffc0bee13a36, exception_keeper_lineno_2);
    }

    NORMALIZE_EXCEPTION(&exception_keeper_type_2, &exception_keeper_value_2, &exception_keeper_tb_2);
    PUBLISH_EXCEPTION(&exception_keeper_type_2, &exception_keeper_value_2, &exception_keeper_tb_2);
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_operand_name_2;
        PyObject *tmp_compexpr_left_5;
        PyObject *tmp_compexpr_right_5;
        tmp_compexpr_left_5 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_5 = PyExc_AttributeError;
        tmp_res = EXCEPTION_MATCH_BOOL(tmp_compexpr_left_5, tmp_compexpr_right_5);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 722;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_2 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 722;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
            goto branch_yes_3;
        } else {
            goto branch_no_3;
        }
        branch_yes_3:;
        tmp_result = RERAISE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
        if (unlikely(tmp_result == false)) {
            exception_lineno = 719;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_187fe5b9a88e33cc73e9ffc0bee13a36->m_frame) frame_187fe5b9a88e33cc73e9ffc0bee13a36->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
        branch_no_3:;
    }
    goto try_end_2;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_12___init__);
    return NULL;
    // End of try:
    try_end_2:;
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(var_context);
        tmp_assattr_name_1 = var_context;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__context, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 725;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        tmp_assattr_name_2 = Py_None;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain__passphrase_helper, tmp_assattr_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 726;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_assattr_target_3;
        tmp_assattr_name_3 = Py_None;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_3 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_3, const_str_plain__passphrase_callback, tmp_assattr_name_3);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 727;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_4;
        PyObject *tmp_assattr_target_4;
        tmp_assattr_name_4 = Py_None;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_4 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_4, const_str_plain__passphrase_userdata, tmp_assattr_name_4);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 728;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_5;
        PyObject *tmp_assattr_target_5;
        tmp_assattr_name_5 = Py_None;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_5 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_5, const_str_plain__verify_helper, tmp_assattr_name_5);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 729;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_6;
        PyObject *tmp_assattr_target_6;
        tmp_assattr_name_6 = Py_None;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_6 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_6, const_str_plain__verify_callback, tmp_assattr_name_6);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 730;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_7;
        PyObject *tmp_assattr_target_7;
        tmp_assattr_name_7 = Py_None;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_7 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_7, const_str_plain__info_callback, tmp_assattr_name_7);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 731;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_8;
        PyObject *tmp_assattr_target_8;
        tmp_assattr_name_8 = Py_None;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_8 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_8, const_str_plain__tlsext_servername_callback, tmp_assattr_name_8);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 732;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_9;
        PyObject *tmp_assattr_target_9;
        tmp_assattr_name_9 = Py_None;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_9 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_9, const_str_plain__app_data, tmp_assattr_name_9);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 733;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_10;
        PyObject *tmp_assattr_target_10;
        tmp_assattr_name_10 = Py_None;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_10 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_10, const_str_plain__npn_advertise_helper, tmp_assattr_name_10);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 734;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_11;
        PyObject *tmp_assattr_target_11;
        tmp_assattr_name_11 = Py_None;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_11 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_11, const_str_plain__npn_advertise_callback, tmp_assattr_name_11);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 735;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_12;
        PyObject *tmp_assattr_target_12;
        tmp_assattr_name_12 = Py_None;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_12 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_12, const_str_plain__npn_select_helper, tmp_assattr_name_12);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 736;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_13;
        PyObject *tmp_assattr_target_13;
        tmp_assattr_name_13 = Py_None;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_13 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_13, const_str_plain__npn_select_callback, tmp_assattr_name_13);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 737;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_14;
        PyObject *tmp_assattr_target_14;
        tmp_assattr_name_14 = Py_None;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_14 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_14, const_str_plain__alpn_select_helper, tmp_assattr_name_14);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 738;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_15;
        PyObject *tmp_assattr_target_15;
        tmp_assattr_name_15 = Py_None;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_15 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_15, const_str_plain__alpn_select_callback, tmp_assattr_name_15);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 739;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_16;
        PyObject *tmp_assattr_target_16;
        tmp_assattr_name_16 = Py_None;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_16 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_16, const_str_plain__ocsp_helper, tmp_assattr_name_16);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 740;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_17;
        PyObject *tmp_assattr_target_17;
        tmp_assattr_name_17 = Py_None;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_17 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_17, const_str_plain__ocsp_callback, tmp_assattr_name_17);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 741;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_18;
        PyObject *tmp_assattr_target_18;
        tmp_assattr_name_18 = Py_None;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_18 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_18, const_str_plain__ocsp_data, tmp_assattr_name_18);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 742;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_called_name_6;
        PyObject *tmp_source_name_6;
        PyObject *tmp_call_result_4;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_11;
        CHECK_OBJECT(par_self);
        tmp_source_name_6 = par_self;
        tmp_called_name_6 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_set_mode);
        if (tmp_called_name_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 744;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_11 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_11 == NULL)) {
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_11 == NULL) {
            Py_DECREF(tmp_called_name_6);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 744;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = tmp_mvar_value_11;
        tmp_args_element_name_9 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain_SSL_MODE_ENABLE_PARTIAL_WRITE);
        if (tmp_args_element_name_9 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_6);

            exception_lineno = 744;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_187fe5b9a88e33cc73e9ffc0bee13a36->m_frame.f_lineno = 744;
        tmp_call_result_4 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_6, tmp_args_element_name_9);
        Py_DECREF(tmp_called_name_6);
        Py_DECREF(tmp_args_element_name_9);
        if (tmp_call_result_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 744;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_4);
    }

#if 1
    RESTORE_FRAME_EXCEPTION(frame_187fe5b9a88e33cc73e9ffc0bee13a36);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION(frame_187fe5b9a88e33cc73e9ffc0bee13a36);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_187fe5b9a88e33cc73e9ffc0bee13a36, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_187fe5b9a88e33cc73e9ffc0bee13a36->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_187fe5b9a88e33cc73e9ffc0bee13a36, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_187fe5b9a88e33cc73e9ffc0bee13a36,
        type_description_1,
        par_self,
        par_method,
        var_method_obj,
        var_res,
        var_context,
        var_method_func
    );


    // Release cached frame.
    if (frame_187fe5b9a88e33cc73e9ffc0bee13a36 == cache_frame_187fe5b9a88e33cc73e9ffc0bee13a36) {
        Py_DECREF(frame_187fe5b9a88e33cc73e9ffc0bee13a36);
    }
    cache_frame_187fe5b9a88e33cc73e9ffc0bee13a36 = NULL;

    assertFrameObject(frame_187fe5b9a88e33cc73e9ffc0bee13a36);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_12___init__);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_method_obj);
    Py_DECREF(var_method_obj);
    var_method_obj = NULL;

    Py_XDECREF(var_res);
    var_res = NULL;

    CHECK_OBJECT((PyObject *)var_context);
    Py_DECREF(var_context);
    var_context = NULL;

    CHECK_OBJECT((PyObject *)var_method_func);
    Py_DECREF(var_method_func);
    var_method_func = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_method_obj);
    var_method_obj = NULL;

    Py_XDECREF(var_res);
    var_res = NULL;

    Py_XDECREF(var_context);
    var_context = NULL;

    Py_XDECREF(var_method_func);
    var_method_func = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_12___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_method);
    Py_DECREF(par_method);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_method);
    Py_DECREF(par_method);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_13_load_verify_locations(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_cafile = python_pars[1];
    PyObject *par_capath = python_pars[2];
    PyObject *var_load_result = NULL;
    struct Nuitka_FrameObject *frame_346033c0896bad93f6cf605df224d7cb;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_346033c0896bad93f6cf605df224d7cb = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_346033c0896bad93f6cf605df224d7cb, codeobj_346033c0896bad93f6cf605df224d7cb, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_346033c0896bad93f6cf605df224d7cb = cache_frame_346033c0896bad93f6cf605df224d7cb;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_346033c0896bad93f6cf605df224d7cb);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_346033c0896bad93f6cf605df224d7cb) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_cafile);
        tmp_compexpr_left_1 = par_cafile;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_source_name_1;
            PyObject *tmp_mvar_value_1;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_1 == NULL)) {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_1 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 763;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_1 = tmp_mvar_value_1;
            tmp_assign_source_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_NULL);
            if (tmp_assign_source_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 763;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_cafile;
                assert(old != NULL);
                par_cafile = tmp_assign_source_1;
                Py_DECREF(old);
            }

        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_called_name_1;
            PyObject *tmp_mvar_value_2;
            PyObject *tmp_args_element_name_1;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__path_string);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__path_string);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 545 ], 41, 0);
                exception_tb = NULL;

                exception_lineno = 765;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_1 = tmp_mvar_value_2;
            CHECK_OBJECT(par_cafile);
            tmp_args_element_name_1 = par_cafile;
            frame_346033c0896bad93f6cf605df224d7cb->m_frame.f_lineno = 765;
            tmp_assign_source_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 765;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_cafile;
                assert(old != NULL);
                par_cafile = tmp_assign_source_2;
                Py_DECREF(old);
            }

        }
        branch_end_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        CHECK_OBJECT(par_capath);
        tmp_compexpr_left_2 = par_capath;
        tmp_compexpr_right_2 = Py_None;
        tmp_condition_result_2 = (tmp_compexpr_left_2 == tmp_compexpr_right_2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_source_name_2;
            PyObject *tmp_mvar_value_3;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_3 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 768;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_2 = tmp_mvar_value_3;
            tmp_assign_source_3 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_NULL);
            if (tmp_assign_source_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 768;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_capath;
                assert(old != NULL);
                par_capath = tmp_assign_source_3;
                Py_DECREF(old);
            }

        }
        goto branch_end_2;
        branch_no_2:;
        {
            PyObject *tmp_assign_source_4;
            PyObject *tmp_called_name_2;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_args_element_name_2;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__path_string);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__path_string);
            }

            if (tmp_mvar_value_4 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 545 ], 41, 0);
                exception_tb = NULL;

                exception_lineno = 770;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_2 = tmp_mvar_value_4;
            CHECK_OBJECT(par_capath);
            tmp_args_element_name_2 = par_capath;
            frame_346033c0896bad93f6cf605df224d7cb->m_frame.f_lineno = 770;
            tmp_assign_source_4 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_2);
            if (tmp_assign_source_4 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 770;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_capath;
                assert(old != NULL);
                par_capath = tmp_assign_source_4;
                Py_DECREF(old);
            }

        }
        branch_end_2:;
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_4;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 772;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_5;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_SSL_CTX_load_verify_locations);
        if (tmp_called_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 772;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_4 = par_self;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain__context);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);

            exception_lineno = 773;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_cafile);
        tmp_args_element_name_4 = par_cafile;
        CHECK_OBJECT(par_capath);
        tmp_args_element_name_5 = par_capath;
        frame_346033c0896bad93f6cf605df224d7cb->m_frame.f_lineno = 772;
        {
            PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5};
            tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_3, call_args);
        }

        Py_DECREF(tmp_called_name_3);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_assign_source_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 772;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_load_result == NULL);
        var_load_result = tmp_assign_source_5;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_operand_name_1;
        CHECK_OBJECT(var_load_result);
        tmp_operand_name_1 = var_load_result;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 775;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
            goto branch_yes_3;
        } else {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_called_name_4;
            PyObject *tmp_mvar_value_6;
            PyObject *tmp_call_result_1;
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error);

            if (unlikely(tmp_mvar_value_6 == NULL)) {
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error);
            }

            if (tmp_mvar_value_6 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 0 ], 49, 0);
                exception_tb = NULL;

                exception_lineno = 776;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_4 = tmp_mvar_value_6;
            frame_346033c0896bad93f6cf605df224d7cb->m_frame.f_lineno = 776;
            tmp_call_result_1 = CALL_FUNCTION_NO_ARGS(tmp_called_name_4);
            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 776;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_1);
        }
        branch_no_3:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_346033c0896bad93f6cf605df224d7cb);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_346033c0896bad93f6cf605df224d7cb);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_346033c0896bad93f6cf605df224d7cb, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_346033c0896bad93f6cf605df224d7cb->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_346033c0896bad93f6cf605df224d7cb, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_346033c0896bad93f6cf605df224d7cb,
        type_description_1,
        par_self,
        par_cafile,
        par_capath,
        var_load_result
    );


    // Release cached frame.
    if (frame_346033c0896bad93f6cf605df224d7cb == cache_frame_346033c0896bad93f6cf605df224d7cb) {
        Py_DECREF(frame_346033c0896bad93f6cf605df224d7cb);
    }
    cache_frame_346033c0896bad93f6cf605df224d7cb = NULL;

    assertFrameObject(frame_346033c0896bad93f6cf605df224d7cb);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_13_load_verify_locations);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)par_capath);
    Py_DECREF(par_capath);
    par_capath = NULL;

    CHECK_OBJECT((PyObject *)par_cafile);
    Py_DECREF(par_cafile);
    par_cafile = NULL;

    CHECK_OBJECT((PyObject *)var_load_result);
    Py_DECREF(var_load_result);
    var_load_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(par_capath);
    par_capath = NULL;

    Py_XDECREF(par_cafile);
    par_cafile = NULL;

    Py_XDECREF(var_load_result);
    var_load_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_13_load_verify_locations);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_14__wrap_callback(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1(python_pars[0]);
    struct Nuitka_CellObject *par_callback = PyCell_NEW1(python_pars[1]);
    PyObject *var_wrapper = NULL;
    struct Nuitka_FrameObject *frame_c566f460e49d418f64d8ae5bff045f3b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_c566f460e49d418f64d8ae5bff045f3b = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_c566f460e49d418f64d8ae5bff045f3b, codeobj_c566f460e49d418f64d8ae5bff045f3b, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_c566f460e49d418f64d8ae5bff045f3b = cache_frame_c566f460e49d418f64d8ae5bff045f3b;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_c566f460e49d418f64d8ae5bff045f3b);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_c566f460e49d418f64d8ae5bff045f3b) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_wraps);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_wraps);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 136 ], 34, 0);
            exception_tb = NULL;

            exception_lineno = 779;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_1;
        CHECK_OBJECT(PyCell_GET(par_callback));
        tmp_args_element_name_1 = PyCell_GET(par_callback);
        frame_c566f460e49d418f64d8ae5bff045f3b->m_frame.f_lineno = 779;
        tmp_called_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_1);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 779;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_2 = MAKE_FUNCTION_OpenSSL$SSL$$$function_14__wrap_callback$$$function_1_wrapper();

        ((struct Nuitka_FunctionObject *)tmp_args_element_name_2)->m_closure[0] = par_callback;
        Py_INCREF(((struct Nuitka_FunctionObject *)tmp_args_element_name_2)->m_closure[0]);
        ((struct Nuitka_FunctionObject *)tmp_args_element_name_2)->m_closure[1] = par_self;
        Py_INCREF(((struct Nuitka_FunctionObject *)tmp_args_element_name_2)->m_closure[1]);


        frame_c566f460e49d418f64d8ae5bff045f3b->m_frame.f_lineno = 779;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_2);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 779;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        assert(var_wrapper == NULL);
        var_wrapper = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_kw_name_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__PassphraseHelper);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__PassphraseHelper);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 586 ], 46, 0);
            exception_tb = NULL;

            exception_lineno = 782;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_2;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 632 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 783;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }

        tmp_tuple_element_1 = tmp_mvar_value_3;
        tmp_args_name_1 = PyTuple_New(2);
        Py_INCREF(tmp_tuple_element_1);
        PyTuple_SET_ITEM(tmp_args_name_1, 0, tmp_tuple_element_1);
        CHECK_OBJECT(var_wrapper);
        tmp_tuple_element_1 = var_wrapper;
        Py_INCREF(tmp_tuple_element_1);
        PyTuple_SET_ITEM(tmp_args_name_1, 1, tmp_tuple_element_1);
        tmp_kw_name_1 = PyDict_Copy(const_dict_4a96d2f6310f0842d222254905a83466);
        frame_c566f460e49d418f64d8ae5bff045f3b->m_frame.f_lineno = 782;
        tmp_return_value = CALL_FUNCTION(tmp_called_name_3, tmp_args_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_args_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 782;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c566f460e49d418f64d8ae5bff045f3b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_c566f460e49d418f64d8ae5bff045f3b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c566f460e49d418f64d8ae5bff045f3b);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_c566f460e49d418f64d8ae5bff045f3b, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_c566f460e49d418f64d8ae5bff045f3b->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_c566f460e49d418f64d8ae5bff045f3b, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c566f460e49d418f64d8ae5bff045f3b,
        type_description_1,
        par_self,
        par_callback,
        var_wrapper
    );


    // Release cached frame.
    if (frame_c566f460e49d418f64d8ae5bff045f3b == cache_frame_c566f460e49d418f64d8ae5bff045f3b) {
        Py_DECREF(frame_c566f460e49d418f64d8ae5bff045f3b);
    }
    cache_frame_c566f460e49d418f64d8ae5bff045f3b = NULL;

    assertFrameObject(frame_c566f460e49d418f64d8ae5bff045f3b);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_14__wrap_callback);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_wrapper);
    Py_DECREF(var_wrapper);
    var_wrapper = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_wrapper);
    var_wrapper = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_14__wrap_callback);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_callback);
    Py_DECREF(par_callback);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_callback);
    Py_DECREF(par_callback);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_14__wrap_callback$$$function_1_wrapper(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_size = python_pars[0];
    PyObject *par_verify = python_pars[1];
    PyObject *par_userdata = python_pars[2];
    struct Nuitka_FrameObject *frame_a9047c1bce52ef36545c3c95123c1a6f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_a9047c1bce52ef36545c3c95123c1a6f = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_a9047c1bce52ef36545c3c95123c1a6f, codeobj_a9047c1bce52ef36545c3c95123c1a6f, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_a9047c1bce52ef36545c3c95123c1a6f = cache_frame_a9047c1bce52ef36545c3c95123c1a6f;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_a9047c1bce52ef36545c3c95123c1a6f);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_a9047c1bce52ef36545c3c95123c1a6f) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_1;
        if (PyCell_GET(self->m_closure[0]) == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "callback");
            exception_tb = NULL;

            exception_lineno = 781;
            type_description_1 = "ooocc";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = PyCell_GET(self->m_closure[0]);
        CHECK_OBJECT(par_size);
        tmp_args_element_name_1 = par_size;
        CHECK_OBJECT(par_verify);
        tmp_args_element_name_2 = par_verify;
        if (PyCell_GET(self->m_closure[1]) == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "self");
            exception_tb = NULL;

            exception_lineno = 781;
            type_description_1 = "ooocc";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = PyCell_GET(self->m_closure[1]);
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__passphrase_userdata);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 781;
            type_description_1 = "ooocc";
            goto frame_exception_exit_1;
        }
        frame_a9047c1bce52ef36545c3c95123c1a6f->m_frame.f_lineno = 781;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_return_value = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_args_element_name_3);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 781;
            type_description_1 = "ooocc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a9047c1bce52ef36545c3c95123c1a6f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_a9047c1bce52ef36545c3c95123c1a6f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a9047c1bce52ef36545c3c95123c1a6f);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_a9047c1bce52ef36545c3c95123c1a6f, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_a9047c1bce52ef36545c3c95123c1a6f->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_a9047c1bce52ef36545c3c95123c1a6f, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a9047c1bce52ef36545c3c95123c1a6f,
        type_description_1,
        par_size,
        par_verify,
        par_userdata,
        self->m_closure[1],
        self->m_closure[0]
    );


    // Release cached frame.
    if (frame_a9047c1bce52ef36545c3c95123c1a6f == cache_frame_a9047c1bce52ef36545c3c95123c1a6f) {
        Py_DECREF(frame_a9047c1bce52ef36545c3c95123c1a6f);
    }
    cache_frame_a9047c1bce52ef36545c3c95123c1a6f = NULL;

    assertFrameObject(frame_a9047c1bce52ef36545c3c95123c1a6f);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_14__wrap_callback$$$function_1_wrapper);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_verify);
    Py_DECREF(par_verify);
    CHECK_OBJECT(par_userdata);
    Py_DECREF(par_userdata);
    CHECK_OBJECT(par_size);
    Py_DECREF(par_size);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_verify);
    Py_DECREF(par_verify);
    CHECK_OBJECT(par_userdata);
    Py_DECREF(par_userdata);
    CHECK_OBJECT(par_size);
    Py_DECREF(par_size);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_15_set_passwd_cb(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_callback = python_pars[1];
    PyObject *par_userdata = python_pars[2];
    struct Nuitka_FrameObject *frame_8f7fd200c22a912bb8feee9fea391456;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_8f7fd200c22a912bb8feee9fea391456 = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_8f7fd200c22a912bb8feee9fea391456, codeobj_8f7fd200c22a912bb8feee9fea391456, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_8f7fd200c22a912bb8feee9fea391456 = cache_frame_8f7fd200c22a912bb8feee9fea391456;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_8f7fd200c22a912bb8feee9fea391456);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_8f7fd200c22a912bb8feee9fea391456) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_1;
        tmp_called_name_1 = LOOKUP_BUILTIN(const_str_plain_callable);
        assert(tmp_called_name_1 != NULL);
        CHECK_OBJECT(par_callback);
        tmp_args_element_name_1 = par_callback;
        frame_8f7fd200c22a912bb8feee9fea391456->m_frame.f_lineno = 804;
        tmp_operand_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 804;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 804;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_3462bf983701fbd7caf2f521f5975fff;
            frame_8f7fd200c22a912bb8feee9fea391456->m_frame.f_lineno = 805;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 805;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        CHECK_OBJECT(par_callback);
        tmp_args_element_name_2 = par_callback;
        frame_8f7fd200c22a912bb8feee9fea391456->m_frame.f_lineno = 807;
        {
            PyObject *call_args[] = {tmp_args_element_name_2};
            tmp_assattr_name_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain__wrap_callback, call_args);
        }

        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 807;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__passphrase_helper, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 807;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__passphrase_helper);
        if (tmp_source_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 808;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_assattr_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_callback);
        Py_DECREF(tmp_source_name_1);
        if (tmp_assattr_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 808;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain__passphrase_callback, tmp_assattr_name_2);
        Py_DECREF(tmp_assattr_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 808;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_4;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_source_name_5;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 809;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_1;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_SSL_CTX_set_default_passwd_cb);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 809;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_4 = par_self;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain__context);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 810;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_5 = par_self;
        tmp_args_element_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain__passphrase_callback);
        if (tmp_args_element_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_3);

            exception_lineno = 810;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_8f7fd200c22a912bb8feee9fea391456->m_frame.f_lineno = 809;
        {
            PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4};
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_3);
        Py_DECREF(tmp_args_element_name_4);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 809;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_assattr_target_3;
        CHECK_OBJECT(par_userdata);
        tmp_assattr_name_3 = par_userdata;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_3 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_3, const_str_plain__passphrase_userdata, tmp_assattr_name_3);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 811;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8f7fd200c22a912bb8feee9fea391456);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8f7fd200c22a912bb8feee9fea391456);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_8f7fd200c22a912bb8feee9fea391456, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_8f7fd200c22a912bb8feee9fea391456->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_8f7fd200c22a912bb8feee9fea391456, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8f7fd200c22a912bb8feee9fea391456,
        type_description_1,
        par_self,
        par_callback,
        par_userdata
    );


    // Release cached frame.
    if (frame_8f7fd200c22a912bb8feee9fea391456 == cache_frame_8f7fd200c22a912bb8feee9fea391456) {
        Py_DECREF(frame_8f7fd200c22a912bb8feee9fea391456);
    }
    cache_frame_8f7fd200c22a912bb8feee9fea391456 = NULL;

    assertFrameObject(frame_8f7fd200c22a912bb8feee9fea391456);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_15_set_passwd_cb);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_callback);
    Py_DECREF(par_callback);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_userdata);
    Py_DECREF(par_userdata);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_callback);
    Py_DECREF(par_callback);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_userdata);
    Py_DECREF(par_userdata);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_16_set_default_verify_paths(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_default_dir = NULL;
    PyObject *var_set_result = NULL;
    PyObject *var_dir_env_var = NULL;
    PyObject *var_file_env_var = NULL;
    PyObject *var_default_file = NULL;
    struct Nuitka_FrameObject *frame_1eb3a30ea8ff5bbf704361f349f12a12;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_1eb3a30ea8ff5bbf704361f349f12a12 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_1eb3a30ea8ff5bbf704361f349f12a12, codeobj_1eb3a30ea8ff5bbf704361f349f12a12, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_1eb3a30ea8ff5bbf704361f349f12a12 = cache_frame_1eb3a30ea8ff5bbf704361f349f12a12;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_1eb3a30ea8ff5bbf704361f349f12a12);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_1eb3a30ea8ff5bbf704361f349f12a12) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 833;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_CTX_set_default_verify_paths);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 833;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__context);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 833;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_1eb3a30ea8ff5bbf704361f349f12a12->m_frame.f_lineno = 833;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 833;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert(var_set_result == NULL);
        var_set_result = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 834;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT(var_set_result);
        tmp_compexpr_left_1 = var_set_result;
        tmp_compexpr_right_1 = const_int_pos_1;
        tmp_args_element_name_2 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 834;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_1eb3a30ea8ff5bbf704361f349f12a12->m_frame.f_lineno = 834;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_2);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 834;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 840;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_3;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_string);
        if (tmp_called_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 840;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_4 == NULL) {
            Py_DECREF(tmp_called_name_3);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 841;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_4;
        frame_1eb3a30ea8ff5bbf704361f349f12a12->m_frame.f_lineno = 841;
        tmp_args_element_name_3 = CALL_METHOD_NO_ARGS(tmp_called_instance_2, const_str_plain_X509_get_default_cert_dir_env);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);

            exception_lineno = 841;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_1eb3a30ea8ff5bbf704361f349f12a12->m_frame.f_lineno = 840;
        tmp_called_instance_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_3, tmp_args_element_name_3);
        Py_DECREF(tmp_called_name_3);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_called_instance_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 840;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_1eb3a30ea8ff5bbf704361f349f12a12->m_frame.f_lineno = 840;
        tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_decode, &PyTuple_GET_ITEM(const_tuple_str_plain_ascii_tuple, 0));

        Py_DECREF(tmp_called_instance_1);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 840;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert(var_dir_env_var == NULL);
        var_dir_env_var = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_called_instance_4;
        PyObject *tmp_mvar_value_6;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 843;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_5;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_string);
        if (tmp_called_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 843;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_6 == NULL) {
            Py_DECREF(tmp_called_name_4);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 844;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_4 = tmp_mvar_value_6;
        frame_1eb3a30ea8ff5bbf704361f349f12a12->m_frame.f_lineno = 844;
        tmp_args_element_name_4 = CALL_METHOD_NO_ARGS(tmp_called_instance_4, const_str_plain_X509_get_default_cert_file_env);
        if (tmp_args_element_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_4);

            exception_lineno = 844;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_1eb3a30ea8ff5bbf704361f349f12a12->m_frame.f_lineno = 843;
        tmp_called_instance_3 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_4, tmp_args_element_name_4);
        Py_DECREF(tmp_called_name_4);
        Py_DECREF(tmp_args_element_name_4);
        if (tmp_called_instance_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 843;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_1eb3a30ea8ff5bbf704361f349f12a12->m_frame.f_lineno = 843;
        tmp_assign_source_3 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_3, const_str_plain_decode, &PyTuple_GET_ITEM(const_tuple_str_plain_ascii_tuple, 0));

        Py_DECREF(tmp_called_instance_3);
        if (tmp_assign_source_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 843;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert(var_file_env_var == NULL);
        var_file_env_var = tmp_assign_source_3;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_called_instance_5;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_args_element_name_6;
        CHECK_OBJECT(par_self);
        tmp_called_instance_5 = par_self;
        CHECK_OBJECT(var_dir_env_var);
        tmp_args_element_name_5 = var_dir_env_var;
        CHECK_OBJECT(var_file_env_var);
        tmp_args_element_name_6 = var_file_env_var;
        frame_1eb3a30ea8ff5bbf704361f349f12a12->m_frame.f_lineno = 846;
        {
            PyObject *call_args[] = {tmp_args_element_name_5, tmp_args_element_name_6};
            tmp_operand_name_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_5, const_str_plain__check_env_vars_set, call_args);
        }

        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 846;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 846;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_4;
            PyObject *tmp_called_name_5;
            PyObject *tmp_source_name_5;
            PyObject *tmp_mvar_value_7;
            PyObject *tmp_args_element_name_7;
            PyObject *tmp_called_instance_6;
            PyObject *tmp_mvar_value_8;
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_7 == NULL)) {
                tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_7 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 847;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_5 = tmp_mvar_value_7;
            tmp_called_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_string);
            if (tmp_called_name_5 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 847;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_8 == NULL)) {
                tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_8 == NULL) {
                Py_DECREF(tmp_called_name_5);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 847;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_6 = tmp_mvar_value_8;
            frame_1eb3a30ea8ff5bbf704361f349f12a12->m_frame.f_lineno = 847;
            tmp_args_element_name_7 = CALL_METHOD_NO_ARGS(tmp_called_instance_6, const_str_plain_X509_get_default_cert_dir);
            if (tmp_args_element_name_7 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_5);

                exception_lineno = 847;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            frame_1eb3a30ea8ff5bbf704361f349f12a12->m_frame.f_lineno = 847;
            tmp_assign_source_4 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_5, tmp_args_element_name_7);
            Py_DECREF(tmp_called_name_5);
            Py_DECREF(tmp_args_element_name_7);
            if (tmp_assign_source_4 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 847;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            assert(var_default_dir == NULL);
            var_default_dir = tmp_assign_source_4;
        }
        {
            PyObject *tmp_assign_source_5;
            PyObject *tmp_called_name_6;
            PyObject *tmp_source_name_6;
            PyObject *tmp_mvar_value_9;
            PyObject *tmp_args_element_name_8;
            PyObject *tmp_called_instance_7;
            PyObject *tmp_mvar_value_10;
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_9 == NULL)) {
                tmp_mvar_value_9 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_9 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 848;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_6 = tmp_mvar_value_9;
            tmp_called_name_6 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_string);
            if (tmp_called_name_6 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 848;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_10 == NULL)) {
                tmp_mvar_value_10 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_10 == NULL) {
                Py_DECREF(tmp_called_name_6);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 848;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_7 = tmp_mvar_value_10;
            frame_1eb3a30ea8ff5bbf704361f349f12a12->m_frame.f_lineno = 848;
            tmp_args_element_name_8 = CALL_METHOD_NO_ARGS(tmp_called_instance_7, const_str_plain_X509_get_default_cert_file);
            if (tmp_args_element_name_8 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_6);

                exception_lineno = 848;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            frame_1eb3a30ea8ff5bbf704361f349f12a12->m_frame.f_lineno = 848;
            tmp_assign_source_5 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_6, tmp_args_element_name_8);
            Py_DECREF(tmp_called_name_6);
            Py_DECREF(tmp_args_element_name_8);
            if (tmp_assign_source_5 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 848;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            assert(var_default_file == NULL);
            var_default_file = tmp_assign_source_5;
        }
        {
            nuitka_bool tmp_condition_result_2;
            int tmp_and_left_truth_1;
            nuitka_bool tmp_and_left_value_1;
            nuitka_bool tmp_and_right_value_1;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_mvar_value_11;
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            PyObject *tmp_mvar_value_12;
            CHECK_OBJECT(var_default_dir);
            tmp_compexpr_left_2 = var_default_dir;
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CRYPTOGRAPHY_MANYLINUX1_CA_DIR);

            if (unlikely(tmp_mvar_value_11 == NULL)) {
                tmp_mvar_value_11 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__CRYPTOGRAPHY_MANYLINUX1_CA_DIR);
            }

            if (tmp_mvar_value_11 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 673 ], 60, 0);
                exception_tb = NULL;

                exception_lineno = 853;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_2 = tmp_mvar_value_11;
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 853;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            tmp_and_left_value_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
            if (tmp_and_left_truth_1 == 1) {
                goto and_right_1;
            } else {
                goto and_left_1;
            }
            and_right_1:;
            CHECK_OBJECT(var_default_file);
            tmp_compexpr_left_3 = var_default_file;
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CRYPTOGRAPHY_MANYLINUX1_CA_FILE);

            if (unlikely(tmp_mvar_value_12 == NULL)) {
                tmp_mvar_value_12 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__CRYPTOGRAPHY_MANYLINUX1_CA_FILE);
            }

            if (tmp_mvar_value_12 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 733 ], 61, 0);
                exception_tb = NULL;

                exception_lineno = 854;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_3 = tmp_mvar_value_12;
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_3, tmp_compexpr_right_3);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 854;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            tmp_and_right_value_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            tmp_condition_result_2 = tmp_and_right_value_1;
            goto and_end_1;
            and_left_1:;
            tmp_condition_result_2 = tmp_and_left_value_1;
            and_end_1:;
            if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
                goto branch_yes_2;
            } else {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_called_name_7;
                PyObject *tmp_source_name_7;
                PyObject *tmp_call_result_2;
                PyObject *tmp_args_element_name_9;
                PyObject *tmp_mvar_value_13;
                PyObject *tmp_args_element_name_10;
                PyObject *tmp_mvar_value_14;
                CHECK_OBJECT(par_self);
                tmp_source_name_7 = par_self;
                tmp_called_name_7 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain__fallback_default_verify_paths);
                if (tmp_called_name_7 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 857;
                    type_description_1 = "oooooo";
                    goto frame_exception_exit_1;
                }
                tmp_mvar_value_13 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CERTIFICATE_FILE_LOCATIONS);

                if (unlikely(tmp_mvar_value_13 == NULL)) {
                    tmp_mvar_value_13 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__CERTIFICATE_FILE_LOCATIONS);
                }

                if (tmp_mvar_value_13 == NULL) {
                    Py_DECREF(tmp_called_name_7);
                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 794 ], 56, 0);
                    exception_tb = NULL;

                    exception_lineno = 858;
                    type_description_1 = "oooooo";
                    goto frame_exception_exit_1;
                }

                tmp_args_element_name_9 = tmp_mvar_value_13;
                tmp_mvar_value_14 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CERTIFICATE_PATH_LOCATIONS);

                if (unlikely(tmp_mvar_value_14 == NULL)) {
                    tmp_mvar_value_14 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__CERTIFICATE_PATH_LOCATIONS);
                }

                if (tmp_mvar_value_14 == NULL) {
                    Py_DECREF(tmp_called_name_7);
                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 850 ], 56, 0);
                    exception_tb = NULL;

                    exception_lineno = 859;
                    type_description_1 = "oooooo";
                    goto frame_exception_exit_1;
                }

                tmp_args_element_name_10 = tmp_mvar_value_14;
                frame_1eb3a30ea8ff5bbf704361f349f12a12->m_frame.f_lineno = 857;
                {
                    PyObject *call_args[] = {tmp_args_element_name_9, tmp_args_element_name_10};
                    tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_7, call_args);
                }

                Py_DECREF(tmp_called_name_7);
                if (tmp_call_result_2 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 857;
                    type_description_1 = "oooooo";
                    goto frame_exception_exit_1;
                }
                Py_DECREF(tmp_call_result_2);
            }
            branch_no_2:;
        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_1eb3a30ea8ff5bbf704361f349f12a12);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_1eb3a30ea8ff5bbf704361f349f12a12);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_1eb3a30ea8ff5bbf704361f349f12a12, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_1eb3a30ea8ff5bbf704361f349f12a12->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_1eb3a30ea8ff5bbf704361f349f12a12, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1eb3a30ea8ff5bbf704361f349f12a12,
        type_description_1,
        par_self,
        var_default_dir,
        var_set_result,
        var_dir_env_var,
        var_file_env_var,
        var_default_file
    );


    // Release cached frame.
    if (frame_1eb3a30ea8ff5bbf704361f349f12a12 == cache_frame_1eb3a30ea8ff5bbf704361f349f12a12) {
        Py_DECREF(frame_1eb3a30ea8ff5bbf704361f349f12a12);
    }
    cache_frame_1eb3a30ea8ff5bbf704361f349f12a12 = NULL;

    assertFrameObject(frame_1eb3a30ea8ff5bbf704361f349f12a12);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_16_set_default_verify_paths);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_default_dir);
    var_default_dir = NULL;

    CHECK_OBJECT((PyObject *)var_set_result);
    Py_DECREF(var_set_result);
    var_set_result = NULL;

    CHECK_OBJECT((PyObject *)var_dir_env_var);
    Py_DECREF(var_dir_env_var);
    var_dir_env_var = NULL;

    CHECK_OBJECT((PyObject *)var_file_env_var);
    Py_DECREF(var_file_env_var);
    var_file_env_var = NULL;

    Py_XDECREF(var_default_file);
    var_default_file = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_default_dir);
    var_default_dir = NULL;

    Py_XDECREF(var_set_result);
    var_set_result = NULL;

    Py_XDECREF(var_dir_env_var);
    var_dir_env_var = NULL;

    Py_XDECREF(var_file_env_var);
    var_file_env_var = NULL;

    Py_XDECREF(var_default_file);
    var_default_file = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_16_set_default_verify_paths);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_17__check_env_vars_set(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_dir_env_var = python_pars[1];
    PyObject *par_file_env_var = python_pars[2];
    struct Nuitka_FrameObject *frame_a34ae73d8f795897cbc3555bccd4619d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_a34ae73d8f795897cbc3555bccd4619d = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_a34ae73d8f795897cbc3555bccd4619d, codeobj_a34ae73d8f795897cbc3555bccd4619d, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_a34ae73d8f795897cbc3555bccd4619d = cache_frame_a34ae73d8f795897cbc3555bccd4619d;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_a34ae73d8f795897cbc3555bccd4619d);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_a34ae73d8f795897cbc3555bccd4619d) == 2); // Frame stack

    // Framed code:
    {
        int tmp_or_left_truth_1;
        PyObject *tmp_or_left_value_1;
        PyObject *tmp_or_right_value_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_os);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_os);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 906 ], 31, 0);
            exception_tb = NULL;

            exception_lineno = 869;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_environ);
        if (tmp_called_instance_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 869;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_file_env_var);
        tmp_args_element_name_1 = par_file_env_var;
        frame_a34ae73d8f795897cbc3555bccd4619d->m_frame.f_lineno = 869;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_compexpr_left_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_get, call_args);
        }

        Py_DECREF(tmp_called_instance_1);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 869;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_or_left_value_1 = (tmp_compexpr_left_1 != tmp_compexpr_right_1) ? Py_True : Py_False;
        Py_DECREF(tmp_compexpr_left_1);
        tmp_or_left_truth_1 = CHECK_IF_TRUE(tmp_or_left_value_1);
        if (tmp_or_left_truth_1 == 1) {
            goto or_left_1;
        } else {
            goto or_right_1;
        }
        or_right_1:;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_os);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_os);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 906 ], 31, 0);
            exception_tb = NULL;

            exception_lineno = 870;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_called_instance_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_environ);
        if (tmp_called_instance_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 870;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_dir_env_var);
        tmp_args_element_name_2 = par_dir_env_var;
        frame_a34ae73d8f795897cbc3555bccd4619d->m_frame.f_lineno = 870;
        {
            PyObject *call_args[] = {tmp_args_element_name_2};
            tmp_compexpr_left_2 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_get, call_args);
        }

        Py_DECREF(tmp_called_instance_2);
        if (tmp_compexpr_left_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 870;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_2 = Py_None;
        tmp_or_right_value_1 = (tmp_compexpr_left_2 != tmp_compexpr_right_2) ? Py_True : Py_False;
        Py_DECREF(tmp_compexpr_left_2);
        tmp_return_value = tmp_or_right_value_1;
        goto or_end_1;
        or_left_1:;
        tmp_return_value = tmp_or_left_value_1;
        or_end_1:;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a34ae73d8f795897cbc3555bccd4619d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_a34ae73d8f795897cbc3555bccd4619d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a34ae73d8f795897cbc3555bccd4619d);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_a34ae73d8f795897cbc3555bccd4619d, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_a34ae73d8f795897cbc3555bccd4619d->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_a34ae73d8f795897cbc3555bccd4619d, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a34ae73d8f795897cbc3555bccd4619d,
        type_description_1,
        par_self,
        par_dir_env_var,
        par_file_env_var
    );


    // Release cached frame.
    if (frame_a34ae73d8f795897cbc3555bccd4619d == cache_frame_a34ae73d8f795897cbc3555bccd4619d) {
        Py_DECREF(frame_a34ae73d8f795897cbc3555bccd4619d);
    }
    cache_frame_a34ae73d8f795897cbc3555bccd4619d = NULL;

    assertFrameObject(frame_a34ae73d8f795897cbc3555bccd4619d);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_17__check_env_vars_set);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_dir_env_var);
    Py_DECREF(par_dir_env_var);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_file_env_var);
    Py_DECREF(par_file_env_var);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_dir_env_var);
    Py_DECREF(par_dir_env_var);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_file_env_var);
    Py_DECREF(par_file_env_var);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_18__fallback_default_verify_paths(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_file_path = python_pars[1];
    PyObject *par_dir_path = python_pars[2];
    PyObject *var_capath = NULL;
    PyObject *var_cafile = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *tmp_for_loop_2__for_iterator = NULL;
    PyObject *tmp_for_loop_2__iter_value = NULL;
    struct Nuitka_FrameObject *frame_567d4caf802af0a89115f921ed8e28e3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    static struct Nuitka_FrameObject *cache_frame_567d4caf802af0a89115f921ed8e28e3 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_567d4caf802af0a89115f921ed8e28e3, codeobj_567d4caf802af0a89115f921ed8e28e3, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_567d4caf802af0a89115f921ed8e28e3 = cache_frame_567d4caf802af0a89115f921ed8e28e3;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_567d4caf802af0a89115f921ed8e28e3);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_567d4caf802af0a89115f921ed8e28e3) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_iter_arg_1;
        CHECK_OBJECT(par_file_path);
        tmp_iter_arg_1 = par_file_path;
        tmp_assign_source_1 = MAKE_ITERATOR(tmp_iter_arg_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 883;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(tmp_for_loop_1__for_iterator == NULL);
        tmp_for_loop_1__for_iterator = tmp_assign_source_1;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT(tmp_for_loop_1__for_iterator);
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_2 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_2 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "ooooo";
                exception_lineno = 883;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_2;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_3;
        CHECK_OBJECT(tmp_for_loop_1__iter_value);
        tmp_assign_source_3 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_cafile;
            var_cafile = tmp_assign_source_3;
            Py_INCREF(var_cafile);
            Py_XDECREF(old);
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        int tmp_truth_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_os);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_os);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 906 ], 31, 0);
            exception_tb = NULL;

            exception_lineno = 884;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_path);
        if (tmp_called_instance_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 884;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT(var_cafile);
        tmp_args_element_name_1 = var_cafile;
        frame_567d4caf802af0a89115f921ed8e28e3->m_frame.f_lineno = 884;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_isfile, call_args);
        }

        Py_DECREF(tmp_called_instance_1);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 884;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE(tmp_call_result_1);
        if (tmp_truth_name_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_call_result_1);

            exception_lineno = 884;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_call_result_1);
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_call_result_2;
            PyObject *tmp_args_element_name_2;
            CHECK_OBJECT(par_self);
            tmp_called_instance_2 = par_self;
            CHECK_OBJECT(var_cafile);
            tmp_args_element_name_2 = var_cafile;
            frame_567d4caf802af0a89115f921ed8e28e3->m_frame.f_lineno = 885;
            {
                PyObject *call_args[] = {tmp_args_element_name_2};
                tmp_call_result_2 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_load_verify_locations, call_args);
            }

            if (tmp_call_result_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 885;
                type_description_1 = "ooooo";
                goto try_except_handler_2;
            }
            Py_DECREF(tmp_call_result_2);
        }
        goto loop_end_1;
        branch_no_1:;
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


        exception_lineno = 883;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_iter_arg_2;
        CHECK_OBJECT(par_dir_path);
        tmp_iter_arg_2 = par_dir_path;
        tmp_assign_source_4 = MAKE_ITERATOR(tmp_iter_arg_2);
        if (tmp_assign_source_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 888;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(tmp_for_loop_2__for_iterator == NULL);
        tmp_for_loop_2__for_iterator = tmp_assign_source_4;
    }
    // Tried code:
    loop_start_2:;
    {
        PyObject *tmp_next_source_2;
        PyObject *tmp_assign_source_5;
        CHECK_OBJECT(tmp_for_loop_2__for_iterator);
        tmp_next_source_2 = tmp_for_loop_2__for_iterator;
        tmp_assign_source_5 = ITERATOR_NEXT(tmp_next_source_2);
        if (tmp_assign_source_5 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_2;
            } else {

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "ooooo";
                exception_lineno = 888;
                goto try_except_handler_3;
            }
        }

        {
            PyObject *old = tmp_for_loop_2__iter_value;
            tmp_for_loop_2__iter_value = tmp_assign_source_5;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_6;
        CHECK_OBJECT(tmp_for_loop_2__iter_value);
        tmp_assign_source_6 = tmp_for_loop_2__iter_value;
        {
            PyObject *old = var_capath;
            var_capath = tmp_assign_source_6;
            Py_INCREF(var_capath);
            Py_XDECREF(old);
        }

    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_3;
        PyObject *tmp_args_element_name_3;
        int tmp_truth_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_os);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_os);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 906 ], 31, 0);
            exception_tb = NULL;

            exception_lineno = 889;
            type_description_1 = "ooooo";
            goto try_except_handler_3;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_called_instance_3 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_path);
        if (tmp_called_instance_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 889;
            type_description_1 = "ooooo";
            goto try_except_handler_3;
        }
        CHECK_OBJECT(var_capath);
        tmp_args_element_name_3 = var_capath;
        frame_567d4caf802af0a89115f921ed8e28e3->m_frame.f_lineno = 889;
        {
            PyObject *call_args[] = {tmp_args_element_name_3};
            tmp_call_result_3 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_3, const_str_plain_isdir, call_args);
        }

        Py_DECREF(tmp_called_instance_3);
        if (tmp_call_result_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 889;
            type_description_1 = "ooooo";
            goto try_except_handler_3;
        }
        tmp_truth_name_2 = CHECK_IF_TRUE(tmp_call_result_3);
        if (tmp_truth_name_2 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_call_result_3);

            exception_lineno = 889;
            type_description_1 = "ooooo";
            goto try_except_handler_3;
        }
        tmp_condition_result_2 = tmp_truth_name_2 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_call_result_3);
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_called_instance_4;
            PyObject *tmp_call_result_4;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_args_element_name_5;
            CHECK_OBJECT(par_self);
            tmp_called_instance_4 = par_self;
            tmp_args_element_name_4 = Py_None;
            CHECK_OBJECT(var_capath);
            tmp_args_element_name_5 = var_capath;
            frame_567d4caf802af0a89115f921ed8e28e3->m_frame.f_lineno = 890;
            {
                PyObject *call_args[] = {tmp_args_element_name_4, tmp_args_element_name_5};
                tmp_call_result_4 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_4, const_str_plain_load_verify_locations, call_args);
            }

            if (tmp_call_result_4 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 890;
                type_description_1 = "ooooo";
                goto try_except_handler_3;
            }
            Py_DECREF(tmp_call_result_4);
        }
        goto loop_end_2;
        branch_no_2:;
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


        exception_lineno = 888;
        type_description_1 = "ooooo";
        goto try_except_handler_3;
    }
    goto loop_start_2;
    loop_end_2:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_for_loop_2__iter_value);
    tmp_for_loop_2__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_2__for_iterator);
    Py_DECREF(tmp_for_loop_2__for_iterator);
    tmp_for_loop_2__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_567d4caf802af0a89115f921ed8e28e3);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_567d4caf802af0a89115f921ed8e28e3);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_567d4caf802af0a89115f921ed8e28e3, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_567d4caf802af0a89115f921ed8e28e3->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_567d4caf802af0a89115f921ed8e28e3, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_567d4caf802af0a89115f921ed8e28e3,
        type_description_1,
        par_self,
        par_file_path,
        par_dir_path,
        var_capath,
        var_cafile
    );


    // Release cached frame.
    if (frame_567d4caf802af0a89115f921ed8e28e3 == cache_frame_567d4caf802af0a89115f921ed8e28e3) {
        Py_DECREF(frame_567d4caf802af0a89115f921ed8e28e3);
    }
    cache_frame_567d4caf802af0a89115f921ed8e28e3 = NULL;

    assertFrameObject(frame_567d4caf802af0a89115f921ed8e28e3);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    Py_XDECREF(tmp_for_loop_2__iter_value);
    tmp_for_loop_2__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_2__for_iterator);
    Py_DECREF(tmp_for_loop_2__for_iterator);
    tmp_for_loop_2__for_iterator = NULL;

    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_18__fallback_default_verify_paths);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_capath);
    var_capath = NULL;

    Py_XDECREF(var_cafile);
    var_cafile = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_capath);
    var_capath = NULL;

    Py_XDECREF(var_cafile);
    var_cafile = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_18__fallback_default_verify_paths);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_file_path);
    Py_DECREF(par_file_path);
    CHECK_OBJECT(par_dir_path);
    Py_DECREF(par_dir_path);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_file_path);
    Py_DECREF(par_file_path);
    CHECK_OBJECT(par_dir_path);
    Py_DECREF(par_dir_path);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_19_use_certificate_chain_file(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_certfile = python_pars[1];
    PyObject *var_result = NULL;
    struct Nuitka_FrameObject *frame_1dc98b765f924dc15a85607868c9dcc9;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_1dc98b765f924dc15a85607868c9dcc9 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_1dc98b765f924dc15a85607868c9dcc9, codeobj_1dc98b765f924dc15a85607868c9dcc9, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_1dc98b765f924dc15a85607868c9dcc9 = cache_frame_1dc98b765f924dc15a85607868c9dcc9;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_1dc98b765f924dc15a85607868c9dcc9);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_1dc98b765f924dc15a85607868c9dcc9) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__path_string);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__path_string);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 545 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 902;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT(par_certfile);
        tmp_args_element_name_1 = par_certfile;
        frame_1dc98b765f924dc15a85607868c9dcc9->m_frame.f_lineno = 902;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 902;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = par_certfile;
            assert(old != NULL);
            par_certfile = tmp_assign_source_1;
            Py_DECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 904;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_CTX_use_certificate_chain_file);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 904;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__context);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 905;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_certfile);
        tmp_args_element_name_3 = par_certfile;
        frame_1dc98b765f924dc15a85607868c9dcc9->m_frame.f_lineno = 904;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 904;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_result == NULL);
        var_result = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        CHECK_OBJECT(var_result);
        tmp_operand_name_1 = var_result;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 907;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_name_3;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_call_result_1;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error);
            }

            if (tmp_mvar_value_3 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 0 ], 49, 0);
                exception_tb = NULL;

                exception_lineno = 908;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_3 = tmp_mvar_value_3;
            frame_1dc98b765f924dc15a85607868c9dcc9->m_frame.f_lineno = 908;
            tmp_call_result_1 = CALL_FUNCTION_NO_ARGS(tmp_called_name_3);
            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 908;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_1);
        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_1dc98b765f924dc15a85607868c9dcc9);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_1dc98b765f924dc15a85607868c9dcc9);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_1dc98b765f924dc15a85607868c9dcc9, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_1dc98b765f924dc15a85607868c9dcc9->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_1dc98b765f924dc15a85607868c9dcc9, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1dc98b765f924dc15a85607868c9dcc9,
        type_description_1,
        par_self,
        par_certfile,
        var_result
    );


    // Release cached frame.
    if (frame_1dc98b765f924dc15a85607868c9dcc9 == cache_frame_1dc98b765f924dc15a85607868c9dcc9) {
        Py_DECREF(frame_1dc98b765f924dc15a85607868c9dcc9);
    }
    cache_frame_1dc98b765f924dc15a85607868c9dcc9 = NULL;

    assertFrameObject(frame_1dc98b765f924dc15a85607868c9dcc9);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_19_use_certificate_chain_file);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)par_certfile);
    Py_DECREF(par_certfile);
    par_certfile = NULL;

    CHECK_OBJECT((PyObject *)var_result);
    Py_DECREF(var_result);
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)par_certfile);
    Py_DECREF(par_certfile);
    par_certfile = NULL;

    Py_XDECREF(var_result);
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_19_use_certificate_chain_file);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_20_use_certificate_file(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_certfile = python_pars[1];
    PyObject *par_filetype = python_pars[2];
    PyObject *var_use_result = NULL;
    struct Nuitka_FrameObject *frame_29af76d76b7406a6693f5b340243209e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_29af76d76b7406a6693f5b340243209e = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_29af76d76b7406a6693f5b340243209e, codeobj_29af76d76b7406a6693f5b340243209e, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_29af76d76b7406a6693f5b340243209e = cache_frame_29af76d76b7406a6693f5b340243209e;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_29af76d76b7406a6693f5b340243209e);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_29af76d76b7406a6693f5b340243209e) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__path_string);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__path_string);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 545 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 922;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT(par_certfile);
        tmp_args_element_name_1 = par_certfile;
        frame_29af76d76b7406a6693f5b340243209e->m_frame.f_lineno = 922;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 922;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = par_certfile;
            assert(old != NULL);
            par_certfile = tmp_assign_source_1;
            Py_DECREF(old);
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT(par_filetype);
        tmp_isinstance_inst_1 = par_filetype;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_types);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 459 ], 42, 0);
            exception_tb = NULL;

            exception_lineno = 923;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_2;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 923;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 923;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_7cf2d06a8643ddce5d0ceedd61c750e1;
            frame_29af76d76b7406a6693f5b340243209e->m_frame.f_lineno = 924;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 924;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 926;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_3;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_CTX_use_certificate_file);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 926;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__context);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 927;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_certfile);
        tmp_args_element_name_3 = par_certfile;
        CHECK_OBJECT(par_filetype);
        tmp_args_element_name_4 = par_filetype;
        frame_29af76d76b7406a6693f5b340243209e->m_frame.f_lineno = 926;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4};
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 926;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_use_result == NULL);
        var_use_result = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_2;
        CHECK_OBJECT(var_use_result);
        tmp_operand_name_2 = var_use_result;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 929;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_called_name_3;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_call_result_1;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error);
            }

            if (tmp_mvar_value_4 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 0 ], 49, 0);
                exception_tb = NULL;

                exception_lineno = 930;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_3 = tmp_mvar_value_4;
            frame_29af76d76b7406a6693f5b340243209e->m_frame.f_lineno = 930;
            tmp_call_result_1 = CALL_FUNCTION_NO_ARGS(tmp_called_name_3);
            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 930;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_1);
        }
        branch_no_2:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_29af76d76b7406a6693f5b340243209e);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_29af76d76b7406a6693f5b340243209e);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_29af76d76b7406a6693f5b340243209e, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_29af76d76b7406a6693f5b340243209e->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_29af76d76b7406a6693f5b340243209e, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_29af76d76b7406a6693f5b340243209e,
        type_description_1,
        par_self,
        par_certfile,
        par_filetype,
        var_use_result
    );


    // Release cached frame.
    if (frame_29af76d76b7406a6693f5b340243209e == cache_frame_29af76d76b7406a6693f5b340243209e) {
        Py_DECREF(frame_29af76d76b7406a6693f5b340243209e);
    }
    cache_frame_29af76d76b7406a6693f5b340243209e = NULL;

    assertFrameObject(frame_29af76d76b7406a6693f5b340243209e);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_20_use_certificate_file);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)par_certfile);
    Py_DECREF(par_certfile);
    par_certfile = NULL;

    CHECK_OBJECT((PyObject *)var_use_result);
    Py_DECREF(var_use_result);
    var_use_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)par_certfile);
    Py_DECREF(par_certfile);
    par_certfile = NULL;

    Py_XDECREF(var_use_result);
    var_use_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_20_use_certificate_file);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_filetype);
    Py_DECREF(par_filetype);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_filetype);
    Py_DECREF(par_filetype);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_21_use_certificate(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_cert = python_pars[1];
    PyObject *var_use_result = NULL;
    struct Nuitka_FrameObject *frame_1a8dfef65194129bda154b5d5d19c988;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_1a8dfef65194129bda154b5d5d19c988 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_1a8dfef65194129bda154b5d5d19c988, codeobj_1a8dfef65194129bda154b5d5d19c988, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_1a8dfef65194129bda154b5d5d19c988 = cache_frame_1a8dfef65194129bda154b5d5d19c988;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_1a8dfef65194129bda154b5d5d19c988);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_1a8dfef65194129bda154b5d5d19c988) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_cert);
        tmp_isinstance_inst_1 = par_cert;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 236 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 939;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 939;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 939;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_c804b213c384a15865e18bf31cfff70e;
            frame_1a8dfef65194129bda154b5d5d19c988->m_frame.f_lineno = 940;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 940;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 942;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_CTX_use_certificate);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 942;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__context);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 942;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_cert);
        tmp_source_name_3 = par_cert;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__x509);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_element_name_1);

            exception_lineno = 942;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_1a8dfef65194129bda154b5d5d19c988->m_frame.f_lineno = 942;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 942;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_use_result == NULL);
        var_use_result = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_2;
        CHECK_OBJECT(var_use_result);
        tmp_operand_name_2 = var_use_result;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 943;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_called_name_2;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_call_result_1;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error);
            }

            if (tmp_mvar_value_3 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 0 ], 49, 0);
                exception_tb = NULL;

                exception_lineno = 944;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_2 = tmp_mvar_value_3;
            frame_1a8dfef65194129bda154b5d5d19c988->m_frame.f_lineno = 944;
            tmp_call_result_1 = CALL_FUNCTION_NO_ARGS(tmp_called_name_2);
            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 944;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_1);
        }
        branch_no_2:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_1a8dfef65194129bda154b5d5d19c988);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_1a8dfef65194129bda154b5d5d19c988);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_1a8dfef65194129bda154b5d5d19c988, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_1a8dfef65194129bda154b5d5d19c988->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_1a8dfef65194129bda154b5d5d19c988, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1a8dfef65194129bda154b5d5d19c988,
        type_description_1,
        par_self,
        par_cert,
        var_use_result
    );


    // Release cached frame.
    if (frame_1a8dfef65194129bda154b5d5d19c988 == cache_frame_1a8dfef65194129bda154b5d5d19c988) {
        Py_DECREF(frame_1a8dfef65194129bda154b5d5d19c988);
    }
    cache_frame_1a8dfef65194129bda154b5d5d19c988 = NULL;

    assertFrameObject(frame_1a8dfef65194129bda154b5d5d19c988);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_21_use_certificate);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_use_result);
    Py_DECREF(var_use_result);
    var_use_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_use_result);
    var_use_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_21_use_certificate);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_cert);
    Py_DECREF(par_cert);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_cert);
    Py_DECREF(par_cert);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_22_add_extra_chain_cert(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_certobj = python_pars[1];
    PyObject *var_copy = NULL;
    PyObject *var_add_result = NULL;
    struct Nuitka_FrameObject *frame_822962a03b3cbac836e47fa1e36419fa;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_822962a03b3cbac836e47fa1e36419fa = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_822962a03b3cbac836e47fa1e36419fa, codeobj_822962a03b3cbac836e47fa1e36419fa, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_822962a03b3cbac836e47fa1e36419fa = cache_frame_822962a03b3cbac836e47fa1e36419fa;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_822962a03b3cbac836e47fa1e36419fa);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_822962a03b3cbac836e47fa1e36419fa) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_certobj);
        tmp_isinstance_inst_1 = par_certobj;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 236 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 953;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 953;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 953;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_e51bcf1ff2d3a73499a1380c77d20ade;
            frame_822962a03b3cbac836e47fa1e36419fa->m_frame.f_lineno = 954;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 954;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 956;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_X509_dup);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 956;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_certobj);
        tmp_source_name_2 = par_certobj;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__x509);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 956;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_822962a03b3cbac836e47fa1e36419fa->m_frame.f_lineno = 956;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 956;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_copy == NULL);
        var_copy = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 957;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_3;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_SSL_CTX_add_extra_chain_cert);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 957;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_4 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain__context);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 957;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_copy);
        tmp_args_element_name_3 = var_copy;
        frame_822962a03b3cbac836e47fa1e36419fa->m_frame.f_lineno = 957;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 957;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_add_result == NULL);
        var_add_result = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_2;
        CHECK_OBJECT(var_add_result);
        tmp_operand_name_2 = var_add_result;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 958;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_4;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_4 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 960;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_1 = tmp_mvar_value_4;
            CHECK_OBJECT(var_copy);
            tmp_args_element_name_4 = var_copy;
            frame_822962a03b3cbac836e47fa1e36419fa->m_frame.f_lineno = 960;
            {
                PyObject *call_args[] = {tmp_args_element_name_4};
                tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_X509_free, call_args);
            }

            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 960;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_1);
        }
        {
            PyObject *tmp_called_name_3;
            PyObject *tmp_mvar_value_5;
            PyObject *tmp_call_result_2;
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error);

            if (unlikely(tmp_mvar_value_5 == NULL)) {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error);
            }

            if (tmp_mvar_value_5 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 0 ], 49, 0);
                exception_tb = NULL;

                exception_lineno = 961;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_3 = tmp_mvar_value_5;
            frame_822962a03b3cbac836e47fa1e36419fa->m_frame.f_lineno = 961;
            tmp_call_result_2 = CALL_FUNCTION_NO_ARGS(tmp_called_name_3);
            if (tmp_call_result_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 961;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_2);
        }
        branch_no_2:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_822962a03b3cbac836e47fa1e36419fa);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_822962a03b3cbac836e47fa1e36419fa);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_822962a03b3cbac836e47fa1e36419fa, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_822962a03b3cbac836e47fa1e36419fa->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_822962a03b3cbac836e47fa1e36419fa, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_822962a03b3cbac836e47fa1e36419fa,
        type_description_1,
        par_self,
        par_certobj,
        var_copy,
        var_add_result
    );


    // Release cached frame.
    if (frame_822962a03b3cbac836e47fa1e36419fa == cache_frame_822962a03b3cbac836e47fa1e36419fa) {
        Py_DECREF(frame_822962a03b3cbac836e47fa1e36419fa);
    }
    cache_frame_822962a03b3cbac836e47fa1e36419fa = NULL;

    assertFrameObject(frame_822962a03b3cbac836e47fa1e36419fa);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_22_add_extra_chain_cert);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_copy);
    Py_DECREF(var_copy);
    var_copy = NULL;

    CHECK_OBJECT((PyObject *)var_add_result);
    Py_DECREF(var_add_result);
    var_add_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_copy);
    var_copy = NULL;

    Py_XDECREF(var_add_result);
    var_add_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_22_add_extra_chain_cert);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_certobj);
    Py_DECREF(par_certobj);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_certobj);
    Py_DECREF(par_certobj);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_23__raise_passphrase_exception(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_ff33e982614e50cd77cbd818f47a7a68;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_ff33e982614e50cd77cbd818f47a7a68 = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_ff33e982614e50cd77cbd818f47a7a68, codeobj_ff33e982614e50cd77cbd818f47a7a68, module_OpenSSL$SSL, sizeof(void *));
    frame_ff33e982614e50cd77cbd818f47a7a68 = cache_frame_ff33e982614e50cd77cbd818f47a7a68;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_ff33e982614e50cd77cbd818f47a7a68);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_ff33e982614e50cd77cbd818f47a7a68) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__passphrase_helper);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 964;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 != tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_compexpr_left_1);
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_name_1;
            PyObject *tmp_source_name_2;
            PyObject *tmp_source_name_3;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_mvar_value_1;
            CHECK_OBJECT(par_self);
            tmp_source_name_3 = par_self;
            tmp_source_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__passphrase_helper);
            if (tmp_source_name_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 965;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_raise_if_problem);
            Py_DECREF(tmp_source_name_2);
            if (tmp_called_name_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 965;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Error);

            if (unlikely(tmp_mvar_value_1 == NULL)) {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_Error);
            }

            if (tmp_mvar_value_1 == NULL) {
                Py_DECREF(tmp_called_name_1);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 49 ], 34, 0);
                exception_tb = NULL;

                exception_lineno = 965;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }

            tmp_args_element_name_1 = tmp_mvar_value_1;
            frame_ff33e982614e50cd77cbd818f47a7a68->m_frame.f_lineno = 965;
            tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
            Py_DECREF(tmp_called_name_1);
            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 965;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_1);
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 0 ], 49, 0);
            exception_tb = NULL;

            exception_lineno = 967;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        frame_ff33e982614e50cd77cbd818f47a7a68->m_frame.f_lineno = 967;
        tmp_call_result_2 = CALL_FUNCTION_NO_ARGS(tmp_called_name_2);
        if (tmp_call_result_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 967;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_2);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ff33e982614e50cd77cbd818f47a7a68);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ff33e982614e50cd77cbd818f47a7a68);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_ff33e982614e50cd77cbd818f47a7a68, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_ff33e982614e50cd77cbd818f47a7a68->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_ff33e982614e50cd77cbd818f47a7a68, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ff33e982614e50cd77cbd818f47a7a68,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_ff33e982614e50cd77cbd818f47a7a68 == cache_frame_ff33e982614e50cd77cbd818f47a7a68) {
        Py_DECREF(frame_ff33e982614e50cd77cbd818f47a7a68);
    }
    cache_frame_ff33e982614e50cd77cbd818f47a7a68 = NULL;

    assertFrameObject(frame_ff33e982614e50cd77cbd818f47a7a68);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_23__raise_passphrase_exception);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_24_use_privatekey_file(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_keyfile = python_pars[1];
    PyObject *par_filetype = python_pars[2];
    PyObject *var_use_result = NULL;
    struct Nuitka_FrameObject *frame_c9eaa039e52a2d0cfe9a9fd0371f8a5f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_c9eaa039e52a2d0cfe9a9fd0371f8a5f = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_c9eaa039e52a2d0cfe9a9fd0371f8a5f, codeobj_c9eaa039e52a2d0cfe9a9fd0371f8a5f, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_c9eaa039e52a2d0cfe9a9fd0371f8a5f = cache_frame_c9eaa039e52a2d0cfe9a9fd0371f8a5f;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_c9eaa039e52a2d0cfe9a9fd0371f8a5f);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_c9eaa039e52a2d0cfe9a9fd0371f8a5f) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__path_string);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__path_string);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 545 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 980;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT(par_keyfile);
        tmp_args_element_name_1 = par_keyfile;
        frame_c9eaa039e52a2d0cfe9a9fd0371f8a5f->m_frame.f_lineno = 980;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 980;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = par_keyfile;
            assert(old != NULL);
            par_keyfile = tmp_assign_source_1;
            Py_DECREF(old);
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT(par_filetype);
        tmp_compexpr_left_1 = par_filetype;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__UNSPECIFIED);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__UNSPECIFIED);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 937 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 982;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_2;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_mvar_value_3;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM);
            }

            if (tmp_mvar_value_3 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 632 ], 41, 0);
                exception_tb = NULL;

                exception_lineno = 983;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_assign_source_2 = tmp_mvar_value_3;
            {
                PyObject *old = par_filetype;
                assert(old != NULL);
                par_filetype = tmp_assign_source_2;
                Py_INCREF(par_filetype);
                Py_DECREF(old);
            }

        }
        goto branch_end_1;
        branch_no_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_operand_name_1;
            PyObject *tmp_isinstance_inst_1;
            PyObject *tmp_isinstance_cls_1;
            PyObject *tmp_mvar_value_4;
            CHECK_OBJECT(par_filetype);
            tmp_isinstance_inst_1 = par_filetype;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_types);
            }

            if (tmp_mvar_value_4 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 459 ], 42, 0);
                exception_tb = NULL;

                exception_lineno = 984;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_isinstance_cls_1 = tmp_mvar_value_4;
            tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 984;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 984;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
                goto branch_yes_2;
            } else {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_raise_type_1;
                PyObject *tmp_make_exception_arg_1;
                tmp_make_exception_arg_1 = const_str_digest_7cf2d06a8643ddce5d0ceedd61c750e1;
                frame_c9eaa039e52a2d0cfe9a9fd0371f8a5f->m_frame.f_lineno = 985;
                tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
                assert(!(tmp_raise_type_1 == NULL));
                exception_type = tmp_raise_type_1;
                exception_lineno = 985;
                RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            branch_no_2:;
        }
        branch_end_1:;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 987;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_5;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_CTX_use_PrivateKey_file);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 987;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__context);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 988;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_keyfile);
        tmp_args_element_name_3 = par_keyfile;
        CHECK_OBJECT(par_filetype);
        tmp_args_element_name_4 = par_filetype;
        frame_c9eaa039e52a2d0cfe9a9fd0371f8a5f->m_frame.f_lineno = 987;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4};
            tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assign_source_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 987;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_use_result == NULL);
        var_use_result = tmp_assign_source_3;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_operand_name_2;
        CHECK_OBJECT(var_use_result);
        tmp_operand_name_2 = var_use_result;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 989;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
            goto branch_yes_3;
        } else {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_call_result_1;
            CHECK_OBJECT(par_self);
            tmp_called_instance_1 = par_self;
            frame_c9eaa039e52a2d0cfe9a9fd0371f8a5f->m_frame.f_lineno = 990;
            tmp_call_result_1 = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain__raise_passphrase_exception);
            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 990;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_1);
        }
        branch_no_3:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c9eaa039e52a2d0cfe9a9fd0371f8a5f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c9eaa039e52a2d0cfe9a9fd0371f8a5f);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_c9eaa039e52a2d0cfe9a9fd0371f8a5f, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_c9eaa039e52a2d0cfe9a9fd0371f8a5f->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_c9eaa039e52a2d0cfe9a9fd0371f8a5f, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c9eaa039e52a2d0cfe9a9fd0371f8a5f,
        type_description_1,
        par_self,
        par_keyfile,
        par_filetype,
        var_use_result
    );


    // Release cached frame.
    if (frame_c9eaa039e52a2d0cfe9a9fd0371f8a5f == cache_frame_c9eaa039e52a2d0cfe9a9fd0371f8a5f) {
        Py_DECREF(frame_c9eaa039e52a2d0cfe9a9fd0371f8a5f);
    }
    cache_frame_c9eaa039e52a2d0cfe9a9fd0371f8a5f = NULL;

    assertFrameObject(frame_c9eaa039e52a2d0cfe9a9fd0371f8a5f);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_24_use_privatekey_file);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)par_keyfile);
    Py_DECREF(par_keyfile);
    par_keyfile = NULL;

    CHECK_OBJECT((PyObject *)par_filetype);
    Py_DECREF(par_filetype);
    par_filetype = NULL;

    CHECK_OBJECT((PyObject *)var_use_result);
    Py_DECREF(var_use_result);
    var_use_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)par_keyfile);
    Py_DECREF(par_keyfile);
    par_keyfile = NULL;

    Py_XDECREF(par_filetype);
    par_filetype = NULL;

    Py_XDECREF(var_use_result);
    var_use_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_24_use_privatekey_file);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_25_use_privatekey(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_pkey = python_pars[1];
    PyObject *var_use_result = NULL;
    struct Nuitka_FrameObject *frame_5e575d8ecc92ab2025e10ae05258d327;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_5e575d8ecc92ab2025e10ae05258d327 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_5e575d8ecc92ab2025e10ae05258d327, codeobj_5e575d8ecc92ab2025e10ae05258d327, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_5e575d8ecc92ab2025e10ae05258d327 = cache_frame_5e575d8ecc92ab2025e10ae05258d327;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_5e575d8ecc92ab2025e10ae05258d327);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_5e575d8ecc92ab2025e10ae05258d327) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_pkey);
        tmp_isinstance_inst_1 = par_pkey;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_PKey);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 978 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 999;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 999;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 999;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_499043b9b2da602637f07b1aa101ddfb;
            frame_5e575d8ecc92ab2025e10ae05258d327->m_frame.f_lineno = 1000;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1000;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1002;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_CTX_use_PrivateKey);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1002;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__context);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1002;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_pkey);
        tmp_source_name_3 = par_pkey;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__pkey);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_element_name_1);

            exception_lineno = 1002;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_5e575d8ecc92ab2025e10ae05258d327->m_frame.f_lineno = 1002;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1002;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_use_result == NULL);
        var_use_result = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_2;
        CHECK_OBJECT(var_use_result);
        tmp_operand_name_2 = var_use_result;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1003;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_call_result_1;
            CHECK_OBJECT(par_self);
            tmp_called_instance_1 = par_self;
            frame_5e575d8ecc92ab2025e10ae05258d327->m_frame.f_lineno = 1004;
            tmp_call_result_1 = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain__raise_passphrase_exception);
            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1004;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_1);
        }
        branch_no_2:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5e575d8ecc92ab2025e10ae05258d327);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5e575d8ecc92ab2025e10ae05258d327);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_5e575d8ecc92ab2025e10ae05258d327, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_5e575d8ecc92ab2025e10ae05258d327->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_5e575d8ecc92ab2025e10ae05258d327, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5e575d8ecc92ab2025e10ae05258d327,
        type_description_1,
        par_self,
        par_pkey,
        var_use_result
    );


    // Release cached frame.
    if (frame_5e575d8ecc92ab2025e10ae05258d327 == cache_frame_5e575d8ecc92ab2025e10ae05258d327) {
        Py_DECREF(frame_5e575d8ecc92ab2025e10ae05258d327);
    }
    cache_frame_5e575d8ecc92ab2025e10ae05258d327 = NULL;

    assertFrameObject(frame_5e575d8ecc92ab2025e10ae05258d327);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_25_use_privatekey);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_use_result);
    Py_DECREF(var_use_result);
    var_use_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_use_result);
    var_use_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_25_use_privatekey);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_pkey);
    Py_DECREF(par_pkey);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_pkey);
    Py_DECREF(par_pkey);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_26_check_privatekey(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_c1f5ffac0bddcd92b9fd18b1877284a7;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_c1f5ffac0bddcd92b9fd18b1877284a7 = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_c1f5ffac0bddcd92b9fd18b1877284a7, codeobj_c1f5ffac0bddcd92b9fd18b1877284a7, module_OpenSSL$SSL, sizeof(void *));
    frame_c1f5ffac0bddcd92b9fd18b1877284a7 = cache_frame_c1f5ffac0bddcd92b9fd18b1877284a7;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_c1f5ffac0bddcd92b9fd18b1877284a7);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_c1f5ffac0bddcd92b9fd18b1877284a7) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1013;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_CTX_check_private_key);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1013;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__context);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1013;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_c1f5ffac0bddcd92b9fd18b1877284a7->m_frame.f_lineno = 1013;
        tmp_operand_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1013;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1013;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_name_2;
            PyObject *tmp_mvar_value_2;
            PyObject *tmp_call_result_1;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 0 ], 49, 0);
                exception_tb = NULL;

                exception_lineno = 1014;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }

            tmp_called_name_2 = tmp_mvar_value_2;
            frame_c1f5ffac0bddcd92b9fd18b1877284a7->m_frame.f_lineno = 1014;
            tmp_call_result_1 = CALL_FUNCTION_NO_ARGS(tmp_called_name_2);
            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1014;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_1);
        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c1f5ffac0bddcd92b9fd18b1877284a7);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c1f5ffac0bddcd92b9fd18b1877284a7);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_c1f5ffac0bddcd92b9fd18b1877284a7, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_c1f5ffac0bddcd92b9fd18b1877284a7->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_c1f5ffac0bddcd92b9fd18b1877284a7, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c1f5ffac0bddcd92b9fd18b1877284a7,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_c1f5ffac0bddcd92b9fd18b1877284a7 == cache_frame_c1f5ffac0bddcd92b9fd18b1877284a7) {
        Py_DECREF(frame_c1f5ffac0bddcd92b9fd18b1877284a7);
    }
    cache_frame_c1f5ffac0bddcd92b9fd18b1877284a7 = NULL;

    assertFrameObject(frame_c1f5ffac0bddcd92b9fd18b1877284a7);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_26_check_privatekey);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_27_load_client_ca(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_cafile = python_pars[1];
    PyObject *var_ca_list = NULL;
    struct Nuitka_FrameObject *frame_2d489c67d8f0900c68ccd131eb39b31e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_2d489c67d8f0900c68ccd131eb39b31e = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_2d489c67d8f0900c68ccd131eb39b31e, codeobj_2d489c67d8f0900c68ccd131eb39b31e, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_2d489c67d8f0900c68ccd131eb39b31e = cache_frame_2d489c67d8f0900c68ccd131eb39b31e;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_2d489c67d8f0900c68ccd131eb39b31e);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_2d489c67d8f0900c68ccd131eb39b31e) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1025;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_load_client_CA_file);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1025;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn);
        }

        if (tmp_mvar_value_2 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1011 ], 52, 0);
            exception_tb = NULL;

            exception_lineno = 1026;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        tmp_args_element_name_2 = const_str_plain_cafile;
        CHECK_OBJECT(par_cafile);
        tmp_args_element_name_3 = par_cafile;
        frame_2d489c67d8f0900c68ccd131eb39b31e->m_frame.f_lineno = 1026;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1026;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_2d489c67d8f0900c68ccd131eb39b31e->m_frame.f_lineno = 1025;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1025;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_ca_list == NULL);
        var_ca_list = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 1028;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_3;
        CHECK_OBJECT(var_ca_list);
        tmp_compexpr_left_1 = var_ca_list;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1028;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_4;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_NULL);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1028;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_4 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_args_element_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1028;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_2d489c67d8f0900c68ccd131eb39b31e->m_frame.f_lineno = 1028;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_3, tmp_args_element_name_4);
        Py_DECREF(tmp_args_element_name_4);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1028;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_4;
        PyObject *tmp_args_element_name_6;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1029;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_5;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_SSL_CTX_set_client_CA_list);
        if (tmp_called_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1029;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_4 = par_self;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain__context);
        if (tmp_args_element_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_4);

            exception_lineno = 1029;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_ca_list);
        tmp_args_element_name_6 = var_ca_list;
        frame_2d489c67d8f0900c68ccd131eb39b31e->m_frame.f_lineno = 1029;
        {
            PyObject *call_args[] = {tmp_args_element_name_5, tmp_args_element_name_6};
            tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_4, call_args);
        }

        Py_DECREF(tmp_called_name_4);
        Py_DECREF(tmp_args_element_name_5);
        if (tmp_call_result_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1029;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_2);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2d489c67d8f0900c68ccd131eb39b31e);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2d489c67d8f0900c68ccd131eb39b31e);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_2d489c67d8f0900c68ccd131eb39b31e, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_2d489c67d8f0900c68ccd131eb39b31e->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_2d489c67d8f0900c68ccd131eb39b31e, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2d489c67d8f0900c68ccd131eb39b31e,
        type_description_1,
        par_self,
        par_cafile,
        var_ca_list
    );


    // Release cached frame.
    if (frame_2d489c67d8f0900c68ccd131eb39b31e == cache_frame_2d489c67d8f0900c68ccd131eb39b31e) {
        Py_DECREF(frame_2d489c67d8f0900c68ccd131eb39b31e);
    }
    cache_frame_2d489c67d8f0900c68ccd131eb39b31e = NULL;

    assertFrameObject(frame_2d489c67d8f0900c68ccd131eb39b31e);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_27_load_client_ca);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_ca_list);
    Py_DECREF(var_ca_list);
    var_ca_list = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_ca_list);
    var_ca_list = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_27_load_client_ca);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_cafile);
    Py_DECREF(par_cafile);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_cafile);
    Py_DECREF(par_cafile);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_28_set_session_id(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_buf = python_pars[1];
    struct Nuitka_FrameObject *frame_bd9f3e8d092c4130e2f017c3c9cd2b5e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_bd9f3e8d092c4130e2f017c3c9cd2b5e = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_bd9f3e8d092c4130e2f017c3c9cd2b5e, codeobj_bd9f3e8d092c4130e2f017c3c9cd2b5e, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *));
    frame_bd9f3e8d092c4130e2f017c3c9cd2b5e = cache_frame_bd9f3e8d092c4130e2f017c3c9cd2b5e;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_bd9f3e8d092c4130e2f017c3c9cd2b5e);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_bd9f3e8d092c4130e2f017c3c9cd2b5e) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1011 ], 52, 0);
            exception_tb = NULL;

            exception_lineno = 1042;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        tmp_args_element_name_1 = const_str_plain_buf;
        CHECK_OBJECT(par_buf);
        tmp_args_element_name_2 = par_buf;
        frame_bd9f3e8d092c4130e2f017c3c9cd2b5e->m_frame.f_lineno = 1042;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1042;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = par_buf;
            assert(old != NULL);
            par_buf = tmp_assign_source_1;
            Py_DECREF(old);
        }

    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_len_arg_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 1043;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1044;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_3;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_CTX_set_session_id_context);
        if (tmp_called_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1044;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__context);
        if (tmp_args_element_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);

            exception_lineno = 1045;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_buf);
        tmp_args_element_name_5 = par_buf;
        CHECK_OBJECT(par_buf);
        tmp_len_arg_1 = par_buf;
        tmp_args_element_name_6 = BUILTIN_LEN(tmp_len_arg_1);
        if (tmp_args_element_name_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);
            Py_DECREF(tmp_args_element_name_4);

            exception_lineno = 1047;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_bd9f3e8d092c4130e2f017c3c9cd2b5e->m_frame.f_lineno = 1044;
        {
            PyObject *call_args[] = {tmp_args_element_name_4, tmp_args_element_name_5, tmp_args_element_name_6};
            tmp_compexpr_left_1 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_3, call_args);
        }

        Py_DECREF(tmp_called_name_3);
        Py_DECREF(tmp_args_element_name_4);
        Py_DECREF(tmp_args_element_name_6);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1044;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = const_int_pos_1;
        tmp_args_element_name_3 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1044;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_bd9f3e8d092c4130e2f017c3c9cd2b5e->m_frame.f_lineno = 1043;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_3);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1043;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_bd9f3e8d092c4130e2f017c3c9cd2b5e);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_bd9f3e8d092c4130e2f017c3c9cd2b5e);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_bd9f3e8d092c4130e2f017c3c9cd2b5e, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_bd9f3e8d092c4130e2f017c3c9cd2b5e->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_bd9f3e8d092c4130e2f017c3c9cd2b5e, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_bd9f3e8d092c4130e2f017c3c9cd2b5e,
        type_description_1,
        par_self,
        par_buf
    );


    // Release cached frame.
    if (frame_bd9f3e8d092c4130e2f017c3c9cd2b5e == cache_frame_bd9f3e8d092c4130e2f017c3c9cd2b5e) {
        Py_DECREF(frame_bd9f3e8d092c4130e2f017c3c9cd2b5e);
    }
    cache_frame_bd9f3e8d092c4130e2f017c3c9cd2b5e = NULL;

    assertFrameObject(frame_bd9f3e8d092c4130e2f017c3c9cd2b5e);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_28_set_session_id);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)par_buf);
    Py_DECREF(par_buf);
    par_buf = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)par_buf);
    Py_DECREF(par_buf);
    par_buf = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_28_set_session_id);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_29_set_session_cache_mode(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_mode = python_pars[1];
    struct Nuitka_FrameObject *frame_c427551e2adf1aa767652146eebdf018;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_c427551e2adf1aa767652146eebdf018 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_c427551e2adf1aa767652146eebdf018, codeobj_c427551e2adf1aa767652146eebdf018, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *));
    frame_c427551e2adf1aa767652146eebdf018 = cache_frame_c427551e2adf1aa767652146eebdf018;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_c427551e2adf1aa767652146eebdf018);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_c427551e2adf1aa767652146eebdf018) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_mode);
        tmp_isinstance_inst_1 = par_mode;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_types);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 459 ], 42, 0);
            exception_tb = NULL;

            exception_lineno = 1063;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1063;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1063;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_71f502d97e845c89ec13eb6ef271f294;
            frame_c427551e2adf1aa767652146eebdf018->m_frame.f_lineno = 1064;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1064;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1066;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_CTX_set_session_cache_mode);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1066;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__context);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1066;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_mode);
        tmp_args_element_name_2 = par_mode;
        frame_c427551e2adf1aa767652146eebdf018->m_frame.f_lineno = 1066;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1066;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c427551e2adf1aa767652146eebdf018);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_c427551e2adf1aa767652146eebdf018);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c427551e2adf1aa767652146eebdf018);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_c427551e2adf1aa767652146eebdf018, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_c427551e2adf1aa767652146eebdf018->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_c427551e2adf1aa767652146eebdf018, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c427551e2adf1aa767652146eebdf018,
        type_description_1,
        par_self,
        par_mode
    );


    // Release cached frame.
    if (frame_c427551e2adf1aa767652146eebdf018 == cache_frame_c427551e2adf1aa767652146eebdf018) {
        Py_DECREF(frame_c427551e2adf1aa767652146eebdf018);
    }
    cache_frame_c427551e2adf1aa767652146eebdf018 = NULL;

    assertFrameObject(frame_c427551e2adf1aa767652146eebdf018);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_29_set_session_cache_mode);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_mode);
    Py_DECREF(par_mode);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_mode);
    Py_DECREF(par_mode);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_30_get_session_cache_mode(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_5817b5e321e605b5e5aa93bf0883e885;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_5817b5e321e605b5e5aa93bf0883e885 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_5817b5e321e605b5e5aa93bf0883e885, codeobj_5817b5e321e605b5e5aa93bf0883e885, module_OpenSSL$SSL, sizeof(void *));
    frame_5817b5e321e605b5e5aa93bf0883e885 = cache_frame_5817b5e321e605b5e5aa93bf0883e885;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_5817b5e321e605b5e5aa93bf0883e885);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_5817b5e321e605b5e5aa93bf0883e885) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1076;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_CTX_get_session_cache_mode);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1076;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__context);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1076;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_5817b5e321e605b5e5aa93bf0883e885->m_frame.f_lineno = 1076;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1076;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5817b5e321e605b5e5aa93bf0883e885);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_5817b5e321e605b5e5aa93bf0883e885);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5817b5e321e605b5e5aa93bf0883e885);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_5817b5e321e605b5e5aa93bf0883e885, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_5817b5e321e605b5e5aa93bf0883e885->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_5817b5e321e605b5e5aa93bf0883e885, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5817b5e321e605b5e5aa93bf0883e885,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_5817b5e321e605b5e5aa93bf0883e885 == cache_frame_5817b5e321e605b5e5aa93bf0883e885) {
        Py_DECREF(frame_5817b5e321e605b5e5aa93bf0883e885);
    }
    cache_frame_5817b5e321e605b5e5aa93bf0883e885 = NULL;

    assertFrameObject(frame_5817b5e321e605b5e5aa93bf0883e885);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_30_get_session_cache_mode);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_31_set_verify(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_mode = python_pars[1];
    PyObject *par_callback = python_pars[2];
    struct Nuitka_FrameObject *frame_c067e3d1636e863e171637342c310c8c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_c067e3d1636e863e171637342c310c8c = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_c067e3d1636e863e171637342c310c8c, codeobj_c067e3d1636e863e171637342c310c8c, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_c067e3d1636e863e171637342c310c8c = cache_frame_c067e3d1636e863e171637342c310c8c;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_c067e3d1636e863e171637342c310c8c);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_c067e3d1636e863e171637342c310c8c) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_mode);
        tmp_isinstance_inst_1 = par_mode;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_types);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 459 ], 42, 0);
            exception_tb = NULL;

            exception_lineno = 1097;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1097;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1097;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_71f502d97e845c89ec13eb6ef271f294;
            frame_c067e3d1636e863e171637342c310c8c->m_frame.f_lineno = 1098;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1098;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_1;
        tmp_called_name_1 = LOOKUP_BUILTIN(const_str_plain_callable);
        assert(tmp_called_name_1 != NULL);
        CHECK_OBJECT(par_callback);
        tmp_args_element_name_1 = par_callback;
        frame_c067e3d1636e863e171637342c310c8c->m_frame.f_lineno = 1100;
        tmp_operand_name_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        if (tmp_operand_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1100;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_2);
        Py_DECREF(tmp_operand_name_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1100;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            tmp_make_exception_arg_2 = const_str_digest_3462bf983701fbd7caf2f521f5975fff;
            frame_c067e3d1636e863e171637342c310c8c->m_frame.f_lineno = 1101;
            tmp_raise_type_2 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_2);
            assert(!(tmp_raise_type_2 == NULL));
            exception_type = tmp_raise_type_2;
            exception_lineno = 1101;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__VerifyHelper);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__VerifyHelper);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1063 ], 42, 0);
            exception_tb = NULL;

            exception_lineno = 1103;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT(par_callback);
        tmp_args_element_name_2 = par_callback;
        frame_c067e3d1636e863e171637342c310c8c->m_frame.f_lineno = 1103;
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_2);
        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1103;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__verify_helper, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1103;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__verify_helper);
        if (tmp_source_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1104;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_assattr_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_callback);
        Py_DECREF(tmp_source_name_1);
        if (tmp_assattr_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1104;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain__verify_callback, tmp_assattr_name_2);
        Py_DECREF(tmp_assattr_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1104;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_4;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_5;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1105;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_3;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_SSL_CTX_set_verify);
        if (tmp_called_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1105;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_4 = par_self;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain__context);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);

            exception_lineno = 1105;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_mode);
        tmp_args_element_name_4 = par_mode;
        CHECK_OBJECT(par_self);
        tmp_source_name_5 = par_self;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain__verify_callback);
        if (tmp_args_element_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);
            Py_DECREF(tmp_args_element_name_3);

            exception_lineno = 1105;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_c067e3d1636e863e171637342c310c8c->m_frame.f_lineno = 1105;
        {
            PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5};
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_3, call_args);
        }

        Py_DECREF(tmp_called_name_3);
        Py_DECREF(tmp_args_element_name_3);
        Py_DECREF(tmp_args_element_name_5);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1105;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c067e3d1636e863e171637342c310c8c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c067e3d1636e863e171637342c310c8c);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_c067e3d1636e863e171637342c310c8c, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_c067e3d1636e863e171637342c310c8c->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_c067e3d1636e863e171637342c310c8c, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c067e3d1636e863e171637342c310c8c,
        type_description_1,
        par_self,
        par_mode,
        par_callback
    );


    // Release cached frame.
    if (frame_c067e3d1636e863e171637342c310c8c == cache_frame_c067e3d1636e863e171637342c310c8c) {
        Py_DECREF(frame_c067e3d1636e863e171637342c310c8c);
    }
    cache_frame_c067e3d1636e863e171637342c310c8c = NULL;

    assertFrameObject(frame_c067e3d1636e863e171637342c310c8c);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_31_set_verify);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_callback);
    Py_DECREF(par_callback);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_mode);
    Py_DECREF(par_mode);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_callback);
    Py_DECREF(par_callback);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_mode);
    Py_DECREF(par_mode);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_32_set_verify_depth(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_depth = python_pars[1];
    struct Nuitka_FrameObject *frame_df923127bdb888edf2c0aee9d730721d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_df923127bdb888edf2c0aee9d730721d = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_df923127bdb888edf2c0aee9d730721d, codeobj_df923127bdb888edf2c0aee9d730721d, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *));
    frame_df923127bdb888edf2c0aee9d730721d = cache_frame_df923127bdb888edf2c0aee9d730721d;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_df923127bdb888edf2c0aee9d730721d);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_df923127bdb888edf2c0aee9d730721d) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_depth);
        tmp_isinstance_inst_1 = par_depth;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_types);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 459 ], 42, 0);
            exception_tb = NULL;

            exception_lineno = 1115;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1115;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1115;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_d242bea258df0e7212519aa660c5f53d;
            frame_df923127bdb888edf2c0aee9d730721d->m_frame.f_lineno = 1116;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1116;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1118;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_CTX_set_verify_depth);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1118;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__context);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1118;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_depth);
        tmp_args_element_name_2 = par_depth;
        frame_df923127bdb888edf2c0aee9d730721d->m_frame.f_lineno = 1118;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1118;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_df923127bdb888edf2c0aee9d730721d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_df923127bdb888edf2c0aee9d730721d);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_df923127bdb888edf2c0aee9d730721d, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_df923127bdb888edf2c0aee9d730721d->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_df923127bdb888edf2c0aee9d730721d, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_df923127bdb888edf2c0aee9d730721d,
        type_description_1,
        par_self,
        par_depth
    );


    // Release cached frame.
    if (frame_df923127bdb888edf2c0aee9d730721d == cache_frame_df923127bdb888edf2c0aee9d730721d) {
        Py_DECREF(frame_df923127bdb888edf2c0aee9d730721d);
    }
    cache_frame_df923127bdb888edf2c0aee9d730721d = NULL;

    assertFrameObject(frame_df923127bdb888edf2c0aee9d730721d);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_32_set_verify_depth);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_depth);
    Py_DECREF(par_depth);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_depth);
    Py_DECREF(par_depth);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_33_get_verify_mode(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_a8347686a3eb5f3ebe1515762b155d4a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_a8347686a3eb5f3ebe1515762b155d4a = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_a8347686a3eb5f3ebe1515762b155d4a, codeobj_a8347686a3eb5f3ebe1515762b155d4a, module_OpenSSL$SSL, sizeof(void *));
    frame_a8347686a3eb5f3ebe1515762b155d4a = cache_frame_a8347686a3eb5f3ebe1515762b155d4a;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_a8347686a3eb5f3ebe1515762b155d4a);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_a8347686a3eb5f3ebe1515762b155d4a) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1127;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_CTX_get_verify_mode);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1127;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__context);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1127;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_a8347686a3eb5f3ebe1515762b155d4a->m_frame.f_lineno = 1127;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1127;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a8347686a3eb5f3ebe1515762b155d4a);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_a8347686a3eb5f3ebe1515762b155d4a);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a8347686a3eb5f3ebe1515762b155d4a);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_a8347686a3eb5f3ebe1515762b155d4a, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_a8347686a3eb5f3ebe1515762b155d4a->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_a8347686a3eb5f3ebe1515762b155d4a, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a8347686a3eb5f3ebe1515762b155d4a,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_a8347686a3eb5f3ebe1515762b155d4a == cache_frame_a8347686a3eb5f3ebe1515762b155d4a) {
        Py_DECREF(frame_a8347686a3eb5f3ebe1515762b155d4a);
    }
    cache_frame_a8347686a3eb5f3ebe1515762b155d4a = NULL;

    assertFrameObject(frame_a8347686a3eb5f3ebe1515762b155d4a);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_33_get_verify_mode);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_34_get_verify_depth(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_db4c7bea0bf7206725d167d502c6eba5;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_db4c7bea0bf7206725d167d502c6eba5 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_db4c7bea0bf7206725d167d502c6eba5, codeobj_db4c7bea0bf7206725d167d502c6eba5, module_OpenSSL$SSL, sizeof(void *));
    frame_db4c7bea0bf7206725d167d502c6eba5 = cache_frame_db4c7bea0bf7206725d167d502c6eba5;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_db4c7bea0bf7206725d167d502c6eba5);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_db4c7bea0bf7206725d167d502c6eba5) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1136;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_CTX_get_verify_depth);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1136;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__context);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1136;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_db4c7bea0bf7206725d167d502c6eba5->m_frame.f_lineno = 1136;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1136;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_db4c7bea0bf7206725d167d502c6eba5);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_db4c7bea0bf7206725d167d502c6eba5);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_db4c7bea0bf7206725d167d502c6eba5);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_db4c7bea0bf7206725d167d502c6eba5, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_db4c7bea0bf7206725d167d502c6eba5->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_db4c7bea0bf7206725d167d502c6eba5, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_db4c7bea0bf7206725d167d502c6eba5,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_db4c7bea0bf7206725d167d502c6eba5 == cache_frame_db4c7bea0bf7206725d167d502c6eba5) {
        Py_DECREF(frame_db4c7bea0bf7206725d167d502c6eba5);
    }
    cache_frame_db4c7bea0bf7206725d167d502c6eba5 = NULL;

    assertFrameObject(frame_db4c7bea0bf7206725d167d502c6eba5);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_34_get_verify_depth);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_35_load_tmp_dh(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_dhfile = python_pars[1];
    PyObject *var_bio = NULL;
    PyObject *var_dh = NULL;
    struct Nuitka_FrameObject *frame_30235f217fa5586477415a9239a3581a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_30235f217fa5586477415a9239a3581a = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_30235f217fa5586477415a9239a3581a, codeobj_30235f217fa5586477415a9239a3581a, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_30235f217fa5586477415a9239a3581a = cache_frame_30235f217fa5586477415a9239a3581a;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_30235f217fa5586477415a9239a3581a);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_30235f217fa5586477415a9239a3581a) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__path_string);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__path_string);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 545 ], 41, 0);
            exception_tb = NULL;

            exception_lineno = 1147;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT(par_dhfile);
        tmp_args_element_name_1 = par_dhfile;
        frame_30235f217fa5586477415a9239a3581a->m_frame.f_lineno = 1147;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1147;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = par_dhfile;
            assert(old != NULL);
            par_dhfile = tmp_assign_source_1;
            Py_DECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1149;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_2;
        CHECK_OBJECT(par_dhfile);
        tmp_args_element_name_2 = par_dhfile;
        tmp_args_element_name_3 = const_str_plain_r;
        frame_30235f217fa5586477415a9239a3581a->m_frame.f_lineno = 1149;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_assign_source_2 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain_BIO_new_file, call_args);
        }

        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1149;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_bio == NULL);
        var_bio = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_3;
        CHECK_OBJECT(var_bio);
        tmp_compexpr_left_1 = var_bio;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1150;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_3;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_NULL);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1150;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1150;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_name_2;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_call_result_1;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error);
            }

            if (tmp_mvar_value_4 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 0 ], 49, 0);
                exception_tb = NULL;

                exception_lineno = 1151;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_2 = tmp_mvar_value_4;
            frame_30235f217fa5586477415a9239a3581a->m_frame.f_lineno = 1151;
            tmp_call_result_1 = CALL_FUNCTION_NO_ARGS(tmp_called_name_2);
            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1151;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_1);
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_6;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1152;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_5;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_gc);
        if (tmp_called_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1152;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_bio);
        tmp_args_element_name_4 = var_bio;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_6 == NULL) {
            Py_DECREF(tmp_called_name_3);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1152;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_6;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_BIO_free);
        if (tmp_args_element_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);

            exception_lineno = 1152;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_30235f217fa5586477415a9239a3581a->m_frame.f_lineno = 1152;
        {
            PyObject *call_args[] = {tmp_args_element_name_4, tmp_args_element_name_5};
            tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_3, call_args);
        }

        Py_DECREF(tmp_called_name_3);
        Py_DECREF(tmp_args_element_name_5);
        if (tmp_assign_source_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1152;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var_bio;
            assert(old != NULL);
            var_bio = tmp_assign_source_3;
            Py_DECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_9;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_10;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_7 == NULL)) {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_7 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1154;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_7;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_PEM_read_bio_DHparams);
        if (tmp_called_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1154;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_bio);
        tmp_args_element_name_6 = var_bio;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_8 == NULL)) {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_8 == NULL) {
            Py_DECREF(tmp_called_name_4);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1154;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_8;
        tmp_args_element_name_7 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_NULL);
        if (tmp_args_element_name_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_4);

            exception_lineno = 1154;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_9 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_9 == NULL)) {
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_9 == NULL) {
            Py_DECREF(tmp_called_name_4);
            Py_DECREF(tmp_args_element_name_7);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1154;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_9;
        tmp_args_element_name_8 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_NULL);
        if (tmp_args_element_name_8 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_4);
            Py_DECREF(tmp_args_element_name_7);

            exception_lineno = 1154;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_10 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_10 == NULL)) {
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_10 == NULL) {
            Py_DECREF(tmp_called_name_4);
            Py_DECREF(tmp_args_element_name_7);
            Py_DECREF(tmp_args_element_name_8);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1154;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = tmp_mvar_value_10;
        tmp_args_element_name_9 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain_NULL);
        if (tmp_args_element_name_9 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_4);
            Py_DECREF(tmp_args_element_name_7);
            Py_DECREF(tmp_args_element_name_8);

            exception_lineno = 1154;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_30235f217fa5586477415a9239a3581a->m_frame.f_lineno = 1154;
        {
            PyObject *call_args[] = {tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8, tmp_args_element_name_9};
            tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS4(tmp_called_name_4, call_args);
        }

        Py_DECREF(tmp_called_name_4);
        Py_DECREF(tmp_args_element_name_7);
        Py_DECREF(tmp_args_element_name_8);
        Py_DECREF(tmp_args_element_name_9);
        if (tmp_assign_source_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1154;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_dh == NULL);
        var_dh = tmp_assign_source_4;
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_called_name_5;
        PyObject *tmp_source_name_8;
        PyObject *tmp_mvar_value_11;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_args_element_name_11;
        PyObject *tmp_source_name_9;
        PyObject *tmp_mvar_value_12;
        tmp_mvar_value_11 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_11 == NULL)) {
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_11 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1155;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_8 = tmp_mvar_value_11;
        tmp_called_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_8, const_str_plain_gc);
        if (tmp_called_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1155;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_dh);
        tmp_args_element_name_10 = var_dh;
        tmp_mvar_value_12 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_12 == NULL)) {
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_12 == NULL) {
            Py_DECREF(tmp_called_name_5);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1155;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_9 = tmp_mvar_value_12;
        tmp_args_element_name_11 = LOOKUP_ATTRIBUTE(tmp_source_name_9, const_str_plain_DH_free);
        if (tmp_args_element_name_11 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_5);

            exception_lineno = 1155;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_30235f217fa5586477415a9239a3581a->m_frame.f_lineno = 1155;
        {
            PyObject *call_args[] = {tmp_args_element_name_10, tmp_args_element_name_11};
            tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_5, call_args);
        }

        Py_DECREF(tmp_called_name_5);
        Py_DECREF(tmp_args_element_name_11);
        if (tmp_assign_source_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1155;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var_dh;
            assert(old != NULL);
            var_dh = tmp_assign_source_5;
            Py_DECREF(old);
        }

    }
    {
        PyObject *tmp_called_name_6;
        PyObject *tmp_source_name_10;
        PyObject *tmp_mvar_value_13;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_12;
        PyObject *tmp_source_name_11;
        PyObject *tmp_args_element_name_13;
        tmp_mvar_value_13 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_13 == NULL)) {
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_13 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1156;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_10 = tmp_mvar_value_13;
        tmp_called_name_6 = LOOKUP_ATTRIBUTE(tmp_source_name_10, const_str_plain_SSL_CTX_set_tmp_dh);
        if (tmp_called_name_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1156;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_11 = par_self;
        tmp_args_element_name_12 = LOOKUP_ATTRIBUTE(tmp_source_name_11, const_str_plain__context);
        if (tmp_args_element_name_12 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_6);

            exception_lineno = 1156;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_dh);
        tmp_args_element_name_13 = var_dh;
        frame_30235f217fa5586477415a9239a3581a->m_frame.f_lineno = 1156;
        {
            PyObject *call_args[] = {tmp_args_element_name_12, tmp_args_element_name_13};
            tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_6, call_args);
        }

        Py_DECREF(tmp_called_name_6);
        Py_DECREF(tmp_args_element_name_12);
        if (tmp_call_result_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1156;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_2);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_30235f217fa5586477415a9239a3581a);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_30235f217fa5586477415a9239a3581a);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_30235f217fa5586477415a9239a3581a, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_30235f217fa5586477415a9239a3581a->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_30235f217fa5586477415a9239a3581a, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_30235f217fa5586477415a9239a3581a,
        type_description_1,
        par_self,
        par_dhfile,
        var_bio,
        var_dh
    );


    // Release cached frame.
    if (frame_30235f217fa5586477415a9239a3581a == cache_frame_30235f217fa5586477415a9239a3581a) {
        Py_DECREF(frame_30235f217fa5586477415a9239a3581a);
    }
    cache_frame_30235f217fa5586477415a9239a3581a = NULL;

    assertFrameObject(frame_30235f217fa5586477415a9239a3581a);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_35_load_tmp_dh);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)par_dhfile);
    Py_DECREF(par_dhfile);
    par_dhfile = NULL;

    CHECK_OBJECT((PyObject *)var_bio);
    Py_DECREF(var_bio);
    var_bio = NULL;

    CHECK_OBJECT((PyObject *)var_dh);
    Py_DECREF(var_dh);
    var_dh = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)par_dhfile);
    Py_DECREF(par_dhfile);
    par_dhfile = NULL;

    Py_XDECREF(var_bio);
    var_bio = NULL;

    Py_XDECREF(var_dh);
    var_dh = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_35_load_tmp_dh);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_36_set_tmp_ecdh(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_curve = python_pars[1];
    struct Nuitka_FrameObject *frame_4617788626982375adc8761ce194469c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_4617788626982375adc8761ce194469c = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_4617788626982375adc8761ce194469c, codeobj_4617788626982375adc8761ce194469c, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *));
    frame_4617788626982375adc8761ce194469c = cache_frame_4617788626982375adc8761ce194469c;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_4617788626982375adc8761ce194469c);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_4617788626982375adc8761ce194469c) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_called_instance_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1168;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_CTX_set_tmp_ecdh);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1168;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__context);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1168;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_curve);
        tmp_called_instance_1 = par_curve;
        frame_4617788626982375adc8761ce194469c->m_frame.f_lineno = 1168;
        tmp_args_element_name_2 = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain__to_EC_KEY);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_element_name_1);

            exception_lineno = 1168;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_4617788626982375adc8761ce194469c->m_frame.f_lineno = 1168;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1168;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_4617788626982375adc8761ce194469c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_4617788626982375adc8761ce194469c);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_4617788626982375adc8761ce194469c, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_4617788626982375adc8761ce194469c->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_4617788626982375adc8761ce194469c, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4617788626982375adc8761ce194469c,
        type_description_1,
        par_self,
        par_curve
    );


    // Release cached frame.
    if (frame_4617788626982375adc8761ce194469c == cache_frame_4617788626982375adc8761ce194469c) {
        Py_DECREF(frame_4617788626982375adc8761ce194469c);
    }
    cache_frame_4617788626982375adc8761ce194469c = NULL;

    assertFrameObject(frame_4617788626982375adc8761ce194469c);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_36_set_tmp_ecdh);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_curve);
    Py_DECREF(par_curve);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_curve);
    Py_DECREF(par_curve);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_37_set_cipher_list(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_cipher_list = python_pars[1];
    PyObject *var_tmpconn = NULL;
    struct Nuitka_FrameObject *frame_2b3317a29293d550661be41a8c0a9de2;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_2b3317a29293d550661be41a8c0a9de2 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_2b3317a29293d550661be41a8c0a9de2, codeobj_2b3317a29293d550661be41a8c0a9de2, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_2b3317a29293d550661be41a8c0a9de2 = cache_frame_2b3317a29293d550661be41a8c0a9de2;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_2b3317a29293d550661be41a8c0a9de2);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_2b3317a29293d550661be41a8c0a9de2) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1011 ], 52, 0);
            exception_tb = NULL;

            exception_lineno = 1180;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        tmp_args_element_name_1 = const_str_plain_cipher_list;
        CHECK_OBJECT(par_cipher_list);
        tmp_args_element_name_2 = par_cipher_list;
        frame_2b3317a29293d550661be41a8c0a9de2->m_frame.f_lineno = 1180;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1180;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = par_cipher_list;
            assert(old != NULL);
            par_cipher_list = tmp_assign_source_1;
            Py_DECREF(old);
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        CHECK_OBJECT(par_cipher_list);
        tmp_isinstance_inst_1 = par_cipher_list;
        tmp_isinstance_cls_1 = (PyObject *)&PyString_Type;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1182;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1182;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_428eff9fedd3b449496fa307af56b948;
            frame_2b3317a29293d550661be41a8c0a9de2->m_frame.f_lineno = 1183;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1183;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_5;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 1185;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1186;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_3;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_CTX_set_cipher_list);
        if (tmp_called_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1186;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__context);
        if (tmp_args_element_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);

            exception_lineno = 1186;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_cipher_list);
        tmp_args_element_name_5 = par_cipher_list;
        frame_2b3317a29293d550661be41a8c0a9de2->m_frame.f_lineno = 1186;
        {
            PyObject *call_args[] = {tmp_args_element_name_4, tmp_args_element_name_5};
            tmp_compexpr_left_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_3, call_args);
        }

        Py_DECREF(tmp_called_name_3);
        Py_DECREF(tmp_args_element_name_4);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1186;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = const_int_pos_1;
        tmp_args_element_name_3 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1186;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_2b3317a29293d550661be41a8c0a9de2->m_frame.f_lineno = 1185;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_3);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1185;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_4;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_args_element_name_7;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Connection);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_Connection);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 269 ], 39, 0);
            exception_tb = NULL;

            exception_lineno = 1193;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_4 = tmp_mvar_value_4;
        CHECK_OBJECT(par_self);
        tmp_args_element_name_6 = par_self;
        tmp_args_element_name_7 = Py_None;
        frame_2b3317a29293d550661be41a8c0a9de2->m_frame.f_lineno = 1193;
        {
            PyObject *call_args[] = {tmp_args_element_name_6, tmp_args_element_name_7};
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_4, call_args);
        }

        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1193;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_tmpconn == NULL);
        var_tmpconn = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_name_5;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_called_instance_1;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 1194;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_5 = tmp_mvar_value_5;
        CHECK_OBJECT(var_tmpconn);
        tmp_called_instance_1 = var_tmpconn;
        frame_2b3317a29293d550661be41a8c0a9de2->m_frame.f_lineno = 1195;
        tmp_compexpr_left_2 = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_get_cipher_list);
        if (tmp_compexpr_left_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1195;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_2 = LIST_COPY(const_list_6fa8c3d8587ec1659fa28b2f58883e42_list);
        tmp_args_element_name_8 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
        Py_DECREF(tmp_compexpr_left_2);
        Py_DECREF(tmp_compexpr_right_2);
        if (tmp_args_element_name_8 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1195;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_2b3317a29293d550661be41a8c0a9de2->m_frame.f_lineno = 1194;
        tmp_call_result_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_5, tmp_args_element_name_8);
        Py_DECREF(tmp_args_element_name_8);
        if (tmp_call_result_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1194;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_2);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2b3317a29293d550661be41a8c0a9de2);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2b3317a29293d550661be41a8c0a9de2);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_2b3317a29293d550661be41a8c0a9de2, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_2b3317a29293d550661be41a8c0a9de2->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_2b3317a29293d550661be41a8c0a9de2, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2b3317a29293d550661be41a8c0a9de2,
        type_description_1,
        par_self,
        par_cipher_list,
        var_tmpconn
    );


    // Release cached frame.
    if (frame_2b3317a29293d550661be41a8c0a9de2 == cache_frame_2b3317a29293d550661be41a8c0a9de2) {
        Py_DECREF(frame_2b3317a29293d550661be41a8c0a9de2);
    }
    cache_frame_2b3317a29293d550661be41a8c0a9de2 = NULL;

    assertFrameObject(frame_2b3317a29293d550661be41a8c0a9de2);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_37_set_cipher_list);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)par_cipher_list);
    Py_DECREF(par_cipher_list);
    par_cipher_list = NULL;

    CHECK_OBJECT((PyObject *)var_tmpconn);
    Py_DECREF(var_tmpconn);
    var_tmpconn = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)par_cipher_list);
    Py_DECREF(par_cipher_list);
    par_cipher_list = NULL;

    Py_XDECREF(var_tmpconn);
    var_tmpconn = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_37_set_cipher_list);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_38_set_client_ca_list(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_certificate_authorities = python_pars[1];
    PyObject *var_copy = NULL;
    PyObject *var_name_stack = NULL;
    PyObject *var_ca_name = NULL;
    PyObject *var_push_result = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_08c15e906deacdd0080dc5380f603678;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_08c15e906deacdd0080dc5380f603678 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_08c15e906deacdd0080dc5380f603678, codeobj_08c15e906deacdd0080dc5380f603678, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_08c15e906deacdd0080dc5380f603678 = cache_frame_08c15e906deacdd0080dc5380f603678;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_08c15e906deacdd0080dc5380f603678);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_08c15e906deacdd0080dc5380f603678) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1215;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_08c15e906deacdd0080dc5380f603678->m_frame.f_lineno = 1215;
        tmp_assign_source_1 = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_sk_X509_NAME_new_null);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1215;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert(var_name_stack == NULL);
        var_name_stack = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 1216;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_2;
        CHECK_OBJECT(var_name_stack);
        tmp_compexpr_left_1 = var_name_stack;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1216;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_3;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_NULL);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1216;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_1 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1216;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_08c15e906deacdd0080dc5380f603678->m_frame.f_lineno = 1216;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1216;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_iter_arg_1;
        CHECK_OBJECT(par_certificate_authorities);
        tmp_iter_arg_1 = par_certificate_authorities;
        tmp_assign_source_2 = MAKE_ITERATOR(tmp_iter_arg_1);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1219;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }
        assert(tmp_for_loop_1__for_iterator == NULL);
        tmp_for_loop_1__for_iterator = tmp_assign_source_2;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_3;
        CHECK_OBJECT(tmp_for_loop_1__for_iterator);
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_3 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_3 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "oooooo";
                exception_lineno = 1219;
                goto try_except_handler_3;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_3;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_4;
        CHECK_OBJECT(tmp_for_loop_1__iter_value);
        tmp_assign_source_4 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_ca_name;
            var_ca_name = tmp_assign_source_4;
            Py_INCREF(var_ca_name);
            Py_XDECREF(old);
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_4;
        CHECK_OBJECT(var_ca_name);
        tmp_isinstance_inst_1 = var_ca_name;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509Name);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Name);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1105 ], 37, 0);
            exception_tb = NULL;

            exception_lineno = 1220;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_4;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1220;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1220;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            PyObject *tmp_tuple_element_1;
            PyObject *tmp_source_name_2;
            PyObject *tmp_type_arg_1;
            tmp_left_name_1 = const_str_digest_4387d84e76f6b2a931cf315cb767f6ce;
            CHECK_OBJECT(var_ca_name);
            tmp_type_arg_1 = var_ca_name;
            tmp_source_name_2 = BUILTIN_TYPE1(tmp_type_arg_1);
            assert(!(tmp_source_name_2 == NULL));
            tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain___name__);
            Py_DECREF(tmp_source_name_2);
            if (tmp_tuple_element_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1224;
                type_description_1 = "oooooo";
                goto try_except_handler_3;
            }
            tmp_right_name_1 = PyTuple_New(1);
            PyTuple_SET_ITEM(tmp_right_name_1, 0, tmp_tuple_element_1);
            tmp_make_exception_arg_1 = BINARY_OPERATION_MOD_STR_TUPLE(tmp_left_name_1, tmp_right_name_1);
            Py_DECREF(tmp_right_name_1);
            if (tmp_make_exception_arg_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1222;
                type_description_1 = "oooooo";
                goto try_except_handler_3;
            }
            frame_08c15e906deacdd0080dc5380f603678->m_frame.f_lineno = 1221;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            Py_DECREF(tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1221;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_4;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1227;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }

        tmp_source_name_3 = tmp_mvar_value_5;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_X509_NAME_dup);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1227;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }
        CHECK_OBJECT(var_ca_name);
        tmp_source_name_4 = var_ca_name;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain__name);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 1227;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }
        frame_08c15e906deacdd0080dc5380f603678->m_frame.f_lineno = 1227;
        tmp_assign_source_5 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_2);
        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assign_source_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1227;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }
        {
            PyObject *old = var_copy;
            var_copy = tmp_assign_source_5;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_7;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_6 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 1228;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }

        tmp_called_name_3 = tmp_mvar_value_6;
        CHECK_OBJECT(var_copy);
        tmp_compexpr_left_2 = var_copy;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_7 == NULL)) {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_7 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1228;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }

        tmp_source_name_5 = tmp_mvar_value_7;
        tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_NULL);
        if (tmp_compexpr_right_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1228;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }
        tmp_args_element_name_3 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
        Py_DECREF(tmp_compexpr_right_2);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1228;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }
        frame_08c15e906deacdd0080dc5380f603678->m_frame.f_lineno = 1228;
        tmp_call_result_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_3, tmp_args_element_name_3);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_call_result_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1228;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }
        Py_DECREF(tmp_call_result_2);
    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_8 == NULL)) {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_8 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1229;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }

        tmp_called_instance_2 = tmp_mvar_value_8;
        CHECK_OBJECT(var_name_stack);
        tmp_args_element_name_4 = var_name_stack;
        CHECK_OBJECT(var_copy);
        tmp_args_element_name_5 = var_copy;
        frame_08c15e906deacdd0080dc5380f603678->m_frame.f_lineno = 1229;
        {
            PyObject *call_args[] = {tmp_args_element_name_4, tmp_args_element_name_5};
            tmp_assign_source_6 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_2, const_str_plain_sk_X509_NAME_push, call_args);
        }

        if (tmp_assign_source_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1229;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }
        {
            PyObject *old = var_push_result;
            var_push_result = tmp_assign_source_6;
            Py_XDECREF(old);
        }

    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_2;
        CHECK_OBJECT(var_push_result);
        tmp_operand_name_2 = var_push_result;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1230;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }
        tmp_condition_result_2 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_called_instance_3;
            PyObject *tmp_mvar_value_9;
            PyObject *tmp_call_result_3;
            PyObject *tmp_args_element_name_6;
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_9 == NULL)) {
                tmp_mvar_value_9 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_9 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1231;
                type_description_1 = "oooooo";
                goto try_except_handler_3;
            }

            tmp_called_instance_3 = tmp_mvar_value_9;
            CHECK_OBJECT(var_copy);
            tmp_args_element_name_6 = var_copy;
            frame_08c15e906deacdd0080dc5380f603678->m_frame.f_lineno = 1231;
            {
                PyObject *call_args[] = {tmp_args_element_name_6};
                tmp_call_result_3 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_3, const_str_plain_X509_NAME_free, call_args);
            }

            if (tmp_call_result_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1231;
                type_description_1 = "oooooo";
                goto try_except_handler_3;
            }
            Py_DECREF(tmp_call_result_3);
        }
        {
            PyObject *tmp_called_name_4;
            PyObject *tmp_mvar_value_10;
            PyObject *tmp_call_result_4;
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error);

            if (unlikely(tmp_mvar_value_10 == NULL)) {
                tmp_mvar_value_10 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error);
            }

            if (tmp_mvar_value_10 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 0 ], 49, 0);
                exception_tb = NULL;

                exception_lineno = 1232;
                type_description_1 = "oooooo";
                goto try_except_handler_3;
            }

            tmp_called_name_4 = tmp_mvar_value_10;
            frame_08c15e906deacdd0080dc5380f603678->m_frame.f_lineno = 1232;
            tmp_call_result_4 = CALL_FUNCTION_NO_ARGS(tmp_called_name_4);
            if (tmp_call_result_4 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1232;
                type_description_1 = "oooooo";
                goto try_except_handler_3;
            }
            Py_DECREF(tmp_call_result_4);
        }
        branch_no_2:;
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


        exception_lineno = 1219;
        type_description_1 = "oooooo";
        goto try_except_handler_3;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    // End of try:
    try_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION(frame_08c15e906deacdd0080dc5380f603678);
    if (exception_keeper_tb_2 == NULL) {
        exception_keeper_tb_2 = MAKE_TRACEBACK(frame_08c15e906deacdd0080dc5380f603678, exception_keeper_lineno_2);
    } else if (exception_keeper_lineno_2 != 0) {
        exception_keeper_tb_2 = ADD_TRACEBACK(exception_keeper_tb_2, frame_08c15e906deacdd0080dc5380f603678, exception_keeper_lineno_2);
    }

    NORMALIZE_EXCEPTION(&exception_keeper_type_2, &exception_keeper_value_2, &exception_keeper_tb_2);
    PUBLISH_EXCEPTION(&exception_keeper_type_2, &exception_keeper_value_2, &exception_keeper_tb_2);
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        tmp_compexpr_left_3 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_3 = PyExc_Exception;
        tmp_res = EXCEPTION_MATCH_BOOL(tmp_compexpr_left_3, tmp_compexpr_right_3);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1233;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
            goto branch_yes_3;
        } else {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_called_instance_4;
            PyObject *tmp_mvar_value_11;
            PyObject *tmp_call_result_5;
            PyObject *tmp_args_element_name_7;
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_11 == NULL)) {
                tmp_mvar_value_11 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_11 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1234;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_4 = tmp_mvar_value_11;
            CHECK_OBJECT(var_name_stack);
            tmp_args_element_name_7 = var_name_stack;
            frame_08c15e906deacdd0080dc5380f603678->m_frame.f_lineno = 1234;
            {
                PyObject *call_args[] = {tmp_args_element_name_7};
                tmp_call_result_5 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_4, const_str_plain_sk_X509_NAME_free, call_args);
            }

            if (tmp_call_result_5 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1234;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_5);
        }
        tmp_result = RERAISE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
        if (unlikely(tmp_result == false)) {
            exception_lineno = 1235;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_08c15e906deacdd0080dc5380f603678->m_frame) frame_08c15e906deacdd0080dc5380f603678->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
        goto branch_end_3;
        branch_no_3:;
        tmp_result = RERAISE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
        if (unlikely(tmp_result == false)) {
            exception_lineno = 1218;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_08c15e906deacdd0080dc5380f603678->m_frame) frame_08c15e906deacdd0080dc5380f603678->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
        branch_end_3:;
    }
    // End of try:
    try_end_2:;
    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    {
        PyObject *tmp_called_name_5;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_12;
        PyObject *tmp_call_result_6;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_source_name_7;
        PyObject *tmp_args_element_name_9;
        tmp_mvar_value_12 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_12 == NULL)) {
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_12 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1237;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_12;
        tmp_called_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_SSL_CTX_set_client_CA_list);
        if (tmp_called_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1237;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_7 = par_self;
        tmp_args_element_name_8 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain__context);
        if (tmp_args_element_name_8 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_5);

            exception_lineno = 1237;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_name_stack);
        tmp_args_element_name_9 = var_name_stack;
        frame_08c15e906deacdd0080dc5380f603678->m_frame.f_lineno = 1237;
        {
            PyObject *call_args[] = {tmp_args_element_name_8, tmp_args_element_name_9};
            tmp_call_result_6 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_5, call_args);
        }

        Py_DECREF(tmp_called_name_5);
        Py_DECREF(tmp_args_element_name_8);
        if (tmp_call_result_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1237;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_6);
    }

#if 1
    RESTORE_FRAME_EXCEPTION(frame_08c15e906deacdd0080dc5380f603678);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION(frame_08c15e906deacdd0080dc5380f603678);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_08c15e906deacdd0080dc5380f603678, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_08c15e906deacdd0080dc5380f603678->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_08c15e906deacdd0080dc5380f603678, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_08c15e906deacdd0080dc5380f603678,
        type_description_1,
        par_self,
        par_certificate_authorities,
        var_copy,
        var_name_stack,
        var_ca_name,
        var_push_result
    );


    // Release cached frame.
    if (frame_08c15e906deacdd0080dc5380f603678 == cache_frame_08c15e906deacdd0080dc5380f603678) {
        Py_DECREF(frame_08c15e906deacdd0080dc5380f603678);
    }
    cache_frame_08c15e906deacdd0080dc5380f603678 = NULL;

    assertFrameObject(frame_08c15e906deacdd0080dc5380f603678);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_38_set_client_ca_list);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_copy);
    var_copy = NULL;

    CHECK_OBJECT((PyObject *)var_name_stack);
    Py_DECREF(var_name_stack);
    var_name_stack = NULL;

    Py_XDECREF(var_ca_name);
    var_ca_name = NULL;

    Py_XDECREF(var_push_result);
    var_push_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_copy);
    var_copy = NULL;

    Py_XDECREF(var_name_stack);
    var_name_stack = NULL;

    Py_XDECREF(var_ca_name);
    var_ca_name = NULL;

    Py_XDECREF(var_push_result);
    var_push_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_38_set_client_ca_list);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_certificate_authorities);
    Py_DECREF(par_certificate_authorities);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_certificate_authorities);
    Py_DECREF(par_certificate_authorities);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_39_add_client_ca(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_certificate_authority = python_pars[1];
    PyObject *var_add_result = NULL;
    struct Nuitka_FrameObject *frame_13d36b1bd050046a04a5eb1214a2c430;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_13d36b1bd050046a04a5eb1214a2c430 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_13d36b1bd050046a04a5eb1214a2c430, codeobj_13d36b1bd050046a04a5eb1214a2c430, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_13d36b1bd050046a04a5eb1214a2c430 = cache_frame_13d36b1bd050046a04a5eb1214a2c430;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_13d36b1bd050046a04a5eb1214a2c430);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_13d36b1bd050046a04a5eb1214a2c430) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_certificate_authority);
        tmp_isinstance_inst_1 = par_certificate_authority;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 236 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1252;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1252;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1252;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_f5111f918158679228186076f422f85e;
            frame_13d36b1bd050046a04a5eb1214a2c430->m_frame.f_lineno = 1253;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1253;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1255;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_CTX_add_client_CA);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1255;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__context);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1256;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_certificate_authority);
        tmp_source_name_3 = par_certificate_authority;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__x509);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_element_name_1);

            exception_lineno = 1256;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_13d36b1bd050046a04a5eb1214a2c430->m_frame.f_lineno = 1255;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1255;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_add_result == NULL);
        var_add_result = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 1257;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_3;
        CHECK_OBJECT(var_add_result);
        tmp_compexpr_left_1 = var_add_result;
        tmp_compexpr_right_1 = const_int_pos_1;
        tmp_args_element_name_3 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1257;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_13d36b1bd050046a04a5eb1214a2c430->m_frame.f_lineno = 1257;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_3);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1257;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_13d36b1bd050046a04a5eb1214a2c430);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_13d36b1bd050046a04a5eb1214a2c430);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_13d36b1bd050046a04a5eb1214a2c430, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_13d36b1bd050046a04a5eb1214a2c430->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_13d36b1bd050046a04a5eb1214a2c430, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_13d36b1bd050046a04a5eb1214a2c430,
        type_description_1,
        par_self,
        par_certificate_authority,
        var_add_result
    );


    // Release cached frame.
    if (frame_13d36b1bd050046a04a5eb1214a2c430 == cache_frame_13d36b1bd050046a04a5eb1214a2c430) {
        Py_DECREF(frame_13d36b1bd050046a04a5eb1214a2c430);
    }
    cache_frame_13d36b1bd050046a04a5eb1214a2c430 = NULL;

    assertFrameObject(frame_13d36b1bd050046a04a5eb1214a2c430);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_39_add_client_ca);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_add_result);
    Py_DECREF(var_add_result);
    var_add_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_add_result);
    var_add_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_39_add_client_ca);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_certificate_authority);
    Py_DECREF(par_certificate_authority);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_certificate_authority);
    Py_DECREF(par_certificate_authority);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_40_set_timeout(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_timeout = python_pars[1];
    struct Nuitka_FrameObject *frame_a709177b545996fdc26d1f69a26d148a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_a709177b545996fdc26d1f69a26d148a = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_a709177b545996fdc26d1f69a26d148a, codeobj_a709177b545996fdc26d1f69a26d148a, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *));
    frame_a709177b545996fdc26d1f69a26d148a = cache_frame_a709177b545996fdc26d1f69a26d148a;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_a709177b545996fdc26d1f69a26d148a);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_a709177b545996fdc26d1f69a26d148a) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_timeout);
        tmp_isinstance_inst_1 = par_timeout;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_types);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 459 ], 42, 0);
            exception_tb = NULL;

            exception_lineno = 1268;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1268;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1268;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_7ac3fb96e522dea60117802c4a4274df;
            frame_a709177b545996fdc26d1f69a26d148a->m_frame.f_lineno = 1269;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1269;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1271;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_CTX_set_timeout);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1271;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__context);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1271;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_timeout);
        tmp_args_element_name_2 = par_timeout;
        frame_a709177b545996fdc26d1f69a26d148a->m_frame.f_lineno = 1271;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1271;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a709177b545996fdc26d1f69a26d148a);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_a709177b545996fdc26d1f69a26d148a);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a709177b545996fdc26d1f69a26d148a);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_a709177b545996fdc26d1f69a26d148a, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_a709177b545996fdc26d1f69a26d148a->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_a709177b545996fdc26d1f69a26d148a, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a709177b545996fdc26d1f69a26d148a,
        type_description_1,
        par_self,
        par_timeout
    );


    // Release cached frame.
    if (frame_a709177b545996fdc26d1f69a26d148a == cache_frame_a709177b545996fdc26d1f69a26d148a) {
        Py_DECREF(frame_a709177b545996fdc26d1f69a26d148a);
    }
    cache_frame_a709177b545996fdc26d1f69a26d148a = NULL;

    assertFrameObject(frame_a709177b545996fdc26d1f69a26d148a);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_40_set_timeout);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_timeout);
    Py_DECREF(par_timeout);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_timeout);
    Py_DECREF(par_timeout);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_41_get_timeout(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_01a9999db18bff60965b0449882ec682;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_01a9999db18bff60965b0449882ec682 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_01a9999db18bff60965b0449882ec682, codeobj_01a9999db18bff60965b0449882ec682, module_OpenSSL$SSL, sizeof(void *));
    frame_01a9999db18bff60965b0449882ec682 = cache_frame_01a9999db18bff60965b0449882ec682;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_01a9999db18bff60965b0449882ec682);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_01a9999db18bff60965b0449882ec682) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1280;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_CTX_get_timeout);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1280;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__context);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1280;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_01a9999db18bff60965b0449882ec682->m_frame.f_lineno = 1280;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1280;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_01a9999db18bff60965b0449882ec682);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_01a9999db18bff60965b0449882ec682);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_01a9999db18bff60965b0449882ec682);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_01a9999db18bff60965b0449882ec682, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_01a9999db18bff60965b0449882ec682->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_01a9999db18bff60965b0449882ec682, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_01a9999db18bff60965b0449882ec682,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_01a9999db18bff60965b0449882ec682 == cache_frame_01a9999db18bff60965b0449882ec682) {
        Py_DECREF(frame_01a9999db18bff60965b0449882ec682);
    }
    cache_frame_01a9999db18bff60965b0449882ec682 = NULL;

    assertFrameObject(frame_01a9999db18bff60965b0449882ec682);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_41_get_timeout);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_42_set_info_callback(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_CellObject *par_callback = PyCell_NEW1(python_pars[1]);
    PyObject *var_wrapper = NULL;
    struct Nuitka_FrameObject *frame_8789032a2a2c430ee61b2a9a442b588d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_8789032a2a2c430ee61b2a9a442b588d = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_8789032a2a2c430ee61b2a9a442b588d, codeobj_8789032a2a2c430ee61b2a9a442b588d, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_8789032a2a2c430ee61b2a9a442b588d = cache_frame_8789032a2a2c430ee61b2a9a442b588d;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_8789032a2a2c430ee61b2a9a442b588d);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_8789032a2a2c430ee61b2a9a442b588d) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_wraps);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_wraps);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 136 ], 34, 0);
            exception_tb = NULL;

            exception_lineno = 1294;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_1;
        CHECK_OBJECT(PyCell_GET(par_callback));
        tmp_args_element_name_1 = PyCell_GET(par_callback);
        frame_8789032a2a2c430ee61b2a9a442b588d->m_frame.f_lineno = 1294;
        tmp_called_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_1);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1294;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_2 = MAKE_FUNCTION_OpenSSL$SSL$$$function_42_set_info_callback$$$function_1_wrapper();

        ((struct Nuitka_FunctionObject *)tmp_args_element_name_2)->m_closure[0] = par_callback;
        Py_INCREF(((struct Nuitka_FunctionObject *)tmp_args_element_name_2)->m_closure[0]);


        frame_8789032a2a2c430ee61b2a9a442b588d->m_frame.f_lineno = 1294;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_2);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1294;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }
        assert(var_wrapper == NULL);
        var_wrapper = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1297;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_2;
        tmp_args_element_name_3 = const_str_digest_215c056443df9aa1456b62fe40673d54;
        CHECK_OBJECT(var_wrapper);
        tmp_args_element_name_4 = var_wrapper;
        frame_8789032a2a2c430ee61b2a9a442b588d->m_frame.f_lineno = 1297;
        {
            PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4};
            tmp_assattr_name_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain_callback, call_args);
        }

        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1297;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__info_callback, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1297;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_source_name_3;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1299;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_3;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_CTX_set_info_callback);
        if (tmp_called_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1299;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__context);
        if (tmp_args_element_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);

            exception_lineno = 1299;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_args_element_name_6 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__info_callback);
        if (tmp_args_element_name_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);
            Py_DECREF(tmp_args_element_name_5);

            exception_lineno = 1299;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }
        frame_8789032a2a2c430ee61b2a9a442b588d->m_frame.f_lineno = 1299;
        {
            PyObject *call_args[] = {tmp_args_element_name_5, tmp_args_element_name_6};
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_3, call_args);
        }

        Py_DECREF(tmp_called_name_3);
        Py_DECREF(tmp_args_element_name_5);
        Py_DECREF(tmp_args_element_name_6);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1299;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8789032a2a2c430ee61b2a9a442b588d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8789032a2a2c430ee61b2a9a442b588d);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_8789032a2a2c430ee61b2a9a442b588d, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_8789032a2a2c430ee61b2a9a442b588d->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_8789032a2a2c430ee61b2a9a442b588d, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8789032a2a2c430ee61b2a9a442b588d,
        type_description_1,
        par_self,
        par_callback,
        var_wrapper
    );


    // Release cached frame.
    if (frame_8789032a2a2c430ee61b2a9a442b588d == cache_frame_8789032a2a2c430ee61b2a9a442b588d) {
        Py_DECREF(frame_8789032a2a2c430ee61b2a9a442b588d);
    }
    cache_frame_8789032a2a2c430ee61b2a9a442b588d = NULL;

    assertFrameObject(frame_8789032a2a2c430ee61b2a9a442b588d);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_42_set_info_callback);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_wrapper);
    Py_DECREF(var_wrapper);
    var_wrapper = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_wrapper);
    var_wrapper = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_42_set_info_callback);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_callback);
    Py_DECREF(par_callback);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_callback);
    Py_DECREF(par_callback);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_42_set_info_callback$$$function_1_wrapper(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_ssl = python_pars[0];
    PyObject *par_where = python_pars[1];
    PyObject *par_return_code = python_pars[2];
    struct Nuitka_FrameObject *frame_a732a29d3f3e6b4a55e2a24a6a2d57ce;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_a732a29d3f3e6b4a55e2a24a6a2d57ce = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_a732a29d3f3e6b4a55e2a24a6a2d57ce, codeobj_a732a29d3f3e6b4a55e2a24a6a2d57ce, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_a732a29d3f3e6b4a55e2a24a6a2d57ce = cache_frame_a732a29d3f3e6b4a55e2a24a6a2d57ce;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_a732a29d3f3e6b4a55e2a24a6a2d57ce);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_a732a29d3f3e6b4a55e2a24a6a2d57ce) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_subscript_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        if (PyCell_GET(self->m_closure[0]) == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "callback");
            exception_tb = NULL;

            exception_lineno = 1296;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = PyCell_GET(self->m_closure[0]);
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Connection);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_Connection);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 269 ], 39, 0);
            exception_tb = NULL;

            exception_lineno = 1296;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__reverse_mapping);
        if (tmp_subscribed_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1296;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_ssl);
        tmp_subscript_name_1 = par_ssl;
        tmp_args_element_name_1 = LOOKUP_SUBSCRIPT(tmp_subscribed_name_1, tmp_subscript_name_1);
        Py_DECREF(tmp_subscribed_name_1);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1296;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_where);
        tmp_args_element_name_2 = par_where;
        CHECK_OBJECT(par_return_code);
        tmp_args_element_name_3 = par_return_code;
        frame_a732a29d3f3e6b4a55e2a24a6a2d57ce->m_frame.f_lineno = 1296;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_args_element_name_1);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1296;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a732a29d3f3e6b4a55e2a24a6a2d57ce);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a732a29d3f3e6b4a55e2a24a6a2d57ce);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_a732a29d3f3e6b4a55e2a24a6a2d57ce, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_a732a29d3f3e6b4a55e2a24a6a2d57ce->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_a732a29d3f3e6b4a55e2a24a6a2d57ce, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a732a29d3f3e6b4a55e2a24a6a2d57ce,
        type_description_1,
        par_ssl,
        par_where,
        par_return_code,
        self->m_closure[0]
    );


    // Release cached frame.
    if (frame_a732a29d3f3e6b4a55e2a24a6a2d57ce == cache_frame_a732a29d3f3e6b4a55e2a24a6a2d57ce) {
        Py_DECREF(frame_a732a29d3f3e6b4a55e2a24a6a2d57ce);
    }
    cache_frame_a732a29d3f3e6b4a55e2a24a6a2d57ce = NULL;

    assertFrameObject(frame_a732a29d3f3e6b4a55e2a24a6a2d57ce);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_42_set_info_callback$$$function_1_wrapper);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_ssl);
    Py_DECREF(par_ssl);
    CHECK_OBJECT(par_where);
    Py_DECREF(par_where);
    CHECK_OBJECT(par_return_code);
    Py_DECREF(par_return_code);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_ssl);
    Py_DECREF(par_ssl);
    CHECK_OBJECT(par_where);
    Py_DECREF(par_where);
    CHECK_OBJECT(par_return_code);
    Py_DECREF(par_return_code);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_43_get_app_data(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_9d4bbd15181b53f3bd7f364d6e6e4145;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_9d4bbd15181b53f3bd7f364d6e6e4145 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_9d4bbd15181b53f3bd7f364d6e6e4145, codeobj_9d4bbd15181b53f3bd7f364d6e6e4145, module_OpenSSL$SSL, sizeof(void *));
    frame_9d4bbd15181b53f3bd7f364d6e6e4145 = cache_frame_9d4bbd15181b53f3bd7f364d6e6e4145;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_9d4bbd15181b53f3bd7f364d6e6e4145);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_9d4bbd15181b53f3bd7f364d6e6e4145) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_return_value = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__app_data);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1307;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9d4bbd15181b53f3bd7f364d6e6e4145);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_9d4bbd15181b53f3bd7f364d6e6e4145);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9d4bbd15181b53f3bd7f364d6e6e4145);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_9d4bbd15181b53f3bd7f364d6e6e4145, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_9d4bbd15181b53f3bd7f364d6e6e4145->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_9d4bbd15181b53f3bd7f364d6e6e4145, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9d4bbd15181b53f3bd7f364d6e6e4145,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_9d4bbd15181b53f3bd7f364d6e6e4145 == cache_frame_9d4bbd15181b53f3bd7f364d6e6e4145) {
        Py_DECREF(frame_9d4bbd15181b53f3bd7f364d6e6e4145);
    }
    cache_frame_9d4bbd15181b53f3bd7f364d6e6e4145 = NULL;

    assertFrameObject(frame_9d4bbd15181b53f3bd7f364d6e6e4145);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_43_get_app_data);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_44_set_app_data(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_data = python_pars[1];
    struct Nuitka_FrameObject *frame_0a6cc7d4157b03d199984fd3c032b609;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_0a6cc7d4157b03d199984fd3c032b609 = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_0a6cc7d4157b03d199984fd3c032b609, codeobj_0a6cc7d4157b03d199984fd3c032b609, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *));
    frame_0a6cc7d4157b03d199984fd3c032b609 = cache_frame_0a6cc7d4157b03d199984fd3c032b609;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_0a6cc7d4157b03d199984fd3c032b609);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_0a6cc7d4157b03d199984fd3c032b609) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_data);
        tmp_assattr_name_1 = par_data;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__app_data, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1316;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0a6cc7d4157b03d199984fd3c032b609);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0a6cc7d4157b03d199984fd3c032b609);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_0a6cc7d4157b03d199984fd3c032b609, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_0a6cc7d4157b03d199984fd3c032b609->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_0a6cc7d4157b03d199984fd3c032b609, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0a6cc7d4157b03d199984fd3c032b609,
        type_description_1,
        par_self,
        par_data
    );


    // Release cached frame.
    if (frame_0a6cc7d4157b03d199984fd3c032b609 == cache_frame_0a6cc7d4157b03d199984fd3c032b609) {
        Py_DECREF(frame_0a6cc7d4157b03d199984fd3c032b609);
    }
    cache_frame_0a6cc7d4157b03d199984fd3c032b609 = NULL;

    assertFrameObject(frame_0a6cc7d4157b03d199984fd3c032b609);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_44_set_app_data);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_data);
    Py_DECREF(par_data);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_data);
    Py_DECREF(par_data);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_45_get_cert_store(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_pystore = NULL;
    PyObject *var_store = NULL;
    struct Nuitka_FrameObject *frame_15a969cf6b2c91b8e511081a7c0a39b6;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_15a969cf6b2c91b8e511081a7c0a39b6 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_15a969cf6b2c91b8e511081a7c0a39b6, codeobj_15a969cf6b2c91b8e511081a7c0a39b6, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_15a969cf6b2c91b8e511081a7c0a39b6 = cache_frame_15a969cf6b2c91b8e511081a7c0a39b6;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_15a969cf6b2c91b8e511081a7c0a39b6);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_15a969cf6b2c91b8e511081a7c0a39b6) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1326;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_CTX_get_cert_store);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1326;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__context);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1326;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_15a969cf6b2c91b8e511081a7c0a39b6->m_frame.f_lineno = 1326;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1326;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_store == NULL);
        var_store = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT(var_store);
        tmp_compexpr_left_1 = var_store;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1327;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_NULL);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1327;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1327;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_None;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_mvar_value_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509Store);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Store);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1142 ], 38, 0);
            exception_tb = NULL;

            exception_lineno = 1331;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_3;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain___new__);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1331;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509Store);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Store);
        }

        if (tmp_mvar_value_4 == NULL) {
            Py_DECREF(tmp_called_name_2);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1142 ], 38, 0);
            exception_tb = NULL;

            exception_lineno = 1331;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_2 = tmp_mvar_value_4;
        frame_15a969cf6b2c91b8e511081a7c0a39b6->m_frame.f_lineno = 1331;
        tmp_assign_source_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_2);
        Py_DECREF(tmp_called_name_2);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1331;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_pystore == NULL);
        var_pystore = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(var_store);
        tmp_assattr_name_1 = var_store;
        CHECK_OBJECT(var_pystore);
        tmp_assattr_target_1 = var_pystore;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__store, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1332;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_15a969cf6b2c91b8e511081a7c0a39b6);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_15a969cf6b2c91b8e511081a7c0a39b6);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_15a969cf6b2c91b8e511081a7c0a39b6);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_15a969cf6b2c91b8e511081a7c0a39b6, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_15a969cf6b2c91b8e511081a7c0a39b6->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_15a969cf6b2c91b8e511081a7c0a39b6, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_15a969cf6b2c91b8e511081a7c0a39b6,
        type_description_1,
        par_self,
        var_pystore,
        var_store
    );


    // Release cached frame.
    if (frame_15a969cf6b2c91b8e511081a7c0a39b6 == cache_frame_15a969cf6b2c91b8e511081a7c0a39b6) {
        Py_DECREF(frame_15a969cf6b2c91b8e511081a7c0a39b6);
    }
    cache_frame_15a969cf6b2c91b8e511081a7c0a39b6 = NULL;

    assertFrameObject(frame_15a969cf6b2c91b8e511081a7c0a39b6);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT(var_pystore);
    tmp_return_value = var_pystore;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_45_get_cert_store);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_pystore);
    var_pystore = NULL;

    CHECK_OBJECT((PyObject *)var_store);
    Py_DECREF(var_store);
    var_store = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_pystore);
    var_pystore = NULL;

    Py_XDECREF(var_store);
    var_store = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_45_get_cert_store);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_46_set_options(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_options = python_pars[1];
    struct Nuitka_FrameObject *frame_0632cad59439bdd081092e8e08dbc92d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_0632cad59439bdd081092e8e08dbc92d = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_0632cad59439bdd081092e8e08dbc92d, codeobj_0632cad59439bdd081092e8e08dbc92d, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *));
    frame_0632cad59439bdd081092e8e08dbc92d = cache_frame_0632cad59439bdd081092e8e08dbc92d;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_0632cad59439bdd081092e8e08dbc92d);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_0632cad59439bdd081092e8e08dbc92d) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_options);
        tmp_isinstance_inst_1 = par_options;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_types);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 459 ], 42, 0);
            exception_tb = NULL;

            exception_lineno = 1343;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1343;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1343;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_a068c39f2c9878239ba2a3b47e83e1e0;
            frame_0632cad59439bdd081092e8e08dbc92d->m_frame.f_lineno = 1344;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1344;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1346;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_CTX_set_options);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1346;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__context);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1346;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_options);
        tmp_args_element_name_2 = par_options;
        frame_0632cad59439bdd081092e8e08dbc92d->m_frame.f_lineno = 1346;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1346;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0632cad59439bdd081092e8e08dbc92d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_0632cad59439bdd081092e8e08dbc92d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0632cad59439bdd081092e8e08dbc92d);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_0632cad59439bdd081092e8e08dbc92d, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_0632cad59439bdd081092e8e08dbc92d->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_0632cad59439bdd081092e8e08dbc92d, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0632cad59439bdd081092e8e08dbc92d,
        type_description_1,
        par_self,
        par_options
    );


    // Release cached frame.
    if (frame_0632cad59439bdd081092e8e08dbc92d == cache_frame_0632cad59439bdd081092e8e08dbc92d) {
        Py_DECREF(frame_0632cad59439bdd081092e8e08dbc92d);
    }
    cache_frame_0632cad59439bdd081092e8e08dbc92d = NULL;

    assertFrameObject(frame_0632cad59439bdd081092e8e08dbc92d);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_46_set_options);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_options);
    Py_DECREF(par_options);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_options);
    Py_DECREF(par_options);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_47_set_mode(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_mode = python_pars[1];
    struct Nuitka_FrameObject *frame_de42447e718b11e0e561f2def518a1f5;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_de42447e718b11e0e561f2def518a1f5 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_de42447e718b11e0e561f2def518a1f5, codeobj_de42447e718b11e0e561f2def518a1f5, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *));
    frame_de42447e718b11e0e561f2def518a1f5 = cache_frame_de42447e718b11e0e561f2def518a1f5;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_de42447e718b11e0e561f2def518a1f5);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_de42447e718b11e0e561f2def518a1f5) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_mode);
        tmp_isinstance_inst_1 = par_mode;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_types);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 459 ], 42, 0);
            exception_tb = NULL;

            exception_lineno = 1356;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1356;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1356;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_71f502d97e845c89ec13eb6ef271f294;
            frame_de42447e718b11e0e561f2def518a1f5->m_frame.f_lineno = 1357;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1357;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1359;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_CTX_set_mode);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1359;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__context);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1359;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_mode);
        tmp_args_element_name_2 = par_mode;
        frame_de42447e718b11e0e561f2def518a1f5->m_frame.f_lineno = 1359;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1359;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_de42447e718b11e0e561f2def518a1f5);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_de42447e718b11e0e561f2def518a1f5);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_de42447e718b11e0e561f2def518a1f5);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_de42447e718b11e0e561f2def518a1f5, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_de42447e718b11e0e561f2def518a1f5->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_de42447e718b11e0e561f2def518a1f5, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_de42447e718b11e0e561f2def518a1f5,
        type_description_1,
        par_self,
        par_mode
    );


    // Release cached frame.
    if (frame_de42447e718b11e0e561f2def518a1f5 == cache_frame_de42447e718b11e0e561f2def518a1f5) {
        Py_DECREF(frame_de42447e718b11e0e561f2def518a1f5);
    }
    cache_frame_de42447e718b11e0e561f2def518a1f5 = NULL;

    assertFrameObject(frame_de42447e718b11e0e561f2def518a1f5);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_47_set_mode);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_mode);
    Py_DECREF(par_mode);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_mode);
    Py_DECREF(par_mode);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_48_set_tlsext_servername_callback(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_CellObject *par_callback = PyCell_NEW1(python_pars[1]);
    PyObject *var_wrapper = NULL;
    struct Nuitka_FrameObject *frame_bfea99648ca6c20c83b6bfd2c85611c5;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_bfea99648ca6c20c83b6bfd2c85611c5 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_bfea99648ca6c20c83b6bfd2c85611c5, codeobj_bfea99648ca6c20c83b6bfd2c85611c5, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_bfea99648ca6c20c83b6bfd2c85611c5 = cache_frame_bfea99648ca6c20c83b6bfd2c85611c5;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_bfea99648ca6c20c83b6bfd2c85611c5);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_bfea99648ca6c20c83b6bfd2c85611c5) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_wraps);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_wraps);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 136 ], 34, 0);
            exception_tb = NULL;

            exception_lineno = 1372;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_1;
        CHECK_OBJECT(PyCell_GET(par_callback));
        tmp_args_element_name_1 = PyCell_GET(par_callback);
        frame_bfea99648ca6c20c83b6bfd2c85611c5->m_frame.f_lineno = 1372;
        tmp_called_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_1);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1372;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_2 = MAKE_FUNCTION_OpenSSL$SSL$$$function_48_set_tlsext_servername_callback$$$function_1_wrapper();

        ((struct Nuitka_FunctionObject *)tmp_args_element_name_2)->m_closure[0] = par_callback;
        Py_INCREF(((struct Nuitka_FunctionObject *)tmp_args_element_name_2)->m_closure[0]);


        frame_bfea99648ca6c20c83b6bfd2c85611c5->m_frame.f_lineno = 1372;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_2);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1372;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }
        assert(var_wrapper == NULL);
        var_wrapper = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1377;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_2;
        tmp_args_element_name_3 = const_str_digest_b02795b9590127f96a3b627129a2fbd2;
        CHECK_OBJECT(var_wrapper);
        tmp_args_element_name_4 = var_wrapper;
        frame_bfea99648ca6c20c83b6bfd2c85611c5->m_frame.f_lineno = 1377;
        {
            PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4};
            tmp_assattr_name_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain_callback, call_args);
        }

        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1377;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__tlsext_servername_callback, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1377;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_source_name_3;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1379;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_3;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_CTX_set_tlsext_servername_callback);
        if (tmp_called_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1379;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__context);
        if (tmp_args_element_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);

            exception_lineno = 1380;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_args_element_name_6 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__tlsext_servername_callback);
        if (tmp_args_element_name_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);
            Py_DECREF(tmp_args_element_name_5);

            exception_lineno = 1380;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }
        frame_bfea99648ca6c20c83b6bfd2c85611c5->m_frame.f_lineno = 1379;
        {
            PyObject *call_args[] = {tmp_args_element_name_5, tmp_args_element_name_6};
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_3, call_args);
        }

        Py_DECREF(tmp_called_name_3);
        Py_DECREF(tmp_args_element_name_5);
        Py_DECREF(tmp_args_element_name_6);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1379;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_bfea99648ca6c20c83b6bfd2c85611c5);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_bfea99648ca6c20c83b6bfd2c85611c5);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_bfea99648ca6c20c83b6bfd2c85611c5, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_bfea99648ca6c20c83b6bfd2c85611c5->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_bfea99648ca6c20c83b6bfd2c85611c5, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_bfea99648ca6c20c83b6bfd2c85611c5,
        type_description_1,
        par_self,
        par_callback,
        var_wrapper
    );


    // Release cached frame.
    if (frame_bfea99648ca6c20c83b6bfd2c85611c5 == cache_frame_bfea99648ca6c20c83b6bfd2c85611c5) {
        Py_DECREF(frame_bfea99648ca6c20c83b6bfd2c85611c5);
    }
    cache_frame_bfea99648ca6c20c83b6bfd2c85611c5 = NULL;

    assertFrameObject(frame_bfea99648ca6c20c83b6bfd2c85611c5);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_48_set_tlsext_servername_callback);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_wrapper);
    Py_DECREF(var_wrapper);
    var_wrapper = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_wrapper);
    var_wrapper = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_48_set_tlsext_servername_callback);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_callback);
    Py_DECREF(par_callback);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_callback);
    Py_DECREF(par_callback);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_48_set_tlsext_servername_callback$$$function_1_wrapper(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_ssl = python_pars[0];
    PyObject *par_alert = python_pars[1];
    PyObject *par_arg = python_pars[2];
    struct Nuitka_FrameObject *frame_ce0f4a68c73e09b427efa61d82289d07;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_ce0f4a68c73e09b427efa61d82289d07 = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_ce0f4a68c73e09b427efa61d82289d07, codeobj_ce0f4a68c73e09b427efa61d82289d07, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_ce0f4a68c73e09b427efa61d82289d07 = cache_frame_ce0f4a68c73e09b427efa61d82289d07;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_ce0f4a68c73e09b427efa61d82289d07);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_ce0f4a68c73e09b427efa61d82289d07) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_subscript_name_1;
        if (PyCell_GET(self->m_closure[0]) == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "callback");
            exception_tb = NULL;

            exception_lineno = 1374;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = PyCell_GET(self->m_closure[0]);
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Connection);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_Connection);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 269 ], 39, 0);
            exception_tb = NULL;

            exception_lineno = 1374;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__reverse_mapping);
        if (tmp_subscribed_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1374;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_ssl);
        tmp_subscript_name_1 = par_ssl;
        tmp_args_element_name_1 = LOOKUP_SUBSCRIPT(tmp_subscribed_name_1, tmp_subscript_name_1);
        Py_DECREF(tmp_subscribed_name_1);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1374;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }
        frame_ce0f4a68c73e09b427efa61d82289d07->m_frame.f_lineno = 1374;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1374;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ce0f4a68c73e09b427efa61d82289d07);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ce0f4a68c73e09b427efa61d82289d07);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_ce0f4a68c73e09b427efa61d82289d07, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_ce0f4a68c73e09b427efa61d82289d07->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_ce0f4a68c73e09b427efa61d82289d07, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ce0f4a68c73e09b427efa61d82289d07,
        type_description_1,
        par_ssl,
        par_alert,
        par_arg,
        self->m_closure[0]
    );


    // Release cached frame.
    if (frame_ce0f4a68c73e09b427efa61d82289d07 == cache_frame_ce0f4a68c73e09b427efa61d82289d07) {
        Py_DECREF(frame_ce0f4a68c73e09b427efa61d82289d07);
    }
    cache_frame_ce0f4a68c73e09b427efa61d82289d07 = NULL;

    assertFrameObject(frame_ce0f4a68c73e09b427efa61d82289d07);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = const_int_0;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_48_set_tlsext_servername_callback$$$function_1_wrapper);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_ssl);
    Py_DECREF(par_ssl);
    CHECK_OBJECT(par_arg);
    Py_DECREF(par_arg);
    CHECK_OBJECT(par_alert);
    Py_DECREF(par_alert);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_ssl);
    Py_DECREF(par_ssl);
    CHECK_OBJECT(par_arg);
    Py_DECREF(par_arg);
    CHECK_OBJECT(par_alert);
    Py_DECREF(par_alert);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_49_set_tlsext_use_srtp(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_profiles = python_pars[1];
    struct Nuitka_FrameObject *frame_d8df85ffb933c241e379fed2d072ff49;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_d8df85ffb933c241e379fed2d072ff49 = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_d8df85ffb933c241e379fed2d072ff49, codeobj_d8df85ffb933c241e379fed2d072ff49, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *));
    frame_d8df85ffb933c241e379fed2d072ff49 = cache_frame_d8df85ffb933c241e379fed2d072ff49;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_d8df85ffb933c241e379fed2d072ff49);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_d8df85ffb933c241e379fed2d072ff49) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        CHECK_OBJECT(par_profiles);
        tmp_isinstance_inst_1 = par_profiles;
        tmp_isinstance_cls_1 = (PyObject *)&PyString_Type;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1390;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1390;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_75d74458faf9dee1d9b7a20a034cfad7;
            frame_d8df85ffb933c241e379fed2d072ff49->m_frame.f_lineno = 1391;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1391;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 1393;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1394;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_CTX_set_tlsext_use_srtp);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1394;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__context);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 1394;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_profiles);
        tmp_args_element_name_3 = par_profiles;
        frame_d8df85ffb933c241e379fed2d072ff49->m_frame.f_lineno = 1394;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_compexpr_left_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1394;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = const_int_0;
        tmp_args_element_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1394;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_d8df85ffb933c241e379fed2d072ff49->m_frame.f_lineno = 1393;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1393;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_d8df85ffb933c241e379fed2d072ff49);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_d8df85ffb933c241e379fed2d072ff49);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_d8df85ffb933c241e379fed2d072ff49, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_d8df85ffb933c241e379fed2d072ff49->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_d8df85ffb933c241e379fed2d072ff49, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d8df85ffb933c241e379fed2d072ff49,
        type_description_1,
        par_self,
        par_profiles
    );


    // Release cached frame.
    if (frame_d8df85ffb933c241e379fed2d072ff49 == cache_frame_d8df85ffb933c241e379fed2d072ff49) {
        Py_DECREF(frame_d8df85ffb933c241e379fed2d072ff49);
    }
    cache_frame_d8df85ffb933c241e379fed2d072ff49 = NULL;

    assertFrameObject(frame_d8df85ffb933c241e379fed2d072ff49);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_49_set_tlsext_use_srtp);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_profiles);
    Py_DECREF(par_profiles);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_profiles);
    Py_DECREF(par_profiles);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_50_set_npn_advertise_callback(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_callback = python_pars[1];
    struct Nuitka_FrameObject *frame_c82e8c12b8026efc371154571f833311;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_c82e8c12b8026efc371154571f833311 = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_c82e8c12b8026efc371154571f833311, codeobj_c82e8c12b8026efc371154571f833311, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *));
    frame_c82e8c12b8026efc371154571f833311 = cache_frame_c82e8c12b8026efc371154571f833311;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_c82e8c12b8026efc371154571f833311);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_c82e8c12b8026efc371154571f833311) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__NpnAdvertiseHelper);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__NpnAdvertiseHelper);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1180 ], 48, 0);
            exception_tb = NULL;

            exception_lineno = 1411;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT(par_callback);
        tmp_args_element_name_1 = par_callback;
        frame_c82e8c12b8026efc371154571f833311->m_frame.f_lineno = 1411;
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1411;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__npn_advertise_helper, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1411;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__npn_advertise_helper);
        if (tmp_source_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1412;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_assattr_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_callback);
        Py_DECREF(tmp_source_name_1);
        if (tmp_assattr_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1412;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain__npn_advertise_callback, tmp_assattr_name_2);
        Py_DECREF(tmp_assattr_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1412;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_5;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1413;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_SSL_CTX_set_next_protos_advertised_cb);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1413;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_4 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain__context);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 1414;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_5 = par_self;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain__npn_advertise_callback);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_2);

            exception_lineno = 1414;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_3 == NULL) {
            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_2);
            Py_DECREF(tmp_args_element_name_3);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1414;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_3;
        tmp_args_element_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_NULL);
        if (tmp_args_element_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_2);
            Py_DECREF(tmp_args_element_name_3);

            exception_lineno = 1414;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_c82e8c12b8026efc371154571f833311->m_frame.f_lineno = 1413;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4};
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_2);
        Py_DECREF(tmp_args_element_name_3);
        Py_DECREF(tmp_args_element_name_4);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1413;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c82e8c12b8026efc371154571f833311);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c82e8c12b8026efc371154571f833311);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_c82e8c12b8026efc371154571f833311, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_c82e8c12b8026efc371154571f833311->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_c82e8c12b8026efc371154571f833311, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c82e8c12b8026efc371154571f833311,
        type_description_1,
        par_self,
        par_callback
    );


    // Release cached frame.
    if (frame_c82e8c12b8026efc371154571f833311 == cache_frame_c82e8c12b8026efc371154571f833311) {
        Py_DECREF(frame_c82e8c12b8026efc371154571f833311);
    }
    cache_frame_c82e8c12b8026efc371154571f833311 = NULL;

    assertFrameObject(frame_c82e8c12b8026efc371154571f833311);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_50_set_npn_advertise_callback);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_callback);
    Py_DECREF(par_callback);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_callback);
    Py_DECREF(par_callback);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_51_set_npn_select_callback(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_callback = python_pars[1];
    struct Nuitka_FrameObject *frame_7e20264abef33d5c372261962149019f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_7e20264abef33d5c372261962149019f = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_7e20264abef33d5c372261962149019f, codeobj_7e20264abef33d5c372261962149019f, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *));
    frame_7e20264abef33d5c372261962149019f = cache_frame_7e20264abef33d5c372261962149019f;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_7e20264abef33d5c372261962149019f);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_7e20264abef33d5c372261962149019f) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__NpnSelectHelper);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__NpnSelectHelper);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1228 ], 45, 0);
            exception_tb = NULL;

            exception_lineno = 1429;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT(par_callback);
        tmp_args_element_name_1 = par_callback;
        frame_7e20264abef33d5c372261962149019f->m_frame.f_lineno = 1429;
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1429;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__npn_select_helper, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1429;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__npn_select_helper);
        if (tmp_source_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1430;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_assattr_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_callback);
        Py_DECREF(tmp_source_name_1);
        if (tmp_assattr_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1430;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain__npn_select_callback, tmp_assattr_name_2);
        Py_DECREF(tmp_assattr_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1430;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_5;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1431;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_SSL_CTX_set_next_proto_select_cb);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1431;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_4 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain__context);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 1432;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_5 = par_self;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain__npn_select_callback);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_2);

            exception_lineno = 1432;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_3 == NULL) {
            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_2);
            Py_DECREF(tmp_args_element_name_3);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1432;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_3;
        tmp_args_element_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_NULL);
        if (tmp_args_element_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_2);
            Py_DECREF(tmp_args_element_name_3);

            exception_lineno = 1432;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_7e20264abef33d5c372261962149019f->m_frame.f_lineno = 1431;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4};
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_2);
        Py_DECREF(tmp_args_element_name_3);
        Py_DECREF(tmp_args_element_name_4);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1431;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_7e20264abef33d5c372261962149019f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_7e20264abef33d5c372261962149019f);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_7e20264abef33d5c372261962149019f, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_7e20264abef33d5c372261962149019f->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_7e20264abef33d5c372261962149019f, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7e20264abef33d5c372261962149019f,
        type_description_1,
        par_self,
        par_callback
    );


    // Release cached frame.
    if (frame_7e20264abef33d5c372261962149019f == cache_frame_7e20264abef33d5c372261962149019f) {
        Py_DECREF(frame_7e20264abef33d5c372261962149019f);
    }
    cache_frame_7e20264abef33d5c372261962149019f = NULL;

    assertFrameObject(frame_7e20264abef33d5c372261962149019f);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_51_set_npn_select_callback);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_callback);
    Py_DECREF(par_callback);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_callback);
    Py_DECREF(par_callback);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_52_set_alpn_protos(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_protos = python_pars[1];
    PyObject *var_protostr = NULL;
    PyObject *var_input_str = NULL;
    PyObject *tmp_genexpr_1__$0 = NULL;
    struct Nuitka_FrameObject *frame_ce17632235d529b0e086bbba8d5f4d69;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_ce17632235d529b0e086bbba8d5f4d69 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_ce17632235d529b0e086bbba8d5f4d69, codeobj_ce17632235d529b0e086bbba8d5f4d69, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_ce17632235d529b0e086bbba8d5f4d69 = cache_frame_ce17632235d529b0e086bbba8d5f4d69;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_ce17632235d529b0e086bbba8d5f4d69);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_ce17632235d529b0e086bbba8d5f4d69) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_2;
        tmp_source_name_1 = const_str_empty;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_join);
        assert(!(tmp_called_name_1 == NULL));
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_chain);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_chain);
        }

        if (tmp_mvar_value_1 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 308 ], 34, 0);
            exception_tb = NULL;

            exception_lineno = 1448;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_1;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_from_iterable);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1448;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT(par_protos);
            tmp_iter_arg_1 = par_protos;
            tmp_assign_source_2 = MAKE_ITERATOR(tmp_iter_arg_1);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1448;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            assert(tmp_genexpr_1__$0 == NULL);
            tmp_genexpr_1__$0 = tmp_assign_source_2;
        }
        // Tried code:
        tmp_args_element_name_2 = OpenSSL$SSL$$$function_52_set_alpn_protos$$$genexpr_1_genexpr_maker();

        ((struct Nuitka_GeneratorObject *)tmp_args_element_name_2)->m_closure[0] = PyCell_NEW0(tmp_genexpr_1__$0);


        goto try_return_handler_2;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_52_set_alpn_protos);
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        CHECK_OBJECT((PyObject *)tmp_genexpr_1__$0);
        Py_DECREF(tmp_genexpr_1__$0);
        tmp_genexpr_1__$0 = NULL;

        goto outline_result_1;
        // End of try:
        CHECK_OBJECT((PyObject *)tmp_genexpr_1__$0);
        Py_DECREF(tmp_genexpr_1__$0);
        tmp_genexpr_1__$0 = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_52_set_alpn_protos);
        return NULL;
        outline_result_1:;
        frame_ce17632235d529b0e086bbba8d5f4d69->m_frame.f_lineno = 1448;
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_2);
        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1448;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_ce17632235d529b0e086bbba8d5f4d69->m_frame.f_lineno = 1447;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1447;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_protostr == NULL);
        var_protostr = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1453;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_2;
        tmp_args_element_name_3 = const_str_digest_81f1b0dfcc7a862e6940580ec4cc42d3;
        CHECK_OBJECT(var_protostr);
        tmp_args_element_name_4 = var_protostr;
        frame_ce17632235d529b0e086bbba8d5f4d69->m_frame.f_lineno = 1453;
        {
            PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4};
            tmp_assign_source_3 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain_new, call_args);
        }

        if (tmp_assign_source_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1453;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_input_str == NULL);
        var_input_str = tmp_assign_source_3;
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_4;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_len_arg_1;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1454;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_3;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_SSL_CTX_set_alpn_protos);
        if (tmp_called_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1454;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_4 = par_self;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain__context);
        if (tmp_args_element_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);

            exception_lineno = 1454;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_input_str);
        tmp_args_element_name_6 = var_input_str;
        CHECK_OBJECT(var_protostr);
        tmp_len_arg_1 = var_protostr;
        tmp_args_element_name_7 = BUILTIN_LEN(tmp_len_arg_1);
        if (tmp_args_element_name_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);
            Py_DECREF(tmp_args_element_name_5);

            exception_lineno = 1454;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_ce17632235d529b0e086bbba8d5f4d69->m_frame.f_lineno = 1454;
        {
            PyObject *call_args[] = {tmp_args_element_name_5, tmp_args_element_name_6, tmp_args_element_name_7};
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_3, call_args);
        }

        Py_DECREF(tmp_called_name_3);
        Py_DECREF(tmp_args_element_name_5);
        Py_DECREF(tmp_args_element_name_7);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1454;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ce17632235d529b0e086bbba8d5f4d69);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ce17632235d529b0e086bbba8d5f4d69);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_ce17632235d529b0e086bbba8d5f4d69, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_ce17632235d529b0e086bbba8d5f4d69->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_ce17632235d529b0e086bbba8d5f4d69, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ce17632235d529b0e086bbba8d5f4d69,
        type_description_1,
        par_self,
        par_protos,
        var_protostr,
        var_input_str
    );


    // Release cached frame.
    if (frame_ce17632235d529b0e086bbba8d5f4d69 == cache_frame_ce17632235d529b0e086bbba8d5f4d69) {
        Py_DECREF(frame_ce17632235d529b0e086bbba8d5f4d69);
    }
    cache_frame_ce17632235d529b0e086bbba8d5f4d69 = NULL;

    assertFrameObject(frame_ce17632235d529b0e086bbba8d5f4d69);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_52_set_alpn_protos);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_protostr);
    Py_DECREF(var_protostr);
    var_protostr = NULL;

    CHECK_OBJECT((PyObject *)var_input_str);
    Py_DECREF(var_input_str);
    var_input_str = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_protostr);
    var_protostr = NULL;

    Py_XDECREF(var_input_str);
    var_input_str = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_52_set_alpn_protos);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_protos);
    Py_DECREF(par_protos);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_protos);
    Py_DECREF(par_protos);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}



struct OpenSSL$SSL$$$function_52_set_alpn_protos$$$genexpr_1_genexpr_locals {
    PyObject *var_p;
    PyObject *tmp_iter_value_0;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *OpenSSL$SSL$$$function_52_set_alpn_protos$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value ) {
    CHECK_OBJECT((PyObject *)generator);
    assert(Nuitka_Generator_Check( (PyObject *)generator ));

    // Heap access if used.
    struct OpenSSL$SSL$$$function_52_set_alpn_protos$$$genexpr_1_genexpr_locals *generator_heap = (struct OpenSSL$SSL$$$function_52_set_alpn_protos$$$genexpr_1_genexpr_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_p = NULL;
    generator_heap->tmp_iter_value_0 = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_m_frame, codeobj_187ce20cb779135c6ac49e57137cf08a, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *));
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF(generator->m_frame);
    assert(Py_REFCNT(generator->m_frame) == 2); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR(generator->m_frame->m_frame.f_back);

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF(generator->m_frame->m_frame.f_back);

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF(generator->m_frame);

    Nuitka_Frame_MarkAsExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

        EXC_TYPE_F(generator) = EXC_TYPE(thread_state);
        if (EXC_TYPE_F(generator) == Py_None) EXC_TYPE_F(generator) = NULL;
        Py_XINCREF(EXC_TYPE_F(generator));
        EXC_VALUE_F(generator) = EXC_VALUE(thread_state);
        Py_XINCREF(EXC_VALUE_F(generator));
        EXC_TRACEBACK_F(generator) = EXC_TRACEBACK(thread_state);
        Py_XINCREF(EXC_TRACEBACK_F(generator));
    }

#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_1;
        CHECK_OBJECT(PyCell_GET(generator->m_closure[0]));
        tmp_next_source_1 = PyCell_GET(generator->m_closure[0]);
        tmp_assign_source_1 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_1 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);
                generator_heap->type_description_1 = "No";
                generator_heap->exception_lineno = 1448;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_iter_value_0;
            generator_heap->tmp_iter_value_0 = tmp_assign_source_1;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT(generator_heap->tmp_iter_value_0);
        tmp_assign_source_2 = generator_heap->tmp_iter_value_0;
        {
            PyObject *old = generator_heap->var_p;
            generator_heap->var_p = tmp_assign_source_2;
            Py_INCREF(generator_heap->var_p);
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_expression_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_len_arg_1;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_int2byte);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_int2byte);
        }

        if (tmp_mvar_value_1 == NULL) {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF(generator_heap->exception_type);
            generator_heap->exception_value = UNSTREAM_STRING(&constant_bin[ 342 ], 37, 0);
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 1448;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT(generator_heap->var_p);
        tmp_len_arg_1 = generator_heap->var_p;
        tmp_args_element_name_1 = BUILTIN_LEN(tmp_len_arg_1);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 1448;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        generator->m_frame->m_frame.f_lineno = 1448;
        tmp_tuple_element_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 1448;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_expression_name_1 = PyTuple_New(2);
        PyTuple_SET_ITEM(tmp_expression_name_1, 0, tmp_tuple_element_1);
        CHECK_OBJECT(generator_heap->var_p);
        tmp_tuple_element_1 = generator_heap->var_p;
        Py_INCREF(tmp_tuple_element_1);
        PyTuple_SET_ITEM(tmp_expression_name_1, 1, tmp_tuple_element_1);
        Nuitka_PreserveHeap(generator_heap->yield_tmps, &tmp_tuple_element_1, sizeof(PyObject *), &tmp_called_name_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), &tmp_args_element_name_1, sizeof(PyObject *), &tmp_len_arg_1, sizeof(PyObject *), NULL);
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        Nuitka_RestoreHeap(generator_heap->yield_tmps, &tmp_tuple_element_1, sizeof(PyObject *), &tmp_called_name_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), &tmp_args_element_name_1, sizeof(PyObject *), &tmp_len_arg_1, sizeof(PyObject *), NULL);
        if (yield_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 1448;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


        generator_heap->exception_lineno = 1448;
        generator_heap->type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    // Allow re-use of the frame again.
    Py_DECREF(generator->m_frame);
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if (!EXCEPTION_MATCH_GENERATOR(generator_heap->exception_type)) {
        if (generator_heap->exception_tb == NULL) {
            generator_heap->exception_tb = MAKE_TRACEBACK(generator->m_frame, generator_heap->exception_lineno);
        } else if (generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame) {
            generator_heap->exception_tb = ADD_TRACEBACK(generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno);
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            NULL,
            generator_heap->var_p
        );


        // Release cached frame.
        if (generator->m_frame == cache_m_frame) {
            Py_DECREF(generator->m_frame);
        }
        cache_m_frame = NULL;

        assertFrameObject(generator->m_frame);
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    Py_DECREF(generator->m_frame);

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->var_p);
    generator_heap->var_p = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    Py_XDECREF(generator_heap->var_p);
    generator_heap->var_p = NULL;



    return NULL;

    function_exception_exit:
    assert(generator_heap->exception_type);
    RESTORE_ERROR_OCCURRED(generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb);

    return NULL;

}

static PyObject *OpenSSL$SSL$$$function_52_set_alpn_protos$$$genexpr_1_genexpr_maker(void) {
    return Nuitka_Generator_New(
        OpenSSL$SSL$$$function_52_set_alpn_protos$$$genexpr_1_genexpr_context,
        module_OpenSSL$SSL,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_187ce20cb779135c6ac49e57137cf08a,
        1,
        sizeof(struct OpenSSL$SSL$$$function_52_set_alpn_protos$$$genexpr_1_genexpr_locals)
    );
}


static PyObject *impl_OpenSSL$SSL$$$function_53_set_alpn_select_callback(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_callback = python_pars[1];
    struct Nuitka_FrameObject *frame_42236c687cf1136b7c7bf18f19fec11f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_42236c687cf1136b7c7bf18f19fec11f = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_42236c687cf1136b7c7bf18f19fec11f, codeobj_42236c687cf1136b7c7bf18f19fec11f, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *));
    frame_42236c687cf1136b7c7bf18f19fec11f = cache_frame_42236c687cf1136b7c7bf18f19fec11f;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_42236c687cf1136b7c7bf18f19fec11f);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_42236c687cf1136b7c7bf18f19fec11f) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ALPNSelectHelper);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ALPNSelectHelper);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1273 ], 46, 0);
            exception_tb = NULL;

            exception_lineno = 1467;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT(par_callback);
        tmp_args_element_name_1 = par_callback;
        frame_42236c687cf1136b7c7bf18f19fec11f->m_frame.f_lineno = 1467;
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1467;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__alpn_select_helper, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1467;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__alpn_select_helper);
        if (tmp_source_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1468;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_assattr_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_callback);
        Py_DECREF(tmp_source_name_1);
        if (tmp_assattr_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1468;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain__alpn_select_callback, tmp_assattr_name_2);
        Py_DECREF(tmp_assattr_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1468;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_5;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1469;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_SSL_CTX_set_alpn_select_cb);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1469;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_4 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain__context);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 1470;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_5 = par_self;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain__alpn_select_callback);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_2);

            exception_lineno = 1470;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_3 == NULL) {
            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_2);
            Py_DECREF(tmp_args_element_name_3);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1470;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_3;
        tmp_args_element_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_NULL);
        if (tmp_args_element_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_2);
            Py_DECREF(tmp_args_element_name_3);

            exception_lineno = 1470;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_42236c687cf1136b7c7bf18f19fec11f->m_frame.f_lineno = 1469;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4};
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_2);
        Py_DECREF(tmp_args_element_name_3);
        Py_DECREF(tmp_args_element_name_4);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1469;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_42236c687cf1136b7c7bf18f19fec11f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_42236c687cf1136b7c7bf18f19fec11f);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_42236c687cf1136b7c7bf18f19fec11f, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_42236c687cf1136b7c7bf18f19fec11f->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_42236c687cf1136b7c7bf18f19fec11f, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_42236c687cf1136b7c7bf18f19fec11f,
        type_description_1,
        par_self,
        par_callback
    );


    // Release cached frame.
    if (frame_42236c687cf1136b7c7bf18f19fec11f == cache_frame_42236c687cf1136b7c7bf18f19fec11f) {
        Py_DECREF(frame_42236c687cf1136b7c7bf18f19fec11f);
    }
    cache_frame_42236c687cf1136b7c7bf18f19fec11f = NULL;

    assertFrameObject(frame_42236c687cf1136b7c7bf18f19fec11f);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_53_set_alpn_select_callback);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_callback);
    Py_DECREF(par_callback);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_callback);
    Py_DECREF(par_callback);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_54__set_ocsp_callback(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_helper = python_pars[1];
    PyObject *par_data = python_pars[2];
    PyObject *var_rc = NULL;
    struct Nuitka_FrameObject *frame_638f4df5700a78f0b7a07a86c27fb3a2;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_638f4df5700a78f0b7a07a86c27fb3a2 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_638f4df5700a78f0b7a07a86c27fb3a2, codeobj_638f4df5700a78f0b7a07a86c27fb3a2, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_638f4df5700a78f0b7a07a86c27fb3a2 = cache_frame_638f4df5700a78f0b7a07a86c27fb3a2;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_638f4df5700a78f0b7a07a86c27fb3a2);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_638f4df5700a78f0b7a07a86c27fb3a2) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_helper);
        tmp_assattr_name_1 = par_helper;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__ocsp_helper, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1478;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT(par_helper);
        tmp_source_name_1 = par_helper;
        tmp_assattr_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_callback);
        if (tmp_assattr_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1479;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain__ocsp_callback, tmp_assattr_name_2);
        Py_DECREF(tmp_assattr_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1479;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_data);
        tmp_compexpr_left_1 = par_data;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assattr_name_3;
            PyObject *tmp_source_name_2;
            PyObject *tmp_mvar_value_1;
            PyObject *tmp_assattr_target_3;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_1 == NULL)) {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_1 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1481;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_2 = tmp_mvar_value_1;
            tmp_assattr_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_NULL);
            if (tmp_assattr_name_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1481;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(par_self);
            tmp_assattr_target_3 = par_self;
            tmp_result = SET_ATTRIBUTE(tmp_assattr_target_3, const_str_plain__ocsp_data, tmp_assattr_name_3);
            Py_DECREF(tmp_assattr_name_3);
            if (tmp_result == false) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1481;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assattr_name_4;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_mvar_value_2;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_assattr_target_4;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1483;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_1 = tmp_mvar_value_2;
            CHECK_OBJECT(par_data);
            tmp_args_element_name_1 = par_data;
            frame_638f4df5700a78f0b7a07a86c27fb3a2->m_frame.f_lineno = 1483;
            {
                PyObject *call_args[] = {tmp_args_element_name_1};
                tmp_assattr_name_4 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_new_handle, call_args);
            }

            if (tmp_assattr_name_4 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1483;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(par_self);
            tmp_assattr_target_4 = par_self;
            tmp_result = SET_ATTRIBUTE(tmp_assattr_target_4, const_str_plain__ocsp_data, tmp_assattr_name_4);
            Py_DECREF(tmp_assattr_name_4);
            if (tmp_result == false) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1483;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
        }
        branch_end_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_5;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1485;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_3;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_SSL_CTX_set_tlsext_status_cb);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1485;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_4 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain__context);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1486;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_5 = par_self;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain__ocsp_callback);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_element_name_2);

            exception_lineno = 1486;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_638f4df5700a78f0b7a07a86c27fb3a2->m_frame.f_lineno = 1485;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_2);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1485;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_rc == NULL);
        var_rc = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 1488;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_4;
        CHECK_OBJECT(var_rc);
        tmp_compexpr_left_2 = var_rc;
        tmp_compexpr_right_2 = const_int_pos_1;
        tmp_args_element_name_4 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
        if (tmp_args_element_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1488;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_638f4df5700a78f0b7a07a86c27fb3a2->m_frame.f_lineno = 1488;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_4);
        Py_DECREF(tmp_args_element_name_4);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1488;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_7;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_source_name_8;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1489;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_5;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_SSL_CTX_set_tlsext_status_arg);
        if (tmp_called_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1489;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_7 = par_self;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain__context);
        if (tmp_args_element_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);

            exception_lineno = 1489;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_8 = par_self;
        tmp_args_element_name_6 = LOOKUP_ATTRIBUTE(tmp_source_name_8, const_str_plain__ocsp_data);
        if (tmp_args_element_name_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);
            Py_DECREF(tmp_args_element_name_5);

            exception_lineno = 1489;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_638f4df5700a78f0b7a07a86c27fb3a2->m_frame.f_lineno = 1489;
        {
            PyObject *call_args[] = {tmp_args_element_name_5, tmp_args_element_name_6};
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_3, call_args);
        }

        Py_DECREF(tmp_called_name_3);
        Py_DECREF(tmp_args_element_name_5);
        Py_DECREF(tmp_args_element_name_6);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1489;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var_rc;
            assert(old != NULL);
            var_rc = tmp_assign_source_2;
            Py_DECREF(old);
        }

    }
    {
        PyObject *tmp_called_name_4;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_6 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 1490;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_4 = tmp_mvar_value_6;
        CHECK_OBJECT(var_rc);
        tmp_compexpr_left_3 = var_rc;
        tmp_compexpr_right_3 = const_int_pos_1;
        tmp_args_element_name_7 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_3, tmp_compexpr_right_3);
        if (tmp_args_element_name_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1490;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_638f4df5700a78f0b7a07a86c27fb3a2->m_frame.f_lineno = 1490;
        tmp_call_result_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_4, tmp_args_element_name_7);
        Py_DECREF(tmp_args_element_name_7);
        if (tmp_call_result_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1490;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_2);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_638f4df5700a78f0b7a07a86c27fb3a2);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_638f4df5700a78f0b7a07a86c27fb3a2);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_638f4df5700a78f0b7a07a86c27fb3a2, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_638f4df5700a78f0b7a07a86c27fb3a2->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_638f4df5700a78f0b7a07a86c27fb3a2, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_638f4df5700a78f0b7a07a86c27fb3a2,
        type_description_1,
        par_self,
        par_helper,
        par_data,
        var_rc
    );


    // Release cached frame.
    if (frame_638f4df5700a78f0b7a07a86c27fb3a2 == cache_frame_638f4df5700a78f0b7a07a86c27fb3a2) {
        Py_DECREF(frame_638f4df5700a78f0b7a07a86c27fb3a2);
    }
    cache_frame_638f4df5700a78f0b7a07a86c27fb3a2 = NULL;

    assertFrameObject(frame_638f4df5700a78f0b7a07a86c27fb3a2);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_54__set_ocsp_callback);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_rc);
    Py_DECREF(var_rc);
    var_rc = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_rc);
    var_rc = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_54__set_ocsp_callback);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_data);
    Py_DECREF(par_data);
    CHECK_OBJECT(par_helper);
    Py_DECREF(par_helper);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_data);
    Py_DECREF(par_data);
    CHECK_OBJECT(par_helper);
    Py_DECREF(par_helper);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_55_set_ocsp_server_callback(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_callback = python_pars[1];
    PyObject *par_data = python_pars[2];
    PyObject *var_helper = NULL;
    struct Nuitka_FrameObject *frame_03577ba5881bc60859c4e27b32960700;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_03577ba5881bc60859c4e27b32960700 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_03577ba5881bc60859c4e27b32960700, codeobj_03577ba5881bc60859c4e27b32960700, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_03577ba5881bc60859c4e27b32960700 = cache_frame_03577ba5881bc60859c4e27b32960700;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_03577ba5881bc60859c4e27b32960700);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_03577ba5881bc60859c4e27b32960700) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__OCSPServerCallbackHelper);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__OCSPServerCallbackHelper);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1319 ], 54, 0);
            exception_tb = NULL;

            exception_lineno = 1507;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT(par_callback);
        tmp_args_element_name_1 = par_callback;
        frame_03577ba5881bc60859c4e27b32960700->m_frame.f_lineno = 1507;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1507;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_helper == NULL);
        var_helper = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        CHECK_OBJECT(var_helper);
        tmp_args_element_name_2 = var_helper;
        CHECK_OBJECT(par_data);
        tmp_args_element_name_3 = par_data;
        frame_03577ba5881bc60859c4e27b32960700->m_frame.f_lineno = 1508;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain__set_ocsp_callback, call_args);
        }

        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1508;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_03577ba5881bc60859c4e27b32960700);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_03577ba5881bc60859c4e27b32960700);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_03577ba5881bc60859c4e27b32960700, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_03577ba5881bc60859c4e27b32960700->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_03577ba5881bc60859c4e27b32960700, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_03577ba5881bc60859c4e27b32960700,
        type_description_1,
        par_self,
        par_callback,
        par_data,
        var_helper
    );


    // Release cached frame.
    if (frame_03577ba5881bc60859c4e27b32960700 == cache_frame_03577ba5881bc60859c4e27b32960700) {
        Py_DECREF(frame_03577ba5881bc60859c4e27b32960700);
    }
    cache_frame_03577ba5881bc60859c4e27b32960700 = NULL;

    assertFrameObject(frame_03577ba5881bc60859c4e27b32960700);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_55_set_ocsp_server_callback);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_helper);
    Py_DECREF(var_helper);
    var_helper = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_helper);
    var_helper = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_55_set_ocsp_server_callback);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_callback);
    Py_DECREF(par_callback);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_data);
    Py_DECREF(par_data);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_callback);
    Py_DECREF(par_callback);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_data);
    Py_DECREF(par_data);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_56_set_ocsp_client_callback(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_callback = python_pars[1];
    PyObject *par_data = python_pars[2];
    PyObject *var_helper = NULL;
    struct Nuitka_FrameObject *frame_d67706623e0b60e72dc27ab285eeed79;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_d67706623e0b60e72dc27ab285eeed79 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_d67706623e0b60e72dc27ab285eeed79, codeobj_d67706623e0b60e72dc27ab285eeed79, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_d67706623e0b60e72dc27ab285eeed79 = cache_frame_d67706623e0b60e72dc27ab285eeed79;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_d67706623e0b60e72dc27ab285eeed79);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_d67706623e0b60e72dc27ab285eeed79) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__OCSPClientCallbackHelper);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__OCSPClientCallbackHelper);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1373 ], 54, 0);
            exception_tb = NULL;

            exception_lineno = 1527;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT(par_callback);
        tmp_args_element_name_1 = par_callback;
        frame_d67706623e0b60e72dc27ab285eeed79->m_frame.f_lineno = 1527;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1527;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_helper == NULL);
        var_helper = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        CHECK_OBJECT(var_helper);
        tmp_args_element_name_2 = var_helper;
        CHECK_OBJECT(par_data);
        tmp_args_element_name_3 = par_data;
        frame_d67706623e0b60e72dc27ab285eeed79->m_frame.f_lineno = 1528;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain__set_ocsp_callback, call_args);
        }

        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1528;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_d67706623e0b60e72dc27ab285eeed79);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_d67706623e0b60e72dc27ab285eeed79);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_d67706623e0b60e72dc27ab285eeed79, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_d67706623e0b60e72dc27ab285eeed79->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_d67706623e0b60e72dc27ab285eeed79, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d67706623e0b60e72dc27ab285eeed79,
        type_description_1,
        par_self,
        par_callback,
        par_data,
        var_helper
    );


    // Release cached frame.
    if (frame_d67706623e0b60e72dc27ab285eeed79 == cache_frame_d67706623e0b60e72dc27ab285eeed79) {
        Py_DECREF(frame_d67706623e0b60e72dc27ab285eeed79);
    }
    cache_frame_d67706623e0b60e72dc27ab285eeed79 = NULL;

    assertFrameObject(frame_d67706623e0b60e72dc27ab285eeed79);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_56_set_ocsp_client_callback);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_helper);
    Py_DECREF(var_helper);
    var_helper = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_helper);
    var_helper = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_56_set_ocsp_client_callback);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_callback);
    Py_DECREF(par_callback);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_data);
    Py_DECREF(par_data);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_callback);
    Py_DECREF(par_callback);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_data);
    Py_DECREF(par_data);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_57___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_context = python_pars[1];
    PyObject *par_socket = python_pars[2];
    PyObject *var_ssl = NULL;
    PyObject *var_set_result = NULL;
    struct Nuitka_FrameObject *frame_c93d963cdd7d7cda8b597989582cd847;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_c93d963cdd7d7cda8b597989582cd847 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_c93d963cdd7d7cda8b597989582cd847, codeobj_c93d963cdd7d7cda8b597989582cd847, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_c93d963cdd7d7cda8b597989582cd847 = cache_frame_c93d963cdd7d7cda8b597989582cd847;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_c93d963cdd7d7cda8b597989582cd847);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_c93d963cdd7d7cda8b597989582cd847) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_context);
        tmp_isinstance_inst_1 = par_context;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Context);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_Context);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1427 ], 36, 0);
            exception_tb = NULL;

            exception_lineno = 1550;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1550;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1550;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_627e1a07a1a60af86ff9e544428f2f09;
            frame_c93d963cdd7d7cda8b597989582cd847->m_frame.f_lineno = 1551;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1551;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1553;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_new);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1553;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_context);
        tmp_source_name_2 = par_context;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__context);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1553;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_c93d963cdd7d7cda8b597989582cd847->m_frame.f_lineno = 1553;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1553;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(var_ssl == NULL);
        var_ssl = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1554;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_3;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_gc);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1554;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_ssl);
        tmp_args_element_name_2 = var_ssl;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_4 == NULL) {
            Py_DECREF(tmp_called_name_2);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1554;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_4;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_SSL_free);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 1554;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_c93d963cdd7d7cda8b597989582cd847->m_frame.f_lineno = 1554;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1554;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__ssl, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1554;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_source_name_6;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_6;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1559;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_5;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_SSL_set_mode);
        if (tmp_called_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1559;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_6 = par_self;
        tmp_args_element_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain__ssl);
        if (tmp_args_element_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);

            exception_lineno = 1559;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_6 == NULL) {
            Py_DECREF(tmp_called_name_3);
            Py_DECREF(tmp_args_element_name_4);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1559;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = tmp_mvar_value_6;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain_SSL_MODE_AUTO_RETRY);
        if (tmp_args_element_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);
            Py_DECREF(tmp_args_element_name_4);

            exception_lineno = 1559;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_c93d963cdd7d7cda8b597989582cd847->m_frame.f_lineno = 1559;
        {
            PyObject *call_args[] = {tmp_args_element_name_4, tmp_args_element_name_5};
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_3, call_args);
        }

        Py_DECREF(tmp_called_name_3);
        Py_DECREF(tmp_args_element_name_4);
        Py_DECREF(tmp_args_element_name_5);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1559;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT(par_context);
        tmp_assattr_name_2 = par_context;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain__context, tmp_assattr_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1560;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_assattr_target_3;
        tmp_assattr_name_3 = Py_None;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_3 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_3, const_str_plain__app_data, tmp_assattr_name_3);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1561;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_4;
        PyObject *tmp_assattr_target_4;
        tmp_assattr_name_4 = Py_None;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_4 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_4, const_str_plain__npn_advertise_callback_args, tmp_assattr_name_4);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1567;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_5;
        PyObject *tmp_assattr_target_5;
        tmp_assattr_name_5 = Py_None;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_5 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_5, const_str_plain__npn_select_callback_args, tmp_assattr_name_5);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1568;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_6;
        PyObject *tmp_assattr_target_6;
        tmp_assattr_name_6 = Py_None;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_6 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_6, const_str_plain__alpn_select_callback_args, tmp_assattr_name_6);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1574;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_ass_subvalue_1;
        PyObject *tmp_ass_subscribed_1;
        PyObject *tmp_source_name_8;
        PyObject *tmp_ass_subscript_1;
        PyObject *tmp_source_name_9;
        CHECK_OBJECT(par_self);
        tmp_ass_subvalue_1 = par_self;
        CHECK_OBJECT(par_self);
        tmp_source_name_8 = par_self;
        tmp_ass_subscribed_1 = LOOKUP_ATTRIBUTE(tmp_source_name_8, const_str_plain__reverse_mapping);
        if (tmp_ass_subscribed_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1576;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_9 = par_self;
        tmp_ass_subscript_1 = LOOKUP_ATTRIBUTE(tmp_source_name_9, const_str_plain__ssl);
        if (tmp_ass_subscript_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_ass_subscribed_1);

            exception_lineno = 1576;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_result = SET_SUBSCRIPT(tmp_ass_subscribed_1, tmp_ass_subscript_1, tmp_ass_subvalue_1);
        Py_DECREF(tmp_ass_subscribed_1);
        Py_DECREF(tmp_ass_subscript_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1576;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_socket);
        tmp_compexpr_left_1 = par_socket;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_2 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assattr_name_7;
            PyObject *tmp_assattr_target_7;
            tmp_assattr_name_7 = Py_None;
            CHECK_OBJECT(par_self);
            tmp_assattr_target_7 = par_self;
            tmp_result = SET_ATTRIBUTE(tmp_assattr_target_7, const_str_plain__socket, tmp_assattr_name_7);
            if (tmp_result == false) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1579;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
        }
        {
            PyObject *tmp_assattr_name_8;
            PyObject *tmp_called_name_4;
            PyObject *tmp_source_name_10;
            PyObject *tmp_mvar_value_7;
            PyObject *tmp_args_element_name_6;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_mvar_value_8;
            PyObject *tmp_assattr_target_8;
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_7 == NULL)) {
                tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_7 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1581;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_10 = tmp_mvar_value_7;
            tmp_called_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_10, const_str_plain_BIO_new);
            if (tmp_called_name_4 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1581;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_8 == NULL)) {
                tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_8 == NULL) {
                Py_DECREF(tmp_called_name_4);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1581;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_1 = tmp_mvar_value_8;
            frame_c93d963cdd7d7cda8b597989582cd847->m_frame.f_lineno = 1581;
            tmp_args_element_name_6 = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_BIO_s_mem);
            if (tmp_args_element_name_6 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_4);

                exception_lineno = 1581;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            frame_c93d963cdd7d7cda8b597989582cd847->m_frame.f_lineno = 1581;
            tmp_assattr_name_8 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_4, tmp_args_element_name_6);
            Py_DECREF(tmp_called_name_4);
            Py_DECREF(tmp_args_element_name_6);
            if (tmp_assattr_name_8 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1581;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(par_self);
            tmp_assattr_target_8 = par_self;
            tmp_result = SET_ATTRIBUTE(tmp_assattr_target_8, const_str_plain__into_ssl, tmp_assattr_name_8);
            Py_DECREF(tmp_assattr_name_8);
            if (tmp_result == false) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1581;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
        }
        {
            PyObject *tmp_called_name_5;
            PyObject *tmp_mvar_value_9;
            PyObject *tmp_call_result_2;
            PyObject *tmp_args_element_name_7;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_source_name_11;
            PyObject *tmp_source_name_12;
            PyObject *tmp_mvar_value_10;
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert);

            if (unlikely(tmp_mvar_value_9 == NULL)) {
                tmp_mvar_value_9 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
            }

            if (tmp_mvar_value_9 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
                exception_tb = NULL;

                exception_lineno = 1582;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_5 = tmp_mvar_value_9;
            CHECK_OBJECT(par_self);
            tmp_source_name_11 = par_self;
            tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE(tmp_source_name_11, const_str_plain__into_ssl);
            if (tmp_compexpr_left_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1582;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_10 == NULL)) {
                tmp_mvar_value_10 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_10 == NULL) {
                Py_DECREF(tmp_compexpr_left_2);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1582;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_12 = tmp_mvar_value_10;
            tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE(tmp_source_name_12, const_str_plain_NULL);
            if (tmp_compexpr_right_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_compexpr_left_2);

                exception_lineno = 1582;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_args_element_name_7 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
            Py_DECREF(tmp_compexpr_left_2);
            Py_DECREF(tmp_compexpr_right_2);
            if (tmp_args_element_name_7 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1582;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            frame_c93d963cdd7d7cda8b597989582cd847->m_frame.f_lineno = 1582;
            tmp_call_result_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_5, tmp_args_element_name_7);
            Py_DECREF(tmp_args_element_name_7);
            if (tmp_call_result_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1582;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_2);
        }
        {
            PyObject *tmp_assattr_name_9;
            PyObject *tmp_called_name_6;
            PyObject *tmp_source_name_13;
            PyObject *tmp_mvar_value_11;
            PyObject *tmp_args_element_name_8;
            PyObject *tmp_called_instance_2;
            PyObject *tmp_mvar_value_12;
            PyObject *tmp_assattr_target_9;
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_11 == NULL)) {
                tmp_mvar_value_11 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_11 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1584;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_13 = tmp_mvar_value_11;
            tmp_called_name_6 = LOOKUP_ATTRIBUTE(tmp_source_name_13, const_str_plain_BIO_new);
            if (tmp_called_name_6 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1584;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_12 == NULL)) {
                tmp_mvar_value_12 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_12 == NULL) {
                Py_DECREF(tmp_called_name_6);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1584;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_2 = tmp_mvar_value_12;
            frame_c93d963cdd7d7cda8b597989582cd847->m_frame.f_lineno = 1584;
            tmp_args_element_name_8 = CALL_METHOD_NO_ARGS(tmp_called_instance_2, const_str_plain_BIO_s_mem);
            if (tmp_args_element_name_8 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_6);

                exception_lineno = 1584;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            frame_c93d963cdd7d7cda8b597989582cd847->m_frame.f_lineno = 1584;
            tmp_assattr_name_9 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_6, tmp_args_element_name_8);
            Py_DECREF(tmp_called_name_6);
            Py_DECREF(tmp_args_element_name_8);
            if (tmp_assattr_name_9 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1584;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(par_self);
            tmp_assattr_target_9 = par_self;
            tmp_result = SET_ATTRIBUTE(tmp_assattr_target_9, const_str_plain__from_ssl, tmp_assattr_name_9);
            Py_DECREF(tmp_assattr_name_9);
            if (tmp_result == false) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1584;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
        }
        {
            PyObject *tmp_called_name_7;
            PyObject *tmp_mvar_value_13;
            PyObject *tmp_call_result_3;
            PyObject *tmp_args_element_name_9;
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            PyObject *tmp_source_name_14;
            PyObject *tmp_source_name_15;
            PyObject *tmp_mvar_value_14;
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert);

            if (unlikely(tmp_mvar_value_13 == NULL)) {
                tmp_mvar_value_13 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
            }

            if (tmp_mvar_value_13 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
                exception_tb = NULL;

                exception_lineno = 1585;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_7 = tmp_mvar_value_13;
            CHECK_OBJECT(par_self);
            tmp_source_name_14 = par_self;
            tmp_compexpr_left_3 = LOOKUP_ATTRIBUTE(tmp_source_name_14, const_str_plain__from_ssl);
            if (tmp_compexpr_left_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1585;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_14 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_14 == NULL)) {
                tmp_mvar_value_14 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_14 == NULL) {
                Py_DECREF(tmp_compexpr_left_3);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1585;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_15 = tmp_mvar_value_14;
            tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE(tmp_source_name_15, const_str_plain_NULL);
            if (tmp_compexpr_right_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_compexpr_left_3);

                exception_lineno = 1585;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_args_element_name_9 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_3, tmp_compexpr_right_3);
            Py_DECREF(tmp_compexpr_left_3);
            Py_DECREF(tmp_compexpr_right_3);
            if (tmp_args_element_name_9 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1585;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            frame_c93d963cdd7d7cda8b597989582cd847->m_frame.f_lineno = 1585;
            tmp_call_result_3 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_7, tmp_args_element_name_9);
            Py_DECREF(tmp_args_element_name_9);
            if (tmp_call_result_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1585;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_3);
        }
        {
            PyObject *tmp_called_name_8;
            PyObject *tmp_source_name_16;
            PyObject *tmp_mvar_value_15;
            PyObject *tmp_call_result_4;
            PyObject *tmp_args_element_name_10;
            PyObject *tmp_source_name_17;
            PyObject *tmp_args_element_name_11;
            PyObject *tmp_source_name_18;
            PyObject *tmp_args_element_name_12;
            PyObject *tmp_source_name_19;
            tmp_mvar_value_15 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_15 == NULL)) {
                tmp_mvar_value_15 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_15 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1587;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_16 = tmp_mvar_value_15;
            tmp_called_name_8 = LOOKUP_ATTRIBUTE(tmp_source_name_16, const_str_plain_SSL_set_bio);
            if (tmp_called_name_8 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1587;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(par_self);
            tmp_source_name_17 = par_self;
            tmp_args_element_name_10 = LOOKUP_ATTRIBUTE(tmp_source_name_17, const_str_plain__ssl);
            if (tmp_args_element_name_10 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_8);

                exception_lineno = 1587;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(par_self);
            tmp_source_name_18 = par_self;
            tmp_args_element_name_11 = LOOKUP_ATTRIBUTE(tmp_source_name_18, const_str_plain__into_ssl);
            if (tmp_args_element_name_11 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_8);
                Py_DECREF(tmp_args_element_name_10);

                exception_lineno = 1587;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(par_self);
            tmp_source_name_19 = par_self;
            tmp_args_element_name_12 = LOOKUP_ATTRIBUTE(tmp_source_name_19, const_str_plain__from_ssl);
            if (tmp_args_element_name_12 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_8);
                Py_DECREF(tmp_args_element_name_10);
                Py_DECREF(tmp_args_element_name_11);

                exception_lineno = 1587;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            frame_c93d963cdd7d7cda8b597989582cd847->m_frame.f_lineno = 1587;
            {
                PyObject *call_args[] = {tmp_args_element_name_10, tmp_args_element_name_11, tmp_args_element_name_12};
                tmp_call_result_4 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_8, call_args);
            }

            Py_DECREF(tmp_called_name_8);
            Py_DECREF(tmp_args_element_name_10);
            Py_DECREF(tmp_args_element_name_11);
            Py_DECREF(tmp_args_element_name_12);
            if (tmp_call_result_4 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1587;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_4);
        }
        goto branch_end_2;
        branch_no_2:;
        {
            PyObject *tmp_assattr_name_10;
            PyObject *tmp_assattr_target_10;
            tmp_assattr_name_10 = Py_None;
            CHECK_OBJECT(par_self);
            tmp_assattr_target_10 = par_self;
            tmp_result = SET_ATTRIBUTE(tmp_assattr_target_10, const_str_plain__into_ssl, tmp_assattr_name_10);
            if (tmp_result == false) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1589;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
        }
        {
            PyObject *tmp_assattr_name_11;
            PyObject *tmp_assattr_target_11;
            tmp_assattr_name_11 = Py_None;
            CHECK_OBJECT(par_self);
            tmp_assattr_target_11 = par_self;
            tmp_result = SET_ATTRIBUTE(tmp_assattr_target_11, const_str_plain__from_ssl, tmp_assattr_name_11);
            if (tmp_result == false) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1590;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
        }
        {
            PyObject *tmp_assattr_name_12;
            PyObject *tmp_assattr_target_12;
            CHECK_OBJECT(par_socket);
            tmp_assattr_name_12 = par_socket;
            CHECK_OBJECT(par_self);
            tmp_assattr_target_12 = par_self;
            tmp_result = SET_ATTRIBUTE(tmp_assattr_target_12, const_str_plain__socket, tmp_assattr_name_12);
            if (tmp_result == false) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1591;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
        }
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_called_name_9;
            PyObject *tmp_source_name_20;
            PyObject *tmp_mvar_value_16;
            PyObject *tmp_args_element_name_13;
            PyObject *tmp_source_name_21;
            PyObject *tmp_args_element_name_14;
            PyObject *tmp_called_name_10;
            PyObject *tmp_mvar_value_17;
            PyObject *tmp_args_element_name_15;
            PyObject *tmp_source_name_22;
            tmp_mvar_value_16 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_16 == NULL)) {
                tmp_mvar_value_16 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_16 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1592;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_20 = tmp_mvar_value_16;
            tmp_called_name_9 = LOOKUP_ATTRIBUTE(tmp_source_name_20, const_str_plain_SSL_set_fd);
            if (tmp_called_name_9 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1592;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(par_self);
            tmp_source_name_21 = par_self;
            tmp_args_element_name_13 = LOOKUP_ATTRIBUTE(tmp_source_name_21, const_str_plain__ssl);
            if (tmp_args_element_name_13 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_9);

                exception_lineno = 1593;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_17 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__asFileDescriptor);

            if (unlikely(tmp_mvar_value_17 == NULL)) {
                tmp_mvar_value_17 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__asFileDescriptor);
            }

            if (tmp_mvar_value_17 == NULL) {
                Py_DECREF(tmp_called_name_9);
                Py_DECREF(tmp_args_element_name_13);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 1463 ], 46, 0);
                exception_tb = NULL;

                exception_lineno = 1593;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_10 = tmp_mvar_value_17;
            CHECK_OBJECT(par_self);
            tmp_source_name_22 = par_self;
            tmp_args_element_name_15 = LOOKUP_ATTRIBUTE(tmp_source_name_22, const_str_plain__socket);
            if (tmp_args_element_name_15 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_9);
                Py_DECREF(tmp_args_element_name_13);

                exception_lineno = 1593;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            frame_c93d963cdd7d7cda8b597989582cd847->m_frame.f_lineno = 1593;
            tmp_args_element_name_14 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_10, tmp_args_element_name_15);
            Py_DECREF(tmp_args_element_name_15);
            if (tmp_args_element_name_14 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_9);
                Py_DECREF(tmp_args_element_name_13);

                exception_lineno = 1593;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            frame_c93d963cdd7d7cda8b597989582cd847->m_frame.f_lineno = 1592;
            {
                PyObject *call_args[] = {tmp_args_element_name_13, tmp_args_element_name_14};
                tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_9, call_args);
            }

            Py_DECREF(tmp_called_name_9);
            Py_DECREF(tmp_args_element_name_13);
            Py_DECREF(tmp_args_element_name_14);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1592;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            assert(var_set_result == NULL);
            var_set_result = tmp_assign_source_2;
        }
        {
            PyObject *tmp_called_name_11;
            PyObject *tmp_mvar_value_18;
            PyObject *tmp_call_result_5;
            PyObject *tmp_args_element_name_16;
            PyObject *tmp_compexpr_left_4;
            PyObject *tmp_compexpr_right_4;
            tmp_mvar_value_18 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert);

            if (unlikely(tmp_mvar_value_18 == NULL)) {
                tmp_mvar_value_18 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
            }

            if (tmp_mvar_value_18 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
                exception_tb = NULL;

                exception_lineno = 1594;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_11 = tmp_mvar_value_18;
            CHECK_OBJECT(var_set_result);
            tmp_compexpr_left_4 = var_set_result;
            tmp_compexpr_right_4 = const_int_pos_1;
            tmp_args_element_name_16 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_4, tmp_compexpr_right_4);
            if (tmp_args_element_name_16 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1594;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            frame_c93d963cdd7d7cda8b597989582cd847->m_frame.f_lineno = 1594;
            tmp_call_result_5 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_11, tmp_args_element_name_16);
            Py_DECREF(tmp_args_element_name_16);
            if (tmp_call_result_5 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1594;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_5);
        }
        branch_end_2:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c93d963cdd7d7cda8b597989582cd847);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c93d963cdd7d7cda8b597989582cd847);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_c93d963cdd7d7cda8b597989582cd847, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_c93d963cdd7d7cda8b597989582cd847->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_c93d963cdd7d7cda8b597989582cd847, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c93d963cdd7d7cda8b597989582cd847,
        type_description_1,
        par_self,
        par_context,
        par_socket,
        var_ssl,
        var_set_result
    );


    // Release cached frame.
    if (frame_c93d963cdd7d7cda8b597989582cd847 == cache_frame_c93d963cdd7d7cda8b597989582cd847) {
        Py_DECREF(frame_c93d963cdd7d7cda8b597989582cd847);
    }
    cache_frame_c93d963cdd7d7cda8b597989582cd847 = NULL;

    assertFrameObject(frame_c93d963cdd7d7cda8b597989582cd847);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_57___init__);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_ssl);
    Py_DECREF(var_ssl);
    var_ssl = NULL;

    Py_XDECREF(var_set_result);
    var_set_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_ssl);
    var_ssl = NULL;

    Py_XDECREF(var_set_result);
    var_set_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_57___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_socket);
    Py_DECREF(par_socket);
    CHECK_OBJECT(par_context);
    Py_DECREF(par_context);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_socket);
    Py_DECREF(par_socket);
    CHECK_OBJECT(par_context);
    Py_DECREF(par_context);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_58___getattr__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_name = python_pars[1];
    struct Nuitka_FrameObject *frame_9ff72b44efcfb2d4a96a40edcf67b8cf;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_9ff72b44efcfb2d4a96a40edcf67b8cf = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_9ff72b44efcfb2d4a96a40edcf67b8cf, codeobj_9ff72b44efcfb2d4a96a40edcf67b8cf, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *));
    frame_9ff72b44efcfb2d4a96a40edcf67b8cf = cache_frame_9ff72b44efcfb2d4a96a40edcf67b8cf;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_9ff72b44efcfb2d4a96a40edcf67b8cf);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_9ff72b44efcfb2d4a96a40edcf67b8cf) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__socket);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1601;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_compexpr_left_1);
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            PyObject *tmp_tuple_element_1;
            PyObject *tmp_source_name_2;
            PyObject *tmp_source_name_3;
            tmp_left_name_1 = const_str_digest_ca7f1c3e5d90e78a07e9f85863c06c8e;
            CHECK_OBJECT(par_self);
            tmp_source_name_3 = par_self;
            tmp_source_name_2 = LOOKUP_ATTRIBUTE_CLASS_SLOT(tmp_source_name_3);
            if (tmp_source_name_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1603;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain___name__);
            Py_DECREF(tmp_source_name_2);
            if (tmp_tuple_element_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1603;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_right_name_1 = PyTuple_New(2);
            PyTuple_SET_ITEM(tmp_right_name_1, 0, tmp_tuple_element_1);
            CHECK_OBJECT(par_name);
            tmp_tuple_element_1 = par_name;
            Py_INCREF(tmp_tuple_element_1);
            PyTuple_SET_ITEM(tmp_right_name_1, 1, tmp_tuple_element_1);
            tmp_make_exception_arg_1 = BINARY_OPERATION_MOD_STR_TUPLE(tmp_left_name_1, tmp_right_name_1);
            Py_DECREF(tmp_right_name_1);
            if (tmp_make_exception_arg_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1602;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            frame_9ff72b44efcfb2d4a96a40edcf67b8cf->m_frame.f_lineno = 1602;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_AttributeError, tmp_make_exception_arg_1);
            Py_DECREF(tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1602;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_getattr_target_1;
            PyObject *tmp_source_name_4;
            PyObject *tmp_getattr_attr_1;
            CHECK_OBJECT(par_self);
            tmp_source_name_4 = par_self;
            tmp_getattr_target_1 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain__socket);
            if (tmp_getattr_target_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1606;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(par_name);
            tmp_getattr_attr_1 = par_name;
            tmp_return_value = BUILTIN_GETATTR(tmp_getattr_target_1, tmp_getattr_attr_1, NULL);
            Py_DECREF(tmp_getattr_target_1);
            if (tmp_return_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1606;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9ff72b44efcfb2d4a96a40edcf67b8cf);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_9ff72b44efcfb2d4a96a40edcf67b8cf);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9ff72b44efcfb2d4a96a40edcf67b8cf);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_9ff72b44efcfb2d4a96a40edcf67b8cf, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_9ff72b44efcfb2d4a96a40edcf67b8cf->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_9ff72b44efcfb2d4a96a40edcf67b8cf, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9ff72b44efcfb2d4a96a40edcf67b8cf,
        type_description_1,
        par_self,
        par_name
    );


    // Release cached frame.
    if (frame_9ff72b44efcfb2d4a96a40edcf67b8cf == cache_frame_9ff72b44efcfb2d4a96a40edcf67b8cf) {
        Py_DECREF(frame_9ff72b44efcfb2d4a96a40edcf67b8cf);
    }
    cache_frame_9ff72b44efcfb2d4a96a40edcf67b8cf = NULL;

    assertFrameObject(frame_9ff72b44efcfb2d4a96a40edcf67b8cf);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_58___getattr__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_name);
    Py_DECREF(par_name);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_name);
    Py_DECREF(par_name);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_59__raise_ssl_error(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_ssl = python_pars[1];
    PyObject *par_result = python_pars[2];
    PyObject *var_errno = NULL;
    PyObject *var_error = NULL;
    struct Nuitka_FrameObject *frame_ecbdc66f85a0b113e83a292b998563db;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_ecbdc66f85a0b113e83a292b998563db = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_ecbdc66f85a0b113e83a292b998563db, codeobj_ecbdc66f85a0b113e83a292b998563db, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_ecbdc66f85a0b113e83a292b998563db = cache_frame_ecbdc66f85a0b113e83a292b998563db;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_ecbdc66f85a0b113e83a292b998563db);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_ecbdc66f85a0b113e83a292b998563db) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__context);
        if (tmp_source_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1609;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__verify_helper);
        Py_DECREF(tmp_source_name_1);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1609;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 != tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_compexpr_left_1);
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_source_name_3;
            PyObject *tmp_source_name_4;
            PyObject *tmp_call_result_1;
            CHECK_OBJECT(par_self);
            tmp_source_name_4 = par_self;
            tmp_source_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain__context);
            if (tmp_source_name_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1610;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_called_instance_1 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__verify_helper);
            Py_DECREF(tmp_source_name_3);
            if (tmp_called_instance_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1610;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            frame_ecbdc66f85a0b113e83a292b998563db->m_frame.f_lineno = 1610;
            tmp_call_result_1 = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_raise_if_problem);
            Py_DECREF(tmp_called_instance_1);
            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1610;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_1);
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_5;
        PyObject *tmp_source_name_6;
        CHECK_OBJECT(par_self);
        tmp_source_name_6 = par_self;
        tmp_source_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain__context);
        if (tmp_source_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1611;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain__npn_advertise_helper);
        Py_DECREF(tmp_source_name_5);
        if (tmp_compexpr_left_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1611;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_2 = Py_None;
        tmp_condition_result_2 = (tmp_compexpr_left_2 != tmp_compexpr_right_2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_compexpr_left_2);
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_source_name_7;
            PyObject *tmp_source_name_8;
            PyObject *tmp_call_result_2;
            CHECK_OBJECT(par_self);
            tmp_source_name_8 = par_self;
            tmp_source_name_7 = LOOKUP_ATTRIBUTE(tmp_source_name_8, const_str_plain__context);
            if (tmp_source_name_7 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1612;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_called_instance_2 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain__npn_advertise_helper);
            Py_DECREF(tmp_source_name_7);
            if (tmp_called_instance_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1612;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            frame_ecbdc66f85a0b113e83a292b998563db->m_frame.f_lineno = 1612;
            tmp_call_result_2 = CALL_METHOD_NO_ARGS(tmp_called_instance_2, const_str_plain_raise_if_problem);
            Py_DECREF(tmp_called_instance_2);
            if (tmp_call_result_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1612;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_2);
        }
        branch_no_2:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_source_name_9;
        PyObject *tmp_source_name_10;
        CHECK_OBJECT(par_self);
        tmp_source_name_10 = par_self;
        tmp_source_name_9 = LOOKUP_ATTRIBUTE(tmp_source_name_10, const_str_plain__context);
        if (tmp_source_name_9 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1613;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_left_3 = LOOKUP_ATTRIBUTE(tmp_source_name_9, const_str_plain__npn_select_helper);
        Py_DECREF(tmp_source_name_9);
        if (tmp_compexpr_left_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1613;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_3 = Py_None;
        tmp_condition_result_3 = (tmp_compexpr_left_3 != tmp_compexpr_right_3) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_compexpr_left_3);
        if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
            goto branch_yes_3;
        } else {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_called_instance_3;
            PyObject *tmp_source_name_11;
            PyObject *tmp_source_name_12;
            PyObject *tmp_call_result_3;
            CHECK_OBJECT(par_self);
            tmp_source_name_12 = par_self;
            tmp_source_name_11 = LOOKUP_ATTRIBUTE(tmp_source_name_12, const_str_plain__context);
            if (tmp_source_name_11 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1614;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_called_instance_3 = LOOKUP_ATTRIBUTE(tmp_source_name_11, const_str_plain__npn_select_helper);
            Py_DECREF(tmp_source_name_11);
            if (tmp_called_instance_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1614;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            frame_ecbdc66f85a0b113e83a292b998563db->m_frame.f_lineno = 1614;
            tmp_call_result_3 = CALL_METHOD_NO_ARGS(tmp_called_instance_3, const_str_plain_raise_if_problem);
            Py_DECREF(tmp_called_instance_3);
            if (tmp_call_result_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1614;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_3);
        }
        branch_no_3:;
    }
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        PyObject *tmp_source_name_13;
        PyObject *tmp_source_name_14;
        CHECK_OBJECT(par_self);
        tmp_source_name_14 = par_self;
        tmp_source_name_13 = LOOKUP_ATTRIBUTE(tmp_source_name_14, const_str_plain__context);
        if (tmp_source_name_13 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1615;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_left_4 = LOOKUP_ATTRIBUTE(tmp_source_name_13, const_str_plain__alpn_select_helper);
        Py_DECREF(tmp_source_name_13);
        if (tmp_compexpr_left_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1615;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_4 = Py_None;
        tmp_condition_result_4 = (tmp_compexpr_left_4 != tmp_compexpr_right_4) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_compexpr_left_4);
        if (tmp_condition_result_4 == NUITKA_BOOL_TRUE) {
            goto branch_yes_4;
        } else {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_called_instance_4;
            PyObject *tmp_source_name_15;
            PyObject *tmp_source_name_16;
            PyObject *tmp_call_result_4;
            CHECK_OBJECT(par_self);
            tmp_source_name_16 = par_self;
            tmp_source_name_15 = LOOKUP_ATTRIBUTE(tmp_source_name_16, const_str_plain__context);
            if (tmp_source_name_15 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1616;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_called_instance_4 = LOOKUP_ATTRIBUTE(tmp_source_name_15, const_str_plain__alpn_select_helper);
            Py_DECREF(tmp_source_name_15);
            if (tmp_called_instance_4 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1616;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            frame_ecbdc66f85a0b113e83a292b998563db->m_frame.f_lineno = 1616;
            tmp_call_result_4 = CALL_METHOD_NO_ARGS(tmp_called_instance_4, const_str_plain_raise_if_problem);
            Py_DECREF(tmp_called_instance_4);
            if (tmp_call_result_4 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1616;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_4);
        }
        branch_no_4:;
    }
    {
        nuitka_bool tmp_condition_result_5;
        PyObject *tmp_compexpr_left_5;
        PyObject *tmp_compexpr_right_5;
        PyObject *tmp_source_name_17;
        PyObject *tmp_source_name_18;
        CHECK_OBJECT(par_self);
        tmp_source_name_18 = par_self;
        tmp_source_name_17 = LOOKUP_ATTRIBUTE(tmp_source_name_18, const_str_plain__context);
        if (tmp_source_name_17 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1617;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_left_5 = LOOKUP_ATTRIBUTE(tmp_source_name_17, const_str_plain__ocsp_helper);
        Py_DECREF(tmp_source_name_17);
        if (tmp_compexpr_left_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1617;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_5 = Py_None;
        tmp_condition_result_5 = (tmp_compexpr_left_5 != tmp_compexpr_right_5) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_compexpr_left_5);
        if (tmp_condition_result_5 == NUITKA_BOOL_TRUE) {
            goto branch_yes_5;
        } else {
            goto branch_no_5;
        }
        branch_yes_5:;
        {
            PyObject *tmp_called_instance_5;
            PyObject *tmp_source_name_19;
            PyObject *tmp_source_name_20;
            PyObject *tmp_call_result_5;
            CHECK_OBJECT(par_self);
            tmp_source_name_20 = par_self;
            tmp_source_name_19 = LOOKUP_ATTRIBUTE(tmp_source_name_20, const_str_plain__context);
            if (tmp_source_name_19 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1618;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_called_instance_5 = LOOKUP_ATTRIBUTE(tmp_source_name_19, const_str_plain__ocsp_helper);
            Py_DECREF(tmp_source_name_19);
            if (tmp_called_instance_5 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1618;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            frame_ecbdc66f85a0b113e83a292b998563db->m_frame.f_lineno = 1618;
            tmp_call_result_5 = CALL_METHOD_NO_ARGS(tmp_called_instance_5, const_str_plain_raise_if_problem);
            Py_DECREF(tmp_called_instance_5);
            if (tmp_call_result_5 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1618;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_5);
        }
        branch_no_5:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_6;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1620;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_6 = tmp_mvar_value_1;
        CHECK_OBJECT(par_ssl);
        tmp_args_element_name_1 = par_ssl;
        CHECK_OBJECT(par_result);
        tmp_args_element_name_2 = par_result;
        frame_ecbdc66f85a0b113e83a292b998563db->m_frame.f_lineno = 1620;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_6, const_str_plain_SSL_get_error, call_args);
        }

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1620;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(var_error == NULL);
        var_error = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_6;
        PyObject *tmp_compexpr_left_6;
        PyObject *tmp_compexpr_right_6;
        PyObject *tmp_source_name_21;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT(var_error);
        tmp_compexpr_left_6 = var_error;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1621;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_21 = tmp_mvar_value_2;
        tmp_compexpr_right_6 = LOOKUP_ATTRIBUTE(tmp_source_name_21, const_str_plain_SSL_ERROR_WANT_READ);
        if (tmp_compexpr_right_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1621;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_6, tmp_compexpr_right_6);
        Py_DECREF(tmp_compexpr_right_6);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1621;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_6 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_6 == NUITKA_BOOL_TRUE) {
            goto branch_yes_6;
        } else {
            goto branch_no_6;
        }
        branch_yes_6:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_called_name_1;
            PyObject *tmp_mvar_value_3;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_WantReadError);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_WantReadError);
            }

            if (tmp_mvar_value_3 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 1509 ], 42, 0);
                exception_tb = NULL;

                exception_lineno = 1622;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_1 = tmp_mvar_value_3;
            frame_ecbdc66f85a0b113e83a292b998563db->m_frame.f_lineno = 1622;
            tmp_raise_type_1 = CALL_FUNCTION_NO_ARGS(tmp_called_name_1);
            if (tmp_raise_type_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1622;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            exception_type = tmp_raise_type_1;
            exception_lineno = 1622;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        goto branch_end_6;
        branch_no_6:;
        {
            nuitka_bool tmp_condition_result_7;
            PyObject *tmp_compexpr_left_7;
            PyObject *tmp_compexpr_right_7;
            PyObject *tmp_source_name_22;
            PyObject *tmp_mvar_value_4;
            CHECK_OBJECT(var_error);
            tmp_compexpr_left_7 = var_error;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_4 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1623;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_22 = tmp_mvar_value_4;
            tmp_compexpr_right_7 = LOOKUP_ATTRIBUTE(tmp_source_name_22, const_str_plain_SSL_ERROR_WANT_WRITE);
            if (tmp_compexpr_right_7 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1623;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_7, tmp_compexpr_right_7);
            Py_DECREF(tmp_compexpr_right_7);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1623;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_7 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_7 == NUITKA_BOOL_TRUE) {
                goto branch_yes_7;
            } else {
                goto branch_no_7;
            }
            branch_yes_7:;
            {
                PyObject *tmp_raise_type_2;
                PyObject *tmp_called_name_2;
                PyObject *tmp_mvar_value_5;
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_WantWriteError);

                if (unlikely(tmp_mvar_value_5 == NULL)) {
                    tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_WantWriteError);
                }

                if (tmp_mvar_value_5 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 1551 ], 43, 0);
                    exception_tb = NULL;

                    exception_lineno = 1624;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_name_2 = tmp_mvar_value_5;
                frame_ecbdc66f85a0b113e83a292b998563db->m_frame.f_lineno = 1624;
                tmp_raise_type_2 = CALL_FUNCTION_NO_ARGS(tmp_called_name_2);
                if (tmp_raise_type_2 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 1624;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                exception_type = tmp_raise_type_2;
                exception_lineno = 1624;
                RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            goto branch_end_7;
            branch_no_7:;
            {
                nuitka_bool tmp_condition_result_8;
                PyObject *tmp_compexpr_left_8;
                PyObject *tmp_compexpr_right_8;
                PyObject *tmp_source_name_23;
                PyObject *tmp_mvar_value_6;
                CHECK_OBJECT(var_error);
                tmp_compexpr_left_8 = var_error;
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

                if (unlikely(tmp_mvar_value_6 == NULL)) {
                    tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
                }

                if (tmp_mvar_value_6 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 1625;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_23 = tmp_mvar_value_6;
                tmp_compexpr_right_8 = LOOKUP_ATTRIBUTE(tmp_source_name_23, const_str_plain_SSL_ERROR_ZERO_RETURN);
                if (tmp_compexpr_right_8 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 1625;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_8, tmp_compexpr_right_8);
                Py_DECREF(tmp_compexpr_right_8);
                if (tmp_res == -1) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 1625;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                tmp_condition_result_8 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                if (tmp_condition_result_8 == NUITKA_BOOL_TRUE) {
                    goto branch_yes_8;
                } else {
                    goto branch_no_8;
                }
                branch_yes_8:;
                {
                    PyObject *tmp_raise_type_3;
                    PyObject *tmp_called_name_3;
                    PyObject *tmp_mvar_value_7;
                    tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_ZeroReturnError);

                    if (unlikely(tmp_mvar_value_7 == NULL)) {
                        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ZeroReturnError);
                    }

                    if (tmp_mvar_value_7 == NULL) {

                        exception_type = PyExc_NameError;
                        Py_INCREF(exception_type);
                        exception_value = UNSTREAM_STRING(&constant_bin[ 1594 ], 44, 0);
                        exception_tb = NULL;

                        exception_lineno = 1626;
                        type_description_1 = "ooooo";
                        goto frame_exception_exit_1;
                    }

                    tmp_called_name_3 = tmp_mvar_value_7;
                    frame_ecbdc66f85a0b113e83a292b998563db->m_frame.f_lineno = 1626;
                    tmp_raise_type_3 = CALL_FUNCTION_NO_ARGS(tmp_called_name_3);
                    if (tmp_raise_type_3 == NULL) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                        exception_lineno = 1626;
                        type_description_1 = "ooooo";
                        goto frame_exception_exit_1;
                    }
                    exception_type = tmp_raise_type_3;
                    exception_lineno = 1626;
                    RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                goto branch_end_8;
                branch_no_8:;
                {
                    nuitka_bool tmp_condition_result_9;
                    PyObject *tmp_compexpr_left_9;
                    PyObject *tmp_compexpr_right_9;
                    PyObject *tmp_source_name_24;
                    PyObject *tmp_mvar_value_8;
                    CHECK_OBJECT(var_error);
                    tmp_compexpr_left_9 = var_error;
                    tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

                    if (unlikely(tmp_mvar_value_8 == NULL)) {
                        tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
                    }

                    if (tmp_mvar_value_8 == NULL) {

                        exception_type = PyExc_NameError;
                        Py_INCREF(exception_type);
                        exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                        exception_tb = NULL;

                        exception_lineno = 1627;
                        type_description_1 = "ooooo";
                        goto frame_exception_exit_1;
                    }

                    tmp_source_name_24 = tmp_mvar_value_8;
                    tmp_compexpr_right_9 = LOOKUP_ATTRIBUTE(tmp_source_name_24, const_str_plain_SSL_ERROR_WANT_X509_LOOKUP);
                    if (tmp_compexpr_right_9 == NULL) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                        exception_lineno = 1627;
                        type_description_1 = "ooooo";
                        goto frame_exception_exit_1;
                    }
                    tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_9, tmp_compexpr_right_9);
                    Py_DECREF(tmp_compexpr_right_9);
                    if (tmp_res == -1) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                        exception_lineno = 1627;
                        type_description_1 = "ooooo";
                        goto frame_exception_exit_1;
                    }
                    tmp_condition_result_9 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                    if (tmp_condition_result_9 == NUITKA_BOOL_TRUE) {
                        goto branch_yes_9;
                    } else {
                        goto branch_no_9;
                    }
                    branch_yes_9:;
                    {
                        PyObject *tmp_raise_type_4;
                        PyObject *tmp_called_name_4;
                        PyObject *tmp_mvar_value_9;
                        tmp_mvar_value_9 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_WantX509LookupError);

                        if (unlikely(tmp_mvar_value_9 == NULL)) {
                            tmp_mvar_value_9 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_WantX509LookupError);
                        }

                        if (tmp_mvar_value_9 == NULL) {

                            exception_type = PyExc_NameError;
                            Py_INCREF(exception_type);
                            exception_value = UNSTREAM_STRING(&constant_bin[ 1638 ], 48, 0);
                            exception_tb = NULL;

                            exception_lineno = 1629;
                            type_description_1 = "ooooo";
                            goto frame_exception_exit_1;
                        }

                        tmp_called_name_4 = tmp_mvar_value_9;
                        frame_ecbdc66f85a0b113e83a292b998563db->m_frame.f_lineno = 1629;
                        tmp_raise_type_4 = CALL_FUNCTION_NO_ARGS(tmp_called_name_4);
                        if (tmp_raise_type_4 == NULL) {
                            assert(ERROR_OCCURRED());

                            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                            exception_lineno = 1629;
                            type_description_1 = "ooooo";
                            goto frame_exception_exit_1;
                        }
                        exception_type = tmp_raise_type_4;
                        exception_lineno = 1629;
                        RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                        type_description_1 = "ooooo";
                        goto frame_exception_exit_1;
                    }
                    goto branch_end_9;
                    branch_no_9:;
                    {
                        nuitka_bool tmp_condition_result_10;
                        PyObject *tmp_compexpr_left_10;
                        PyObject *tmp_compexpr_right_10;
                        PyObject *tmp_source_name_25;
                        PyObject *tmp_mvar_value_10;
                        CHECK_OBJECT(var_error);
                        tmp_compexpr_left_10 = var_error;
                        tmp_mvar_value_10 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

                        if (unlikely(tmp_mvar_value_10 == NULL)) {
                            tmp_mvar_value_10 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
                        }

                        if (tmp_mvar_value_10 == NULL) {

                            exception_type = PyExc_NameError;
                            Py_INCREF(exception_type);
                            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                            exception_tb = NULL;

                            exception_lineno = 1630;
                            type_description_1 = "ooooo";
                            goto frame_exception_exit_1;
                        }

                        tmp_source_name_25 = tmp_mvar_value_10;
                        tmp_compexpr_right_10 = LOOKUP_ATTRIBUTE(tmp_source_name_25, const_str_plain_SSL_ERROR_SYSCALL);
                        if (tmp_compexpr_right_10 == NULL) {
                            assert(ERROR_OCCURRED());

                            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                            exception_lineno = 1630;
                            type_description_1 = "ooooo";
                            goto frame_exception_exit_1;
                        }
                        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_10, tmp_compexpr_right_10);
                        Py_DECREF(tmp_compexpr_right_10);
                        if (tmp_res == -1) {
                            assert(ERROR_OCCURRED());

                            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                            exception_lineno = 1630;
                            type_description_1 = "ooooo";
                            goto frame_exception_exit_1;
                        }
                        tmp_condition_result_10 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                        if (tmp_condition_result_10 == NUITKA_BOOL_TRUE) {
                            goto branch_yes_10;
                        } else {
                            goto branch_no_10;
                        }
                        branch_yes_10:;
                        {
                            nuitka_bool tmp_condition_result_11;
                            PyObject *tmp_compexpr_left_11;
                            PyObject *tmp_compexpr_right_11;
                            PyObject *tmp_called_instance_7;
                            PyObject *tmp_mvar_value_11;
                            tmp_mvar_value_11 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

                            if (unlikely(tmp_mvar_value_11 == NULL)) {
                                tmp_mvar_value_11 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
                            }

                            if (tmp_mvar_value_11 == NULL) {

                                exception_type = PyExc_NameError;
                                Py_INCREF(exception_type);
                                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                                exception_tb = NULL;

                                exception_lineno = 1631;
                                type_description_1 = "ooooo";
                                goto frame_exception_exit_1;
                            }

                            tmp_called_instance_7 = tmp_mvar_value_11;
                            frame_ecbdc66f85a0b113e83a292b998563db->m_frame.f_lineno = 1631;
                            tmp_compexpr_left_11 = CALL_METHOD_NO_ARGS(tmp_called_instance_7, const_str_plain_ERR_peek_error);
                            if (tmp_compexpr_left_11 == NULL) {
                                assert(ERROR_OCCURRED());

                                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                                exception_lineno = 1631;
                                type_description_1 = "ooooo";
                                goto frame_exception_exit_1;
                            }
                            tmp_compexpr_right_11 = const_int_0;
                            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_INT(tmp_compexpr_left_11, tmp_compexpr_right_11);
                            Py_DECREF(tmp_compexpr_left_11);
                            if (tmp_res == -1) {
                                assert(ERROR_OCCURRED());

                                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                                exception_lineno = 1631;
                                type_description_1 = "ooooo";
                                goto frame_exception_exit_1;
                            }
                            tmp_condition_result_11 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                            if (tmp_condition_result_11 == NUITKA_BOOL_TRUE) {
                                goto branch_yes_11;
                            } else {
                                goto branch_no_11;
                            }
                            branch_yes_11:;
                            {
                                nuitka_bool tmp_condition_result_12;
                                PyObject *tmp_compexpr_left_12;
                                PyObject *tmp_compexpr_right_12;
                                CHECK_OBJECT(par_result);
                                tmp_compexpr_left_12 = par_result;
                                tmp_compexpr_right_12 = const_int_0;
                                tmp_res = RICH_COMPARE_BOOL_LT_OBJECT_INT(tmp_compexpr_left_12, tmp_compexpr_right_12);
                                if (tmp_res == -1) {
                                    assert(ERROR_OCCURRED());

                                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                                    exception_lineno = 1632;
                                    type_description_1 = "ooooo";
                                    goto frame_exception_exit_1;
                                }
                                tmp_condition_result_12 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                                if (tmp_condition_result_12 == NUITKA_BOOL_TRUE) {
                                    goto branch_yes_12;
                                } else {
                                    goto branch_no_12;
                                }
                                branch_yes_12:;
                                {
                                    nuitka_bool tmp_condition_result_13;
                                    PyObject *tmp_compexpr_left_13;
                                    PyObject *tmp_compexpr_right_13;
                                    PyObject *tmp_mvar_value_12;
                                    tmp_mvar_value_12 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_platform);

                                    if (unlikely(tmp_mvar_value_12 == NULL)) {
                                        tmp_mvar_value_12 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_platform);
                                    }

                                    if (tmp_mvar_value_12 == NULL) {

                                        exception_type = PyExc_NameError;
                                        Py_INCREF(exception_type);
                                        exception_value = UNSTREAM_STRING(&constant_bin[ 1686 ], 37, 0);
                                        exception_tb = NULL;

                                        exception_lineno = 1633;
                                        type_description_1 = "ooooo";
                                        goto frame_exception_exit_1;
                                    }

                                    tmp_compexpr_left_13 = tmp_mvar_value_12;
                                    tmp_compexpr_right_13 = const_str_plain_win32;
                                    tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_13, tmp_compexpr_right_13);
                                    if (tmp_res == -1) {
                                        assert(ERROR_OCCURRED());

                                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                                        exception_lineno = 1633;
                                        type_description_1 = "ooooo";
                                        goto frame_exception_exit_1;
                                    }
                                    tmp_condition_result_13 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                                    if (tmp_condition_result_13 == NUITKA_BOOL_TRUE) {
                                        goto branch_yes_13;
                                    } else {
                                        goto branch_no_13;
                                    }
                                    branch_yes_13:;
                                    {
                                        PyObject *tmp_assign_source_2;
                                        PyObject *tmp_subscribed_name_1;
                                        PyObject *tmp_called_instance_8;
                                        PyObject *tmp_mvar_value_13;
                                        PyObject *tmp_subscript_name_1;
                                        tmp_mvar_value_13 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

                                        if (unlikely(tmp_mvar_value_13 == NULL)) {
                                            tmp_mvar_value_13 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
                                        }

                                        if (tmp_mvar_value_13 == NULL) {

                                            exception_type = PyExc_NameError;
                                            Py_INCREF(exception_type);
                                            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                                            exception_tb = NULL;

                                            exception_lineno = 1634;
                                            type_description_1 = "ooooo";
                                            goto frame_exception_exit_1;
                                        }

                                        tmp_called_instance_8 = tmp_mvar_value_13;
                                        frame_ecbdc66f85a0b113e83a292b998563db->m_frame.f_lineno = 1634;
                                        tmp_subscribed_name_1 = CALL_METHOD_NO_ARGS(tmp_called_instance_8, const_str_plain_getwinerror);
                                        if (tmp_subscribed_name_1 == NULL) {
                                            assert(ERROR_OCCURRED());

                                            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                                            exception_lineno = 1634;
                                            type_description_1 = "ooooo";
                                            goto frame_exception_exit_1;
                                        }
                                        tmp_subscript_name_1 = const_int_0;
                                        tmp_assign_source_2 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_1, tmp_subscript_name_1, 0);
                                        Py_DECREF(tmp_subscribed_name_1);
                                        if (tmp_assign_source_2 == NULL) {
                                            assert(ERROR_OCCURRED());

                                            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                                            exception_lineno = 1634;
                                            type_description_1 = "ooooo";
                                            goto frame_exception_exit_1;
                                        }
                                        assert(var_errno == NULL);
                                        var_errno = tmp_assign_source_2;
                                    }
                                    goto branch_end_13;
                                    branch_no_13:;
                                    {
                                        PyObject *tmp_assign_source_3;
                                        PyObject *tmp_source_name_26;
                                        PyObject *tmp_mvar_value_14;
                                        tmp_mvar_value_14 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

                                        if (unlikely(tmp_mvar_value_14 == NULL)) {
                                            tmp_mvar_value_14 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
                                        }

                                        if (tmp_mvar_value_14 == NULL) {

                                            exception_type = PyExc_NameError;
                                            Py_INCREF(exception_type);
                                            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                                            exception_tb = NULL;

                                            exception_lineno = 1636;
                                            type_description_1 = "ooooo";
                                            goto frame_exception_exit_1;
                                        }

                                        tmp_source_name_26 = tmp_mvar_value_14;
                                        tmp_assign_source_3 = LOOKUP_ATTRIBUTE(tmp_source_name_26, const_str_plain_errno);
                                        if (tmp_assign_source_3 == NULL) {
                                            assert(ERROR_OCCURRED());

                                            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                                            exception_lineno = 1636;
                                            type_description_1 = "ooooo";
                                            goto frame_exception_exit_1;
                                        }
                                        assert(var_errno == NULL);
                                        var_errno = tmp_assign_source_3;
                                    }
                                    branch_end_13:;
                                }
                                {
                                    nuitka_bool tmp_condition_result_14;
                                    PyObject *tmp_compexpr_left_14;
                                    PyObject *tmp_compexpr_right_14;
                                    CHECK_OBJECT(var_errno);
                                    tmp_compexpr_left_14 = var_errno;
                                    tmp_compexpr_right_14 = const_int_0;
                                    tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_INT(tmp_compexpr_left_14, tmp_compexpr_right_14);
                                    if (tmp_res == -1) {
                                        assert(ERROR_OCCURRED());

                                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                                        exception_lineno = 1638;
                                        type_description_1 = "ooooo";
                                        goto frame_exception_exit_1;
                                    }
                                    tmp_condition_result_14 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                                    if (tmp_condition_result_14 == NUITKA_BOOL_TRUE) {
                                        goto branch_yes_14;
                                    } else {
                                        goto branch_no_14;
                                    }
                                    branch_yes_14:;
                                    {
                                        PyObject *tmp_raise_type_5;
                                        PyObject *tmp_called_name_5;
                                        PyObject *tmp_mvar_value_15;
                                        PyObject *tmp_args_element_name_3;
                                        PyObject *tmp_args_element_name_4;
                                        PyObject *tmp_called_instance_9;
                                        PyObject *tmp_mvar_value_16;
                                        PyObject *tmp_args_element_name_5;
                                        tmp_mvar_value_15 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SysCallError);

                                        if (unlikely(tmp_mvar_value_15 == NULL)) {
                                            tmp_mvar_value_15 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_SysCallError);
                                        }

                                        if (tmp_mvar_value_15 == NULL) {

                                            exception_type = PyExc_NameError;
                                            Py_INCREF(exception_type);
                                            exception_value = UNSTREAM_STRING(&constant_bin[ 1723 ], 41, 0);
                                            exception_tb = NULL;

                                            exception_lineno = 1639;
                                            type_description_1 = "ooooo";
                                            goto frame_exception_exit_1;
                                        }

                                        tmp_called_name_5 = tmp_mvar_value_15;
                                        CHECK_OBJECT(var_errno);
                                        tmp_args_element_name_3 = var_errno;
                                        tmp_mvar_value_16 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_errorcode);

                                        if (unlikely(tmp_mvar_value_16 == NULL)) {
                                            tmp_mvar_value_16 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_errorcode);
                                        }

                                        if (tmp_mvar_value_16 == NULL) {

                                            exception_type = PyExc_NameError;
                                            Py_INCREF(exception_type);
                                            exception_value = UNSTREAM_STRING(&constant_bin[ 1764 ], 38, 0);
                                            exception_tb = NULL;

                                            exception_lineno = 1639;
                                            type_description_1 = "ooooo";
                                            goto frame_exception_exit_1;
                                        }

                                        tmp_called_instance_9 = tmp_mvar_value_16;
                                        CHECK_OBJECT(var_errno);
                                        tmp_args_element_name_5 = var_errno;
                                        frame_ecbdc66f85a0b113e83a292b998563db->m_frame.f_lineno = 1639;
                                        {
                                            PyObject *call_args[] = {tmp_args_element_name_5};
                                            tmp_args_element_name_4 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_9, const_str_plain_get, call_args);
                                        }

                                        if (tmp_args_element_name_4 == NULL) {
                                            assert(ERROR_OCCURRED());

                                            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                                            exception_lineno = 1639;
                                            type_description_1 = "ooooo";
                                            goto frame_exception_exit_1;
                                        }
                                        frame_ecbdc66f85a0b113e83a292b998563db->m_frame.f_lineno = 1639;
                                        {
                                            PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4};
                                            tmp_raise_type_5 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_5, call_args);
                                        }

                                        Py_DECREF(tmp_args_element_name_4);
                                        if (tmp_raise_type_5 == NULL) {
                                            assert(ERROR_OCCURRED());

                                            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                                            exception_lineno = 1639;
                                            type_description_1 = "ooooo";
                                            goto frame_exception_exit_1;
                                        }
                                        exception_type = tmp_raise_type_5;
                                        exception_lineno = 1639;
                                        RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                                        type_description_1 = "ooooo";
                                        goto frame_exception_exit_1;
                                    }
                                    branch_no_14:;
                                }
                                branch_no_12:;
                            }
                            {
                                PyObject *tmp_raise_type_6;
                                PyObject *tmp_called_name_6;
                                PyObject *tmp_mvar_value_17;
                                tmp_mvar_value_17 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SysCallError);

                                if (unlikely(tmp_mvar_value_17 == NULL)) {
                                    tmp_mvar_value_17 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_SysCallError);
                                }

                                if (tmp_mvar_value_17 == NULL) {

                                    exception_type = PyExc_NameError;
                                    Py_INCREF(exception_type);
                                    exception_value = UNSTREAM_STRING(&constant_bin[ 1723 ], 41, 0);
                                    exception_tb = NULL;

                                    exception_lineno = 1640;
                                    type_description_1 = "ooooo";
                                    goto frame_exception_exit_1;
                                }

                                tmp_called_name_6 = tmp_mvar_value_17;
                                frame_ecbdc66f85a0b113e83a292b998563db->m_frame.f_lineno = 1640;
                                tmp_raise_type_6 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_6, &PyTuple_GET_ITEM(const_tuple_int_neg_1_str_digest_fa91b370bf4aa8601b20ad022c04c7f5_tuple, 0));

                                if (tmp_raise_type_6 == NULL) {
                                    assert(ERROR_OCCURRED());

                                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                                    exception_lineno = 1640;
                                    type_description_1 = "ooooo";
                                    goto frame_exception_exit_1;
                                }
                                exception_type = tmp_raise_type_6;
                                exception_lineno = 1640;
                                RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                                type_description_1 = "ooooo";
                                goto frame_exception_exit_1;
                            }
                            goto branch_end_11;
                            branch_no_11:;
                            {
                                PyObject *tmp_called_name_7;
                                PyObject *tmp_mvar_value_18;
                                PyObject *tmp_call_result_6;
                                tmp_mvar_value_18 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error);

                                if (unlikely(tmp_mvar_value_18 == NULL)) {
                                    tmp_mvar_value_18 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error);
                                }

                                if (tmp_mvar_value_18 == NULL) {

                                    exception_type = PyExc_NameError;
                                    Py_INCREF(exception_type);
                                    exception_value = UNSTREAM_STRING(&constant_bin[ 0 ], 49, 0);
                                    exception_tb = NULL;

                                    exception_lineno = 1643;
                                    type_description_1 = "ooooo";
                                    goto frame_exception_exit_1;
                                }

                                tmp_called_name_7 = tmp_mvar_value_18;
                                frame_ecbdc66f85a0b113e83a292b998563db->m_frame.f_lineno = 1643;
                                tmp_call_result_6 = CALL_FUNCTION_NO_ARGS(tmp_called_name_7);
                                if (tmp_call_result_6 == NULL) {
                                    assert(ERROR_OCCURRED());

                                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                                    exception_lineno = 1643;
                                    type_description_1 = "ooooo";
                                    goto frame_exception_exit_1;
                                }
                                Py_DECREF(tmp_call_result_6);
                            }
                            branch_end_11:;
                        }
                        goto branch_end_10;
                        branch_no_10:;
                        {
                            nuitka_bool tmp_condition_result_15;
                            PyObject *tmp_operand_name_1;
                            PyObject *tmp_compexpr_left_15;
                            PyObject *tmp_compexpr_right_15;
                            PyObject *tmp_source_name_27;
                            PyObject *tmp_mvar_value_19;
                            CHECK_OBJECT(var_error);
                            tmp_compexpr_left_15 = var_error;
                            tmp_mvar_value_19 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

                            if (unlikely(tmp_mvar_value_19 == NULL)) {
                                tmp_mvar_value_19 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
                            }

                            if (tmp_mvar_value_19 == NULL) {

                                exception_type = PyExc_NameError;
                                Py_INCREF(exception_type);
                                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                                exception_tb = NULL;

                                exception_lineno = 1644;
                                type_description_1 = "ooooo";
                                goto frame_exception_exit_1;
                            }

                            tmp_source_name_27 = tmp_mvar_value_19;
                            tmp_compexpr_right_15 = LOOKUP_ATTRIBUTE(tmp_source_name_27, const_str_plain_SSL_ERROR_NONE);
                            if (tmp_compexpr_right_15 == NULL) {
                                assert(ERROR_OCCURRED());

                                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                                exception_lineno = 1644;
                                type_description_1 = "ooooo";
                                goto frame_exception_exit_1;
                            }
                            tmp_operand_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_15, tmp_compexpr_right_15);
                            Py_DECREF(tmp_compexpr_right_15);
                            if (tmp_operand_name_1 == NULL) {
                                assert(ERROR_OCCURRED());

                                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                                exception_lineno = 1644;
                                type_description_1 = "ooooo";
                                goto frame_exception_exit_1;
                            }
                            tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
                            Py_DECREF(tmp_operand_name_1);
                            if (tmp_res == -1) {
                                assert(ERROR_OCCURRED());

                                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                                exception_lineno = 1644;
                                type_description_1 = "ooooo";
                                goto frame_exception_exit_1;
                            }
                            tmp_condition_result_15 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                            if (tmp_condition_result_15 == NUITKA_BOOL_TRUE) {
                                goto branch_yes_15;
                            } else {
                                goto branch_no_15;
                            }
                            branch_yes_15:;
                            {
                                PyObject *tmp_called_name_8;
                                PyObject *tmp_mvar_value_20;
                                PyObject *tmp_call_result_7;
                                tmp_mvar_value_20 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error);

                                if (unlikely(tmp_mvar_value_20 == NULL)) {
                                    tmp_mvar_value_20 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error);
                                }

                                if (tmp_mvar_value_20 == NULL) {

                                    exception_type = PyExc_NameError;
                                    Py_INCREF(exception_type);
                                    exception_value = UNSTREAM_STRING(&constant_bin[ 0 ], 49, 0);
                                    exception_tb = NULL;

                                    exception_lineno = 1647;
                                    type_description_1 = "ooooo";
                                    goto frame_exception_exit_1;
                                }

                                tmp_called_name_8 = tmp_mvar_value_20;
                                frame_ecbdc66f85a0b113e83a292b998563db->m_frame.f_lineno = 1647;
                                tmp_call_result_7 = CALL_FUNCTION_NO_ARGS(tmp_called_name_8);
                                if (tmp_call_result_7 == NULL) {
                                    assert(ERROR_OCCURRED());

                                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                                    exception_lineno = 1647;
                                    type_description_1 = "ooooo";
                                    goto frame_exception_exit_1;
                                }
                                Py_DECREF(tmp_call_result_7);
                            }
                            branch_no_15:;
                        }
                        branch_end_10:;
                    }
                    branch_end_9:;
                }
                branch_end_8:;
            }
            branch_end_7:;
        }
        branch_end_6:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ecbdc66f85a0b113e83a292b998563db);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ecbdc66f85a0b113e83a292b998563db);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_ecbdc66f85a0b113e83a292b998563db, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_ecbdc66f85a0b113e83a292b998563db->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_ecbdc66f85a0b113e83a292b998563db, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ecbdc66f85a0b113e83a292b998563db,
        type_description_1,
        par_self,
        par_ssl,
        par_result,
        var_errno,
        var_error
    );


    // Release cached frame.
    if (frame_ecbdc66f85a0b113e83a292b998563db == cache_frame_ecbdc66f85a0b113e83a292b998563db) {
        Py_DECREF(frame_ecbdc66f85a0b113e83a292b998563db);
    }
    cache_frame_ecbdc66f85a0b113e83a292b998563db = NULL;

    assertFrameObject(frame_ecbdc66f85a0b113e83a292b998563db);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_59__raise_ssl_error);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_error);
    Py_DECREF(var_error);
    var_error = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_errno);
    var_errno = NULL;

    Py_XDECREF(var_error);
    var_error = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_59__raise_ssl_error);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_ssl);
    Py_DECREF(par_ssl);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_result);
    Py_DECREF(par_result);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_ssl);
    Py_DECREF(par_ssl);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_result);
    Py_DECREF(par_result);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_60_get_context(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_85b9d973a13dac4e475a6908180fcbd0;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_85b9d973a13dac4e475a6908180fcbd0 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_85b9d973a13dac4e475a6908180fcbd0, codeobj_85b9d973a13dac4e475a6908180fcbd0, module_OpenSSL$SSL, sizeof(void *));
    frame_85b9d973a13dac4e475a6908180fcbd0 = cache_frame_85b9d973a13dac4e475a6908180fcbd0;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_85b9d973a13dac4e475a6908180fcbd0);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_85b9d973a13dac4e475a6908180fcbd0) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_return_value = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__context);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1654;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_85b9d973a13dac4e475a6908180fcbd0);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_85b9d973a13dac4e475a6908180fcbd0);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_85b9d973a13dac4e475a6908180fcbd0);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_85b9d973a13dac4e475a6908180fcbd0, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_85b9d973a13dac4e475a6908180fcbd0->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_85b9d973a13dac4e475a6908180fcbd0, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_85b9d973a13dac4e475a6908180fcbd0,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_85b9d973a13dac4e475a6908180fcbd0 == cache_frame_85b9d973a13dac4e475a6908180fcbd0) {
        Py_DECREF(frame_85b9d973a13dac4e475a6908180fcbd0);
    }
    cache_frame_85b9d973a13dac4e475a6908180fcbd0 = NULL;

    assertFrameObject(frame_85b9d973a13dac4e475a6908180fcbd0);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_60_get_context);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_61_set_context(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_context = python_pars[1];
    struct Nuitka_FrameObject *frame_b2045a22f86b32602807c3a9b9a1b9a9;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_b2045a22f86b32602807c3a9b9a1b9a9 = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_b2045a22f86b32602807c3a9b9a1b9a9, codeobj_b2045a22f86b32602807c3a9b9a1b9a9, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *));
    frame_b2045a22f86b32602807c3a9b9a1b9a9 = cache_frame_b2045a22f86b32602807c3a9b9a1b9a9;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_b2045a22f86b32602807c3a9b9a1b9a9);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_b2045a22f86b32602807c3a9b9a1b9a9) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_context);
        tmp_isinstance_inst_1 = par_context;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Context);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_Context);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1427 ], 36, 0);
            exception_tb = NULL;

            exception_lineno = 1663;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1663;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1663;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_627e1a07a1a60af86ff9e544428f2f09;
            frame_b2045a22f86b32602807c3a9b9a1b9a9->m_frame.f_lineno = 1664;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1664;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1666;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_set_SSL_CTX);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1666;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__ssl);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1666;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_context);
        tmp_source_name_3 = par_context;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__context);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_element_name_1);

            exception_lineno = 1666;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_b2045a22f86b32602807c3a9b9a1b9a9->m_frame.f_lineno = 1666;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1666;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_context);
        tmp_assattr_name_1 = par_context;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__context, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1667;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b2045a22f86b32602807c3a9b9a1b9a9);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b2045a22f86b32602807c3a9b9a1b9a9);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_b2045a22f86b32602807c3a9b9a1b9a9, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_b2045a22f86b32602807c3a9b9a1b9a9->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_b2045a22f86b32602807c3a9b9a1b9a9, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b2045a22f86b32602807c3a9b9a1b9a9,
        type_description_1,
        par_self,
        par_context
    );


    // Release cached frame.
    if (frame_b2045a22f86b32602807c3a9b9a1b9a9 == cache_frame_b2045a22f86b32602807c3a9b9a1b9a9) {
        Py_DECREF(frame_b2045a22f86b32602807c3a9b9a1b9a9);
    }
    cache_frame_b2045a22f86b32602807c3a9b9a1b9a9 = NULL;

    assertFrameObject(frame_b2045a22f86b32602807c3a9b9a1b9a9);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_61_set_context);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_context);
    Py_DECREF(par_context);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_context);
    Py_DECREF(par_context);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_62_get_servername(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_name = NULL;
    struct Nuitka_FrameObject *frame_4b891c2de54665c165f85dce04cb4cb8;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_4b891c2de54665c165f85dce04cb4cb8 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_4b891c2de54665c165f85dce04cb4cb8, codeobj_4b891c2de54665c165f85dce04cb4cb8, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *));
    frame_4b891c2de54665c165f85dce04cb4cb8 = cache_frame_4b891c2de54665c165f85dce04cb4cb8;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_4b891c2de54665c165f85dce04cb4cb8);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_4b891c2de54665c165f85dce04cb4cb8) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1679;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_get_servername);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1679;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__ssl);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1680;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_element_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1680;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_TLSEXT_NAMETYPE_host_name);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_element_name_1);

            exception_lineno = 1680;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_4b891c2de54665c165f85dce04cb4cb8->m_frame.f_lineno = 1679;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1679;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert(var_name == NULL);
        var_name = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_3;
        CHECK_OBJECT(var_name);
        tmp_compexpr_left_1 = var_name;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1682;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_3;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_NULL);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1682;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1682;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_None;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1685;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_4;
        CHECK_OBJECT(var_name);
        tmp_args_element_name_3 = var_name;
        frame_4b891c2de54665c165f85dce04cb4cb8->m_frame.f_lineno = 1685;
        {
            PyObject *call_args[] = {tmp_args_element_name_3};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_string, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1685;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_4b891c2de54665c165f85dce04cb4cb8);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_4b891c2de54665c165f85dce04cb4cb8);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_4b891c2de54665c165f85dce04cb4cb8);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_4b891c2de54665c165f85dce04cb4cb8, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_4b891c2de54665c165f85dce04cb4cb8->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_4b891c2de54665c165f85dce04cb4cb8, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4b891c2de54665c165f85dce04cb4cb8,
        type_description_1,
        par_self,
        var_name
    );


    // Release cached frame.
    if (frame_4b891c2de54665c165f85dce04cb4cb8 == cache_frame_4b891c2de54665c165f85dce04cb4cb8) {
        Py_DECREF(frame_4b891c2de54665c165f85dce04cb4cb8);
    }
    cache_frame_4b891c2de54665c165f85dce04cb4cb8 = NULL;

    assertFrameObject(frame_4b891c2de54665c165f85dce04cb4cb8);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_62_get_servername);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_name);
    Py_DECREF(var_name);
    var_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_name);
    var_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_62_get_servername);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_63_set_tlsext_host_name(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_name = python_pars[1];
    struct Nuitka_FrameObject *frame_e3c8ae13ac9eb0f32a9b6fc044804d84;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_e3c8ae13ac9eb0f32a9b6fc044804d84 = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_e3c8ae13ac9eb0f32a9b6fc044804d84, codeobj_e3c8ae13ac9eb0f32a9b6fc044804d84, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *));
    frame_e3c8ae13ac9eb0f32a9b6fc044804d84 = cache_frame_e3c8ae13ac9eb0f32a9b6fc044804d84;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_e3c8ae13ac9eb0f32a9b6fc044804d84);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_e3c8ae13ac9eb0f32a9b6fc044804d84) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        CHECK_OBJECT(par_name);
        tmp_isinstance_inst_1 = par_name;
        tmp_isinstance_cls_1 = (PyObject *)&PyString_Type;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1696;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1696;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_d89a36d0b4664ac4178af2071f30652f;
            frame_e3c8ae13ac9eb0f32a9b6fc044804d84->m_frame.f_lineno = 1697;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1697;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_1;
            PyObject *tmp_compexpr_right_1;
            tmp_compexpr_left_1 = const_str_chr_0;
            CHECK_OBJECT(par_name);
            tmp_compexpr_right_1 = par_name;
            tmp_res = PySequence_Contains(tmp_compexpr_right_1, tmp_compexpr_left_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1698;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
                goto branch_yes_2;
            } else {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_raise_type_2;
                PyObject *tmp_make_exception_arg_2;
                tmp_make_exception_arg_2 = const_str_digest_b965e7ab82e8e0c92ec2736091bc1c12;
                frame_e3c8ae13ac9eb0f32a9b6fc044804d84->m_frame.f_lineno = 1699;
                tmp_raise_type_2 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_2);
                assert(!(tmp_raise_type_2 == NULL));
                exception_type = tmp_raise_type_2;
                exception_lineno = 1699;
                RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            branch_no_2:;
        }
        branch_end_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1702;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_set_tlsext_host_name);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1702;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__ssl);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1702;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_name);
        tmp_args_element_name_2 = par_name;
        frame_e3c8ae13ac9eb0f32a9b6fc044804d84->m_frame.f_lineno = 1702;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1702;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e3c8ae13ac9eb0f32a9b6fc044804d84);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e3c8ae13ac9eb0f32a9b6fc044804d84);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_e3c8ae13ac9eb0f32a9b6fc044804d84, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_e3c8ae13ac9eb0f32a9b6fc044804d84->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_e3c8ae13ac9eb0f32a9b6fc044804d84, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e3c8ae13ac9eb0f32a9b6fc044804d84,
        type_description_1,
        par_self,
        par_name
    );


    // Release cached frame.
    if (frame_e3c8ae13ac9eb0f32a9b6fc044804d84 == cache_frame_e3c8ae13ac9eb0f32a9b6fc044804d84) {
        Py_DECREF(frame_e3c8ae13ac9eb0f32a9b6fc044804d84);
    }
    cache_frame_e3c8ae13ac9eb0f32a9b6fc044804d84 = NULL;

    assertFrameObject(frame_e3c8ae13ac9eb0f32a9b6fc044804d84);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_63_set_tlsext_host_name);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_name);
    Py_DECREF(par_name);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_name);
    Py_DECREF(par_name);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_64_pending(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_b6d73ec0251ecf129f902466d7d1010b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_b6d73ec0251ecf129f902466d7d1010b = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_b6d73ec0251ecf129f902466d7d1010b, codeobj_b6d73ec0251ecf129f902466d7d1010b, module_OpenSSL$SSL, sizeof(void *));
    frame_b6d73ec0251ecf129f902466d7d1010b = cache_frame_b6d73ec0251ecf129f902466d7d1010b;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_b6d73ec0251ecf129f902466d7d1010b);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_b6d73ec0251ecf129f902466d7d1010b) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1711;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_pending);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1711;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__ssl);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1711;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_b6d73ec0251ecf129f902466d7d1010b->m_frame.f_lineno = 1711;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1711;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b6d73ec0251ecf129f902466d7d1010b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_b6d73ec0251ecf129f902466d7d1010b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b6d73ec0251ecf129f902466d7d1010b);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_b6d73ec0251ecf129f902466d7d1010b, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_b6d73ec0251ecf129f902466d7d1010b->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_b6d73ec0251ecf129f902466d7d1010b, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b6d73ec0251ecf129f902466d7d1010b,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_b6d73ec0251ecf129f902466d7d1010b == cache_frame_b6d73ec0251ecf129f902466d7d1010b) {
        Py_DECREF(frame_b6d73ec0251ecf129f902466d7d1010b);
    }
    cache_frame_b6d73ec0251ecf129f902466d7d1010b = NULL;

    assertFrameObject(frame_b6d73ec0251ecf129f902466d7d1010b);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_64_pending);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_65_send(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_buf = python_pars[1];
    PyObject *par_flags = python_pars[2];
    PyObject *var_result = NULL;
    struct Nuitka_FrameObject *frame_c3dfbb3b28d031b8f3e3ccaa5745dfa1;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_c3dfbb3b28d031b8f3e3ccaa5745dfa1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_c3dfbb3b28d031b8f3e3ccaa5745dfa1, codeobj_c3dfbb3b28d031b8f3e3ccaa5745dfa1, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_c3dfbb3b28d031b8f3e3ccaa5745dfa1 = cache_frame_c3dfbb3b28d031b8f3e3ccaa5745dfa1;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_c3dfbb3b28d031b8f3e3ccaa5745dfa1);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_c3dfbb3b28d031b8f3e3ccaa5745dfa1) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1011 ], 52, 0);
            exception_tb = NULL;

            exception_lineno = 1725;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        tmp_args_element_name_1 = const_str_plain_buf;
        CHECK_OBJECT(par_buf);
        tmp_args_element_name_2 = par_buf;
        frame_c3dfbb3b28d031b8f3e3ccaa5745dfa1->m_frame.f_lineno = 1725;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1725;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = par_buf;
            assert(old != NULL);
            par_buf = tmp_assign_source_1;
            Py_DECREF(old);
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        CHECK_OBJECT(par_buf);
        tmp_isinstance_inst_1 = par_buf;
        tmp_isinstance_cls_1 = (PyObject *)&PyMemoryView_Type;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1727;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_called_instance_1;
            CHECK_OBJECT(par_buf);
            tmp_called_instance_1 = par_buf;
            frame_c3dfbb3b28d031b8f3e3ccaa5745dfa1->m_frame.f_lineno = 1728;
            tmp_assign_source_2 = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_tobytes);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1728;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_buf;
                assert(old != NULL);
                par_buf = tmp_assign_source_2;
                Py_DECREF(old);
            }

        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_isinstance_inst_2;
        PyObject *tmp_isinstance_cls_2;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT(par_buf);
        tmp_isinstance_inst_2 = par_buf;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__buffer);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__buffer);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1802 ], 36, 0);
            exception_tb = NULL;

            exception_lineno = 1729;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_2 = tmp_mvar_value_2;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_2, tmp_isinstance_cls_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1729;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_str_arg_1;
            CHECK_OBJECT(par_buf);
            tmp_str_arg_1 = par_buf;
            tmp_assign_source_3 = PyObject_Str(tmp_str_arg_1);
            if (tmp_assign_source_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1730;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_buf;
                assert(old != NULL);
                par_buf = tmp_assign_source_3;
                Py_DECREF(old);
            }

        }
        branch_no_2:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_3;
        PyObject *tmp_isinstance_cls_3;
        if (par_buf == NULL) {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("local variable '%s' referenced before assignment", "buf");
            exception_tb = NULL;

            exception_lineno = 1731;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_inst_3 = par_buf;
        tmp_isinstance_cls_3 = (PyObject *)&PyString_Type;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_3, tmp_isinstance_cls_3);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1731;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1731;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
            goto branch_yes_3;
        } else {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_e0c534afee902e78ce11df02f380dfa7;
            frame_c3dfbb3b28d031b8f3e3ccaa5745dfa1->m_frame.f_lineno = 1732;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1732;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        branch_no_3:;
    }
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_len_arg_1;
        if (par_buf == NULL) {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("local variable '%s' referenced before assignment", "buf");
            exception_tb = NULL;

            exception_lineno = 1733;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_len_arg_1 = par_buf;
        tmp_compexpr_left_1 = BUILTIN_LEN(tmp_len_arg_1);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1733;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = const_int_pos_2147483647;
        tmp_res = RICH_COMPARE_BOOL_GT_OBJECT_INT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        assert(!(tmp_res == -1));
        tmp_condition_result_4 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_4 == NUITKA_BOOL_TRUE) {
            goto branch_yes_4;
        } else {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            tmp_make_exception_arg_2 = const_str_digest_8cde8912e8f2207155a1addb0752791f;
            frame_c3dfbb3b28d031b8f3e3ccaa5745dfa1->m_frame.f_lineno = 1734;
            tmp_raise_type_2 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_2);
            assert(!(tmp_raise_type_2 == NULL));
            exception_type = tmp_raise_type_2;
            exception_lineno = 1734;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        branch_no_4:;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_len_arg_2;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1736;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_3;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_write);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1736;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__ssl);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 1736;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        if (par_buf == NULL) {
            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_3);
            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("local variable '%s' referenced before assignment", "buf");
            exception_tb = NULL;

            exception_lineno = 1736;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_4 = par_buf;
        if (par_buf == NULL) {
            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_3);
            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("local variable '%s' referenced before assignment", "buf");
            exception_tb = NULL;

            exception_lineno = 1736;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_len_arg_2 = par_buf;
        tmp_args_element_name_5 = BUILTIN_LEN(tmp_len_arg_2);
        if (tmp_args_element_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_3);

            exception_lineno = 1736;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_c3dfbb3b28d031b8f3e3ccaa5745dfa1->m_frame.f_lineno = 1736;
        {
            PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5};
            tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_3);
        Py_DECREF(tmp_args_element_name_5);
        if (tmp_assign_source_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1736;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_result == NULL);
        var_result = tmp_assign_source_4;
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_source_name_4;
        PyObject *tmp_args_element_name_7;
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__raise_ssl_error);
        if (tmp_called_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1737;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_4 = par_self;
        tmp_args_element_name_6 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain__ssl);
        if (tmp_args_element_name_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);

            exception_lineno = 1737;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_result);
        tmp_args_element_name_7 = var_result;
        frame_c3dfbb3b28d031b8f3e3ccaa5745dfa1->m_frame.f_lineno = 1737;
        {
            PyObject *call_args[] = {tmp_args_element_name_6, tmp_args_element_name_7};
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_3, call_args);
        }

        Py_DECREF(tmp_called_name_3);
        Py_DECREF(tmp_args_element_name_6);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1737;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c3dfbb3b28d031b8f3e3ccaa5745dfa1);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c3dfbb3b28d031b8f3e3ccaa5745dfa1);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_c3dfbb3b28d031b8f3e3ccaa5745dfa1, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_c3dfbb3b28d031b8f3e3ccaa5745dfa1->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_c3dfbb3b28d031b8f3e3ccaa5745dfa1, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c3dfbb3b28d031b8f3e3ccaa5745dfa1,
        type_description_1,
        par_self,
        par_buf,
        par_flags,
        var_result
    );


    // Release cached frame.
    if (frame_c3dfbb3b28d031b8f3e3ccaa5745dfa1 == cache_frame_c3dfbb3b28d031b8f3e3ccaa5745dfa1) {
        Py_DECREF(frame_c3dfbb3b28d031b8f3e3ccaa5745dfa1);
    }
    cache_frame_c3dfbb3b28d031b8f3e3ccaa5745dfa1 = NULL;

    assertFrameObject(frame_c3dfbb3b28d031b8f3e3ccaa5745dfa1);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT(var_result);
    tmp_return_value = var_result;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_65_send);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(par_buf);
    par_buf = NULL;

    CHECK_OBJECT((PyObject *)var_result);
    Py_DECREF(var_result);
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(par_buf);
    par_buf = NULL;

    Py_XDECREF(var_result);
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_65_send);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_flags);
    Py_DECREF(par_flags);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_flags);
    Py_DECREF(par_flags);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_66_sendall(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_buf = python_pars[1];
    PyObject *par_flags = python_pars[2];
    PyObject *var_left_to_send = NULL;
    PyObject *var_data = NULL;
    PyObject *var_result = NULL;
    PyObject *var_total_sent = NULL;
    struct Nuitka_FrameObject *frame_b9ad0ac22cd13b3cff0f4d819d0dee45;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_b9ad0ac22cd13b3cff0f4d819d0dee45 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_b9ad0ac22cd13b3cff0f4d819d0dee45, codeobj_b9ad0ac22cd13b3cff0f4d819d0dee45, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_b9ad0ac22cd13b3cff0f4d819d0dee45 = cache_frame_b9ad0ac22cd13b3cff0f4d819d0dee45;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_b9ad0ac22cd13b3cff0f4d819d0dee45);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_b9ad0ac22cd13b3cff0f4d819d0dee45) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1011 ], 52, 0);
            exception_tb = NULL;

            exception_lineno = 1752;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        tmp_args_element_name_1 = const_str_plain_buf;
        CHECK_OBJECT(par_buf);
        tmp_args_element_name_2 = par_buf;
        frame_b9ad0ac22cd13b3cff0f4d819d0dee45->m_frame.f_lineno = 1752;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1752;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = par_buf;
            assert(old != NULL);
            par_buf = tmp_assign_source_1;
            Py_DECREF(old);
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        CHECK_OBJECT(par_buf);
        tmp_isinstance_inst_1 = par_buf;
        tmp_isinstance_cls_1 = (PyObject *)&PyMemoryView_Type;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1754;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_called_instance_1;
            CHECK_OBJECT(par_buf);
            tmp_called_instance_1 = par_buf;
            frame_b9ad0ac22cd13b3cff0f4d819d0dee45->m_frame.f_lineno = 1755;
            tmp_assign_source_2 = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_tobytes);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1755;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_buf;
                assert(old != NULL);
                par_buf = tmp_assign_source_2;
                Py_DECREF(old);
            }

        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_isinstance_inst_2;
        PyObject *tmp_isinstance_cls_2;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT(par_buf);
        tmp_isinstance_inst_2 = par_buf;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__buffer);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__buffer);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1802 ], 36, 0);
            exception_tb = NULL;

            exception_lineno = 1756;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_2 = tmp_mvar_value_2;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_2, tmp_isinstance_cls_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1756;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_str_arg_1;
            CHECK_OBJECT(par_buf);
            tmp_str_arg_1 = par_buf;
            tmp_assign_source_3 = PyObject_Str(tmp_str_arg_1);
            if (tmp_assign_source_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1757;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_buf;
                assert(old != NULL);
                par_buf = tmp_assign_source_3;
                Py_DECREF(old);
            }

        }
        branch_no_2:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_3;
        PyObject *tmp_isinstance_cls_3;
        if (par_buf == NULL) {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("local variable '%s' referenced before assignment", "buf");
            exception_tb = NULL;

            exception_lineno = 1758;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_inst_3 = par_buf;
        tmp_isinstance_cls_3 = (PyObject *)&PyString_Type;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_3, tmp_isinstance_cls_3);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1758;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1758;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
            goto branch_yes_3;
        } else {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_f64bec1377ff9f22e4ed4c823f6a5647;
            frame_b9ad0ac22cd13b3cff0f4d819d0dee45->m_frame.f_lineno = 1759;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1759;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_3:;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_len_arg_1;
        if (par_buf == NULL) {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("local variable '%s' referenced before assignment", "buf");
            exception_tb = NULL;

            exception_lineno = 1761;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_len_arg_1 = par_buf;
        tmp_assign_source_4 = BUILTIN_LEN(tmp_len_arg_1);
        if (tmp_assign_source_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1761;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_left_to_send == NULL);
        var_left_to_send = tmp_assign_source_4;
    }
    {
        PyObject *tmp_assign_source_5;
        tmp_assign_source_5 = const_int_0;
        assert(var_total_sent == NULL);
        Py_INCREF(tmp_assign_source_5);
        var_total_sent = tmp_assign_source_5;
    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1763;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_3;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_new);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1763;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = const_str_digest_c561652c58984ec0e9541542aa405594;
        if (par_buf == NULL) {
            Py_DECREF(tmp_called_name_2);
            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyString_FromFormat("local variable '%s' referenced before assignment", "buf");
            exception_tb = NULL;

            exception_lineno = 1763;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_4 = par_buf;
        frame_b9ad0ac22cd13b3cff0f4d819d0dee45->m_frame.f_lineno = 1763;
        {
            PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4};
            tmp_assign_source_6 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        if (tmp_assign_source_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1763;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_data == NULL);
        var_data = tmp_assign_source_6;
    }
    loop_start_1:;
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_operand_name_2;
        CHECK_OBJECT(var_left_to_send);
        tmp_operand_name_2 = var_left_to_send;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1765;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_4 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_4 == NUITKA_BOOL_TRUE) {
            goto branch_yes_4;
        } else {
            goto branch_no_4;
        }
        branch_yes_4:;
        goto loop_end_1;
        branch_no_4:;
    }
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_3;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_called_name_4;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_args_element_name_9;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1768;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_4;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_SSL_write);
        if (tmp_called_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1768;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__ssl);
        if (tmp_args_element_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);

            exception_lineno = 1769;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_data);
        tmp_left_name_1 = var_data;
        CHECK_OBJECT(var_total_sent);
        tmp_right_name_1 = var_total_sent;
        tmp_args_element_name_6 = BINARY_OPERATION_ADD_OBJECT_OBJECT(tmp_left_name_1, tmp_right_name_1);
        if (tmp_args_element_name_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);
            Py_DECREF(tmp_args_element_name_5);

            exception_lineno = 1770;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_called_name_4 = LOOKUP_BUILTIN(const_str_plain_min);
        assert(tmp_called_name_4 != NULL);
        CHECK_OBJECT(var_left_to_send);
        tmp_args_element_name_8 = var_left_to_send;
        tmp_args_element_name_9 = const_int_pos_2147483647;
        frame_b9ad0ac22cd13b3cff0f4d819d0dee45->m_frame.f_lineno = 1771;
        {
            PyObject *call_args[] = {tmp_args_element_name_8, tmp_args_element_name_9};
            tmp_args_element_name_7 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_4, call_args);
        }

        if (tmp_args_element_name_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);
            Py_DECREF(tmp_args_element_name_5);
            Py_DECREF(tmp_args_element_name_6);

            exception_lineno = 1771;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        frame_b9ad0ac22cd13b3cff0f4d819d0dee45->m_frame.f_lineno = 1768;
        {
            PyObject *call_args[] = {tmp_args_element_name_5, tmp_args_element_name_6, tmp_args_element_name_7};
            tmp_assign_source_7 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_3, call_args);
        }

        Py_DECREF(tmp_called_name_3);
        Py_DECREF(tmp_args_element_name_5);
        Py_DECREF(tmp_args_element_name_6);
        Py_DECREF(tmp_args_element_name_7);
        if (tmp_assign_source_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1768;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var_result;
            var_result = tmp_assign_source_7;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_called_name_5;
        PyObject *tmp_source_name_4;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_source_name_5;
        PyObject *tmp_args_element_name_11;
        CHECK_OBJECT(par_self);
        tmp_source_name_4 = par_self;
        tmp_called_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain__raise_ssl_error);
        if (tmp_called_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1773;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_5 = par_self;
        tmp_args_element_name_10 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain__ssl);
        if (tmp_args_element_name_10 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_5);

            exception_lineno = 1773;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_result);
        tmp_args_element_name_11 = var_result;
        frame_b9ad0ac22cd13b3cff0f4d819d0dee45->m_frame.f_lineno = 1773;
        {
            PyObject *call_args[] = {tmp_args_element_name_10, tmp_args_element_name_11};
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_5, call_args);
        }

        Py_DECREF(tmp_called_name_5);
        Py_DECREF(tmp_args_element_name_10);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1773;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_assign_source_8;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_2;
        CHECK_OBJECT(var_total_sent);
        tmp_left_name_2 = var_total_sent;
        CHECK_OBJECT(var_result);
        tmp_right_name_2 = var_result;
        tmp_result = BINARY_OPERATION_ADD_OBJECT_OBJECT_INPLACE(&tmp_left_name_2, tmp_right_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1774;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_8 = tmp_left_name_2;
        var_total_sent = tmp_assign_source_8;

    }
    {
        PyObject *tmp_assign_source_9;
        PyObject *tmp_left_name_3;
        PyObject *tmp_right_name_3;
        CHECK_OBJECT(var_left_to_send);
        tmp_left_name_3 = var_left_to_send;
        CHECK_OBJECT(var_result);
        tmp_right_name_3 = var_result;
        tmp_result = BINARY_OPERATION_INPLACE(PyNumber_InPlaceSubtract, &tmp_left_name_3, tmp_right_name_3);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1775;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_9 = tmp_left_name_3;
        var_left_to_send = tmp_assign_source_9;

    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


        exception_lineno = 1765;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    goto loop_start_1;
    loop_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b9ad0ac22cd13b3cff0f4d819d0dee45);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b9ad0ac22cd13b3cff0f4d819d0dee45);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_b9ad0ac22cd13b3cff0f4d819d0dee45, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_b9ad0ac22cd13b3cff0f4d819d0dee45->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_b9ad0ac22cd13b3cff0f4d819d0dee45, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b9ad0ac22cd13b3cff0f4d819d0dee45,
        type_description_1,
        par_self,
        par_buf,
        par_flags,
        var_left_to_send,
        var_data,
        var_result,
        var_total_sent
    );


    // Release cached frame.
    if (frame_b9ad0ac22cd13b3cff0f4d819d0dee45 == cache_frame_b9ad0ac22cd13b3cff0f4d819d0dee45) {
        Py_DECREF(frame_b9ad0ac22cd13b3cff0f4d819d0dee45);
    }
    cache_frame_b9ad0ac22cd13b3cff0f4d819d0dee45 = NULL;

    assertFrameObject(frame_b9ad0ac22cd13b3cff0f4d819d0dee45);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_66_sendall);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_left_to_send);
    Py_DECREF(var_left_to_send);
    var_left_to_send = NULL;

    CHECK_OBJECT((PyObject *)var_data);
    Py_DECREF(var_data);
    var_data = NULL;

    Py_XDECREF(var_result);
    var_result = NULL;

    CHECK_OBJECT((PyObject *)var_total_sent);
    Py_DECREF(var_total_sent);
    var_total_sent = NULL;

    Py_XDECREF(par_buf);
    par_buf = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_left_to_send);
    var_left_to_send = NULL;

    Py_XDECREF(var_data);
    var_data = NULL;

    Py_XDECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_total_sent);
    var_total_sent = NULL;

    Py_XDECREF(par_buf);
    par_buf = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_66_sendall);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_flags);
    Py_DECREF(par_flags);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_flags);
    Py_DECREF(par_flags);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_67_recv(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_bufsiz = python_pars[1];
    PyObject *par_flags = python_pars[2];
    PyObject *var_buf = NULL;
    PyObject *var_result = NULL;
    struct Nuitka_FrameObject *frame_97860a8503a242ea2870dd155ed6cf25;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_97860a8503a242ea2870dd155ed6cf25 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_97860a8503a242ea2870dd155ed6cf25, codeobj_97860a8503a242ea2870dd155ed6cf25, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_97860a8503a242ea2870dd155ed6cf25 = cache_frame_97860a8503a242ea2870dd155ed6cf25;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_97860a8503a242ea2870dd155ed6cf25);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_97860a8503a242ea2870dd155ed6cf25) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__no_zero_allocator);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__no_zero_allocator);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1838 ], 47, 0);
            exception_tb = NULL;

            exception_lineno = 1786;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        tmp_args_element_name_1 = const_str_digest_c561652c58984ec0e9541542aa405594;
        CHECK_OBJECT(par_bufsiz);
        tmp_args_element_name_2 = par_bufsiz;
        frame_97860a8503a242ea2870dd155ed6cf25->m_frame.f_lineno = 1786;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1786;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(var_buf == NULL);
        var_buf = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_and_left_truth_1;
        nuitka_bool tmp_and_left_value_1;
        nuitka_bool tmp_and_right_value_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_op_bitand_res_1;
        int tmp_truth_name_1;
        CHECK_OBJECT(par_flags);
        tmp_compexpr_left_1 = par_flags;
        tmp_compexpr_right_1 = Py_None;
        tmp_and_left_value_1 = (tmp_compexpr_left_1 != tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if (tmp_and_left_truth_1 == 1) {
            goto and_right_1;
        } else {
            goto and_left_1;
        }
        and_right_1:;
        CHECK_OBJECT(par_flags);
        tmp_left_name_1 = par_flags;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_socket);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_socket);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1885 ], 35, 0);
            exception_tb = NULL;

            exception_lineno = 1787;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_right_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_MSG_PEEK);
        if (tmp_right_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1787;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_op_bitand_res_1 = BINARY_OPERATION_BITAND_OBJECT_OBJECT(tmp_left_name_1, tmp_right_name_1);
        Py_DECREF(tmp_right_name_1);
        if (tmp_op_bitand_res_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1787;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE(tmp_op_bitand_res_1);
        if (tmp_truth_name_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_op_bitand_res_1);

            exception_lineno = 1787;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_op_bitand_res_1);
        tmp_condition_result_1 = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_condition_result_1 = tmp_and_left_value_1;
        and_end_1:;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_2;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_source_name_3;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_args_element_name_5;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_3 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1788;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_2 = tmp_mvar_value_3;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_SSL_peek);
            if (tmp_called_name_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1788;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(par_self);
            tmp_source_name_3 = par_self;
            tmp_args_element_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__ssl);
            if (tmp_args_element_name_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_2);

                exception_lineno = 1788;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_buf);
            tmp_args_element_name_4 = var_buf;
            CHECK_OBJECT(par_bufsiz);
            tmp_args_element_name_5 = par_bufsiz;
            frame_97860a8503a242ea2870dd155ed6cf25->m_frame.f_lineno = 1788;
            {
                PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5};
                tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_2, call_args);
            }

            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_3);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1788;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            assert(var_result == NULL);
            var_result = tmp_assign_source_2;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_called_name_3;
            PyObject *tmp_source_name_4;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_args_element_name_6;
            PyObject *tmp_source_name_5;
            PyObject *tmp_args_element_name_7;
            PyObject *tmp_args_element_name_8;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_4 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1790;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_4 = tmp_mvar_value_4;
            tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_SSL_read);
            if (tmp_called_name_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1790;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(par_self);
            tmp_source_name_5 = par_self;
            tmp_args_element_name_6 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain__ssl);
            if (tmp_args_element_name_6 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_3);

                exception_lineno = 1790;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_buf);
            tmp_args_element_name_7 = var_buf;
            CHECK_OBJECT(par_bufsiz);
            tmp_args_element_name_8 = par_bufsiz;
            frame_97860a8503a242ea2870dd155ed6cf25->m_frame.f_lineno = 1790;
            {
                PyObject *call_args[] = {tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8};
                tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_3, call_args);
            }

            Py_DECREF(tmp_called_name_3);
            Py_DECREF(tmp_args_element_name_6);
            if (tmp_assign_source_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1790;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            assert(var_result == NULL);
            var_result = tmp_assign_source_3;
        }
        branch_end_1:;
    }
    {
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_6;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_source_name_7;
        PyObject *tmp_args_element_name_10;
        CHECK_OBJECT(par_self);
        tmp_source_name_6 = par_self;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain__raise_ssl_error);
        if (tmp_called_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1791;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_7 = par_self;
        tmp_args_element_name_9 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain__ssl);
        if (tmp_args_element_name_9 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_4);

            exception_lineno = 1791;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_result);
        tmp_args_element_name_10 = var_result;
        frame_97860a8503a242ea2870dd155ed6cf25->m_frame.f_lineno = 1791;
        {
            PyObject *call_args[] = {tmp_args_element_name_9, tmp_args_element_name_10};
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_4, call_args);
        }

        Py_DECREF(tmp_called_name_4);
        Py_DECREF(tmp_args_element_name_9);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1791;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        Py_ssize_t tmp_sliceslicedel_index_lower_1;
        Py_ssize_t tmp_slice_index_upper_1;
        PyObject *tmp_slice_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_11;
        PyObject *tmp_args_element_name_12;
        tmp_sliceslicedel_index_lower_1 = 0;
        tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1792;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_5;
        CHECK_OBJECT(var_buf);
        tmp_args_element_name_11 = var_buf;
        CHECK_OBJECT(var_result);
        tmp_args_element_name_12 = var_result;
        frame_97860a8503a242ea2870dd155ed6cf25->m_frame.f_lineno = 1792;
        {
            PyObject *call_args[] = {tmp_args_element_name_11, tmp_args_element_name_12};
            tmp_slice_source_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain_buffer, call_args);
        }

        if (tmp_slice_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1792;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = LOOKUP_INDEX_SLICE(tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1);
        Py_DECREF(tmp_slice_source_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1792;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_97860a8503a242ea2870dd155ed6cf25);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_97860a8503a242ea2870dd155ed6cf25);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_97860a8503a242ea2870dd155ed6cf25);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_97860a8503a242ea2870dd155ed6cf25, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_97860a8503a242ea2870dd155ed6cf25->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_97860a8503a242ea2870dd155ed6cf25, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_97860a8503a242ea2870dd155ed6cf25,
        type_description_1,
        par_self,
        par_bufsiz,
        par_flags,
        var_buf,
        var_result
    );


    // Release cached frame.
    if (frame_97860a8503a242ea2870dd155ed6cf25 == cache_frame_97860a8503a242ea2870dd155ed6cf25) {
        Py_DECREF(frame_97860a8503a242ea2870dd155ed6cf25);
    }
    cache_frame_97860a8503a242ea2870dd155ed6cf25 = NULL;

    assertFrameObject(frame_97860a8503a242ea2870dd155ed6cf25);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_67_recv);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_buf);
    Py_DECREF(var_buf);
    var_buf = NULL;

    CHECK_OBJECT((PyObject *)var_result);
    Py_DECREF(var_result);
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_buf);
    var_buf = NULL;

    Py_XDECREF(var_result);
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_67_recv);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_flags);
    Py_DECREF(par_flags);
    CHECK_OBJECT(par_bufsiz);
    Py_DECREF(par_bufsiz);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_flags);
    Py_DECREF(par_flags);
    CHECK_OBJECT(par_bufsiz);
    Py_DECREF(par_bufsiz);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_68_recv_into(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_buffer = python_pars[1];
    PyObject *par_nbytes = python_pars[2];
    PyObject *par_flags = python_pars[3];
    PyObject *var_buf = NULL;
    PyObject *var_result = NULL;
    struct Nuitka_FrameObject *frame_be94e691bb77258f38f88be8b8aadc60;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_be94e691bb77258f38f88be8b8aadc60 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_be94e691bb77258f38f88be8b8aadc60, codeobj_be94e691bb77258f38f88be8b8aadc60, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_be94e691bb77258f38f88be8b8aadc60 = cache_frame_be94e691bb77258f38f88be8b8aadc60;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_be94e691bb77258f38f88be8b8aadc60);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_be94e691bb77258f38f88be8b8aadc60) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_nbytes);
        tmp_compexpr_left_1 = par_nbytes;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_len_arg_1;
            CHECK_OBJECT(par_buffer);
            tmp_len_arg_1 = par_buffer;
            tmp_assign_source_1 = BUILTIN_LEN(tmp_len_arg_1);
            if (tmp_assign_source_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1810;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_nbytes;
                assert(old != NULL);
                par_nbytes = tmp_assign_source_1;
                Py_DECREF(old);
            }

        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_called_name_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_len_arg_2;
            tmp_called_name_1 = LOOKUP_BUILTIN(const_str_plain_min);
            assert(tmp_called_name_1 != NULL);
            CHECK_OBJECT(par_nbytes);
            tmp_args_element_name_1 = par_nbytes;
            CHECK_OBJECT(par_buffer);
            tmp_len_arg_2 = par_buffer;
            tmp_args_element_name_2 = BUILTIN_LEN(tmp_len_arg_2);
            if (tmp_args_element_name_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1812;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            frame_be94e691bb77258f38f88be8b8aadc60->m_frame.f_lineno = 1812;
            {
                PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
                tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
            }

            Py_DECREF(tmp_args_element_name_2);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1812;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_nbytes;
                assert(old != NULL);
                par_nbytes = tmp_assign_source_2;
                Py_DECREF(old);
            }

        }
        branch_end_1:;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__no_zero_allocator);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__no_zero_allocator);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1838 ], 47, 0);
            exception_tb = NULL;

            exception_lineno = 1817;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_1;
        tmp_args_element_name_3 = const_str_digest_c561652c58984ec0e9541542aa405594;
        CHECK_OBJECT(par_nbytes);
        tmp_args_element_name_4 = par_nbytes;
        frame_be94e691bb77258f38f88be8b8aadc60->m_frame.f_lineno = 1817;
        {
            PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4};
            tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        if (tmp_assign_source_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1817;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert(var_buf == NULL);
        var_buf = tmp_assign_source_3;
    }
    {
        nuitka_bool tmp_condition_result_2;
        int tmp_and_left_truth_1;
        nuitka_bool tmp_and_left_value_1;
        nuitka_bool tmp_and_right_value_1;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_op_bitand_res_1;
        int tmp_truth_name_1;
        CHECK_OBJECT(par_flags);
        tmp_compexpr_left_2 = par_flags;
        tmp_compexpr_right_2 = Py_None;
        tmp_and_left_value_1 = (tmp_compexpr_left_2 != tmp_compexpr_right_2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if (tmp_and_left_truth_1 == 1) {
            goto and_right_1;
        } else {
            goto and_left_1;
        }
        and_right_1:;
        CHECK_OBJECT(par_flags);
        tmp_left_name_1 = par_flags;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_socket);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_socket);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1885 ], 35, 0);
            exception_tb = NULL;

            exception_lineno = 1818;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_right_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_MSG_PEEK);
        if (tmp_right_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1818;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_op_bitand_res_1 = BINARY_OPERATION_BITAND_OBJECT_OBJECT(tmp_left_name_1, tmp_right_name_1);
        Py_DECREF(tmp_right_name_1);
        if (tmp_op_bitand_res_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1818;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE(tmp_op_bitand_res_1);
        if (tmp_truth_name_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_op_bitand_res_1);

            exception_lineno = 1818;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_op_bitand_res_1);
        tmp_condition_result_2 = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_condition_result_2 = tmp_and_left_value_1;
        and_end_1:;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_4;
            PyObject *tmp_called_name_3;
            PyObject *tmp_source_name_2;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_args_element_name_5;
            PyObject *tmp_source_name_3;
            PyObject *tmp_args_element_name_6;
            PyObject *tmp_args_element_name_7;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_3 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1819;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_2 = tmp_mvar_value_3;
            tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_SSL_peek);
            if (tmp_called_name_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1819;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(par_self);
            tmp_source_name_3 = par_self;
            tmp_args_element_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__ssl);
            if (tmp_args_element_name_5 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_3);

                exception_lineno = 1819;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_buf);
            tmp_args_element_name_6 = var_buf;
            CHECK_OBJECT(par_nbytes);
            tmp_args_element_name_7 = par_nbytes;
            frame_be94e691bb77258f38f88be8b8aadc60->m_frame.f_lineno = 1819;
            {
                PyObject *call_args[] = {tmp_args_element_name_5, tmp_args_element_name_6, tmp_args_element_name_7};
                tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_3, call_args);
            }

            Py_DECREF(tmp_called_name_3);
            Py_DECREF(tmp_args_element_name_5);
            if (tmp_assign_source_4 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1819;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            assert(var_result == NULL);
            var_result = tmp_assign_source_4;
        }
        goto branch_end_2;
        branch_no_2:;
        {
            PyObject *tmp_assign_source_5;
            PyObject *tmp_called_name_4;
            PyObject *tmp_source_name_4;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_args_element_name_8;
            PyObject *tmp_source_name_5;
            PyObject *tmp_args_element_name_9;
            PyObject *tmp_args_element_name_10;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_4 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1821;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_4 = tmp_mvar_value_4;
            tmp_called_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_SSL_read);
            if (tmp_called_name_4 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1821;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(par_self);
            tmp_source_name_5 = par_self;
            tmp_args_element_name_8 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain__ssl);
            if (tmp_args_element_name_8 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_4);

                exception_lineno = 1821;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_buf);
            tmp_args_element_name_9 = var_buf;
            CHECK_OBJECT(par_nbytes);
            tmp_args_element_name_10 = par_nbytes;
            frame_be94e691bb77258f38f88be8b8aadc60->m_frame.f_lineno = 1821;
            {
                PyObject *call_args[] = {tmp_args_element_name_8, tmp_args_element_name_9, tmp_args_element_name_10};
                tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_4, call_args);
            }

            Py_DECREF(tmp_called_name_4);
            Py_DECREF(tmp_args_element_name_8);
            if (tmp_assign_source_5 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1821;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            assert(var_result == NULL);
            var_result = tmp_assign_source_5;
        }
        branch_end_2:;
    }
    {
        PyObject *tmp_called_name_5;
        PyObject *tmp_source_name_6;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_11;
        PyObject *tmp_source_name_7;
        PyObject *tmp_args_element_name_12;
        CHECK_OBJECT(par_self);
        tmp_source_name_6 = par_self;
        tmp_called_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain__raise_ssl_error);
        if (tmp_called_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1822;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_7 = par_self;
        tmp_args_element_name_11 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain__ssl);
        if (tmp_args_element_name_11 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_5);

            exception_lineno = 1822;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_result);
        tmp_args_element_name_12 = var_result;
        frame_be94e691bb77258f38f88be8b8aadc60->m_frame.f_lineno = 1822;
        {
            PyObject *call_args[] = {tmp_args_element_name_11, tmp_args_element_name_12};
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_5, call_args);
        }

        Py_DECREF(tmp_called_name_5);
        Py_DECREF(tmp_args_element_name_11);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1822;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_sliceass_value_1;
        PyObject *tmp_called_name_6;
        PyObject *tmp_args_element_name_13;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_14;
        PyObject *tmp_args_element_name_15;
        PyObject *tmp_sliceass_target_1;
        PyObject *tmp_sliceass_upper_1;
        tmp_called_name_6 = (PyObject *)&PyMemoryView_Type;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1828;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_5;
        CHECK_OBJECT(var_buf);
        tmp_args_element_name_14 = var_buf;
        CHECK_OBJECT(var_result);
        tmp_args_element_name_15 = var_result;
        frame_be94e691bb77258f38f88be8b8aadc60->m_frame.f_lineno = 1828;
        {
            PyObject *call_args[] = {tmp_args_element_name_14, tmp_args_element_name_15};
            tmp_args_element_name_13 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain_buffer, call_args);
        }

        if (tmp_args_element_name_13 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1828;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_be94e691bb77258f38f88be8b8aadc60->m_frame.f_lineno = 1828;
        tmp_sliceass_value_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_6, tmp_args_element_name_13);
        Py_DECREF(tmp_args_element_name_13);
        if (tmp_sliceass_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1828;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_buffer);
        tmp_sliceass_target_1 = par_buffer;
        CHECK_OBJECT(var_result);
        tmp_sliceass_upper_1 = var_result;
        tmp_result = SET_SLICE(tmp_sliceass_target_1, Py_None, tmp_sliceass_upper_1, tmp_sliceass_value_1);
        Py_DECREF(tmp_sliceass_value_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1828;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_be94e691bb77258f38f88be8b8aadc60);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_be94e691bb77258f38f88be8b8aadc60);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_be94e691bb77258f38f88be8b8aadc60, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_be94e691bb77258f38f88be8b8aadc60->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_be94e691bb77258f38f88be8b8aadc60, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_be94e691bb77258f38f88be8b8aadc60,
        type_description_1,
        par_self,
        par_buffer,
        par_nbytes,
        par_flags,
        var_buf,
        var_result
    );


    // Release cached frame.
    if (frame_be94e691bb77258f38f88be8b8aadc60 == cache_frame_be94e691bb77258f38f88be8b8aadc60) {
        Py_DECREF(frame_be94e691bb77258f38f88be8b8aadc60);
    }
    cache_frame_be94e691bb77258f38f88be8b8aadc60 = NULL;

    assertFrameObject(frame_be94e691bb77258f38f88be8b8aadc60);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT(var_result);
    tmp_return_value = var_result;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_68_recv_into);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)par_nbytes);
    Py_DECREF(par_nbytes);
    par_nbytes = NULL;

    CHECK_OBJECT((PyObject *)var_buf);
    Py_DECREF(var_buf);
    var_buf = NULL;

    CHECK_OBJECT((PyObject *)var_result);
    Py_DECREF(var_result);
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(par_nbytes);
    par_nbytes = NULL;

    Py_XDECREF(var_buf);
    var_buf = NULL;

    Py_XDECREF(var_result);
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_68_recv_into);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_buffer);
    Py_DECREF(par_buffer);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_flags);
    Py_DECREF(par_flags);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_buffer);
    Py_DECREF(par_buffer);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_flags);
    Py_DECREF(par_flags);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_69__handle_bio_errors(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_bio = python_pars[1];
    PyObject *par_result = python_pars[2];
    struct Nuitka_FrameObject *frame_8e1387e41345949ee09c7bd644ab240f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_8e1387e41345949ee09c7bd644ab240f = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_8e1387e41345949ee09c7bd644ab240f, codeobj_8e1387e41345949ee09c7bd644ab240f, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_8e1387e41345949ee09c7bd644ab240f = cache_frame_8e1387e41345949ee09c7bd644ab240f;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_8e1387e41345949ee09c7bd644ab240f);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_8e1387e41345949ee09c7bd644ab240f) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        int tmp_truth_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1833;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT(par_bio);
        tmp_args_element_name_1 = par_bio;
        frame_8e1387e41345949ee09c7bd644ab240f->m_frame.f_lineno = 1833;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_BIO_should_retry, call_args);
        }

        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1833;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE(tmp_call_result_1);
        if (tmp_truth_name_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_call_result_1);

            exception_lineno = 1833;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_call_result_1);
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_called_instance_2;
            PyObject *tmp_mvar_value_2;
            PyObject *tmp_call_result_2;
            PyObject *tmp_args_element_name_2;
            int tmp_truth_name_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1834;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_2 = tmp_mvar_value_2;
            CHECK_OBJECT(par_bio);
            tmp_args_element_name_2 = par_bio;
            frame_8e1387e41345949ee09c7bd644ab240f->m_frame.f_lineno = 1834;
            {
                PyObject *call_args[] = {tmp_args_element_name_2};
                tmp_call_result_2 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_BIO_should_read, call_args);
            }

            if (tmp_call_result_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1834;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_truth_name_2 = CHECK_IF_TRUE(tmp_call_result_2);
            if (tmp_truth_name_2 == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_call_result_2);

                exception_lineno = 1834;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = tmp_truth_name_2 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            Py_DECREF(tmp_call_result_2);
            if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
                goto branch_yes_2;
            } else {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_raise_type_1;
                PyObject *tmp_called_name_1;
                PyObject *tmp_mvar_value_3;
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_WantReadError);

                if (unlikely(tmp_mvar_value_3 == NULL)) {
                    tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_WantReadError);
                }

                if (tmp_mvar_value_3 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 1509 ], 42, 0);
                    exception_tb = NULL;

                    exception_lineno = 1835;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_name_1 = tmp_mvar_value_3;
                frame_8e1387e41345949ee09c7bd644ab240f->m_frame.f_lineno = 1835;
                tmp_raise_type_1 = CALL_FUNCTION_NO_ARGS(tmp_called_name_1);
                if (tmp_raise_type_1 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 1835;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                exception_type = tmp_raise_type_1;
                exception_lineno = 1835;
                RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            goto branch_end_2;
            branch_no_2:;
            {
                nuitka_bool tmp_condition_result_3;
                PyObject *tmp_called_instance_3;
                PyObject *tmp_mvar_value_4;
                PyObject *tmp_call_result_3;
                PyObject *tmp_args_element_name_3;
                int tmp_truth_name_3;
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

                if (unlikely(tmp_mvar_value_4 == NULL)) {
                    tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
                }

                if (tmp_mvar_value_4 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                    exception_tb = NULL;

                    exception_lineno = 1836;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_instance_3 = tmp_mvar_value_4;
                CHECK_OBJECT(par_bio);
                tmp_args_element_name_3 = par_bio;
                frame_8e1387e41345949ee09c7bd644ab240f->m_frame.f_lineno = 1836;
                {
                    PyObject *call_args[] = {tmp_args_element_name_3};
                    tmp_call_result_3 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_3, const_str_plain_BIO_should_write, call_args);
                }

                if (tmp_call_result_3 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 1836;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                tmp_truth_name_3 = CHECK_IF_TRUE(tmp_call_result_3);
                if (tmp_truth_name_3 == -1) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    Py_DECREF(tmp_call_result_3);

                    exception_lineno = 1836;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                tmp_condition_result_3 = tmp_truth_name_3 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                Py_DECREF(tmp_call_result_3);
                if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
                    goto branch_yes_3;
                } else {
                    goto branch_no_3;
                }
                branch_yes_3:;
                {
                    PyObject *tmp_raise_type_2;
                    PyObject *tmp_called_name_2;
                    PyObject *tmp_mvar_value_5;
                    tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_WantWriteError);

                    if (unlikely(tmp_mvar_value_5 == NULL)) {
                        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_WantWriteError);
                    }

                    if (tmp_mvar_value_5 == NULL) {

                        exception_type = PyExc_NameError;
                        Py_INCREF(exception_type);
                        exception_value = UNSTREAM_STRING(&constant_bin[ 1551 ], 43, 0);
                        exception_tb = NULL;

                        exception_lineno = 1838;
                        type_description_1 = "ooo";
                        goto frame_exception_exit_1;
                    }

                    tmp_called_name_2 = tmp_mvar_value_5;
                    frame_8e1387e41345949ee09c7bd644ab240f->m_frame.f_lineno = 1838;
                    tmp_raise_type_2 = CALL_FUNCTION_NO_ARGS(tmp_called_name_2);
                    if (tmp_raise_type_2 == NULL) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                        exception_lineno = 1838;
                        type_description_1 = "ooo";
                        goto frame_exception_exit_1;
                    }
                    exception_type = tmp_raise_type_2;
                    exception_lineno = 1838;
                    RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                goto branch_end_3;
                branch_no_3:;
                {
                    nuitka_bool tmp_condition_result_4;
                    PyObject *tmp_called_instance_4;
                    PyObject *tmp_mvar_value_6;
                    PyObject *tmp_call_result_4;
                    PyObject *tmp_args_element_name_4;
                    int tmp_truth_name_4;
                    tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

                    if (unlikely(tmp_mvar_value_6 == NULL)) {
                        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
                    }

                    if (tmp_mvar_value_6 == NULL) {

                        exception_type = PyExc_NameError;
                        Py_INCREF(exception_type);
                        exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                        exception_tb = NULL;

                        exception_lineno = 1839;
                        type_description_1 = "ooo";
                        goto frame_exception_exit_1;
                    }

                    tmp_called_instance_4 = tmp_mvar_value_6;
                    CHECK_OBJECT(par_bio);
                    tmp_args_element_name_4 = par_bio;
                    frame_8e1387e41345949ee09c7bd644ab240f->m_frame.f_lineno = 1839;
                    {
                        PyObject *call_args[] = {tmp_args_element_name_4};
                        tmp_call_result_4 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_4, const_str_plain_BIO_should_io_special, call_args);
                    }

                    if (tmp_call_result_4 == NULL) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                        exception_lineno = 1839;
                        type_description_1 = "ooo";
                        goto frame_exception_exit_1;
                    }
                    tmp_truth_name_4 = CHECK_IF_TRUE(tmp_call_result_4);
                    if (tmp_truth_name_4 == -1) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                        Py_DECREF(tmp_call_result_4);

                        exception_lineno = 1839;
                        type_description_1 = "ooo";
                        goto frame_exception_exit_1;
                    }
                    tmp_condition_result_4 = tmp_truth_name_4 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                    Py_DECREF(tmp_call_result_4);
                    if (tmp_condition_result_4 == NUITKA_BOOL_TRUE) {
                        goto branch_yes_4;
                    } else {
                        goto branch_no_4;
                    }
                    branch_yes_4:;
                    {
                        PyObject *tmp_raise_type_3;
                        PyObject *tmp_make_exception_arg_1;
                        tmp_make_exception_arg_1 = const_str_plain_BIO_should_io_special;
                        frame_8e1387e41345949ee09c7bd644ab240f->m_frame.f_lineno = 1842;
                        tmp_raise_type_3 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_1);
                        assert(!(tmp_raise_type_3 == NULL));
                        exception_type = tmp_raise_type_3;
                        exception_lineno = 1842;
                        RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                        type_description_1 = "ooo";
                        goto frame_exception_exit_1;
                    }
                    goto branch_end_4;
                    branch_no_4:;
                    {
                        PyObject *tmp_raise_type_4;
                        PyObject *tmp_make_exception_arg_2;
                        tmp_make_exception_arg_2 = const_str_digest_1491fa532da0499070a77d607dd12a0d;
                        frame_8e1387e41345949ee09c7bd644ab240f->m_frame.f_lineno = 1845;
                        tmp_raise_type_4 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_ValueError, tmp_make_exception_arg_2);
                        assert(!(tmp_raise_type_4 == NULL));
                        exception_type = tmp_raise_type_4;
                        exception_lineno = 1845;
                        RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                        type_description_1 = "ooo";
                        goto frame_exception_exit_1;
                    }
                    branch_end_4:;
                }
                branch_end_3:;
            }
            branch_end_2:;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_called_name_3;
            PyObject *tmp_mvar_value_7;
            PyObject *tmp_call_result_5;
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error);

            if (unlikely(tmp_mvar_value_7 == NULL)) {
                tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error);
            }

            if (tmp_mvar_value_7 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 0 ], 49, 0);
                exception_tb = NULL;

                exception_lineno = 1848;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_3 = tmp_mvar_value_7;
            frame_8e1387e41345949ee09c7bd644ab240f->m_frame.f_lineno = 1848;
            tmp_call_result_5 = CALL_FUNCTION_NO_ARGS(tmp_called_name_3);
            if (tmp_call_result_5 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1848;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_5);
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8e1387e41345949ee09c7bd644ab240f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8e1387e41345949ee09c7bd644ab240f);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_8e1387e41345949ee09c7bd644ab240f, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_8e1387e41345949ee09c7bd644ab240f->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_8e1387e41345949ee09c7bd644ab240f, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8e1387e41345949ee09c7bd644ab240f,
        type_description_1,
        par_self,
        par_bio,
        par_result
    );


    // Release cached frame.
    if (frame_8e1387e41345949ee09c7bd644ab240f == cache_frame_8e1387e41345949ee09c7bd644ab240f) {
        Py_DECREF(frame_8e1387e41345949ee09c7bd644ab240f);
    }
    cache_frame_8e1387e41345949ee09c7bd644ab240f = NULL;

    assertFrameObject(frame_8e1387e41345949ee09c7bd644ab240f);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_69__handle_bio_errors);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_bio);
    Py_DECREF(par_bio);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_result);
    Py_DECREF(par_result);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_bio);
    Py_DECREF(par_bio);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_result);
    Py_DECREF(par_result);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_70_bio_read(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_bufsiz = python_pars[1];
    PyObject *var_buf = NULL;
    PyObject *var_result = NULL;
    struct Nuitka_FrameObject *frame_b7ca808cc5c4c80d7918d0eed15dff75;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_b7ca808cc5c4c80d7918d0eed15dff75 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_b7ca808cc5c4c80d7918d0eed15dff75, codeobj_b7ca808cc5c4c80d7918d0eed15dff75, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_b7ca808cc5c4c80d7918d0eed15dff75 = cache_frame_b7ca808cc5c4c80d7918d0eed15dff75;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_b7ca808cc5c4c80d7918d0eed15dff75);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_b7ca808cc5c4c80d7918d0eed15dff75) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__from_ssl);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1861;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_compexpr_left_1);
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_1fbb26888e8a93a4fffae5202f2e81a6;
            frame_b7ca808cc5c4c80d7918d0eed15dff75->m_frame.f_lineno = 1862;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1862;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_bufsiz);
        tmp_isinstance_inst_1 = par_bufsiz;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_types);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 459 ], 42, 0);
            exception_tb = NULL;

            exception_lineno = 1864;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1864;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1864;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            tmp_make_exception_arg_2 = const_str_digest_f6ccda911266ccc3bb4cd038d18beb52;
            frame_b7ca808cc5c4c80d7918d0eed15dff75->m_frame.f_lineno = 1865;
            tmp_raise_type_2 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_2);
            assert(!(tmp_raise_type_2 == NULL));
            exception_type = tmp_raise_type_2;
            exception_lineno = 1865;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__no_zero_allocator);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__no_zero_allocator);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1838 ], 47, 0);
            exception_tb = NULL;

            exception_lineno = 1867;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_2;
        tmp_args_element_name_1 = const_str_digest_c561652c58984ec0e9541542aa405594;
        CHECK_OBJECT(par_bufsiz);
        tmp_args_element_name_2 = par_bufsiz;
        frame_b7ca808cc5c4c80d7918d0eed15dff75->m_frame.f_lineno = 1867;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1867;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_buf == NULL);
        var_buf = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1868;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_BIO_read);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1868;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__from_ssl);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 1868;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_buf);
        tmp_args_element_name_4 = var_buf;
        CHECK_OBJECT(par_bufsiz);
        tmp_args_element_name_5 = par_bufsiz;
        frame_b7ca808cc5c4c80d7918d0eed15dff75->m_frame.f_lineno = 1868;
        {
            PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5};
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1868;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_result == NULL);
        var_result = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        CHECK_OBJECT(var_result);
        tmp_compexpr_left_2 = var_result;
        tmp_compexpr_right_2 = const_int_0;
        tmp_res = RICH_COMPARE_BOOL_LTE_OBJECT_INT(tmp_compexpr_left_2, tmp_compexpr_right_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1869;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
            goto branch_yes_3;
        } else {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_called_name_3;
            PyObject *tmp_source_name_4;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_6;
            PyObject *tmp_source_name_5;
            PyObject *tmp_args_element_name_7;
            CHECK_OBJECT(par_self);
            tmp_source_name_4 = par_self;
            tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain__handle_bio_errors);
            if (tmp_called_name_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1870;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(par_self);
            tmp_source_name_5 = par_self;
            tmp_args_element_name_6 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain__from_ssl);
            if (tmp_args_element_name_6 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_3);

                exception_lineno = 1870;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_result);
            tmp_args_element_name_7 = var_result;
            frame_b7ca808cc5c4c80d7918d0eed15dff75->m_frame.f_lineno = 1870;
            {
                PyObject *call_args[] = {tmp_args_element_name_6, tmp_args_element_name_7};
                tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_3, call_args);
            }

            Py_DECREF(tmp_called_name_3);
            Py_DECREF(tmp_args_element_name_6);
            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1870;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_1);
        }
        branch_no_3:;
    }
    {
        Py_ssize_t tmp_sliceslicedel_index_lower_1;
        Py_ssize_t tmp_slice_index_upper_1;
        PyObject *tmp_slice_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_args_element_name_9;
        tmp_sliceslicedel_index_lower_1 = 0;
        tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1872;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_4;
        CHECK_OBJECT(var_buf);
        tmp_args_element_name_8 = var_buf;
        CHECK_OBJECT(var_result);
        tmp_args_element_name_9 = var_result;
        frame_b7ca808cc5c4c80d7918d0eed15dff75->m_frame.f_lineno = 1872;
        {
            PyObject *call_args[] = {tmp_args_element_name_8, tmp_args_element_name_9};
            tmp_slice_source_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain_buffer, call_args);
        }

        if (tmp_slice_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1872;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = LOOKUP_INDEX_SLICE(tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1);
        Py_DECREF(tmp_slice_source_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1872;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b7ca808cc5c4c80d7918d0eed15dff75);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_b7ca808cc5c4c80d7918d0eed15dff75);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b7ca808cc5c4c80d7918d0eed15dff75);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_b7ca808cc5c4c80d7918d0eed15dff75, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_b7ca808cc5c4c80d7918d0eed15dff75->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_b7ca808cc5c4c80d7918d0eed15dff75, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b7ca808cc5c4c80d7918d0eed15dff75,
        type_description_1,
        par_self,
        par_bufsiz,
        var_buf,
        var_result
    );


    // Release cached frame.
    if (frame_b7ca808cc5c4c80d7918d0eed15dff75 == cache_frame_b7ca808cc5c4c80d7918d0eed15dff75) {
        Py_DECREF(frame_b7ca808cc5c4c80d7918d0eed15dff75);
    }
    cache_frame_b7ca808cc5c4c80d7918d0eed15dff75 = NULL;

    assertFrameObject(frame_b7ca808cc5c4c80d7918d0eed15dff75);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_70_bio_read);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_buf);
    Py_DECREF(var_buf);
    var_buf = NULL;

    CHECK_OBJECT((PyObject *)var_result);
    Py_DECREF(var_result);
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_buf);
    var_buf = NULL;

    Py_XDECREF(var_result);
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_70_bio_read);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_bufsiz);
    Py_DECREF(par_bufsiz);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_bufsiz);
    Py_DECREF(par_bufsiz);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_71_bio_write(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_buf = python_pars[1];
    PyObject *var_result = NULL;
    struct Nuitka_FrameObject *frame_d5ed49f302d78d068853f841ba5561d8;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_d5ed49f302d78d068853f841ba5561d8 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_d5ed49f302d78d068853f841ba5561d8, codeobj_d5ed49f302d78d068853f841ba5561d8, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_d5ed49f302d78d068853f841ba5561d8 = cache_frame_d5ed49f302d78d068853f841ba5561d8;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_d5ed49f302d78d068853f841ba5561d8);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_d5ed49f302d78d068853f841ba5561d8) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1011 ], 52, 0);
            exception_tb = NULL;

            exception_lineno = 1884;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        tmp_args_element_name_1 = const_str_plain_buf;
        CHECK_OBJECT(par_buf);
        tmp_args_element_name_2 = par_buf;
        frame_d5ed49f302d78d068853f841ba5561d8->m_frame.f_lineno = 1884;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1884;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = par_buf;
            assert(old != NULL);
            par_buf = tmp_assign_source_1;
            Py_DECREF(old);
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__into_ssl);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1886;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_compexpr_left_1);
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_1fbb26888e8a93a4fffae5202f2e81a6;
            frame_d5ed49f302d78d068853f841ba5561d8->m_frame.f_lineno = 1887;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1887;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_len_arg_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1889;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_BIO_write);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1889;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__into_ssl);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 1889;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_buf);
        tmp_args_element_name_4 = par_buf;
        CHECK_OBJECT(par_buf);
        tmp_len_arg_1 = par_buf;
        tmp_args_element_name_5 = BUILTIN_LEN(tmp_len_arg_1);
        if (tmp_args_element_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_3);

            exception_lineno = 1889;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_d5ed49f302d78d068853f841ba5561d8->m_frame.f_lineno = 1889;
        {
            PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5};
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_3);
        Py_DECREF(tmp_args_element_name_5);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1889;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_result == NULL);
        var_result = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        CHECK_OBJECT(var_result);
        tmp_compexpr_left_2 = var_result;
        tmp_compexpr_right_2 = const_int_0;
        tmp_res = RICH_COMPARE_BOOL_LTE_OBJECT_INT(tmp_compexpr_left_2, tmp_compexpr_right_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1890;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_called_name_3;
            PyObject *tmp_source_name_4;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_6;
            PyObject *tmp_source_name_5;
            PyObject *tmp_args_element_name_7;
            CHECK_OBJECT(par_self);
            tmp_source_name_4 = par_self;
            tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain__handle_bio_errors);
            if (tmp_called_name_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1891;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(par_self);
            tmp_source_name_5 = par_self;
            tmp_args_element_name_6 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain__into_ssl);
            if (tmp_args_element_name_6 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_3);

                exception_lineno = 1891;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_result);
            tmp_args_element_name_7 = var_result;
            frame_d5ed49f302d78d068853f841ba5561d8->m_frame.f_lineno = 1891;
            {
                PyObject *call_args[] = {tmp_args_element_name_6, tmp_args_element_name_7};
                tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_3, call_args);
            }

            Py_DECREF(tmp_called_name_3);
            Py_DECREF(tmp_args_element_name_6);
            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1891;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_1);
        }
        branch_no_2:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_d5ed49f302d78d068853f841ba5561d8);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_d5ed49f302d78d068853f841ba5561d8);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_d5ed49f302d78d068853f841ba5561d8, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_d5ed49f302d78d068853f841ba5561d8->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_d5ed49f302d78d068853f841ba5561d8, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d5ed49f302d78d068853f841ba5561d8,
        type_description_1,
        par_self,
        par_buf,
        var_result
    );


    // Release cached frame.
    if (frame_d5ed49f302d78d068853f841ba5561d8 == cache_frame_d5ed49f302d78d068853f841ba5561d8) {
        Py_DECREF(frame_d5ed49f302d78d068853f841ba5561d8);
    }
    cache_frame_d5ed49f302d78d068853f841ba5561d8 = NULL;

    assertFrameObject(frame_d5ed49f302d78d068853f841ba5561d8);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT(var_result);
    tmp_return_value = var_result;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_71_bio_write);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)par_buf);
    Py_DECREF(par_buf);
    par_buf = NULL;

    CHECK_OBJECT((PyObject *)var_result);
    Py_DECREF(var_result);
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)par_buf);
    Py_DECREF(par_buf);
    par_buf = NULL;

    Py_XDECREF(var_result);
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_71_bio_write);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_72_renegotiate(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_7028d427820f53c4d1e8a41a379a1710;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_7028d427820f53c4d1e8a41a379a1710 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_7028d427820f53c4d1e8a41a379a1710, codeobj_7028d427820f53c4d1e8a41a379a1710, module_OpenSSL$SSL, sizeof(void *));
    frame_7028d427820f53c4d1e8a41a379a1710 = cache_frame_7028d427820f53c4d1e8a41a379a1710;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_7028d427820f53c4d1e8a41a379a1710);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_7028d427820f53c4d1e8a41a379a1710) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_called_instance_1;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        frame_7028d427820f53c4d1e8a41a379a1710->m_frame.f_lineno = 1901;
        tmp_operand_name_1 = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_renegotiate_pending);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1901;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1901;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_name_1;
            PyObject *tmp_mvar_value_1;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_compexpr_left_1;
            PyObject *tmp_compexpr_right_1;
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_1;
            PyObject *tmp_mvar_value_2;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_source_name_2;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert);

            if (unlikely(tmp_mvar_value_1 == NULL)) {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
            }

            if (tmp_mvar_value_1 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
                exception_tb = NULL;

                exception_lineno = 1902;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }

            tmp_called_name_1 = tmp_mvar_value_1;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 1902;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }

            tmp_source_name_1 = tmp_mvar_value_2;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_renegotiate);
            if (tmp_called_name_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1902;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(par_self);
            tmp_source_name_2 = par_self;
            tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__ssl);
            if (tmp_args_element_name_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_2);

                exception_lineno = 1902;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            frame_7028d427820f53c4d1e8a41a379a1710->m_frame.f_lineno = 1902;
            tmp_compexpr_left_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_2);
            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_2);
            if (tmp_compexpr_left_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1902;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            tmp_compexpr_right_1 = const_int_pos_1;
            tmp_args_element_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
            Py_DECREF(tmp_compexpr_left_1);
            if (tmp_args_element_name_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1902;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            frame_7028d427820f53c4d1e8a41a379a1710->m_frame.f_lineno = 1902;
            tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
            Py_DECREF(tmp_args_element_name_1);
            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1902;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_1);
        }
        tmp_return_value = Py_True;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_7028d427820f53c4d1e8a41a379a1710);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_7028d427820f53c4d1e8a41a379a1710);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_7028d427820f53c4d1e8a41a379a1710);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_7028d427820f53c4d1e8a41a379a1710, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_7028d427820f53c4d1e8a41a379a1710->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_7028d427820f53c4d1e8a41a379a1710, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7028d427820f53c4d1e8a41a379a1710,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_7028d427820f53c4d1e8a41a379a1710 == cache_frame_7028d427820f53c4d1e8a41a379a1710) {
        Py_DECREF(frame_7028d427820f53c4d1e8a41a379a1710);
    }
    cache_frame_7028d427820f53c4d1e8a41a379a1710 = NULL;

    assertFrameObject(frame_7028d427820f53c4d1e8a41a379a1710);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_False;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_72_renegotiate);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_73_do_handshake(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_result = NULL;
    struct Nuitka_FrameObject *frame_3a54cffed41af1aede27c16b10131e97;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_3a54cffed41af1aede27c16b10131e97 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_3a54cffed41af1aede27c16b10131e97, codeobj_3a54cffed41af1aede27c16b10131e97, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *));
    frame_3a54cffed41af1aede27c16b10131e97 = cache_frame_3a54cffed41af1aede27c16b10131e97;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_3a54cffed41af1aede27c16b10131e97);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_3a54cffed41af1aede27c16b10131e97) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1914;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_do_handshake);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1914;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__ssl);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1914;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_3a54cffed41af1aede27c16b10131e97->m_frame.f_lineno = 1914;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1914;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert(var_result == NULL);
        var_result = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_args_element_name_3;
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__raise_ssl_error);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1915;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_4 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain__ssl);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 1915;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_result);
        tmp_args_element_name_3 = var_result;
        frame_3a54cffed41af1aede27c16b10131e97->m_frame.f_lineno = 1915;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1915;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3a54cffed41af1aede27c16b10131e97);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3a54cffed41af1aede27c16b10131e97);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_3a54cffed41af1aede27c16b10131e97, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_3a54cffed41af1aede27c16b10131e97->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_3a54cffed41af1aede27c16b10131e97, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3a54cffed41af1aede27c16b10131e97,
        type_description_1,
        par_self,
        var_result
    );


    // Release cached frame.
    if (frame_3a54cffed41af1aede27c16b10131e97 == cache_frame_3a54cffed41af1aede27c16b10131e97) {
        Py_DECREF(frame_3a54cffed41af1aede27c16b10131e97);
    }
    cache_frame_3a54cffed41af1aede27c16b10131e97 = NULL;

    assertFrameObject(frame_3a54cffed41af1aede27c16b10131e97);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_73_do_handshake);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_result);
    Py_DECREF(var_result);
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_result);
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_73_do_handshake);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_74_renegotiate_pending(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_d6f61d72394bd98660c5c42254770e72;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_d6f61d72394bd98660c5c42254770e72 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_d6f61d72394bd98660c5c42254770e72, codeobj_d6f61d72394bd98660c5c42254770e72, module_OpenSSL$SSL, sizeof(void *));
    frame_d6f61d72394bd98660c5c42254770e72 = cache_frame_d6f61d72394bd98660c5c42254770e72;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_d6f61d72394bd98660c5c42254770e72);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_d6f61d72394bd98660c5c42254770e72) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1925;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_renegotiate_pending);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1925;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__ssl);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1925;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_d6f61d72394bd98660c5c42254770e72->m_frame.f_lineno = 1925;
        tmp_compexpr_left_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1925;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = const_int_pos_1;
        tmp_return_value = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1925;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_d6f61d72394bd98660c5c42254770e72);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_d6f61d72394bd98660c5c42254770e72);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_d6f61d72394bd98660c5c42254770e72);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_d6f61d72394bd98660c5c42254770e72, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_d6f61d72394bd98660c5c42254770e72->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_d6f61d72394bd98660c5c42254770e72, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d6f61d72394bd98660c5c42254770e72,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_d6f61d72394bd98660c5c42254770e72 == cache_frame_d6f61d72394bd98660c5c42254770e72) {
        Py_DECREF(frame_d6f61d72394bd98660c5c42254770e72);
    }
    cache_frame_d6f61d72394bd98660c5c42254770e72 = NULL;

    assertFrameObject(frame_d6f61d72394bd98660c5c42254770e72);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_74_renegotiate_pending);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_75_total_renegotiations(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_0fadfadb8bb4516eed76800a79e9a7f7;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_0fadfadb8bb4516eed76800a79e9a7f7 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_0fadfadb8bb4516eed76800a79e9a7f7, codeobj_0fadfadb8bb4516eed76800a79e9a7f7, module_OpenSSL$SSL, sizeof(void *));
    frame_0fadfadb8bb4516eed76800a79e9a7f7 = cache_frame_0fadfadb8bb4516eed76800a79e9a7f7;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_0fadfadb8bb4516eed76800a79e9a7f7);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_0fadfadb8bb4516eed76800a79e9a7f7) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1934;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_total_renegotiations);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1934;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__ssl);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1934;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_0fadfadb8bb4516eed76800a79e9a7f7->m_frame.f_lineno = 1934;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1934;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0fadfadb8bb4516eed76800a79e9a7f7);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_0fadfadb8bb4516eed76800a79e9a7f7);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0fadfadb8bb4516eed76800a79e9a7f7);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_0fadfadb8bb4516eed76800a79e9a7f7, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_0fadfadb8bb4516eed76800a79e9a7f7->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_0fadfadb8bb4516eed76800a79e9a7f7, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0fadfadb8bb4516eed76800a79e9a7f7,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_0fadfadb8bb4516eed76800a79e9a7f7 == cache_frame_0fadfadb8bb4516eed76800a79e9a7f7) {
        Py_DECREF(frame_0fadfadb8bb4516eed76800a79e9a7f7);
    }
    cache_frame_0fadfadb8bb4516eed76800a79e9a7f7 = NULL;

    assertFrameObject(frame_0fadfadb8bb4516eed76800a79e9a7f7);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_75_total_renegotiations);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_76_connect(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_addr = python_pars[1];
    struct Nuitka_FrameObject *frame_054eab96f8b2836c51e087bd4de8388e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_054eab96f8b2836c51e087bd4de8388e = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_054eab96f8b2836c51e087bd4de8388e, codeobj_054eab96f8b2836c51e087bd4de8388e, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *));
    frame_054eab96f8b2836c51e087bd4de8388e = cache_frame_054eab96f8b2836c51e087bd4de8388e;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_054eab96f8b2836c51e087bd4de8388e);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_054eab96f8b2836c51e087bd4de8388e) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1945;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_set_connect_state);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1945;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__ssl);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1945;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_054eab96f8b2836c51e087bd4de8388e->m_frame.f_lineno = 1945;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1945;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__socket);
        if (tmp_called_instance_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1946;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_addr);
        tmp_args_element_name_2 = par_addr;
        frame_054eab96f8b2836c51e087bd4de8388e->m_frame.f_lineno = 1946;
        {
            PyObject *call_args[] = {tmp_args_element_name_2};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_connect, call_args);
        }

        Py_DECREF(tmp_called_instance_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1946;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_054eab96f8b2836c51e087bd4de8388e);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_054eab96f8b2836c51e087bd4de8388e);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_054eab96f8b2836c51e087bd4de8388e);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_054eab96f8b2836c51e087bd4de8388e, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_054eab96f8b2836c51e087bd4de8388e->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_054eab96f8b2836c51e087bd4de8388e, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_054eab96f8b2836c51e087bd4de8388e,
        type_description_1,
        par_self,
        par_addr
    );


    // Release cached frame.
    if (frame_054eab96f8b2836c51e087bd4de8388e == cache_frame_054eab96f8b2836c51e087bd4de8388e) {
        Py_DECREF(frame_054eab96f8b2836c51e087bd4de8388e);
    }
    cache_frame_054eab96f8b2836c51e087bd4de8388e = NULL;

    assertFrameObject(frame_054eab96f8b2836c51e087bd4de8388e);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_76_connect);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_addr);
    Py_DECREF(par_addr);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_addr);
    Py_DECREF(par_addr);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_77_connect_ex(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_addr = python_pars[1];
    PyObject *var_connect_ex = NULL;
    struct Nuitka_FrameObject *frame_79150ce062e76c9de8df0c58996d97fe;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_79150ce062e76c9de8df0c58996d97fe = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_79150ce062e76c9de8df0c58996d97fe, codeobj_79150ce062e76c9de8df0c58996d97fe, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_79150ce062e76c9de8df0c58996d97fe = cache_frame_79150ce062e76c9de8df0c58996d97fe;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_79150ce062e76c9de8df0c58996d97fe);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_79150ce062e76c9de8df0c58996d97fe) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__socket);
        if (tmp_source_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1958;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_connect_ex);
        Py_DECREF(tmp_source_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1958;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_connect_ex == NULL);
        var_connect_ex = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        frame_79150ce062e76c9de8df0c58996d97fe->m_frame.f_lineno = 1959;
        tmp_call_result_1 = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_set_connect_state);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1959;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(var_connect_ex);
        tmp_called_name_1 = var_connect_ex;
        CHECK_OBJECT(par_addr);
        tmp_args_element_name_1 = par_addr;
        frame_79150ce062e76c9de8df0c58996d97fe->m_frame.f_lineno = 1960;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1960;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_79150ce062e76c9de8df0c58996d97fe);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_79150ce062e76c9de8df0c58996d97fe);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_79150ce062e76c9de8df0c58996d97fe);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_79150ce062e76c9de8df0c58996d97fe, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_79150ce062e76c9de8df0c58996d97fe->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_79150ce062e76c9de8df0c58996d97fe, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_79150ce062e76c9de8df0c58996d97fe,
        type_description_1,
        par_self,
        par_addr,
        var_connect_ex
    );


    // Release cached frame.
    if (frame_79150ce062e76c9de8df0c58996d97fe == cache_frame_79150ce062e76c9de8df0c58996d97fe) {
        Py_DECREF(frame_79150ce062e76c9de8df0c58996d97fe);
    }
    cache_frame_79150ce062e76c9de8df0c58996d97fe = NULL;

    assertFrameObject(frame_79150ce062e76c9de8df0c58996d97fe);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_77_connect_ex);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_connect_ex);
    Py_DECREF(var_connect_ex);
    var_connect_ex = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_connect_ex);
    var_connect_ex = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_77_connect_ex);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_addr);
    Py_DECREF(par_addr);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_addr);
    Py_DECREF(par_addr);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_78_accept(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_client = NULL;
    PyObject *var_addr = NULL;
    PyObject *var_conn = NULL;
    PyObject *tmp_tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_tuple_unpack_1__source_iter = NULL;
    struct Nuitka_FrameObject *frame_2f4c7f3e7e619c283f90e008af92ff2c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_iterator_attempt;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    static struct Nuitka_FrameObject *cache_frame_2f4c7f3e7e619c283f90e008af92ff2c = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_2f4c7f3e7e619c283f90e008af92ff2c, codeobj_2f4c7f3e7e619c283f90e008af92ff2c, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_2f4c7f3e7e619c283f90e008af92ff2c = cache_frame_2f4c7f3e7e619c283f90e008af92ff2c;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_2f4c7f3e7e619c283f90e008af92ff2c);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_2f4c7f3e7e619c283f90e008af92ff2c) == 2); // Frame stack

    // Framed code:
    // Tried code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__socket);
        if (tmp_called_instance_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1972;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        frame_2f4c7f3e7e619c283f90e008af92ff2c->m_frame.f_lineno = 1972;
        tmp_iter_arg_1 = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_accept);
        Py_DECREF(tmp_called_instance_1);
        if (tmp_iter_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1972;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        tmp_assign_source_1 = MAKE_ITERATOR(tmp_iter_arg_1);
        Py_DECREF(tmp_iter_arg_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1972;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        assert(tmp_tuple_unpack_1__source_iter == NULL);
        tmp_tuple_unpack_1__source_iter = tmp_assign_source_1;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_unpack_1;
        CHECK_OBJECT(tmp_tuple_unpack_1__source_iter);
        tmp_unpack_1 = tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_2 = UNPACK_NEXT(tmp_unpack_1, 0);
        if (tmp_assign_source_2 == NULL) {
            if (!ERROR_OCCURRED()) {
                exception_type = PyExc_StopIteration;
                Py_INCREF(exception_type);
                exception_value = NULL;
                exception_tb = NULL;
            } else {
                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            }


            type_description_1 = "oooo";
            exception_lineno = 1972;
            goto try_except_handler_3;
        }
        assert(tmp_tuple_unpack_1__element_1 == NULL);
        tmp_tuple_unpack_1__element_1 = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_unpack_2;
        CHECK_OBJECT(tmp_tuple_unpack_1__source_iter);
        tmp_unpack_2 = tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_3 = UNPACK_NEXT(tmp_unpack_2, 1);
        if (tmp_assign_source_3 == NULL) {
            if (!ERROR_OCCURRED()) {
                exception_type = PyExc_StopIteration;
                Py_INCREF(exception_type);
                exception_value = NULL;
                exception_tb = NULL;
            } else {
                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            }


            type_description_1 = "oooo";
            exception_lineno = 1972;
            goto try_except_handler_3;
        }
        assert(tmp_tuple_unpack_1__element_2 == NULL);
        tmp_tuple_unpack_1__element_2 = tmp_assign_source_3;
    }
    {
        PyObject *tmp_iterator_name_1;
        CHECK_OBJECT(tmp_tuple_unpack_1__source_iter);
        tmp_iterator_name_1 = tmp_tuple_unpack_1__source_iter;
        // Check if iterator has left-over elements.
        CHECK_OBJECT(tmp_iterator_name_1); assert(HAS_ITERNEXT(tmp_iterator_name_1));

        tmp_iterator_attempt = (*Py_TYPE(tmp_iterator_name_1)->tp_iternext)(tmp_iterator_name_1);

        if (likely(tmp_iterator_attempt == NULL))
        {
            PyObject *error = GET_ERROR_OCCURRED();

            if (error != NULL)
            {
                if (EXCEPTION_MATCH_BOOL_SINGLE(error, PyExc_StopIteration))
                {
                    CLEAR_ERROR_OCCURRED();
                } else {
                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);

                    type_description_1 = "oooo";
                    exception_lineno = 1972;
                    goto try_except_handler_3;
                }
            }
        } else {
            Py_DECREF(tmp_iterator_attempt);

            // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
            PyErr_Format(PyExc_ValueError, "too many values to unpack");
#else
            PyErr_Format(PyExc_ValueError, "too many values to unpack (expected 2)");
#endif
            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);

            type_description_1 = "oooo";
            exception_lineno = 1972;
            goto try_except_handler_3;
        }
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)tmp_tuple_unpack_1__source_iter);
    Py_DECREF(tmp_tuple_unpack_1__source_iter);
    tmp_tuple_unpack_1__source_iter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    // End of try:
    try_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_tuple_unpack_1__element_1);
    tmp_tuple_unpack_1__element_1 = NULL;

    Py_XDECREF(tmp_tuple_unpack_1__element_2);
    tmp_tuple_unpack_1__element_2 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    CHECK_OBJECT((PyObject *)tmp_tuple_unpack_1__source_iter);
    Py_DECREF(tmp_tuple_unpack_1__source_iter);
    tmp_tuple_unpack_1__source_iter = NULL;

    {
        PyObject *tmp_assign_source_4;
        CHECK_OBJECT(tmp_tuple_unpack_1__element_1);
        tmp_assign_source_4 = tmp_tuple_unpack_1__element_1;
        assert(var_client == NULL);
        Py_INCREF(tmp_assign_source_4);
        var_client = tmp_assign_source_4;
    }
    Py_XDECREF(tmp_tuple_unpack_1__element_1);
    tmp_tuple_unpack_1__element_1 = NULL;

    {
        PyObject *tmp_assign_source_5;
        CHECK_OBJECT(tmp_tuple_unpack_1__element_2);
        tmp_assign_source_5 = tmp_tuple_unpack_1__element_2;
        assert(var_addr == NULL);
        Py_INCREF(tmp_assign_source_5);
        var_addr = tmp_assign_source_5;
    }
    Py_XDECREF(tmp_tuple_unpack_1__element_2);
    tmp_tuple_unpack_1__element_2 = NULL;

    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Connection);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_Connection);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 269 ], 39, 0);
            exception_tb = NULL;

            exception_lineno = 1973;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__context);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1973;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_client);
        tmp_args_element_name_2 = var_client;
        frame_2f4c7f3e7e619c283f90e008af92ff2c->m_frame.f_lineno = 1973;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_6 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1973;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_conn == NULL);
        var_conn = tmp_assign_source_6;
    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_call_result_1;
        CHECK_OBJECT(var_conn);
        tmp_called_instance_2 = var_conn;
        frame_2f4c7f3e7e619c283f90e008af92ff2c->m_frame.f_lineno = 1974;
        tmp_call_result_1 = CALL_METHOD_NO_ARGS(tmp_called_instance_2, const_str_plain_set_accept_state);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1974;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2f4c7f3e7e619c283f90e008af92ff2c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2f4c7f3e7e619c283f90e008af92ff2c);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_2f4c7f3e7e619c283f90e008af92ff2c, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_2f4c7f3e7e619c283f90e008af92ff2c->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_2f4c7f3e7e619c283f90e008af92ff2c, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2f4c7f3e7e619c283f90e008af92ff2c,
        type_description_1,
        par_self,
        var_client,
        var_addr,
        var_conn
    );


    // Release cached frame.
    if (frame_2f4c7f3e7e619c283f90e008af92ff2c == cache_frame_2f4c7f3e7e619c283f90e008af92ff2c) {
        Py_DECREF(frame_2f4c7f3e7e619c283f90e008af92ff2c);
    }
    cache_frame_2f4c7f3e7e619c283f90e008af92ff2c = NULL;

    assertFrameObject(frame_2f4c7f3e7e619c283f90e008af92ff2c);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    {
        PyObject *tmp_tuple_element_1;
        CHECK_OBJECT(var_conn);
        tmp_tuple_element_1 = var_conn;
        tmp_return_value = PyTuple_New(2);
        Py_INCREF(tmp_tuple_element_1);
        PyTuple_SET_ITEM(tmp_return_value, 0, tmp_tuple_element_1);
        CHECK_OBJECT(var_addr);
        tmp_tuple_element_1 = var_addr;
        Py_INCREF(tmp_tuple_element_1);
        PyTuple_SET_ITEM(tmp_return_value, 1, tmp_tuple_element_1);
        goto try_return_handler_1;
    }
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_78_accept);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_client);
    Py_DECREF(var_client);
    var_client = NULL;

    CHECK_OBJECT((PyObject *)var_addr);
    Py_DECREF(var_addr);
    var_addr = NULL;

    CHECK_OBJECT((PyObject *)var_conn);
    Py_DECREF(var_conn);
    var_conn = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_client);
    var_client = NULL;

    Py_XDECREF(var_addr);
    var_addr = NULL;

    Py_XDECREF(var_conn);
    var_conn = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_78_accept);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_79_bio_shutdown(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_e6af520114787689a5f9cf0c5c00fde7;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_e6af520114787689a5f9cf0c5c00fde7 = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_e6af520114787689a5f9cf0c5c00fde7, codeobj_e6af520114787689a5f9cf0c5c00fde7, module_OpenSSL$SSL, sizeof(void *));
    frame_e6af520114787689a5f9cf0c5c00fde7 = cache_frame_e6af520114787689a5f9cf0c5c00fde7;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_e6af520114787689a5f9cf0c5c00fde7);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_e6af520114787689a5f9cf0c5c00fde7) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__from_ssl);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1985;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_compexpr_left_1);
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_1fbb26888e8a93a4fffae5202f2e81a6;
            frame_e6af520114787689a5f9cf0c5c00fde7->m_frame.f_lineno = 1986;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 1986;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1988;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_BIO_set_mem_eof_return);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1988;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__into_ssl);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1988;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_2 = const_int_0;
        frame_e6af520114787689a5f9cf0c5c00fde7->m_frame.f_lineno = 1988;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1988;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e6af520114787689a5f9cf0c5c00fde7);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e6af520114787689a5f9cf0c5c00fde7);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_e6af520114787689a5f9cf0c5c00fde7, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_e6af520114787689a5f9cf0c5c00fde7->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_e6af520114787689a5f9cf0c5c00fde7, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e6af520114787689a5f9cf0c5c00fde7,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_e6af520114787689a5f9cf0c5c00fde7 == cache_frame_e6af520114787689a5f9cf0c5c00fde7) {
        Py_DECREF(frame_e6af520114787689a5f9cf0c5c00fde7);
    }
    cache_frame_e6af520114787689a5f9cf0c5c00fde7 = NULL;

    assertFrameObject(frame_e6af520114787689a5f9cf0c5c00fde7);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_79_bio_shutdown);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_80_shutdown(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_result = NULL;
    struct Nuitka_FrameObject *frame_6f36c0fa3d59052efa6a916f18f6c1e1;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_6f36c0fa3d59052efa6a916f18f6c1e1 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_6f36c0fa3d59052efa6a916f18f6c1e1, codeobj_6f36c0fa3d59052efa6a916f18f6c1e1, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *));
    frame_6f36c0fa3d59052efa6a916f18f6c1e1 = cache_frame_6f36c0fa3d59052efa6a916f18f6c1e1;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_6f36c0fa3d59052efa6a916f18f6c1e1);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_6f36c0fa3d59052efa6a916f18f6c1e1) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 1999;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_shutdown);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1999;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__ssl);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1999;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_6f36c0fa3d59052efa6a916f18f6c1e1->m_frame.f_lineno = 1999;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1999;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert(var_result == NULL);
        var_result = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(var_result);
        tmp_compexpr_left_1 = var_result;
        tmp_compexpr_right_1 = const_int_0;
        tmp_res = RICH_COMPARE_BOOL_LT_OBJECT_INT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2000;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_3;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_source_name_4;
            PyObject *tmp_args_element_name_3;
            CHECK_OBJECT(par_self);
            tmp_source_name_3 = par_self;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__raise_ssl_error);
            if (tmp_called_name_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2001;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(par_self);
            tmp_source_name_4 = par_self;
            tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain__ssl);
            if (tmp_args_element_name_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_2);

                exception_lineno = 2001;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_result);
            tmp_args_element_name_3 = var_result;
            frame_6f36c0fa3d59052efa6a916f18f6c1e1->m_frame.f_lineno = 2001;
            {
                PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
                tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
            }

            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_2);
            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2001;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_1);
        }
        goto branch_end_1;
        branch_no_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            CHECK_OBJECT(var_result);
            tmp_compexpr_left_2 = var_result;
            tmp_compexpr_right_2 = const_int_0;
            tmp_res = RICH_COMPARE_BOOL_GT_OBJECT_INT(tmp_compexpr_left_2, tmp_compexpr_right_2);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2002;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
                goto branch_yes_2;
            } else {
                goto branch_no_2;
            }
            branch_yes_2:;
            tmp_return_value = Py_True;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
            goto branch_end_2;
            branch_no_2:;
            tmp_return_value = Py_False;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
            branch_end_2:;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_6f36c0fa3d59052efa6a916f18f6c1e1);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_6f36c0fa3d59052efa6a916f18f6c1e1);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_6f36c0fa3d59052efa6a916f18f6c1e1);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_6f36c0fa3d59052efa6a916f18f6c1e1, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_6f36c0fa3d59052efa6a916f18f6c1e1->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_6f36c0fa3d59052efa6a916f18f6c1e1, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6f36c0fa3d59052efa6a916f18f6c1e1,
        type_description_1,
        par_self,
        var_result
    );


    // Release cached frame.
    if (frame_6f36c0fa3d59052efa6a916f18f6c1e1 == cache_frame_6f36c0fa3d59052efa6a916f18f6c1e1) {
        Py_DECREF(frame_6f36c0fa3d59052efa6a916f18f6c1e1);
    }
    cache_frame_6f36c0fa3d59052efa6a916f18f6c1e1 = NULL;

    assertFrameObject(frame_6f36c0fa3d59052efa6a916f18f6c1e1);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_80_shutdown);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_result);
    Py_DECREF(var_result);
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_result);
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_80_shutdown);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_81_get_cipher_list(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_i = NULL;
    PyObject *var_ciphers = NULL;
    PyObject *var_result = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_dfa471f51052025d0f268f8ce73b5948;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_dfa471f51052025d0f268f8ce73b5948 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = PyList_New(0);
        assert(var_ciphers == NULL);
        var_ciphers = tmp_assign_source_1;
    }
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_dfa471f51052025d0f268f8ce73b5948, codeobj_dfa471f51052025d0f268f8ce73b5948, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_dfa471f51052025d0f268f8ce73b5948 = cache_frame_dfa471f51052025d0f268f8ce73b5948;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_dfa471f51052025d0f268f8ce73b5948);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_dfa471f51052025d0f268f8ce73b5948) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_count);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_count);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1920 ], 34, 0);
            exception_tb = NULL;

            exception_lineno = 2014;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        frame_dfa471f51052025d0f268f8ce73b5948->m_frame.f_lineno = 2014;
        tmp_iter_arg_1 = CALL_FUNCTION_NO_ARGS(tmp_called_name_1);
        if (tmp_iter_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2014;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_2 = MAKE_ITERATOR(tmp_iter_arg_1);
        Py_DECREF(tmp_iter_arg_1);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2014;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(tmp_for_loop_1__for_iterator == NULL);
        tmp_for_loop_1__for_iterator = tmp_assign_source_2;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_3;
        CHECK_OBJECT(tmp_for_loop_1__for_iterator);
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_3 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_3 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "oooo";
                exception_lineno = 2014;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_3;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_4;
        CHECK_OBJECT(tmp_for_loop_1__iter_value);
        tmp_assign_source_4 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_i;
            var_i = tmp_assign_source_4;
            Py_INCREF(var_i);
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2015;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_get_cipher_list);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2015;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__ssl);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 2015;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT(var_i);
        tmp_args_element_name_2 = var_i;
        frame_dfa471f51052025d0f268f8ce73b5948->m_frame.f_lineno = 2015;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2015;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_result;
            var_result = tmp_assign_source_5;
            Py_XDECREF(old);
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_3;
        CHECK_OBJECT(var_result);
        tmp_compexpr_left_1 = var_result;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2016;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }

        tmp_source_name_3 = tmp_mvar_value_3;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_NULL);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2016;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2016;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        goto loop_end_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_4;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_called_name_4;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_5;
        CHECK_OBJECT(var_ciphers);
        tmp_source_name_4 = var_ciphers;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_append);
        if (tmp_called_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2018;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__native);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__native);
        }

        if (tmp_mvar_value_4 == NULL) {
            Py_DECREF(tmp_called_name_3);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1954 ], 36, 0);
            exception_tb = NULL;

            exception_lineno = 2018;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }

        tmp_called_name_4 = tmp_mvar_value_4;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_5 == NULL) {
            Py_DECREF(tmp_called_name_3);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2018;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_1 = tmp_mvar_value_5;
        CHECK_OBJECT(var_result);
        tmp_args_element_name_5 = var_result;
        frame_dfa471f51052025d0f268f8ce73b5948->m_frame.f_lineno = 2018;
        {
            PyObject *call_args[] = {tmp_args_element_name_5};
            tmp_args_element_name_4 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_string, call_args);
        }

        if (tmp_args_element_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);

            exception_lineno = 2018;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        frame_dfa471f51052025d0f268f8ce73b5948->m_frame.f_lineno = 2018;
        tmp_args_element_name_3 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_4, tmp_args_element_name_4);
        Py_DECREF(tmp_args_element_name_4);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);

            exception_lineno = 2018;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        frame_dfa471f51052025d0f268f8ce73b5948->m_frame.f_lineno = 2018;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_3, tmp_args_element_name_3);
        Py_DECREF(tmp_called_name_3);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2018;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        Py_DECREF(tmp_call_result_1);
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


        exception_lineno = 2014;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_dfa471f51052025d0f268f8ce73b5948);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_dfa471f51052025d0f268f8ce73b5948);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_dfa471f51052025d0f268f8ce73b5948, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_dfa471f51052025d0f268f8ce73b5948->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_dfa471f51052025d0f268f8ce73b5948, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_dfa471f51052025d0f268f8ce73b5948,
        type_description_1,
        par_self,
        var_i,
        var_ciphers,
        var_result
    );


    // Release cached frame.
    if (frame_dfa471f51052025d0f268f8ce73b5948 == cache_frame_dfa471f51052025d0f268f8ce73b5948) {
        Py_DECREF(frame_dfa471f51052025d0f268f8ce73b5948);
    }
    cache_frame_dfa471f51052025d0f268f8ce73b5948 = NULL;

    assertFrameObject(frame_dfa471f51052025d0f268f8ce73b5948);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    CHECK_OBJECT(var_ciphers);
    tmp_return_value = var_ciphers;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_81_get_cipher_list);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_i);
    var_i = NULL;

    CHECK_OBJECT((PyObject *)var_ciphers);
    Py_DECREF(var_ciphers);
    var_ciphers = NULL;

    Py_XDECREF(var_result);
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_i);
    var_i = NULL;

    CHECK_OBJECT((PyObject *)var_ciphers);
    Py_DECREF(var_ciphers);
    var_ciphers = NULL;

    Py_XDECREF(var_result);
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_81_get_cipher_list);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_82_get_client_ca_list(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_name = NULL;
    PyObject *var_pyname = NULL;
    PyObject *var_i = NULL;
    PyObject *var_ca_names = NULL;
    PyObject *var_result = NULL;
    PyObject *var_copy = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_c7007220b0b459514c7b12300a002dc2;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    bool tmp_result;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_c7007220b0b459514c7b12300a002dc2 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_c7007220b0b459514c7b12300a002dc2, codeobj_c7007220b0b459514c7b12300a002dc2, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_c7007220b0b459514c7b12300a002dc2 = cache_frame_c7007220b0b459514c7b12300a002dc2;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_c7007220b0b459514c7b12300a002dc2);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_c7007220b0b459514c7b12300a002dc2) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2034;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_get_client_CA_list);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2034;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__ssl);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2034;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        frame_c7007220b0b459514c7b12300a002dc2->m_frame.f_lineno = 2034;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2034;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_ca_names == NULL);
        var_ca_names = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT(var_ca_names);
        tmp_compexpr_left_1 = var_ca_names;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2035;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_NULL);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2035;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2035;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = PyList_New(0);
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_2;
        tmp_assign_source_2 = PyList_New(0);
        assert(var_result == NULL);
        var_result = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_range_arg_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2040;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_3;
        CHECK_OBJECT(var_ca_names);
        tmp_args_element_name_2 = var_ca_names;
        frame_c7007220b0b459514c7b12300a002dc2->m_frame.f_lineno = 2040;
        {
            PyObject *call_args[] = {tmp_args_element_name_2};
            tmp_range_arg_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_sk_X509_NAME_num, call_args);
        }

        if (tmp_range_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2040;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_iter_arg_1 = BUILTIN_RANGE(tmp_range_arg_1);
        Py_DECREF(tmp_range_arg_1);
        if (tmp_iter_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2040;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_3 = MAKE_ITERATOR(tmp_iter_arg_1);
        Py_DECREF(tmp_iter_arg_1);
        if (tmp_assign_source_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2040;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        assert(tmp_for_loop_1__for_iterator == NULL);
        tmp_for_loop_1__for_iterator = tmp_assign_source_3;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_4;
        CHECK_OBJECT(tmp_for_loop_1__for_iterator);
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_4 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_4 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "ooooooo";
                exception_lineno = 2040;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_4;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_5;
        CHECK_OBJECT(tmp_for_loop_1__iter_value);
        tmp_assign_source_5 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_i;
            var_i = tmp_assign_source_5;
            Py_INCREF(var_i);
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2041;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_2 = tmp_mvar_value_4;
        CHECK_OBJECT(var_ca_names);
        tmp_args_element_name_3 = var_ca_names;
        CHECK_OBJECT(var_i);
        tmp_args_element_name_4 = var_i;
        frame_c7007220b0b459514c7b12300a002dc2->m_frame.f_lineno = 2041;
        {
            PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4};
            tmp_assign_source_6 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_2, const_str_plain_sk_X509_NAME_value, call_args);
        }

        if (tmp_assign_source_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2041;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_name;
            var_name = tmp_assign_source_6;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_5;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2042;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_3 = tmp_mvar_value_5;
        CHECK_OBJECT(var_name);
        tmp_args_element_name_5 = var_name;
        frame_c7007220b0b459514c7b12300a002dc2->m_frame.f_lineno = 2042;
        {
            PyObject *call_args[] = {tmp_args_element_name_5};
            tmp_assign_source_7 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_3, const_str_plain_X509_NAME_dup, call_args);
        }

        if (tmp_assign_source_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2042;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_copy;
            var_copy = tmp_assign_source_7;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_7;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_6 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 2043;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }

        tmp_called_name_2 = tmp_mvar_value_6;
        CHECK_OBJECT(var_copy);
        tmp_compexpr_left_2 = var_copy;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_7 == NULL)) {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_7 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2043;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }

        tmp_source_name_4 = tmp_mvar_value_7;
        tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_NULL);
        if (tmp_compexpr_right_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2043;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
        tmp_args_element_name_6 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
        Py_DECREF(tmp_compexpr_right_2);
        if (tmp_args_element_name_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2043;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
        frame_c7007220b0b459514c7b12300a002dc2->m_frame.f_lineno = 2043;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_6);
        Py_DECREF(tmp_args_element_name_6);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2043;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_assign_source_8;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_mvar_value_9;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509Name);

        if (unlikely(tmp_mvar_value_8 == NULL)) {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Name);
        }

        if (tmp_mvar_value_8 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1105 ], 37, 0);
            exception_tb = NULL;

            exception_lineno = 2045;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }

        tmp_source_name_5 = tmp_mvar_value_8;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain___new__);
        if (tmp_called_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2045;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
        tmp_mvar_value_9 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509Name);

        if (unlikely(tmp_mvar_value_9 == NULL)) {
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Name);
        }

        if (tmp_mvar_value_9 == NULL) {
            Py_DECREF(tmp_called_name_3);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1105 ], 37, 0);
            exception_tb = NULL;

            exception_lineno = 2045;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }

        tmp_args_element_name_7 = tmp_mvar_value_9;
        frame_c7007220b0b459514c7b12300a002dc2->m_frame.f_lineno = 2045;
        tmp_assign_source_8 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_3, tmp_args_element_name_7);
        Py_DECREF(tmp_called_name_3);
        if (tmp_assign_source_8 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2045;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_pyname;
            var_pyname = tmp_assign_source_8;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_10;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_11;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_10 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_10 == NULL)) {
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_10 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2046;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }

        tmp_source_name_6 = tmp_mvar_value_10;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_gc);
        if (tmp_called_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2046;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT(var_copy);
        tmp_args_element_name_8 = var_copy;
        tmp_mvar_value_11 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_11 == NULL)) {
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_11 == NULL) {
            Py_DECREF(tmp_called_name_4);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2046;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }

        tmp_source_name_7 = tmp_mvar_value_11;
        tmp_args_element_name_9 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain_X509_NAME_free);
        if (tmp_args_element_name_9 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_4);

            exception_lineno = 2046;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
        frame_c7007220b0b459514c7b12300a002dc2->m_frame.f_lineno = 2046;
        {
            PyObject *call_args[] = {tmp_args_element_name_8, tmp_args_element_name_9};
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_4, call_args);
        }

        Py_DECREF(tmp_called_name_4);
        Py_DECREF(tmp_args_element_name_9);
        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2046;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT(var_pyname);
        tmp_assattr_target_1 = var_pyname;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__name, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2046;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
    }
    {
        PyObject *tmp_called_instance_4;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_10;
        CHECK_OBJECT(var_result);
        tmp_called_instance_4 = var_result;
        CHECK_OBJECT(var_pyname);
        tmp_args_element_name_10 = var_pyname;
        frame_c7007220b0b459514c7b12300a002dc2->m_frame.f_lineno = 2047;
        {
            PyObject *call_args[] = {tmp_args_element_name_10};
            tmp_call_result_2 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_4, const_str_plain_append, call_args);
        }

        if (tmp_call_result_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2047;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
        Py_DECREF(tmp_call_result_2);
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


        exception_lineno = 2040;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c7007220b0b459514c7b12300a002dc2);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_c7007220b0b459514c7b12300a002dc2);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c7007220b0b459514c7b12300a002dc2);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_c7007220b0b459514c7b12300a002dc2, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_c7007220b0b459514c7b12300a002dc2->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_c7007220b0b459514c7b12300a002dc2, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c7007220b0b459514c7b12300a002dc2,
        type_description_1,
        par_self,
        var_name,
        var_pyname,
        var_i,
        var_ca_names,
        var_result,
        var_copy
    );


    // Release cached frame.
    if (frame_c7007220b0b459514c7b12300a002dc2 == cache_frame_c7007220b0b459514c7b12300a002dc2) {
        Py_DECREF(frame_c7007220b0b459514c7b12300a002dc2);
    }
    cache_frame_c7007220b0b459514c7b12300a002dc2 = NULL;

    assertFrameObject(frame_c7007220b0b459514c7b12300a002dc2);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    CHECK_OBJECT(var_result);
    tmp_return_value = var_result;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_82_get_client_ca_list);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_name);
    var_name = NULL;

    Py_XDECREF(var_pyname);
    var_pyname = NULL;

    Py_XDECREF(var_i);
    var_i = NULL;

    CHECK_OBJECT((PyObject *)var_ca_names);
    Py_DECREF(var_ca_names);
    var_ca_names = NULL;

    Py_XDECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_copy);
    var_copy = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_name);
    var_name = NULL;

    Py_XDECREF(var_pyname);
    var_pyname = NULL;

    Py_XDECREF(var_i);
    var_i = NULL;

    Py_XDECREF(var_ca_names);
    var_ca_names = NULL;

    Py_XDECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_copy);
    var_copy = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_82_get_client_ca_list);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_83_makefile(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_args = python_pars[1];
    PyObject *par_kwargs = python_pars[2];
    struct Nuitka_FrameObject *frame_433dfad8408328fc74fc1215c9a5f8eb;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_433dfad8408328fc74fc1215c9a5f8eb = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_433dfad8408328fc74fc1215c9a5f8eb, codeobj_433dfad8408328fc74fc1215c9a5f8eb, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_433dfad8408328fc74fc1215c9a5f8eb = cache_frame_433dfad8408328fc74fc1215c9a5f8eb;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_433dfad8408328fc74fc1215c9a5f8eb);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_433dfad8408328fc74fc1215c9a5f8eb) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_raise_type_1;
        PyObject *tmp_make_exception_arg_1;
        tmp_make_exception_arg_1 = const_str_digest_7540551bed0e4507c2b90cdbe0aa8fb3;
        frame_433dfad8408328fc74fc1215c9a5f8eb->m_frame.f_lineno = 2057;
        tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_NotImplementedError, tmp_make_exception_arg_1);
        assert(!(tmp_raise_type_1 == NULL));
        exception_type = tmp_raise_type_1;
        exception_lineno = 2057;
        RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_433dfad8408328fc74fc1215c9a5f8eb);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_433dfad8408328fc74fc1215c9a5f8eb);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_433dfad8408328fc74fc1215c9a5f8eb, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_433dfad8408328fc74fc1215c9a5f8eb->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_433dfad8408328fc74fc1215c9a5f8eb, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_433dfad8408328fc74fc1215c9a5f8eb,
        type_description_1,
        par_self,
        par_args,
        par_kwargs
    );


    // Release cached frame.
    if (frame_433dfad8408328fc74fc1215c9a5f8eb == cache_frame_433dfad8408328fc74fc1215c9a5f8eb) {
        Py_DECREF(frame_433dfad8408328fc74fc1215c9a5f8eb);
    }
    cache_frame_433dfad8408328fc74fc1215c9a5f8eb = NULL;

    assertFrameObject(frame_433dfad8408328fc74fc1215c9a5f8eb);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_83_makefile);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_args);
    Py_DECREF(par_args);
    CHECK_OBJECT(par_kwargs);
    Py_DECREF(par_kwargs);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

}


static PyObject *impl_OpenSSL$SSL$$$function_84_get_app_data(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_c7e9dcab9b20e02fc8fa7057fd275f11;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_c7e9dcab9b20e02fc8fa7057fd275f11 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_c7e9dcab9b20e02fc8fa7057fd275f11, codeobj_c7e9dcab9b20e02fc8fa7057fd275f11, module_OpenSSL$SSL, sizeof(void *));
    frame_c7e9dcab9b20e02fc8fa7057fd275f11 = cache_frame_c7e9dcab9b20e02fc8fa7057fd275f11;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_c7e9dcab9b20e02fc8fa7057fd275f11);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_c7e9dcab9b20e02fc8fa7057fd275f11) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_return_value = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__app_data);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2066;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c7e9dcab9b20e02fc8fa7057fd275f11);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_c7e9dcab9b20e02fc8fa7057fd275f11);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c7e9dcab9b20e02fc8fa7057fd275f11);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_c7e9dcab9b20e02fc8fa7057fd275f11, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_c7e9dcab9b20e02fc8fa7057fd275f11->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_c7e9dcab9b20e02fc8fa7057fd275f11, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c7e9dcab9b20e02fc8fa7057fd275f11,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_c7e9dcab9b20e02fc8fa7057fd275f11 == cache_frame_c7e9dcab9b20e02fc8fa7057fd275f11) {
        Py_DECREF(frame_c7e9dcab9b20e02fc8fa7057fd275f11);
    }
    cache_frame_c7e9dcab9b20e02fc8fa7057fd275f11 = NULL;

    assertFrameObject(frame_c7e9dcab9b20e02fc8fa7057fd275f11);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_84_get_app_data);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_85_set_app_data(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_data = python_pars[1];
    struct Nuitka_FrameObject *frame_a30e6c3082d13f64248246c7b439f499;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_a30e6c3082d13f64248246c7b439f499 = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_a30e6c3082d13f64248246c7b439f499, codeobj_a30e6c3082d13f64248246c7b439f499, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *));
    frame_a30e6c3082d13f64248246c7b439f499 = cache_frame_a30e6c3082d13f64248246c7b439f499;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_a30e6c3082d13f64248246c7b439f499);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_a30e6c3082d13f64248246c7b439f499) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_data);
        tmp_assattr_name_1 = par_data;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__app_data, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2075;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a30e6c3082d13f64248246c7b439f499);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a30e6c3082d13f64248246c7b439f499);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_a30e6c3082d13f64248246c7b439f499, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_a30e6c3082d13f64248246c7b439f499->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_a30e6c3082d13f64248246c7b439f499, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a30e6c3082d13f64248246c7b439f499,
        type_description_1,
        par_self,
        par_data
    );


    // Release cached frame.
    if (frame_a30e6c3082d13f64248246c7b439f499 == cache_frame_a30e6c3082d13f64248246c7b439f499) {
        Py_DECREF(frame_a30e6c3082d13f64248246c7b439f499);
    }
    cache_frame_a30e6c3082d13f64248246c7b439f499 = NULL;

    assertFrameObject(frame_a30e6c3082d13f64248246c7b439f499);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_85_set_app_data);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_data);
    Py_DECREF(par_data);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_data);
    Py_DECREF(par_data);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_86_get_shutdown(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_290e9c85751ef278e20a65deeb074f76;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_290e9c85751ef278e20a65deeb074f76 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_290e9c85751ef278e20a65deeb074f76, codeobj_290e9c85751ef278e20a65deeb074f76, module_OpenSSL$SSL, sizeof(void *));
    frame_290e9c85751ef278e20a65deeb074f76 = cache_frame_290e9c85751ef278e20a65deeb074f76;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_290e9c85751ef278e20a65deeb074f76);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_290e9c85751ef278e20a65deeb074f76) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2084;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_get_shutdown);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2084;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__ssl);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2084;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_290e9c85751ef278e20a65deeb074f76->m_frame.f_lineno = 2084;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2084;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_290e9c85751ef278e20a65deeb074f76);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_290e9c85751ef278e20a65deeb074f76);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_290e9c85751ef278e20a65deeb074f76);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_290e9c85751ef278e20a65deeb074f76, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_290e9c85751ef278e20a65deeb074f76->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_290e9c85751ef278e20a65deeb074f76, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_290e9c85751ef278e20a65deeb074f76,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_290e9c85751ef278e20a65deeb074f76 == cache_frame_290e9c85751ef278e20a65deeb074f76) {
        Py_DECREF(frame_290e9c85751ef278e20a65deeb074f76);
    }
    cache_frame_290e9c85751ef278e20a65deeb074f76 = NULL;

    assertFrameObject(frame_290e9c85751ef278e20a65deeb074f76);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_86_get_shutdown);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_87_set_shutdown(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_state = python_pars[1];
    struct Nuitka_FrameObject *frame_a79065ffeacdb0a47f1382db19c35f3d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_a79065ffeacdb0a47f1382db19c35f3d = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_a79065ffeacdb0a47f1382db19c35f3d, codeobj_a79065ffeacdb0a47f1382db19c35f3d, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *));
    frame_a79065ffeacdb0a47f1382db19c35f3d = cache_frame_a79065ffeacdb0a47f1382db19c35f3d;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_a79065ffeacdb0a47f1382db19c35f3d);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_a79065ffeacdb0a47f1382db19c35f3d) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_state);
        tmp_isinstance_inst_1 = par_state;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_types);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 459 ], 42, 0);
            exception_tb = NULL;

            exception_lineno = 2093;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2093;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2093;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_8cc305fc9d9a417a96ba57f2c87b94e9;
            frame_a79065ffeacdb0a47f1382db19c35f3d->m_frame.f_lineno = 2094;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 2094;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2096;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_set_shutdown);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2096;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__ssl);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2096;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_state);
        tmp_args_element_name_2 = par_state;
        frame_a79065ffeacdb0a47f1382db19c35f3d->m_frame.f_lineno = 2096;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2096;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a79065ffeacdb0a47f1382db19c35f3d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a79065ffeacdb0a47f1382db19c35f3d);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_a79065ffeacdb0a47f1382db19c35f3d, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_a79065ffeacdb0a47f1382db19c35f3d->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_a79065ffeacdb0a47f1382db19c35f3d, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a79065ffeacdb0a47f1382db19c35f3d,
        type_description_1,
        par_self,
        par_state
    );


    // Release cached frame.
    if (frame_a79065ffeacdb0a47f1382db19c35f3d == cache_frame_a79065ffeacdb0a47f1382db19c35f3d) {
        Py_DECREF(frame_a79065ffeacdb0a47f1382db19c35f3d);
    }
    cache_frame_a79065ffeacdb0a47f1382db19c35f3d = NULL;

    assertFrameObject(frame_a79065ffeacdb0a47f1382db19c35f3d);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_87_set_shutdown);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_state);
    Py_DECREF(par_state);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_state);
    Py_DECREF(par_state);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_88_get_state_string(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_096b136f4a3b30d606655f40a0fcb7eb;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_096b136f4a3b30d606655f40a0fcb7eb = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_096b136f4a3b30d606655f40a0fcb7eb, codeobj_096b136f4a3b30d606655f40a0fcb7eb, module_OpenSSL$SSL, sizeof(void *));
    frame_096b136f4a3b30d606655f40a0fcb7eb = cache_frame_096b136f4a3b30d606655f40a0fcb7eb;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_096b136f4a3b30d606655f40a0fcb7eb);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_096b136f4a3b30d606655f40a0fcb7eb) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2105;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_string);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2105;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2105;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_SSL_state_string_long);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2105;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__ssl);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 2105;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_096b136f4a3b30d606655f40a0fcb7eb->m_frame.f_lineno = 2105;
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_2);
        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2105;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_096b136f4a3b30d606655f40a0fcb7eb->m_frame.f_lineno = 2105;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2105;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_096b136f4a3b30d606655f40a0fcb7eb);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_096b136f4a3b30d606655f40a0fcb7eb);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_096b136f4a3b30d606655f40a0fcb7eb);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_096b136f4a3b30d606655f40a0fcb7eb, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_096b136f4a3b30d606655f40a0fcb7eb->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_096b136f4a3b30d606655f40a0fcb7eb, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_096b136f4a3b30d606655f40a0fcb7eb,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_096b136f4a3b30d606655f40a0fcb7eb == cache_frame_096b136f4a3b30d606655f40a0fcb7eb) {
        Py_DECREF(frame_096b136f4a3b30d606655f40a0fcb7eb);
    }
    cache_frame_096b136f4a3b30d606655f40a0fcb7eb = NULL;

    assertFrameObject(frame_096b136f4a3b30d606655f40a0fcb7eb);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_88_get_state_string);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_89_server_random(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_outp = NULL;
    PyObject *var_session = NULL;
    PyObject *var_length = NULL;
    struct Nuitka_FrameObject *frame_cbb40621241b7978549d445047800574;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_cbb40621241b7978549d445047800574 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_cbb40621241b7978549d445047800574, codeobj_cbb40621241b7978549d445047800574, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_cbb40621241b7978549d445047800574 = cache_frame_cbb40621241b7978549d445047800574;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_cbb40621241b7978549d445047800574);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_cbb40621241b7978549d445047800574) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2113;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_get_session);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2113;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__ssl);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2113;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_cbb40621241b7978549d445047800574->m_frame.f_lineno = 2113;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2113;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_session == NULL);
        var_session = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT(var_session);
        tmp_compexpr_left_1 = var_session;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2114;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_NULL);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2114;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2114;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_None;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_5;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2116;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_3;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_SSL_get_server_random);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2116;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_5 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain__ssl);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 2116;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_4 == NULL) {
            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_2);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2116;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_4;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_NULL);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_2);

            exception_lineno = 2116;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_4 = const_int_0;
        frame_cbb40621241b7978549d445047800574->m_frame.f_lineno = 2116;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4};
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_2);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2116;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_length == NULL);
        var_length = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        CHECK_OBJECT(var_length);
        tmp_compexpr_left_2 = var_length;
        tmp_compexpr_right_2 = const_int_0;
        tmp_operand_name_1 = RICH_COMPARE_GT_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2117;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2117;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_1;
            tmp_raise_type_1 = PyExc_AssertionError;
            exception_type = tmp_raise_type_1;
            Py_INCREF(tmp_raise_type_1);
            exception_lineno = 2117;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_args_element_name_6;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__no_zero_allocator);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__no_zero_allocator);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1838 ], 47, 0);
            exception_tb = NULL;

            exception_lineno = 2118;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_5;
        tmp_args_element_name_5 = const_str_digest_81f1b0dfcc7a862e6940580ec4cc42d3;
        CHECK_OBJECT(var_length);
        tmp_args_element_name_6 = var_length;
        frame_cbb40621241b7978549d445047800574->m_frame.f_lineno = 2118;
        {
            PyObject *call_args[] = {tmp_args_element_name_5, tmp_args_element_name_6};
            tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_3, call_args);
        }

        if (tmp_assign_source_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2118;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_outp == NULL);
        var_outp = tmp_assign_source_3;
    }
    {
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_source_name_8;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_args_element_name_9;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_6 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2119;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = tmp_mvar_value_6;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain_SSL_get_server_random);
        if (tmp_called_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2119;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_8 = par_self;
        tmp_args_element_name_7 = LOOKUP_ATTRIBUTE(tmp_source_name_8, const_str_plain__ssl);
        if (tmp_args_element_name_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_4);

            exception_lineno = 2119;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_outp);
        tmp_args_element_name_8 = var_outp;
        CHECK_OBJECT(var_length);
        tmp_args_element_name_9 = var_length;
        frame_cbb40621241b7978549d445047800574->m_frame.f_lineno = 2119;
        {
            PyObject *call_args[] = {tmp_args_element_name_7, tmp_args_element_name_8, tmp_args_element_name_9};
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_4, call_args);
        }

        Py_DECREF(tmp_called_name_4);
        Py_DECREF(tmp_args_element_name_7);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2119;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        Py_ssize_t tmp_sliceslicedel_index_lower_1;
        Py_ssize_t tmp_slice_index_upper_1;
        PyObject *tmp_slice_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_args_element_name_11;
        tmp_sliceslicedel_index_lower_1 = 0;
        tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_7 == NULL)) {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_7 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2120;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_7;
        CHECK_OBJECT(var_outp);
        tmp_args_element_name_10 = var_outp;
        CHECK_OBJECT(var_length);
        tmp_args_element_name_11 = var_length;
        frame_cbb40621241b7978549d445047800574->m_frame.f_lineno = 2120;
        {
            PyObject *call_args[] = {tmp_args_element_name_10, tmp_args_element_name_11};
            tmp_slice_source_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain_buffer, call_args);
        }

        if (tmp_slice_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2120;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = LOOKUP_INDEX_SLICE(tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1);
        Py_DECREF(tmp_slice_source_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2120;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_cbb40621241b7978549d445047800574);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_cbb40621241b7978549d445047800574);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_cbb40621241b7978549d445047800574);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_cbb40621241b7978549d445047800574, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_cbb40621241b7978549d445047800574->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_cbb40621241b7978549d445047800574, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_cbb40621241b7978549d445047800574,
        type_description_1,
        par_self,
        var_outp,
        var_session,
        var_length
    );


    // Release cached frame.
    if (frame_cbb40621241b7978549d445047800574 == cache_frame_cbb40621241b7978549d445047800574) {
        Py_DECREF(frame_cbb40621241b7978549d445047800574);
    }
    cache_frame_cbb40621241b7978549d445047800574 = NULL;

    assertFrameObject(frame_cbb40621241b7978549d445047800574);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_89_server_random);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_outp);
    var_outp = NULL;

    CHECK_OBJECT((PyObject *)var_session);
    Py_DECREF(var_session);
    var_session = NULL;

    Py_XDECREF(var_length);
    var_length = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_outp);
    var_outp = NULL;

    Py_XDECREF(var_session);
    var_session = NULL;

    Py_XDECREF(var_length);
    var_length = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_89_server_random);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_90_client_random(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_outp = NULL;
    PyObject *var_session = NULL;
    PyObject *var_length = NULL;
    struct Nuitka_FrameObject *frame_4ad7fb1c164aa08c3de4745ff8bb3abb;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_4ad7fb1c164aa08c3de4745ff8bb3abb = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_4ad7fb1c164aa08c3de4745ff8bb3abb, codeobj_4ad7fb1c164aa08c3de4745ff8bb3abb, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_4ad7fb1c164aa08c3de4745ff8bb3abb = cache_frame_4ad7fb1c164aa08c3de4745ff8bb3abb;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_4ad7fb1c164aa08c3de4745ff8bb3abb);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_4ad7fb1c164aa08c3de4745ff8bb3abb) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2128;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_get_session);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2128;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__ssl);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2128;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_4ad7fb1c164aa08c3de4745ff8bb3abb->m_frame.f_lineno = 2128;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2128;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_session == NULL);
        var_session = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT(var_session);
        tmp_compexpr_left_1 = var_session;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2129;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_NULL);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2129;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2129;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_None;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_5;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2132;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_3;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_SSL_get_client_random);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2132;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_5 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain__ssl);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 2132;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_4 == NULL) {
            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_2);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2132;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_4;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_NULL);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_2);

            exception_lineno = 2132;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_4 = const_int_0;
        frame_4ad7fb1c164aa08c3de4745ff8bb3abb->m_frame.f_lineno = 2132;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4};
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_2);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2132;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_length == NULL);
        var_length = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        CHECK_OBJECT(var_length);
        tmp_compexpr_left_2 = var_length;
        tmp_compexpr_right_2 = const_int_0;
        tmp_operand_name_1 = RICH_COMPARE_GT_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2133;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2133;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_1;
            tmp_raise_type_1 = PyExc_AssertionError;
            exception_type = tmp_raise_type_1;
            Py_INCREF(tmp_raise_type_1);
            exception_lineno = 2133;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_args_element_name_6;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__no_zero_allocator);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__no_zero_allocator);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1838 ], 47, 0);
            exception_tb = NULL;

            exception_lineno = 2134;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_5;
        tmp_args_element_name_5 = const_str_digest_81f1b0dfcc7a862e6940580ec4cc42d3;
        CHECK_OBJECT(var_length);
        tmp_args_element_name_6 = var_length;
        frame_4ad7fb1c164aa08c3de4745ff8bb3abb->m_frame.f_lineno = 2134;
        {
            PyObject *call_args[] = {tmp_args_element_name_5, tmp_args_element_name_6};
            tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_3, call_args);
        }

        if (tmp_assign_source_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2134;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_outp == NULL);
        var_outp = tmp_assign_source_3;
    }
    {
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_source_name_8;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_args_element_name_9;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_6 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2135;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = tmp_mvar_value_6;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain_SSL_get_client_random);
        if (tmp_called_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2135;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_8 = par_self;
        tmp_args_element_name_7 = LOOKUP_ATTRIBUTE(tmp_source_name_8, const_str_plain__ssl);
        if (tmp_args_element_name_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_4);

            exception_lineno = 2135;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_outp);
        tmp_args_element_name_8 = var_outp;
        CHECK_OBJECT(var_length);
        tmp_args_element_name_9 = var_length;
        frame_4ad7fb1c164aa08c3de4745ff8bb3abb->m_frame.f_lineno = 2135;
        {
            PyObject *call_args[] = {tmp_args_element_name_7, tmp_args_element_name_8, tmp_args_element_name_9};
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_4, call_args);
        }

        Py_DECREF(tmp_called_name_4);
        Py_DECREF(tmp_args_element_name_7);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2135;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        Py_ssize_t tmp_sliceslicedel_index_lower_1;
        Py_ssize_t tmp_slice_index_upper_1;
        PyObject *tmp_slice_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_args_element_name_11;
        tmp_sliceslicedel_index_lower_1 = 0;
        tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_7 == NULL)) {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_7 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2136;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_7;
        CHECK_OBJECT(var_outp);
        tmp_args_element_name_10 = var_outp;
        CHECK_OBJECT(var_length);
        tmp_args_element_name_11 = var_length;
        frame_4ad7fb1c164aa08c3de4745ff8bb3abb->m_frame.f_lineno = 2136;
        {
            PyObject *call_args[] = {tmp_args_element_name_10, tmp_args_element_name_11};
            tmp_slice_source_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain_buffer, call_args);
        }

        if (tmp_slice_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2136;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = LOOKUP_INDEX_SLICE(tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1);
        Py_DECREF(tmp_slice_source_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2136;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_4ad7fb1c164aa08c3de4745ff8bb3abb);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_4ad7fb1c164aa08c3de4745ff8bb3abb);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_4ad7fb1c164aa08c3de4745ff8bb3abb);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_4ad7fb1c164aa08c3de4745ff8bb3abb, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_4ad7fb1c164aa08c3de4745ff8bb3abb->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_4ad7fb1c164aa08c3de4745ff8bb3abb, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4ad7fb1c164aa08c3de4745ff8bb3abb,
        type_description_1,
        par_self,
        var_outp,
        var_session,
        var_length
    );


    // Release cached frame.
    if (frame_4ad7fb1c164aa08c3de4745ff8bb3abb == cache_frame_4ad7fb1c164aa08c3de4745ff8bb3abb) {
        Py_DECREF(frame_4ad7fb1c164aa08c3de4745ff8bb3abb);
    }
    cache_frame_4ad7fb1c164aa08c3de4745ff8bb3abb = NULL;

    assertFrameObject(frame_4ad7fb1c164aa08c3de4745ff8bb3abb);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_90_client_random);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_outp);
    var_outp = NULL;

    CHECK_OBJECT((PyObject *)var_session);
    Py_DECREF(var_session);
    var_session = NULL;

    Py_XDECREF(var_length);
    var_length = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_outp);
    var_outp = NULL;

    Py_XDECREF(var_session);
    var_session = NULL;

    Py_XDECREF(var_length);
    var_length = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_90_client_random);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_91_master_key(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_outp = NULL;
    PyObject *var_session = NULL;
    PyObject *var_length = NULL;
    struct Nuitka_FrameObject *frame_bb87c94112fe99283e7d060ed1328b6e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_bb87c94112fe99283e7d060ed1328b6e = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_bb87c94112fe99283e7d060ed1328b6e, codeobj_bb87c94112fe99283e7d060ed1328b6e, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_bb87c94112fe99283e7d060ed1328b6e = cache_frame_bb87c94112fe99283e7d060ed1328b6e;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_bb87c94112fe99283e7d060ed1328b6e);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_bb87c94112fe99283e7d060ed1328b6e) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2144;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_get_session);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2144;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__ssl);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2144;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_bb87c94112fe99283e7d060ed1328b6e->m_frame.f_lineno = 2144;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2144;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_session == NULL);
        var_session = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT(var_session);
        tmp_compexpr_left_1 = var_session;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2145;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_NULL);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2145;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2145;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_None;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2148;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_3;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_SSL_SESSION_get_master_key);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2148;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_session);
        tmp_args_element_name_2 = var_session;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_4 == NULL) {
            Py_DECREF(tmp_called_name_2);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2148;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_4;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_NULL);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 2148;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_4 = const_int_0;
        frame_bb87c94112fe99283e7d060ed1328b6e->m_frame.f_lineno = 2148;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4};
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2148;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_length == NULL);
        var_length = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        CHECK_OBJECT(var_length);
        tmp_compexpr_left_2 = var_length;
        tmp_compexpr_right_2 = const_int_0;
        tmp_operand_name_1 = RICH_COMPARE_GT_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2149;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2149;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_1;
            tmp_raise_type_1 = PyExc_AssertionError;
            exception_type = tmp_raise_type_1;
            Py_INCREF(tmp_raise_type_1);
            exception_lineno = 2149;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_args_element_name_6;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__no_zero_allocator);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__no_zero_allocator);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1838 ], 47, 0);
            exception_tb = NULL;

            exception_lineno = 2150;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_5;
        tmp_args_element_name_5 = const_str_digest_81f1b0dfcc7a862e6940580ec4cc42d3;
        CHECK_OBJECT(var_length);
        tmp_args_element_name_6 = var_length;
        frame_bb87c94112fe99283e7d060ed1328b6e->m_frame.f_lineno = 2150;
        {
            PyObject *call_args[] = {tmp_args_element_name_5, tmp_args_element_name_6};
            tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_3, call_args);
        }

        if (tmp_assign_source_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2150;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_outp == NULL);
        var_outp = tmp_assign_source_3;
    }
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_args_element_name_9;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_6 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2151;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_6;
        CHECK_OBJECT(var_session);
        tmp_args_element_name_7 = var_session;
        CHECK_OBJECT(var_outp);
        tmp_args_element_name_8 = var_outp;
        CHECK_OBJECT(var_length);
        tmp_args_element_name_9 = var_length;
        frame_bb87c94112fe99283e7d060ed1328b6e->m_frame.f_lineno = 2151;
        {
            PyObject *call_args[] = {tmp_args_element_name_7, tmp_args_element_name_8, tmp_args_element_name_9};
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS3(tmp_called_instance_1, const_str_plain_SSL_SESSION_get_master_key, call_args);
        }

        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2151;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        Py_ssize_t tmp_sliceslicedel_index_lower_1;
        Py_ssize_t tmp_slice_index_upper_1;
        PyObject *tmp_slice_source_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_args_element_name_11;
        tmp_sliceslicedel_index_lower_1 = 0;
        tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_7 == NULL)) {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_7 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2152;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_7;
        CHECK_OBJECT(var_outp);
        tmp_args_element_name_10 = var_outp;
        CHECK_OBJECT(var_length);
        tmp_args_element_name_11 = var_length;
        frame_bb87c94112fe99283e7d060ed1328b6e->m_frame.f_lineno = 2152;
        {
            PyObject *call_args[] = {tmp_args_element_name_10, tmp_args_element_name_11};
            tmp_slice_source_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_2, const_str_plain_buffer, call_args);
        }

        if (tmp_slice_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2152;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = LOOKUP_INDEX_SLICE(tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1);
        Py_DECREF(tmp_slice_source_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2152;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_bb87c94112fe99283e7d060ed1328b6e);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_bb87c94112fe99283e7d060ed1328b6e);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_bb87c94112fe99283e7d060ed1328b6e);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_bb87c94112fe99283e7d060ed1328b6e, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_bb87c94112fe99283e7d060ed1328b6e->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_bb87c94112fe99283e7d060ed1328b6e, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_bb87c94112fe99283e7d060ed1328b6e,
        type_description_1,
        par_self,
        var_outp,
        var_session,
        var_length
    );


    // Release cached frame.
    if (frame_bb87c94112fe99283e7d060ed1328b6e == cache_frame_bb87c94112fe99283e7d060ed1328b6e) {
        Py_DECREF(frame_bb87c94112fe99283e7d060ed1328b6e);
    }
    cache_frame_bb87c94112fe99283e7d060ed1328b6e = NULL;

    assertFrameObject(frame_bb87c94112fe99283e7d060ed1328b6e);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_91_master_key);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_outp);
    var_outp = NULL;

    CHECK_OBJECT((PyObject *)var_session);
    Py_DECREF(var_session);
    var_session = NULL;

    Py_XDECREF(var_length);
    var_length = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_outp);
    var_outp = NULL;

    Py_XDECREF(var_session);
    var_session = NULL;

    Py_XDECREF(var_length);
    var_length = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_91_master_key);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_92_export_keying_material(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_label = python_pars[1];
    PyObject *par_olen = python_pars[2];
    PyObject *par_context = python_pars[3];
    PyObject *var_outp = NULL;
    PyObject *var_use_context = NULL;
    PyObject *var_success = NULL;
    PyObject *var_context_buf = NULL;
    PyObject *var_context_len = NULL;
    struct Nuitka_FrameObject *frame_26dc7c955eece9f3eeb0e341a1ceda0b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_26dc7c955eece9f3eeb0e341a1ceda0b = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_26dc7c955eece9f3eeb0e341a1ceda0b, codeobj_26dc7c955eece9f3eeb0e341a1ceda0b, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_26dc7c955eece9f3eeb0e341a1ceda0b = cache_frame_26dc7c955eece9f3eeb0e341a1ceda0b;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_26dc7c955eece9f3eeb0e341a1ceda0b);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_26dc7c955eece9f3eeb0e341a1ceda0b) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__no_zero_allocator);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__no_zero_allocator);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1838 ], 47, 0);
            exception_tb = NULL;

            exception_lineno = 2163;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        tmp_args_element_name_1 = const_str_digest_81f1b0dfcc7a862e6940580ec4cc42d3;
        CHECK_OBJECT(par_olen);
        tmp_args_element_name_2 = par_olen;
        frame_26dc7c955eece9f3eeb0e341a1ceda0b->m_frame.f_lineno = 2163;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2163;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_outp == NULL);
        var_outp = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2164;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_assign_source_2 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_NULL);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2164;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_context_buf == NULL);
        var_context_buf = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        tmp_assign_source_3 = const_int_0;
        assert(var_context_len == NULL);
        Py_INCREF(tmp_assign_source_3);
        var_context_len = tmp_assign_source_3;
    }
    {
        PyObject *tmp_assign_source_4;
        tmp_assign_source_4 = const_int_0;
        assert(var_use_context == NULL);
        Py_INCREF(tmp_assign_source_4);
        var_use_context = tmp_assign_source_4;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_context);
        tmp_compexpr_left_1 = par_context;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 != tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_5;
            CHECK_OBJECT(par_context);
            tmp_assign_source_5 = par_context;
            {
                PyObject *old = var_context_buf;
                assert(old != NULL);
                var_context_buf = tmp_assign_source_5;
                Py_INCREF(var_context_buf);
                Py_DECREF(old);
            }

        }
        {
            PyObject *tmp_assign_source_6;
            PyObject *tmp_len_arg_1;
            CHECK_OBJECT(par_context);
            tmp_len_arg_1 = par_context;
            tmp_assign_source_6 = BUILTIN_LEN(tmp_len_arg_1);
            if (tmp_assign_source_6 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2169;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = var_context_len;
                assert(old != NULL);
                var_context_len = tmp_assign_source_6;
                Py_DECREF(old);
            }

        }
        {
            PyObject *tmp_assign_source_7;
            tmp_assign_source_7 = const_int_pos_1;
            {
                PyObject *old = var_use_context;
                assert(old != NULL);
                var_use_context = tmp_assign_source_7;
                Py_INCREF(var_use_context);
                Py_DECREF(old);
            }

        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_8;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_len_arg_2;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_args_element_name_10;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2171;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_SSL_export_keying_material);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2171;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__ssl);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 2171;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_outp);
        tmp_args_element_name_4 = var_outp;
        CHECK_OBJECT(par_olen);
        tmp_args_element_name_5 = par_olen;
        CHECK_OBJECT(par_label);
        tmp_args_element_name_6 = par_label;
        CHECK_OBJECT(par_label);
        tmp_len_arg_2 = par_label;
        tmp_args_element_name_7 = BUILTIN_LEN(tmp_len_arg_2);
        if (tmp_args_element_name_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_3);

            exception_lineno = 2172;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_context_buf);
        tmp_args_element_name_8 = var_context_buf;
        CHECK_OBJECT(var_context_len);
        tmp_args_element_name_9 = var_context_len;
        CHECK_OBJECT(var_use_context);
        tmp_args_element_name_10 = var_use_context;
        frame_26dc7c955eece9f3eeb0e341a1ceda0b->m_frame.f_lineno = 2171;
        {
            PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5, tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8, tmp_args_element_name_9, tmp_args_element_name_10};
            tmp_assign_source_8 = CALL_FUNCTION_WITH_ARGS8(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_3);
        Py_DECREF(tmp_args_element_name_7);
        if (tmp_assign_source_8 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2171;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_success == NULL);
        var_success = tmp_assign_source_8;
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_11;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 2175;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_4;
        CHECK_OBJECT(var_success);
        tmp_compexpr_left_2 = var_success;
        tmp_compexpr_right_2 = const_int_pos_1;
        tmp_args_element_name_11 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
        if (tmp_args_element_name_11 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2175;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        frame_26dc7c955eece9f3eeb0e341a1ceda0b->m_frame.f_lineno = 2175;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_3, tmp_args_element_name_11);
        Py_DECREF(tmp_args_element_name_11);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2175;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        Py_ssize_t tmp_sliceslicedel_index_lower_1;
        Py_ssize_t tmp_slice_index_upper_1;
        PyObject *tmp_slice_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_12;
        PyObject *tmp_args_element_name_13;
        tmp_sliceslicedel_index_lower_1 = 0;
        tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2176;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_5;
        CHECK_OBJECT(var_outp);
        tmp_args_element_name_12 = var_outp;
        CHECK_OBJECT(par_olen);
        tmp_args_element_name_13 = par_olen;
        frame_26dc7c955eece9f3eeb0e341a1ceda0b->m_frame.f_lineno = 2176;
        {
            PyObject *call_args[] = {tmp_args_element_name_12, tmp_args_element_name_13};
            tmp_slice_source_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain_buffer, call_args);
        }

        if (tmp_slice_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2176;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = LOOKUP_INDEX_SLICE(tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1);
        Py_DECREF(tmp_slice_source_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2176;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_26dc7c955eece9f3eeb0e341a1ceda0b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_26dc7c955eece9f3eeb0e341a1ceda0b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_26dc7c955eece9f3eeb0e341a1ceda0b);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_26dc7c955eece9f3eeb0e341a1ceda0b, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_26dc7c955eece9f3eeb0e341a1ceda0b->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_26dc7c955eece9f3eeb0e341a1ceda0b, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_26dc7c955eece9f3eeb0e341a1ceda0b,
        type_description_1,
        par_self,
        par_label,
        par_olen,
        par_context,
        var_outp,
        var_use_context,
        var_success,
        var_context_buf,
        var_context_len
    );


    // Release cached frame.
    if (frame_26dc7c955eece9f3eeb0e341a1ceda0b == cache_frame_26dc7c955eece9f3eeb0e341a1ceda0b) {
        Py_DECREF(frame_26dc7c955eece9f3eeb0e341a1ceda0b);
    }
    cache_frame_26dc7c955eece9f3eeb0e341a1ceda0b = NULL;

    assertFrameObject(frame_26dc7c955eece9f3eeb0e341a1ceda0b);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_92_export_keying_material);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_outp);
    Py_DECREF(var_outp);
    var_outp = NULL;

    CHECK_OBJECT((PyObject *)var_use_context);
    Py_DECREF(var_use_context);
    var_use_context = NULL;

    CHECK_OBJECT((PyObject *)var_success);
    Py_DECREF(var_success);
    var_success = NULL;

    CHECK_OBJECT((PyObject *)var_context_buf);
    Py_DECREF(var_context_buf);
    var_context_buf = NULL;

    CHECK_OBJECT((PyObject *)var_context_len);
    Py_DECREF(var_context_len);
    var_context_len = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_outp);
    var_outp = NULL;

    Py_XDECREF(var_use_context);
    var_use_context = NULL;

    Py_XDECREF(var_success);
    var_success = NULL;

    Py_XDECREF(var_context_buf);
    var_context_buf = NULL;

    Py_XDECREF(var_context_len);
    var_context_len = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_92_export_keying_material);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_label);
    Py_DECREF(par_label);
    CHECK_OBJECT(par_context);
    Py_DECREF(par_context);
    CHECK_OBJECT(par_olen);
    Py_DECREF(par_olen);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_label);
    Py_DECREF(par_label);
    CHECK_OBJECT(par_context);
    Py_DECREF(par_context);
    CHECK_OBJECT(par_olen);
    Py_DECREF(par_olen);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_93_sock_shutdown(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_args = python_pars[1];
    PyObject *par_kwargs = python_pars[2];
    struct Nuitka_FrameObject *frame_0a0cad4a67aba10eabe93e57ee235747;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_0a0cad4a67aba10eabe93e57ee235747 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_0a0cad4a67aba10eabe93e57ee235747, codeobj_0a0cad4a67aba10eabe93e57ee235747, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_0a0cad4a67aba10eabe93e57ee235747 = cache_frame_0a0cad4a67aba10eabe93e57ee235747;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_0a0cad4a67aba10eabe93e57ee235747);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_0a0cad4a67aba10eabe93e57ee235747) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_dircall_arg1_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_dircall_arg2_1;
        PyObject *tmp_dircall_arg3_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__socket);
        if (tmp_source_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2185;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_shutdown);
        Py_DECREF(tmp_source_name_1);
        if (tmp_dircall_arg1_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2185;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_args);
        tmp_dircall_arg2_1 = par_args;
        CHECK_OBJECT(par_kwargs);
        tmp_dircall_arg3_1 = par_kwargs;
        Py_INCREF(tmp_dircall_arg2_1);
        Py_INCREF(tmp_dircall_arg3_1);

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1};
            tmp_return_value = impl___internal__$$$function_1_complex_call_helper_star_list_star_dict(dir_call_args);
        }
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2185;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0a0cad4a67aba10eabe93e57ee235747);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_0a0cad4a67aba10eabe93e57ee235747);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0a0cad4a67aba10eabe93e57ee235747);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_0a0cad4a67aba10eabe93e57ee235747, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_0a0cad4a67aba10eabe93e57ee235747->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_0a0cad4a67aba10eabe93e57ee235747, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0a0cad4a67aba10eabe93e57ee235747,
        type_description_1,
        par_self,
        par_args,
        par_kwargs
    );


    // Release cached frame.
    if (frame_0a0cad4a67aba10eabe93e57ee235747 == cache_frame_0a0cad4a67aba10eabe93e57ee235747) {
        Py_DECREF(frame_0a0cad4a67aba10eabe93e57ee235747);
    }
    cache_frame_0a0cad4a67aba10eabe93e57ee235747 = NULL;

    assertFrameObject(frame_0a0cad4a67aba10eabe93e57ee235747);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_93_sock_shutdown);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_args);
    Py_DECREF(par_args);
    CHECK_OBJECT(par_kwargs);
    Py_DECREF(par_kwargs);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_args);
    Py_DECREF(par_args);
    CHECK_OBJECT(par_kwargs);
    Py_DECREF(par_kwargs);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_94_get_certificate(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_cert = NULL;
    struct Nuitka_FrameObject *frame_3946b9a412811e47d3779a1e62a72e4b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_3946b9a412811e47d3779a1e62a72e4b = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_3946b9a412811e47d3779a1e62a72e4b, codeobj_3946b9a412811e47d3779a1e62a72e4b, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *));
    frame_3946b9a412811e47d3779a1e62a72e4b = cache_frame_3946b9a412811e47d3779a1e62a72e4b;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_3946b9a412811e47d3779a1e62a72e4b);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_3946b9a412811e47d3779a1e62a72e4b) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2193;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_get_certificate);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2193;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__ssl);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2193;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_3946b9a412811e47d3779a1e62a72e4b->m_frame.f_lineno = 2193;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2193;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert(var_cert == NULL);
        var_cert = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT(var_cert);
        tmp_compexpr_left_1 = var_cert;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2194;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_NULL);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2194;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2194;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_2;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_3 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 2195;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_1 = tmp_mvar_value_3;
            CHECK_OBJECT(var_cert);
            tmp_args_element_name_2 = var_cert;
            frame_3946b9a412811e47d3779a1e62a72e4b->m_frame.f_lineno = 2195;
            {
                PyObject *call_args[] = {tmp_args_element_name_2};
                tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_X509_up_ref, call_args);
            }

            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2195;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_1);
        }
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_args_element_name_3;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509);
            }

            if (tmp_mvar_value_4 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 236 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 2196;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_2 = tmp_mvar_value_4;
            CHECK_OBJECT(var_cert);
            tmp_args_element_name_3 = var_cert;
            frame_3946b9a412811e47d3779a1e62a72e4b->m_frame.f_lineno = 2196;
            {
                PyObject *call_args[] = {tmp_args_element_name_3};
                tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain__from_raw_x509_ptr, call_args);
            }

            if (tmp_return_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2196;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3946b9a412811e47d3779a1e62a72e4b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_3946b9a412811e47d3779a1e62a72e4b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3946b9a412811e47d3779a1e62a72e4b);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_3946b9a412811e47d3779a1e62a72e4b, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_3946b9a412811e47d3779a1e62a72e4b->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_3946b9a412811e47d3779a1e62a72e4b, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3946b9a412811e47d3779a1e62a72e4b,
        type_description_1,
        par_self,
        var_cert
    );


    // Release cached frame.
    if (frame_3946b9a412811e47d3779a1e62a72e4b == cache_frame_3946b9a412811e47d3779a1e62a72e4b) {
        Py_DECREF(frame_3946b9a412811e47d3779a1e62a72e4b);
    }
    cache_frame_3946b9a412811e47d3779a1e62a72e4b = NULL;

    assertFrameObject(frame_3946b9a412811e47d3779a1e62a72e4b);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_94_get_certificate);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_cert);
    Py_DECREF(var_cert);
    var_cert = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_cert);
    var_cert = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_94_get_certificate);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_95_get_peer_certificate(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_cert = NULL;
    struct Nuitka_FrameObject *frame_3f6bd2362b83f8e85f091e7fc006c6ad;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_3f6bd2362b83f8e85f091e7fc006c6ad = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_3f6bd2362b83f8e85f091e7fc006c6ad, codeobj_3f6bd2362b83f8e85f091e7fc006c6ad, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *));
    frame_3f6bd2362b83f8e85f091e7fc006c6ad = cache_frame_3f6bd2362b83f8e85f091e7fc006c6ad;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_3f6bd2362b83f8e85f091e7fc006c6ad);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_3f6bd2362b83f8e85f091e7fc006c6ad) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2205;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_get_peer_certificate);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2205;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__ssl);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2205;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_3f6bd2362b83f8e85f091e7fc006c6ad->m_frame.f_lineno = 2205;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2205;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert(var_cert == NULL);
        var_cert = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT(var_cert);
        tmp_compexpr_left_1 = var_cert;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2206;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_NULL);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2206;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2206;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_args_element_name_2;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509);
            }

            if (tmp_mvar_value_3 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 236 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 2207;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_1 = tmp_mvar_value_3;
            CHECK_OBJECT(var_cert);
            tmp_args_element_name_2 = var_cert;
            frame_3f6bd2362b83f8e85f091e7fc006c6ad->m_frame.f_lineno = 2207;
            {
                PyObject *call_args[] = {tmp_args_element_name_2};
                tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain__from_raw_x509_ptr, call_args);
            }

            if (tmp_return_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2207;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3f6bd2362b83f8e85f091e7fc006c6ad);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_3f6bd2362b83f8e85f091e7fc006c6ad);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3f6bd2362b83f8e85f091e7fc006c6ad);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_3f6bd2362b83f8e85f091e7fc006c6ad, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_3f6bd2362b83f8e85f091e7fc006c6ad->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_3f6bd2362b83f8e85f091e7fc006c6ad, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3f6bd2362b83f8e85f091e7fc006c6ad,
        type_description_1,
        par_self,
        var_cert
    );


    // Release cached frame.
    if (frame_3f6bd2362b83f8e85f091e7fc006c6ad == cache_frame_3f6bd2362b83f8e85f091e7fc006c6ad) {
        Py_DECREF(frame_3f6bd2362b83f8e85f091e7fc006c6ad);
    }
    cache_frame_3f6bd2362b83f8e85f091e7fc006c6ad = NULL;

    assertFrameObject(frame_3f6bd2362b83f8e85f091e7fc006c6ad);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_95_get_peer_certificate);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_cert);
    Py_DECREF(var_cert);
    var_cert = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_cert);
    var_cert = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_95_get_peer_certificate);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_96_get_peer_cert_chain(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_i = NULL;
    PyObject *var_cert_stack = NULL;
    PyObject *var_pycert = NULL;
    PyObject *var_cert = NULL;
    PyObject *var_result = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_b0089d377af5c5ab7b6943168bf04c70;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_b0089d377af5c5ab7b6943168bf04c70 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_b0089d377af5c5ab7b6943168bf04c70, codeobj_b0089d377af5c5ab7b6943168bf04c70, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_b0089d377af5c5ab7b6943168bf04c70 = cache_frame_b0089d377af5c5ab7b6943168bf04c70;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_b0089d377af5c5ab7b6943168bf04c70);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_b0089d377af5c5ab7b6943168bf04c70) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2217;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_get_peer_cert_chain);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2217;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__ssl);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2217;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_b0089d377af5c5ab7b6943168bf04c70->m_frame.f_lineno = 2217;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2217;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert(var_cert_stack == NULL);
        var_cert_stack = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT(var_cert_stack);
        tmp_compexpr_left_1 = var_cert_stack;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2218;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_NULL);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2218;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2218;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_None;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_2;
        tmp_assign_source_2 = PyList_New(0);
        assert(var_result == NULL);
        var_result = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_range_arg_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2222;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_3;
        CHECK_OBJECT(var_cert_stack);
        tmp_args_element_name_2 = var_cert_stack;
        frame_b0089d377af5c5ab7b6943168bf04c70->m_frame.f_lineno = 2222;
        {
            PyObject *call_args[] = {tmp_args_element_name_2};
            tmp_range_arg_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_sk_X509_num, call_args);
        }

        if (tmp_range_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2222;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_iter_arg_1 = BUILTIN_RANGE(tmp_range_arg_1);
        Py_DECREF(tmp_range_arg_1);
        if (tmp_iter_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2222;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_3 = MAKE_ITERATOR(tmp_iter_arg_1);
        Py_DECREF(tmp_iter_arg_1);
        if (tmp_assign_source_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2222;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert(tmp_for_loop_1__for_iterator == NULL);
        tmp_for_loop_1__for_iterator = tmp_assign_source_3;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_4;
        CHECK_OBJECT(tmp_for_loop_1__for_iterator);
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_4 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_4 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "oooooo";
                exception_lineno = 2222;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_4;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_5;
        CHECK_OBJECT(tmp_for_loop_1__iter_value);
        tmp_assign_source_5 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_i;
            var_i = tmp_assign_source_5;
            Py_INCREF(var_i);
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2224;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }

        tmp_source_name_4 = tmp_mvar_value_4;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_X509_dup);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2224;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_5 == NULL) {
            Py_DECREF(tmp_called_name_2);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2224;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_2 = tmp_mvar_value_5;
        CHECK_OBJECT(var_cert_stack);
        tmp_args_element_name_4 = var_cert_stack;
        CHECK_OBJECT(var_i);
        tmp_args_element_name_5 = var_i;
        frame_b0089d377af5c5ab7b6943168bf04c70->m_frame.f_lineno = 2224;
        {
            PyObject *call_args[] = {tmp_args_element_name_4, tmp_args_element_name_5};
            tmp_args_element_name_3 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_2, const_str_plain_sk_X509_value, call_args);
        }

        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 2224;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }
        frame_b0089d377af5c5ab7b6943168bf04c70->m_frame.f_lineno = 2224;
        tmp_assign_source_6 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_3);
        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_assign_source_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2224;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_cert;
            var_cert = tmp_assign_source_6;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_args_element_name_6;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_X509);
        }

        if (tmp_mvar_value_6 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 236 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2225;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_3 = tmp_mvar_value_6;
        CHECK_OBJECT(var_cert);
        tmp_args_element_name_6 = var_cert;
        frame_b0089d377af5c5ab7b6943168bf04c70->m_frame.f_lineno = 2225;
        {
            PyObject *call_args[] = {tmp_args_element_name_6};
            tmp_assign_source_7 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_3, const_str_plain__from_raw_x509_ptr, call_args);
        }

        if (tmp_assign_source_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2225;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_pycert;
            var_pycert = tmp_assign_source_7;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_called_instance_4;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_7;
        CHECK_OBJECT(var_result);
        tmp_called_instance_4 = var_result;
        CHECK_OBJECT(var_pycert);
        tmp_args_element_name_7 = var_pycert;
        frame_b0089d377af5c5ab7b6943168bf04c70->m_frame.f_lineno = 2226;
        {
            PyObject *call_args[] = {tmp_args_element_name_7};
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_4, const_str_plain_append, call_args);
        }

        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2226;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }
        Py_DECREF(tmp_call_result_1);
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


        exception_lineno = 2222;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b0089d377af5c5ab7b6943168bf04c70);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_b0089d377af5c5ab7b6943168bf04c70);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b0089d377af5c5ab7b6943168bf04c70);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_b0089d377af5c5ab7b6943168bf04c70, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_b0089d377af5c5ab7b6943168bf04c70->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_b0089d377af5c5ab7b6943168bf04c70, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b0089d377af5c5ab7b6943168bf04c70,
        type_description_1,
        par_self,
        var_i,
        var_cert_stack,
        var_pycert,
        var_cert,
        var_result
    );


    // Release cached frame.
    if (frame_b0089d377af5c5ab7b6943168bf04c70 == cache_frame_b0089d377af5c5ab7b6943168bf04c70) {
        Py_DECREF(frame_b0089d377af5c5ab7b6943168bf04c70);
    }
    cache_frame_b0089d377af5c5ab7b6943168bf04c70 = NULL;

    assertFrameObject(frame_b0089d377af5c5ab7b6943168bf04c70);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    CHECK_OBJECT(var_result);
    tmp_return_value = var_result;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_96_get_peer_cert_chain);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_i);
    var_i = NULL;

    CHECK_OBJECT((PyObject *)var_cert_stack);
    Py_DECREF(var_cert_stack);
    var_cert_stack = NULL;

    Py_XDECREF(var_pycert);
    var_pycert = NULL;

    Py_XDECREF(var_cert);
    var_cert = NULL;

    Py_XDECREF(var_result);
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_i);
    var_i = NULL;

    Py_XDECREF(var_cert_stack);
    var_cert_stack = NULL;

    Py_XDECREF(var_pycert);
    var_pycert = NULL;

    Py_XDECREF(var_cert);
    var_cert = NULL;

    Py_XDECREF(var_result);
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_96_get_peer_cert_chain);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_97_want_read(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_c34dc8d8e69e96a1fdc1da393173e7eb;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_c34dc8d8e69e96a1fdc1da393173e7eb = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_c34dc8d8e69e96a1fdc1da393173e7eb, codeobj_c34dc8d8e69e96a1fdc1da393173e7eb, module_OpenSSL$SSL, sizeof(void *));
    frame_c34dc8d8e69e96a1fdc1da393173e7eb = cache_frame_c34dc8d8e69e96a1fdc1da393173e7eb;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_c34dc8d8e69e96a1fdc1da393173e7eb);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_c34dc8d8e69e96a1fdc1da393173e7eb) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2236;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_want_read);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2236;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__ssl);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2236;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_c34dc8d8e69e96a1fdc1da393173e7eb->m_frame.f_lineno = 2236;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2236;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c34dc8d8e69e96a1fdc1da393173e7eb);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_c34dc8d8e69e96a1fdc1da393173e7eb);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c34dc8d8e69e96a1fdc1da393173e7eb);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_c34dc8d8e69e96a1fdc1da393173e7eb, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_c34dc8d8e69e96a1fdc1da393173e7eb->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_c34dc8d8e69e96a1fdc1da393173e7eb, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c34dc8d8e69e96a1fdc1da393173e7eb,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_c34dc8d8e69e96a1fdc1da393173e7eb == cache_frame_c34dc8d8e69e96a1fdc1da393173e7eb) {
        Py_DECREF(frame_c34dc8d8e69e96a1fdc1da393173e7eb);
    }
    cache_frame_c34dc8d8e69e96a1fdc1da393173e7eb = NULL;

    assertFrameObject(frame_c34dc8d8e69e96a1fdc1da393173e7eb);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_97_want_read);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_98_want_write(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_f69b17c8965a6426ab8e389546eeab2c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_f69b17c8965a6426ab8e389546eeab2c = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_f69b17c8965a6426ab8e389546eeab2c, codeobj_f69b17c8965a6426ab8e389546eeab2c, module_OpenSSL$SSL, sizeof(void *));
    frame_f69b17c8965a6426ab8e389546eeab2c = cache_frame_f69b17c8965a6426ab8e389546eeab2c;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_f69b17c8965a6426ab8e389546eeab2c);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_f69b17c8965a6426ab8e389546eeab2c) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2245;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_want_write);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2245;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__ssl);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2245;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_f69b17c8965a6426ab8e389546eeab2c->m_frame.f_lineno = 2245;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2245;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_f69b17c8965a6426ab8e389546eeab2c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_f69b17c8965a6426ab8e389546eeab2c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_f69b17c8965a6426ab8e389546eeab2c);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_f69b17c8965a6426ab8e389546eeab2c, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_f69b17c8965a6426ab8e389546eeab2c->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_f69b17c8965a6426ab8e389546eeab2c, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f69b17c8965a6426ab8e389546eeab2c,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_f69b17c8965a6426ab8e389546eeab2c == cache_frame_f69b17c8965a6426ab8e389546eeab2c) {
        Py_DECREF(frame_f69b17c8965a6426ab8e389546eeab2c);
    }
    cache_frame_f69b17c8965a6426ab8e389546eeab2c = NULL;

    assertFrameObject(frame_f69b17c8965a6426ab8e389546eeab2c);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_98_want_write);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_99_set_accept_state(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_201bf75d84b5bdea5cfec00b8b8c8ba7;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_201bf75d84b5bdea5cfec00b8b8c8ba7 = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_201bf75d84b5bdea5cfec00b8b8c8ba7, codeobj_201bf75d84b5bdea5cfec00b8b8c8ba7, module_OpenSSL$SSL, sizeof(void *));
    frame_201bf75d84b5bdea5cfec00b8b8c8ba7 = cache_frame_201bf75d84b5bdea5cfec00b8b8c8ba7;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_201bf75d84b5bdea5cfec00b8b8c8ba7);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_201bf75d84b5bdea5cfec00b8b8c8ba7) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2254;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_set_accept_state);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2254;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__ssl);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2254;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_201bf75d84b5bdea5cfec00b8b8c8ba7->m_frame.f_lineno = 2254;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2254;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_201bf75d84b5bdea5cfec00b8b8c8ba7);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_201bf75d84b5bdea5cfec00b8b8c8ba7);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_201bf75d84b5bdea5cfec00b8b8c8ba7, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_201bf75d84b5bdea5cfec00b8b8c8ba7->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_201bf75d84b5bdea5cfec00b8b8c8ba7, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_201bf75d84b5bdea5cfec00b8b8c8ba7,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_201bf75d84b5bdea5cfec00b8b8c8ba7 == cache_frame_201bf75d84b5bdea5cfec00b8b8c8ba7) {
        Py_DECREF(frame_201bf75d84b5bdea5cfec00b8b8c8ba7);
    }
    cache_frame_201bf75d84b5bdea5cfec00b8b8c8ba7 = NULL;

    assertFrameObject(frame_201bf75d84b5bdea5cfec00b8b8c8ba7);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_99_set_accept_state);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_100_set_connect_state(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_d43339cac2a23168c71e48b85d7e240f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_d43339cac2a23168c71e48b85d7e240f = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_d43339cac2a23168c71e48b85d7e240f, codeobj_d43339cac2a23168c71e48b85d7e240f, module_OpenSSL$SSL, sizeof(void *));
    frame_d43339cac2a23168c71e48b85d7e240f = cache_frame_d43339cac2a23168c71e48b85d7e240f;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_d43339cac2a23168c71e48b85d7e240f);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_d43339cac2a23168c71e48b85d7e240f) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2263;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_set_connect_state);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2263;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__ssl);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2263;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_d43339cac2a23168c71e48b85d7e240f->m_frame.f_lineno = 2263;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2263;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_d43339cac2a23168c71e48b85d7e240f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_d43339cac2a23168c71e48b85d7e240f);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_d43339cac2a23168c71e48b85d7e240f, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_d43339cac2a23168c71e48b85d7e240f->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_d43339cac2a23168c71e48b85d7e240f, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d43339cac2a23168c71e48b85d7e240f,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_d43339cac2a23168c71e48b85d7e240f == cache_frame_d43339cac2a23168c71e48b85d7e240f) {
        Py_DECREF(frame_d43339cac2a23168c71e48b85d7e240f);
    }
    cache_frame_d43339cac2a23168c71e48b85d7e240f = NULL;

    assertFrameObject(frame_d43339cac2a23168c71e48b85d7e240f);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_100_set_connect_state);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_101_get_session(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_session = NULL;
    PyObject *var_pysession = NULL;
    struct Nuitka_FrameObject *frame_52829c318867d59743de899b39d5abac;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_52829c318867d59743de899b39d5abac = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_52829c318867d59743de899b39d5abac, codeobj_52829c318867d59743de899b39d5abac, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_52829c318867d59743de899b39d5abac = cache_frame_52829c318867d59743de899b39d5abac;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_52829c318867d59743de899b39d5abac);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_52829c318867d59743de899b39d5abac) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2274;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_get1_session);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2274;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__ssl);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2274;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_52829c318867d59743de899b39d5abac->m_frame.f_lineno = 2274;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2274;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_session == NULL);
        var_session = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT(var_session);
        tmp_compexpr_left_1 = var_session;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2275;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_NULL);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2275;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2275;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_None;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_mvar_value_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Session);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_Session);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1990 ], 36, 0);
            exception_tb = NULL;

            exception_lineno = 2278;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_3;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain___new__);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2278;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Session);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_Session);
        }

        if (tmp_mvar_value_4 == NULL) {
            Py_DECREF(tmp_called_name_2);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1990 ], 36, 0);
            exception_tb = NULL;

            exception_lineno = 2278;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_2 = tmp_mvar_value_4;
        frame_52829c318867d59743de899b39d5abac->m_frame.f_lineno = 2278;
        tmp_assign_source_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_2);
        Py_DECREF(tmp_called_name_2);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2278;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_pysession == NULL);
        var_pysession = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2279;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_5;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_gc);
        if (tmp_called_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2279;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_session);
        tmp_args_element_name_3 = var_session;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_6 == NULL) {
            Py_DECREF(tmp_called_name_3);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2279;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_6;
        tmp_args_element_name_4 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_SSL_SESSION_free);
        if (tmp_args_element_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);

            exception_lineno = 2279;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_52829c318867d59743de899b39d5abac->m_frame.f_lineno = 2279;
        {
            PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4};
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_3, call_args);
        }

        Py_DECREF(tmp_called_name_3);
        Py_DECREF(tmp_args_element_name_4);
        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2279;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_pysession);
        tmp_assattr_target_1 = var_pysession;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__session, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2279;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_52829c318867d59743de899b39d5abac);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_52829c318867d59743de899b39d5abac);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_52829c318867d59743de899b39d5abac);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_52829c318867d59743de899b39d5abac, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_52829c318867d59743de899b39d5abac->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_52829c318867d59743de899b39d5abac, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_52829c318867d59743de899b39d5abac,
        type_description_1,
        par_self,
        var_session,
        var_pysession
    );


    // Release cached frame.
    if (frame_52829c318867d59743de899b39d5abac == cache_frame_52829c318867d59743de899b39d5abac) {
        Py_DECREF(frame_52829c318867d59743de899b39d5abac);
    }
    cache_frame_52829c318867d59743de899b39d5abac = NULL;

    assertFrameObject(frame_52829c318867d59743de899b39d5abac);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT(var_pysession);
    tmp_return_value = var_pysession;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_101_get_session);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_session);
    Py_DECREF(var_session);
    var_session = NULL;

    Py_XDECREF(var_pysession);
    var_pysession = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_session);
    var_session = NULL;

    Py_XDECREF(var_pysession);
    var_pysession = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_101_get_session);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_102_set_session(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_session = python_pars[1];
    PyObject *var_result = NULL;
    struct Nuitka_FrameObject *frame_486bd2bad33e063a2af794bab2239dd3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_486bd2bad33e063a2af794bab2239dd3 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_486bd2bad33e063a2af794bab2239dd3, codeobj_486bd2bad33e063a2af794bab2239dd3, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_486bd2bad33e063a2af794bab2239dd3 = cache_frame_486bd2bad33e063a2af794bab2239dd3;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_486bd2bad33e063a2af794bab2239dd3);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_486bd2bad33e063a2af794bab2239dd3) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_session);
        tmp_isinstance_inst_1 = par_session;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Session);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_Session);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1990 ], 36, 0);
            exception_tb = NULL;

            exception_lineno = 2291;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2291;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2291;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_d5ded94dafea47ce6f2b4fa579755177;
            frame_486bd2bad33e063a2af794bab2239dd3->m_frame.f_lineno = 2292;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_SINGLE_ARG(PyExc_TypeError, tmp_make_exception_arg_1);
            assert(!(tmp_raise_type_1 == NULL));
            exception_type = tmp_raise_type_1;
            exception_lineno = 2292;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2294;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_set_session);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2294;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__ssl);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2294;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_session);
        tmp_source_name_3 = par_session;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__session);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_element_name_1);

            exception_lineno = 2294;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_486bd2bad33e063a2af794bab2239dd3->m_frame.f_lineno = 2294;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2294;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_result == NULL);
        var_result = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_2;
        CHECK_OBJECT(var_result);
        tmp_operand_name_2 = var_result;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2295;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_called_name_2;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_call_result_1;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error);
            }

            if (tmp_mvar_value_3 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 0 ], 49, 0);
                exception_tb = NULL;

                exception_lineno = 2296;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_2 = tmp_mvar_value_3;
            frame_486bd2bad33e063a2af794bab2239dd3->m_frame.f_lineno = 2296;
            tmp_call_result_1 = CALL_FUNCTION_NO_ARGS(tmp_called_name_2);
            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2296;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_1);
        }
        branch_no_2:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_486bd2bad33e063a2af794bab2239dd3);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_486bd2bad33e063a2af794bab2239dd3);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_486bd2bad33e063a2af794bab2239dd3, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_486bd2bad33e063a2af794bab2239dd3->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_486bd2bad33e063a2af794bab2239dd3, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_486bd2bad33e063a2af794bab2239dd3,
        type_description_1,
        par_self,
        par_session,
        var_result
    );


    // Release cached frame.
    if (frame_486bd2bad33e063a2af794bab2239dd3 == cache_frame_486bd2bad33e063a2af794bab2239dd3) {
        Py_DECREF(frame_486bd2bad33e063a2af794bab2239dd3);
    }
    cache_frame_486bd2bad33e063a2af794bab2239dd3 = NULL;

    assertFrameObject(frame_486bd2bad33e063a2af794bab2239dd3);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_102_set_session);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_result);
    Py_DECREF(var_result);
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_result);
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_102_set_session);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_session);
    Py_DECREF(par_session);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_session);
    Py_DECREF(par_session);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_103__get_finished_message(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_function = python_pars[1];
    PyObject *var_buf = NULL;
    PyObject *var_empty = NULL;
    PyObject *var_size = NULL;
    struct Nuitka_FrameObject *frame_22ca8433889a93275ebb1b4e80b3b8e9;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_22ca8433889a93275ebb1b4e80b3b8e9 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_22ca8433889a93275ebb1b4e80b3b8e9, codeobj_22ca8433889a93275ebb1b4e80b3b8e9, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_22ca8433889a93275ebb1b4e80b3b8e9 = cache_frame_22ca8433889a93275ebb1b4e80b3b8e9;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_22ca8433889a93275ebb1b4e80b3b8e9);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_22ca8433889a93275ebb1b4e80b3b8e9) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2322;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_22ca8433889a93275ebb1b4e80b3b8e9->m_frame.f_lineno = 2322;
        tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain_new, &PyTuple_GET_ITEM(const_tuple_str_digest_c561652c58984ec0e9541542aa405594_int_0_tuple, 0));

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2322;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(var_empty == NULL);
        var_empty = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        CHECK_OBJECT(par_function);
        tmp_called_name_1 = par_function;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__ssl);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2323;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_empty);
        tmp_args_element_name_2 = var_empty;
        tmp_args_element_name_3 = const_int_0;
        frame_22ca8433889a93275ebb1b4e80b3b8e9->m_frame.f_lineno = 2323;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2323;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(var_size == NULL);
        var_size = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(var_size);
        tmp_compexpr_left_1 = var_size;
        tmp_compexpr_right_1 = const_int_0;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_INT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2324;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_None;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__no_zero_allocator);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__no_zero_allocator);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1838 ], 47, 0);
            exception_tb = NULL;

            exception_lineno = 2328;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        tmp_args_element_name_4 = const_str_digest_c561652c58984ec0e9541542aa405594;
        CHECK_OBJECT(var_size);
        tmp_args_element_name_5 = var_size;
        frame_22ca8433889a93275ebb1b4e80b3b8e9->m_frame.f_lineno = 2328;
        {
            PyObject *call_args[] = {tmp_args_element_name_4, tmp_args_element_name_5};
            tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        if (tmp_assign_source_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2328;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(var_buf == NULL);
        var_buf = tmp_assign_source_3;
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_args_element_name_8;
        CHECK_OBJECT(par_function);
        tmp_called_name_3 = par_function;
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_6 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__ssl);
        if (tmp_args_element_name_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2329;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_buf);
        tmp_args_element_name_7 = var_buf;
        CHECK_OBJECT(var_size);
        tmp_args_element_name_8 = var_size;
        frame_22ca8433889a93275ebb1b4e80b3b8e9->m_frame.f_lineno = 2329;
        {
            PyObject *call_args[] = {tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8};
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_3, call_args);
        }

        Py_DECREF(tmp_args_element_name_6);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2329;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        Py_ssize_t tmp_sliceslicedel_index_lower_1;
        Py_ssize_t tmp_slice_index_upper_1;
        PyObject *tmp_slice_source_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_args_element_name_10;
        tmp_sliceslicedel_index_lower_1 = 0;
        tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2330;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_3;
        CHECK_OBJECT(var_buf);
        tmp_args_element_name_9 = var_buf;
        CHECK_OBJECT(var_size);
        tmp_args_element_name_10 = var_size;
        frame_22ca8433889a93275ebb1b4e80b3b8e9->m_frame.f_lineno = 2330;
        {
            PyObject *call_args[] = {tmp_args_element_name_9, tmp_args_element_name_10};
            tmp_slice_source_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_2, const_str_plain_buffer, call_args);
        }

        if (tmp_slice_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2330;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = LOOKUP_INDEX_SLICE(tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1);
        Py_DECREF(tmp_slice_source_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2330;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_22ca8433889a93275ebb1b4e80b3b8e9);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_22ca8433889a93275ebb1b4e80b3b8e9);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_22ca8433889a93275ebb1b4e80b3b8e9);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_22ca8433889a93275ebb1b4e80b3b8e9, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_22ca8433889a93275ebb1b4e80b3b8e9->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_22ca8433889a93275ebb1b4e80b3b8e9, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_22ca8433889a93275ebb1b4e80b3b8e9,
        type_description_1,
        par_self,
        par_function,
        var_buf,
        var_empty,
        var_size
    );


    // Release cached frame.
    if (frame_22ca8433889a93275ebb1b4e80b3b8e9 == cache_frame_22ca8433889a93275ebb1b4e80b3b8e9) {
        Py_DECREF(frame_22ca8433889a93275ebb1b4e80b3b8e9);
    }
    cache_frame_22ca8433889a93275ebb1b4e80b3b8e9 = NULL;

    assertFrameObject(frame_22ca8433889a93275ebb1b4e80b3b8e9);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_103__get_finished_message);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_buf);
    var_buf = NULL;

    CHECK_OBJECT((PyObject *)var_empty);
    Py_DECREF(var_empty);
    var_empty = NULL;

    CHECK_OBJECT((PyObject *)var_size);
    Py_DECREF(var_size);
    var_size = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_buf);
    var_buf = NULL;

    Py_XDECREF(var_empty);
    var_empty = NULL;

    Py_XDECREF(var_size);
    var_size = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_103__get_finished_message);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_function);
    Py_DECREF(par_function);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_function);
    Py_DECREF(par_function);
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_104_get_finished(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_729d8bc5b3418129828900f018d231cc;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_729d8bc5b3418129828900f018d231cc = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_729d8bc5b3418129828900f018d231cc, codeobj_729d8bc5b3418129828900f018d231cc, module_OpenSSL$SSL, sizeof(void *));
    frame_729d8bc5b3418129828900f018d231cc = cache_frame_729d8bc5b3418129828900f018d231cc;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_729d8bc5b3418129828900f018d231cc);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_729d8bc5b3418129828900f018d231cc) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__get_finished_message);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2342;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2342;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_1;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_SSL_get_finished);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2342;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_729d8bc5b3418129828900f018d231cc->m_frame.f_lineno = 2342;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2342;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_729d8bc5b3418129828900f018d231cc);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_729d8bc5b3418129828900f018d231cc);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_729d8bc5b3418129828900f018d231cc);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_729d8bc5b3418129828900f018d231cc, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_729d8bc5b3418129828900f018d231cc->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_729d8bc5b3418129828900f018d231cc, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_729d8bc5b3418129828900f018d231cc,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_729d8bc5b3418129828900f018d231cc == cache_frame_729d8bc5b3418129828900f018d231cc) {
        Py_DECREF(frame_729d8bc5b3418129828900f018d231cc);
    }
    cache_frame_729d8bc5b3418129828900f018d231cc = NULL;

    assertFrameObject(frame_729d8bc5b3418129828900f018d231cc);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_104_get_finished);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_105_get_peer_finished(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_a54ef0e991ddc5127543496476fffdc2;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_a54ef0e991ddc5127543496476fffdc2 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_a54ef0e991ddc5127543496476fffdc2, codeobj_a54ef0e991ddc5127543496476fffdc2, module_OpenSSL$SSL, sizeof(void *));
    frame_a54ef0e991ddc5127543496476fffdc2 = cache_frame_a54ef0e991ddc5127543496476fffdc2;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_a54ef0e991ddc5127543496476fffdc2);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_a54ef0e991ddc5127543496476fffdc2) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__get_finished_message);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2354;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2354;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_1;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_SSL_get_peer_finished);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2354;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_a54ef0e991ddc5127543496476fffdc2->m_frame.f_lineno = 2354;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2354;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a54ef0e991ddc5127543496476fffdc2);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_a54ef0e991ddc5127543496476fffdc2);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a54ef0e991ddc5127543496476fffdc2);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_a54ef0e991ddc5127543496476fffdc2, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_a54ef0e991ddc5127543496476fffdc2->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_a54ef0e991ddc5127543496476fffdc2, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a54ef0e991ddc5127543496476fffdc2,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_a54ef0e991ddc5127543496476fffdc2 == cache_frame_a54ef0e991ddc5127543496476fffdc2) {
        Py_DECREF(frame_a54ef0e991ddc5127543496476fffdc2);
    }
    cache_frame_a54ef0e991ddc5127543496476fffdc2 = NULL;

    assertFrameObject(frame_a54ef0e991ddc5127543496476fffdc2);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_105_get_peer_finished);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_106_get_cipher_name(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_cipher = NULL;
    PyObject *var_name = NULL;
    struct Nuitka_FrameObject *frame_5a46eefcdd3d235d3fe799c45ec3726a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_5a46eefcdd3d235d3fe799c45ec3726a = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_5a46eefcdd3d235d3fe799c45ec3726a, codeobj_5a46eefcdd3d235d3fe799c45ec3726a, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_5a46eefcdd3d235d3fe799c45ec3726a = cache_frame_5a46eefcdd3d235d3fe799c45ec3726a;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_5a46eefcdd3d235d3fe799c45ec3726a);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_5a46eefcdd3d235d3fe799c45ec3726a) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2366;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_get_current_cipher);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2366;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__ssl);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2366;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_5a46eefcdd3d235d3fe799c45ec3726a->m_frame.f_lineno = 2366;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2366;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_cipher == NULL);
        var_cipher = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT(var_cipher);
        tmp_compexpr_left_1 = var_cipher;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2367;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_NULL);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2367;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2367;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_None;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_4;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_args_element_name_3;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_3 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 2370;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_4 = tmp_mvar_value_3;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_string);
            if (tmp_called_name_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2370;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_4 == NULL) {
                Py_DECREF(tmp_called_name_2);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 2370;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_1 = tmp_mvar_value_4;
            CHECK_OBJECT(var_cipher);
            tmp_args_element_name_3 = var_cipher;
            frame_5a46eefcdd3d235d3fe799c45ec3726a->m_frame.f_lineno = 2370;
            {
                PyObject *call_args[] = {tmp_args_element_name_3};
                tmp_args_element_name_2 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_SSL_CIPHER_get_name, call_args);
            }

            if (tmp_args_element_name_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_2);

                exception_lineno = 2370;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            frame_5a46eefcdd3d235d3fe799c45ec3726a->m_frame.f_lineno = 2370;
            tmp_assign_source_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_2);
            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_2);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2370;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            assert(var_name == NULL);
            var_name = tmp_assign_source_2;
        }
        {
            PyObject *tmp_called_instance_2;
            CHECK_OBJECT(var_name);
            tmp_called_instance_2 = var_name;
            frame_5a46eefcdd3d235d3fe799c45ec3726a->m_frame.f_lineno = 2371;
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_decode, &PyTuple_GET_ITEM(const_tuple_str_digest_c075052d723d6707083e869a0e3659bb_tuple, 0));

            if (tmp_return_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2371;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5a46eefcdd3d235d3fe799c45ec3726a);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_5a46eefcdd3d235d3fe799c45ec3726a);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5a46eefcdd3d235d3fe799c45ec3726a);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_5a46eefcdd3d235d3fe799c45ec3726a, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_5a46eefcdd3d235d3fe799c45ec3726a->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_5a46eefcdd3d235d3fe799c45ec3726a, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5a46eefcdd3d235d3fe799c45ec3726a,
        type_description_1,
        par_self,
        var_cipher,
        var_name
    );


    // Release cached frame.
    if (frame_5a46eefcdd3d235d3fe799c45ec3726a == cache_frame_5a46eefcdd3d235d3fe799c45ec3726a) {
        Py_DECREF(frame_5a46eefcdd3d235d3fe799c45ec3726a);
    }
    cache_frame_5a46eefcdd3d235d3fe799c45ec3726a = NULL;

    assertFrameObject(frame_5a46eefcdd3d235d3fe799c45ec3726a);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_106_get_cipher_name);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_cipher);
    Py_DECREF(var_cipher);
    var_cipher = NULL;

    Py_XDECREF(var_name);
    var_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_cipher);
    var_cipher = NULL;

    Py_XDECREF(var_name);
    var_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_106_get_cipher_name);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_107_get_cipher_bits(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_cipher = NULL;
    struct Nuitka_FrameObject *frame_eb4e822fd78a70f279bd9df4a597324d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_eb4e822fd78a70f279bd9df4a597324d = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_eb4e822fd78a70f279bd9df4a597324d, codeobj_eb4e822fd78a70f279bd9df4a597324d, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *));
    frame_eb4e822fd78a70f279bd9df4a597324d = cache_frame_eb4e822fd78a70f279bd9df4a597324d;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_eb4e822fd78a70f279bd9df4a597324d);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_eb4e822fd78a70f279bd9df4a597324d) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2383;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_get_current_cipher);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2383;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__ssl);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2383;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_eb4e822fd78a70f279bd9df4a597324d->m_frame.f_lineno = 2383;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2383;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert(var_cipher == NULL);
        var_cipher = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT(var_cipher);
        tmp_compexpr_left_1 = var_cipher;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2384;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_NULL);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2384;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2384;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_None;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_4;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_source_name_5;
            PyObject *tmp_mvar_value_4;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_3 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 2387;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_4 = tmp_mvar_value_3;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_SSL_CIPHER_get_bits);
            if (tmp_called_name_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2387;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT(var_cipher);
            tmp_args_element_name_2 = var_cipher;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_4 == NULL) {
                Py_DECREF(tmp_called_name_2);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 2387;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_5 = tmp_mvar_value_4;
            tmp_args_element_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_NULL);
            if (tmp_args_element_name_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_2);

                exception_lineno = 2387;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            frame_eb4e822fd78a70f279bd9df4a597324d->m_frame.f_lineno = 2387;
            {
                PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
                tmp_return_value = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
            }

            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_3);
            if (tmp_return_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2387;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_eb4e822fd78a70f279bd9df4a597324d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_eb4e822fd78a70f279bd9df4a597324d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_eb4e822fd78a70f279bd9df4a597324d);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_eb4e822fd78a70f279bd9df4a597324d, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_eb4e822fd78a70f279bd9df4a597324d->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_eb4e822fd78a70f279bd9df4a597324d, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_eb4e822fd78a70f279bd9df4a597324d,
        type_description_1,
        par_self,
        var_cipher
    );


    // Release cached frame.
    if (frame_eb4e822fd78a70f279bd9df4a597324d == cache_frame_eb4e822fd78a70f279bd9df4a597324d) {
        Py_DECREF(frame_eb4e822fd78a70f279bd9df4a597324d);
    }
    cache_frame_eb4e822fd78a70f279bd9df4a597324d = NULL;

    assertFrameObject(frame_eb4e822fd78a70f279bd9df4a597324d);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_107_get_cipher_bits);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_cipher);
    Py_DECREF(var_cipher);
    var_cipher = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_cipher);
    var_cipher = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_107_get_cipher_bits);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_108_get_cipher_version(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_cipher = NULL;
    PyObject *var_version = NULL;
    struct Nuitka_FrameObject *frame_6fb08a01e4ea72bc52096d7018179add;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_6fb08a01e4ea72bc52096d7018179add = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_6fb08a01e4ea72bc52096d7018179add, codeobj_6fb08a01e4ea72bc52096d7018179add, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_6fb08a01e4ea72bc52096d7018179add = cache_frame_6fb08a01e4ea72bc52096d7018179add;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_6fb08a01e4ea72bc52096d7018179add);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_6fb08a01e4ea72bc52096d7018179add) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2399;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_get_current_cipher);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2399;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__ssl);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2399;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_6fb08a01e4ea72bc52096d7018179add->m_frame.f_lineno = 2399;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2399;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_cipher == NULL);
        var_cipher = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT(var_cipher);
        tmp_compexpr_left_1 = var_cipher;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2400;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_NULL);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2400;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2400;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_None;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_4;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_args_element_name_3;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
            }

            if (tmp_mvar_value_3 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 2403;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_4 = tmp_mvar_value_3;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_string);
            if (tmp_called_name_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2403;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_4 == NULL) {
                Py_DECREF(tmp_called_name_2);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
                exception_tb = NULL;

                exception_lineno = 2403;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_1 = tmp_mvar_value_4;
            CHECK_OBJECT(var_cipher);
            tmp_args_element_name_3 = var_cipher;
            frame_6fb08a01e4ea72bc52096d7018179add->m_frame.f_lineno = 2403;
            {
                PyObject *call_args[] = {tmp_args_element_name_3};
                tmp_args_element_name_2 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_SSL_CIPHER_get_version, call_args);
            }

            if (tmp_args_element_name_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_called_name_2);

                exception_lineno = 2403;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            frame_6fb08a01e4ea72bc52096d7018179add->m_frame.f_lineno = 2403;
            tmp_assign_source_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_2);
            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_2);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2403;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            assert(var_version == NULL);
            var_version = tmp_assign_source_2;
        }
        {
            PyObject *tmp_called_instance_2;
            CHECK_OBJECT(var_version);
            tmp_called_instance_2 = var_version;
            frame_6fb08a01e4ea72bc52096d7018179add->m_frame.f_lineno = 2404;
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_decode, &PyTuple_GET_ITEM(const_tuple_str_digest_c075052d723d6707083e869a0e3659bb_tuple, 0));

            if (tmp_return_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2404;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_6fb08a01e4ea72bc52096d7018179add);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_6fb08a01e4ea72bc52096d7018179add);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_6fb08a01e4ea72bc52096d7018179add);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_6fb08a01e4ea72bc52096d7018179add, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_6fb08a01e4ea72bc52096d7018179add->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_6fb08a01e4ea72bc52096d7018179add, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6fb08a01e4ea72bc52096d7018179add,
        type_description_1,
        par_self,
        var_cipher,
        var_version
    );


    // Release cached frame.
    if (frame_6fb08a01e4ea72bc52096d7018179add == cache_frame_6fb08a01e4ea72bc52096d7018179add) {
        Py_DECREF(frame_6fb08a01e4ea72bc52096d7018179add);
    }
    cache_frame_6fb08a01e4ea72bc52096d7018179add = NULL;

    assertFrameObject(frame_6fb08a01e4ea72bc52096d7018179add);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_108_get_cipher_version);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_cipher);
    Py_DECREF(var_cipher);
    var_cipher = NULL;

    Py_XDECREF(var_version);
    var_version = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_cipher);
    var_cipher = NULL;

    Py_XDECREF(var_version);
    var_version = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_108_get_cipher_version);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_109_get_protocol_version_name(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_version = NULL;
    struct Nuitka_FrameObject *frame_8a31a568865bc9c9ed09c31a31d8134a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_8a31a568865bc9c9ed09c31a31d8134a = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_8a31a568865bc9c9ed09c31a31d8134a, codeobj_8a31a568865bc9c9ed09c31a31d8134a, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *));
    frame_8a31a568865bc9c9ed09c31a31d8134a = cache_frame_8a31a568865bc9c9ed09c31a31d8134a;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_8a31a568865bc9c9ed09c31a31d8134a);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_8a31a568865bc9c9ed09c31a31d8134a) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2415;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_string);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2415;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2415;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_SSL_get_version);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2415;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_3 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain__ssl);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 2415;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_8a31a568865bc9c9ed09c31a31d8134a->m_frame.f_lineno = 2415;
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_2);
        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2415;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_8a31a568865bc9c9ed09c31a31d8134a->m_frame.f_lineno = 2415;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2415;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert(var_version == NULL);
        var_version = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_instance_1;
        CHECK_OBJECT(var_version);
        tmp_called_instance_1 = var_version;
        frame_8a31a568865bc9c9ed09c31a31d8134a->m_frame.f_lineno = 2416;
        tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_decode, &PyTuple_GET_ITEM(const_tuple_str_digest_c075052d723d6707083e869a0e3659bb_tuple, 0));

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2416;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8a31a568865bc9c9ed09c31a31d8134a);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_8a31a568865bc9c9ed09c31a31d8134a);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8a31a568865bc9c9ed09c31a31d8134a);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_8a31a568865bc9c9ed09c31a31d8134a, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_8a31a568865bc9c9ed09c31a31d8134a->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_8a31a568865bc9c9ed09c31a31d8134a, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8a31a568865bc9c9ed09c31a31d8134a,
        type_description_1,
        par_self,
        var_version
    );


    // Release cached frame.
    if (frame_8a31a568865bc9c9ed09c31a31d8134a == cache_frame_8a31a568865bc9c9ed09c31a31d8134a) {
        Py_DECREF(frame_8a31a568865bc9c9ed09c31a31d8134a);
    }
    cache_frame_8a31a568865bc9c9ed09c31a31d8134a = NULL;

    assertFrameObject(frame_8a31a568865bc9c9ed09c31a31d8134a);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_109_get_protocol_version_name);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_version);
    Py_DECREF(var_version);
    var_version = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_version);
    var_version = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_109_get_protocol_version_name);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_110_get_protocol_version(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_version = NULL;
    struct Nuitka_FrameObject *frame_190fc2095a8f804515eb5f410b637f5e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_190fc2095a8f804515eb5f410b637f5e = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_190fc2095a8f804515eb5f410b637f5e, codeobj_190fc2095a8f804515eb5f410b637f5e, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *));
    frame_190fc2095a8f804515eb5f410b637f5e = cache_frame_190fc2095a8f804515eb5f410b637f5e;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_190fc2095a8f804515eb5f410b637f5e);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_190fc2095a8f804515eb5f410b637f5e) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2426;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_version);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2426;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__ssl);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2426;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_190fc2095a8f804515eb5f410b637f5e->m_frame.f_lineno = 2426;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2426;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert(var_version == NULL);
        var_version = tmp_assign_source_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_190fc2095a8f804515eb5f410b637f5e);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_190fc2095a8f804515eb5f410b637f5e);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_190fc2095a8f804515eb5f410b637f5e, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_190fc2095a8f804515eb5f410b637f5e->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_190fc2095a8f804515eb5f410b637f5e, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_190fc2095a8f804515eb5f410b637f5e,
        type_description_1,
        par_self,
        var_version
    );


    // Release cached frame.
    if (frame_190fc2095a8f804515eb5f410b637f5e == cache_frame_190fc2095a8f804515eb5f410b637f5e) {
        Py_DECREF(frame_190fc2095a8f804515eb5f410b637f5e);
    }
    cache_frame_190fc2095a8f804515eb5f410b637f5e = NULL;

    assertFrameObject(frame_190fc2095a8f804515eb5f410b637f5e);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT(var_version);
    tmp_return_value = var_version;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_110_get_protocol_version);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_version);
    Py_DECREF(var_version);
    var_version = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_110_get_protocol_version);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_111_get_next_proto_negotiated(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_data_len = NULL;
    PyObject *var_data = NULL;
    struct Nuitka_FrameObject *frame_2d525410d7ab181761b0e480a04ac3bb;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_2d525410d7ab181761b0e480a04ac3bb = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_2d525410d7ab181761b0e480a04ac3bb, codeobj_2d525410d7ab181761b0e480a04ac3bb, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_2d525410d7ab181761b0e480a04ac3bb = cache_frame_2d525410d7ab181761b0e480a04ac3bb;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_2d525410d7ab181761b0e480a04ac3bb);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_2d525410d7ab181761b0e480a04ac3bb) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2439;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_2d525410d7ab181761b0e480a04ac3bb->m_frame.f_lineno = 2439;
        tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_new, &PyTuple_GET_ITEM(const_tuple_str_digest_52773e1185116024389d12c91a4ccf3d_tuple, 0));

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2439;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_data == NULL);
        var_data = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2440;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_2;
        frame_2d525410d7ab181761b0e480a04ac3bb->m_frame.f_lineno = 2440;
        tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_new, &PyTuple_GET_ITEM(const_tuple_str_digest_e33a7f733650e687efe98e5491512b82_tuple, 0));

        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2440;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_data_len == NULL);
        var_data_len = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2442;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_3;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_get0_next_proto_negotiated);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2442;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__ssl);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2442;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_data);
        tmp_args_element_name_2 = var_data;
        CHECK_OBJECT(var_data_len);
        tmp_args_element_name_3 = var_data_len;
        frame_2d525410d7ab181761b0e480a04ac3bb->m_frame.f_lineno = 2442;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2442;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        Py_ssize_t tmp_sliceslicedel_index_lower_1;
        Py_ssize_t tmp_slice_index_upper_1;
        PyObject *tmp_slice_source_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_subscript_name_1;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_subscribed_name_2;
        PyObject *tmp_subscript_name_2;
        tmp_sliceslicedel_index_lower_1 = 0;
        tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2444;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_4;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_buffer);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2444;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_data);
        tmp_subscribed_name_1 = var_data;
        tmp_subscript_name_1 = const_int_0;
        tmp_args_element_name_4 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_1, tmp_subscript_name_1, 0);
        if (tmp_args_element_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 2444;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_data_len);
        tmp_subscribed_name_2 = var_data_len;
        tmp_subscript_name_2 = const_int_0;
        tmp_args_element_name_5 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_2, tmp_subscript_name_2, 0);
        if (tmp_args_element_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_4);

            exception_lineno = 2444;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_2d525410d7ab181761b0e480a04ac3bb->m_frame.f_lineno = 2444;
        {
            PyObject *call_args[] = {tmp_args_element_name_4, tmp_args_element_name_5};
            tmp_slice_source_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_4);
        Py_DECREF(tmp_args_element_name_5);
        if (tmp_slice_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2444;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = LOOKUP_INDEX_SLICE(tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1);
        Py_DECREF(tmp_slice_source_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2444;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2d525410d7ab181761b0e480a04ac3bb);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_2d525410d7ab181761b0e480a04ac3bb);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2d525410d7ab181761b0e480a04ac3bb);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_2d525410d7ab181761b0e480a04ac3bb, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_2d525410d7ab181761b0e480a04ac3bb->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_2d525410d7ab181761b0e480a04ac3bb, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2d525410d7ab181761b0e480a04ac3bb,
        type_description_1,
        par_self,
        var_data_len,
        var_data
    );


    // Release cached frame.
    if (frame_2d525410d7ab181761b0e480a04ac3bb == cache_frame_2d525410d7ab181761b0e480a04ac3bb) {
        Py_DECREF(frame_2d525410d7ab181761b0e480a04ac3bb);
    }
    cache_frame_2d525410d7ab181761b0e480a04ac3bb = NULL;

    assertFrameObject(frame_2d525410d7ab181761b0e480a04ac3bb);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_111_get_next_proto_negotiated);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_data_len);
    Py_DECREF(var_data_len);
    var_data_len = NULL;

    CHECK_OBJECT((PyObject *)var_data);
    Py_DECREF(var_data);
    var_data = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_data_len);
    var_data_len = NULL;

    Py_XDECREF(var_data);
    var_data = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_111_get_next_proto_negotiated);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_112_set_alpn_protos(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_protos = python_pars[1];
    PyObject *var_protostr = NULL;
    PyObject *var_input_str = NULL;
    PyObject *tmp_genexpr_1__$0 = NULL;
    struct Nuitka_FrameObject *frame_c5a3b890d44f3c8acdb96b874e67ae24;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_c5a3b890d44f3c8acdb96b874e67ae24 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_c5a3b890d44f3c8acdb96b874e67ae24, codeobj_c5a3b890d44f3c8acdb96b874e67ae24, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_c5a3b890d44f3c8acdb96b874e67ae24 = cache_frame_c5a3b890d44f3c8acdb96b874e67ae24;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_c5a3b890d44f3c8acdb96b874e67ae24);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_c5a3b890d44f3c8acdb96b874e67ae24) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_2;
        tmp_source_name_1 = const_str_empty;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_join);
        assert(!(tmp_called_name_1 == NULL));
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_chain);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_chain);
        }

        if (tmp_mvar_value_1 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 308 ], 34, 0);
            exception_tb = NULL;

            exception_lineno = 2460;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_1;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_from_iterable);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2460;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT(par_protos);
            tmp_iter_arg_1 = par_protos;
            tmp_assign_source_2 = MAKE_ITERATOR(tmp_iter_arg_1);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2460;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            assert(tmp_genexpr_1__$0 == NULL);
            tmp_genexpr_1__$0 = tmp_assign_source_2;
        }
        // Tried code:
        tmp_args_element_name_2 = OpenSSL$SSL$$$function_112_set_alpn_protos$$$genexpr_1_genexpr_maker();

        ((struct Nuitka_GeneratorObject *)tmp_args_element_name_2)->m_closure[0] = PyCell_NEW0(tmp_genexpr_1__$0);


        goto try_return_handler_2;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_112_set_alpn_protos);
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        CHECK_OBJECT((PyObject *)tmp_genexpr_1__$0);
        Py_DECREF(tmp_genexpr_1__$0);
        tmp_genexpr_1__$0 = NULL;

        goto outline_result_1;
        // End of try:
        CHECK_OBJECT((PyObject *)tmp_genexpr_1__$0);
        Py_DECREF(tmp_genexpr_1__$0);
        tmp_genexpr_1__$0 = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_112_set_alpn_protos);
        return NULL;
        outline_result_1:;
        frame_c5a3b890d44f3c8acdb96b874e67ae24->m_frame.f_lineno = 2460;
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_2);
        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2460;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_c5a3b890d44f3c8acdb96b874e67ae24->m_frame.f_lineno = 2459;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2459;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_protostr == NULL);
        var_protostr = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2465;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_2;
        tmp_args_element_name_3 = const_str_digest_81f1b0dfcc7a862e6940580ec4cc42d3;
        CHECK_OBJECT(var_protostr);
        tmp_args_element_name_4 = var_protostr;
        frame_c5a3b890d44f3c8acdb96b874e67ae24->m_frame.f_lineno = 2465;
        {
            PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4};
            tmp_assign_source_3 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain_new, call_args);
        }

        if (tmp_assign_source_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2465;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_input_str == NULL);
        var_input_str = tmp_assign_source_3;
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_4;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_len_arg_1;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2466;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_3;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_SSL_set_alpn_protos);
        if (tmp_called_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2466;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_4 = par_self;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain__ssl);
        if (tmp_args_element_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);

            exception_lineno = 2466;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_input_str);
        tmp_args_element_name_6 = var_input_str;
        CHECK_OBJECT(var_protostr);
        tmp_len_arg_1 = var_protostr;
        tmp_args_element_name_7 = BUILTIN_LEN(tmp_len_arg_1);
        if (tmp_args_element_name_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);
            Py_DECREF(tmp_args_element_name_5);

            exception_lineno = 2466;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_c5a3b890d44f3c8acdb96b874e67ae24->m_frame.f_lineno = 2466;
        {
            PyObject *call_args[] = {tmp_args_element_name_5, tmp_args_element_name_6, tmp_args_element_name_7};
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_3, call_args);
        }

        Py_DECREF(tmp_called_name_3);
        Py_DECREF(tmp_args_element_name_5);
        Py_DECREF(tmp_args_element_name_7);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2466;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c5a3b890d44f3c8acdb96b874e67ae24);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c5a3b890d44f3c8acdb96b874e67ae24);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_c5a3b890d44f3c8acdb96b874e67ae24, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_c5a3b890d44f3c8acdb96b874e67ae24->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_c5a3b890d44f3c8acdb96b874e67ae24, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c5a3b890d44f3c8acdb96b874e67ae24,
        type_description_1,
        par_self,
        par_protos,
        var_protostr,
        var_input_str
    );


    // Release cached frame.
    if (frame_c5a3b890d44f3c8acdb96b874e67ae24 == cache_frame_c5a3b890d44f3c8acdb96b874e67ae24) {
        Py_DECREF(frame_c5a3b890d44f3c8acdb96b874e67ae24);
    }
    cache_frame_c5a3b890d44f3c8acdb96b874e67ae24 = NULL;

    assertFrameObject(frame_c5a3b890d44f3c8acdb96b874e67ae24);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_112_set_alpn_protos);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_protostr);
    Py_DECREF(var_protostr);
    var_protostr = NULL;

    CHECK_OBJECT((PyObject *)var_input_str);
    Py_DECREF(var_input_str);
    var_input_str = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_protostr);
    var_protostr = NULL;

    Py_XDECREF(var_input_str);
    var_input_str = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_112_set_alpn_protos);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_protos);
    Py_DECREF(par_protos);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_protos);
    Py_DECREF(par_protos);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}



struct OpenSSL$SSL$$$function_112_set_alpn_protos$$$genexpr_1_genexpr_locals {
    PyObject *var_p;
    PyObject *tmp_iter_value_0;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *OpenSSL$SSL$$$function_112_set_alpn_protos$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value ) {
    CHECK_OBJECT((PyObject *)generator);
    assert(Nuitka_Generator_Check( (PyObject *)generator ));

    // Heap access if used.
    struct OpenSSL$SSL$$$function_112_set_alpn_protos$$$genexpr_1_genexpr_locals *generator_heap = (struct OpenSSL$SSL$$$function_112_set_alpn_protos$$$genexpr_1_genexpr_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_p = NULL;
    generator_heap->tmp_iter_value_0 = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_m_frame, codeobj_d3b60764eff38474732964f96db6ec32, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *));
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF(generator->m_frame);
    assert(Py_REFCNT(generator->m_frame) == 2); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR(generator->m_frame->m_frame.f_back);

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF(generator->m_frame->m_frame.f_back);

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF(generator->m_frame);

    Nuitka_Frame_MarkAsExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

        EXC_TYPE_F(generator) = EXC_TYPE(thread_state);
        if (EXC_TYPE_F(generator) == Py_None) EXC_TYPE_F(generator) = NULL;
        Py_XINCREF(EXC_TYPE_F(generator));
        EXC_VALUE_F(generator) = EXC_VALUE(thread_state);
        Py_XINCREF(EXC_VALUE_F(generator));
        EXC_TRACEBACK_F(generator) = EXC_TRACEBACK(thread_state);
        Py_XINCREF(EXC_TRACEBACK_F(generator));
    }

#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_1;
        CHECK_OBJECT(PyCell_GET(generator->m_closure[0]));
        tmp_next_source_1 = PyCell_GET(generator->m_closure[0]);
        tmp_assign_source_1 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_1 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);
                generator_heap->type_description_1 = "No";
                generator_heap->exception_lineno = 2460;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_iter_value_0;
            generator_heap->tmp_iter_value_0 = tmp_assign_source_1;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT(generator_heap->tmp_iter_value_0);
        tmp_assign_source_2 = generator_heap->tmp_iter_value_0;
        {
            PyObject *old = generator_heap->var_p;
            generator_heap->var_p = tmp_assign_source_2;
            Py_INCREF(generator_heap->var_p);
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_expression_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_len_arg_1;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_int2byte);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_int2byte);
        }

        if (tmp_mvar_value_1 == NULL) {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF(generator_heap->exception_type);
            generator_heap->exception_value = UNSTREAM_STRING(&constant_bin[ 342 ], 37, 0);
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 2460;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT(generator_heap->var_p);
        tmp_len_arg_1 = generator_heap->var_p;
        tmp_args_element_name_1 = BUILTIN_LEN(tmp_len_arg_1);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 2460;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        generator->m_frame->m_frame.f_lineno = 2460;
        tmp_tuple_element_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 2460;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_expression_name_1 = PyTuple_New(2);
        PyTuple_SET_ITEM(tmp_expression_name_1, 0, tmp_tuple_element_1);
        CHECK_OBJECT(generator_heap->var_p);
        tmp_tuple_element_1 = generator_heap->var_p;
        Py_INCREF(tmp_tuple_element_1);
        PyTuple_SET_ITEM(tmp_expression_name_1, 1, tmp_tuple_element_1);
        Nuitka_PreserveHeap(generator_heap->yield_tmps, &tmp_tuple_element_1, sizeof(PyObject *), &tmp_called_name_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), &tmp_args_element_name_1, sizeof(PyObject *), &tmp_len_arg_1, sizeof(PyObject *), NULL);
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        Nuitka_RestoreHeap(generator_heap->yield_tmps, &tmp_tuple_element_1, sizeof(PyObject *), &tmp_called_name_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), &tmp_args_element_name_1, sizeof(PyObject *), &tmp_len_arg_1, sizeof(PyObject *), NULL);
        if (yield_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


            generator_heap->exception_lineno = 2460;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb);


        generator_heap->exception_lineno = 2460;
        generator_heap->type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting(generator->m_frame);

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    // Allow re-use of the frame again.
    Py_DECREF(generator->m_frame);
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if (!EXCEPTION_MATCH_GENERATOR(generator_heap->exception_type)) {
        if (generator_heap->exception_tb == NULL) {
            generator_heap->exception_tb = MAKE_TRACEBACK(generator->m_frame, generator_heap->exception_lineno);
        } else if (generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame) {
            generator_heap->exception_tb = ADD_TRACEBACK(generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno);
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            NULL,
            generator_heap->var_p
        );


        // Release cached frame.
        if (generator->m_frame == cache_m_frame) {
            Py_DECREF(generator->m_frame);
        }
        cache_m_frame = NULL;

        assertFrameObject(generator->m_frame);
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR(EXC_TYPE_F(generator));
    Py_CLEAR(EXC_VALUE_F(generator));
    Py_CLEAR(EXC_TRACEBACK_F(generator));
#endif

    Py_DECREF(generator->m_frame);

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF(generator_heap->var_p);
    generator_heap->var_p = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF(generator_heap->tmp_iter_value_0);
    generator_heap->tmp_iter_value_0 = NULL;

    Py_XDECREF(generator_heap->var_p);
    generator_heap->var_p = NULL;



    return NULL;

    function_exception_exit:
    assert(generator_heap->exception_type);
    RESTORE_ERROR_OCCURRED(generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb);

    return NULL;

}

static PyObject *OpenSSL$SSL$$$function_112_set_alpn_protos$$$genexpr_1_genexpr_maker(void) {
    return Nuitka_Generator_New(
        OpenSSL$SSL$$$function_112_set_alpn_protos$$$genexpr_1_genexpr_context,
        module_OpenSSL$SSL,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_d3b60764eff38474732964f96db6ec32,
        1,
        sizeof(struct OpenSSL$SSL$$$function_112_set_alpn_protos$$$genexpr_1_genexpr_locals)
    );
}


static PyObject *impl_OpenSSL$SSL$$$function_113_get_alpn_proto_negotiated(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_data_len = NULL;
    PyObject *var_data = NULL;
    struct Nuitka_FrameObject *frame_776624edcfa35f9ea528996d05e133ee;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_776624edcfa35f9ea528996d05e133ee = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_776624edcfa35f9ea528996d05e133ee, codeobj_776624edcfa35f9ea528996d05e133ee, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_776624edcfa35f9ea528996d05e133ee = cache_frame_776624edcfa35f9ea528996d05e133ee;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_776624edcfa35f9ea528996d05e133ee);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_776624edcfa35f9ea528996d05e133ee) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2476;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_776624edcfa35f9ea528996d05e133ee->m_frame.f_lineno = 2476;
        tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_new, &PyTuple_GET_ITEM(const_tuple_str_digest_52773e1185116024389d12c91a4ccf3d_tuple, 0));

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2476;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_data == NULL);
        var_data = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2477;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_2;
        frame_776624edcfa35f9ea528996d05e133ee->m_frame.f_lineno = 2477;
        tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_new, &PyTuple_GET_ITEM(const_tuple_str_digest_e33a7f733650e687efe98e5491512b82_tuple, 0));

        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2477;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_data_len == NULL);
        var_data_len = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2479;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_3;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_get0_alpn_selected);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2479;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__ssl);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2479;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_data);
        tmp_args_element_name_2 = var_data;
        CHECK_OBJECT(var_data_len);
        tmp_args_element_name_3 = var_data_len;
        frame_776624edcfa35f9ea528996d05e133ee->m_frame.f_lineno = 2479;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2479;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        CHECK_OBJECT(var_data_len);
        tmp_operand_name_1 = var_data_len;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2481;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = const_str_empty;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        Py_ssize_t tmp_sliceslicedel_index_lower_1;
        Py_ssize_t tmp_slice_index_upper_1;
        PyObject *tmp_slice_source_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_subscript_name_1;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_subscribed_name_2;
        PyObject *tmp_subscript_name_2;
        tmp_sliceslicedel_index_lower_1 = 0;
        tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 170 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2484;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_4;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_buffer);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2484;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_data);
        tmp_subscribed_name_1 = var_data;
        tmp_subscript_name_1 = const_int_0;
        tmp_args_element_name_4 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_1, tmp_subscript_name_1, 0);
        if (tmp_args_element_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 2484;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_data_len);
        tmp_subscribed_name_2 = var_data_len;
        tmp_subscript_name_2 = const_int_0;
        tmp_args_element_name_5 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_2, tmp_subscript_name_2, 0);
        if (tmp_args_element_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_4);

            exception_lineno = 2484;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_776624edcfa35f9ea528996d05e133ee->m_frame.f_lineno = 2484;
        {
            PyObject *call_args[] = {tmp_args_element_name_4, tmp_args_element_name_5};
            tmp_slice_source_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_4);
        Py_DECREF(tmp_args_element_name_5);
        if (tmp_slice_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2484;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = LOOKUP_INDEX_SLICE(tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1);
        Py_DECREF(tmp_slice_source_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2484;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_776624edcfa35f9ea528996d05e133ee);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_776624edcfa35f9ea528996d05e133ee);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_776624edcfa35f9ea528996d05e133ee);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_776624edcfa35f9ea528996d05e133ee, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_776624edcfa35f9ea528996d05e133ee->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_776624edcfa35f9ea528996d05e133ee, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_776624edcfa35f9ea528996d05e133ee,
        type_description_1,
        par_self,
        var_data_len,
        var_data
    );


    // Release cached frame.
    if (frame_776624edcfa35f9ea528996d05e133ee == cache_frame_776624edcfa35f9ea528996d05e133ee) {
        Py_DECREF(frame_776624edcfa35f9ea528996d05e133ee);
    }
    cache_frame_776624edcfa35f9ea528996d05e133ee = NULL;

    assertFrameObject(frame_776624edcfa35f9ea528996d05e133ee);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_113_get_alpn_proto_negotiated);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_data_len);
    Py_DECREF(var_data_len);
    var_data_len = NULL;

    CHECK_OBJECT((PyObject *)var_data);
    Py_DECREF(var_data);
    var_data = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_data_len);
    var_data_len = NULL;

    Py_XDECREF(var_data);
    var_data = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_113_get_alpn_proto_negotiated);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_114_request_ocsp(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_rc = NULL;
    struct Nuitka_FrameObject *frame_cef9c931fd2f28c31ff360c1fa396b8e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_cef9c931fd2f28c31ff360c1fa396b8e = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_cef9c931fd2f28c31ff360c1fa396b8e, codeobj_cef9c931fd2f28c31ff360c1fa396b8e, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *));
    frame_cef9c931fd2f28c31ff360c1fa396b8e = cache_frame_cef9c931fd2f28c31ff360c1fa396b8e;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_cef9c931fd2f28c31ff360c1fa396b8e);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_cef9c931fd2f28c31ff360c1fa396b8e) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2493;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_SSL_set_tlsext_status_type);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2493;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain__ssl);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 2494;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_element_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 203 ], 33, 0);
            exception_tb = NULL;

            exception_lineno = 2494;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_TLSEXT_STATUSTYPE_ocsp);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_element_name_1);

            exception_lineno = 2494;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_cef9c931fd2f28c31ff360c1fa396b8e->m_frame.f_lineno = 2493;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2493;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert(var_rc == NULL);
        var_rc = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 501 ], 44, 0);
            exception_tb = NULL;

            exception_lineno = 2496;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_3;
        CHECK_OBJECT(var_rc);
        tmp_compexpr_left_1 = var_rc;
        tmp_compexpr_right_1 = const_int_pos_1;
        tmp_args_element_name_3 = RICH_COMPARE_EQ_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2496;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_cef9c931fd2f28c31ff360c1fa396b8e->m_frame.f_lineno = 2496;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_3);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2496;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_cef9c931fd2f28c31ff360c1fa396b8e);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_cef9c931fd2f28c31ff360c1fa396b8e);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_cef9c931fd2f28c31ff360c1fa396b8e, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_cef9c931fd2f28c31ff360c1fa396b8e->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_cef9c931fd2f28c31ff360c1fa396b8e, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_cef9c931fd2f28c31ff360c1fa396b8e,
        type_description_1,
        par_self,
        var_rc
    );


    // Release cached frame.
    if (frame_cef9c931fd2f28c31ff360c1fa396b8e == cache_frame_cef9c931fd2f28c31ff360c1fa396b8e) {
        Py_DECREF(frame_cef9c931fd2f28c31ff360c1fa396b8e);
    }
    cache_frame_cef9c931fd2f28c31ff360c1fa396b8e = NULL;

    assertFrameObject(frame_cef9c931fd2f28c31ff360c1fa396b8e);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_114_request_ocsp);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_rc);
    Py_DECREF(var_rc);
    var_rc = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_rc);
    var_rc = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(OpenSSL$SSL$$$function_114_request_ocsp);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_100_set_connect_state() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_100_set_connect_state,
        const_str_plain_set_connect_state,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d43339cac2a23168c71e48b85d7e240f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_3f54294273e4f6390044ae027b11e5ae,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_101_get_session() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_101_get_session,
        const_str_plain_get_session,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_52829c318867d59743de899b39d5abac,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_ef6e6485863cf611499d4e66d7c8cb32,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_102_set_session() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_102_set_session,
        const_str_plain_set_session,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_486bd2bad33e063a2af794bab2239dd3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_099382aff2f4e6520a621b385fae4992,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_103__get_finished_message() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_103__get_finished_message,
        const_str_plain__get_finished_message,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_22ca8433889a93275ebb1b4e80b3b8e9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_38eb25c1dd31f1c93831bc586a51d94a,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_104_get_finished() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_104_get_finished,
        const_str_plain_get_finished,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_729d8bc5b3418129828900f018d231cc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_a824ae6766bf79c53a58510064186c32,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_105_get_peer_finished() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_105_get_peer_finished,
        const_str_plain_get_peer_finished,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a54ef0e991ddc5127543496476fffdc2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_6a85cdfe995e144af7c992d7adff36a9,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_106_get_cipher_name() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_106_get_cipher_name,
        const_str_plain_get_cipher_name,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_5a46eefcdd3d235d3fe799c45ec3726a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_09af89b9aab79bc5666da647371af25d,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_107_get_cipher_bits() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_107_get_cipher_bits,
        const_str_plain_get_cipher_bits,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_eb4e822fd78a70f279bd9df4a597324d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_b8ccf81a020f16490de1c8527ea9e4d6,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_108_get_cipher_version() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_108_get_cipher_version,
        const_str_plain_get_cipher_version,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_6fb08a01e4ea72bc52096d7018179add,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_0e87e25b0ab76d44ec1e50f187ee33bd,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_109_get_protocol_version_name() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_109_get_protocol_version_name,
        const_str_plain_get_protocol_version_name,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_8a31a568865bc9c9ed09c31a31d8134a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_39e6e3efbf37d872dab9cfbddc398ebf,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_10_SSLeay_version() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_10_SSLeay_version,
        const_str_plain_SSLeay_version,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_afa02031ee1fbc3d4b779093fdfb585c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_1c06dc4166e08805f38a8dca82ce4339,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_110_get_protocol_version() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_110_get_protocol_version,
        const_str_plain_get_protocol_version,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_190fc2095a8f804515eb5f410b637f5e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_776556dd9343f57c1cd72ff937153f0f,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_111_get_next_proto_negotiated() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_111_get_next_proto_negotiated,
        const_str_plain_get_next_proto_negotiated,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_2d525410d7ab181761b0e480a04ac3bb,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_536ef6d81295f4591dd87bc79e8440e7,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_112_set_alpn_protos() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_112_set_alpn_protos,
        const_str_plain_set_alpn_protos,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c5a3b890d44f3c8acdb96b874e67ae24,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_a971aca8bab65513da2005120ca529f5,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_113_get_alpn_proto_negotiated() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_113_get_alpn_proto_negotiated,
        const_str_plain_get_alpn_proto_negotiated,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_776624edcfa35f9ea528996d05e133ee,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_aa803484dcfcfaec3d1d830a5ef1f026,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_114_request_ocsp() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_114_request_ocsp,
        const_str_plain_request_ocsp,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_cef9c931fd2f28c31ff360c1fa396b8e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_1c1aa9b3fa80807ae10c68cfa1a0b8e6,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_11__make_requires() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_11__make_requires,
        const_str_plain__make_requires,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c32e3eca92a8fda3af3c267c3ed289ab,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_b8ec26ebdab81fb3d5f36275b48d4beb,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_11__make_requires$$$function_1__requires_decorator() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_11__make_requires$$$function_1__requires_decorator,
        const_str_plain__requires_decorator,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d5e6e0f6e9a353e330b36c530b5b4bb0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        2
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_11__make_requires$$$function_1__requires_decorator$$$function_1_explode() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_11__make_requires$$$function_1__requires_decorator$$$function_1_explode,
        const_str_plain_explode,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_7a0155ee18f90fe4fffc56c025b25370,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_12___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_12___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_187fe5b9a88e33cc73e9ffc0bee13a36,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_13_load_verify_locations(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_13_load_verify_locations,
        const_str_plain_load_verify_locations,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_346033c0896bad93f6cf605df224d7cb,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_85e95361903fe71cece52bb01216866e,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_14__wrap_callback() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_14__wrap_callback,
        const_str_plain__wrap_callback,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c566f460e49d418f64d8ae5bff045f3b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_14__wrap_callback$$$function_1_wrapper() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_14__wrap_callback$$$function_1_wrapper,
        const_str_plain_wrapper,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a9047c1bce52ef36545c3c95123c1a6f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        2
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_15_set_passwd_cb(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_15_set_passwd_cb,
        const_str_plain_set_passwd_cb,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_8f7fd200c22a912bb8feee9fea391456,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_83abd167711a9d69f6fb1ba8bbb40fdb,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_16_set_default_verify_paths() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_16_set_default_verify_paths,
        const_str_plain_set_default_verify_paths,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_1eb3a30ea8ff5bbf704361f349f12a12,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_7f19e81c824604e95ebb1f01b7f5d7a1,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_17__check_env_vars_set() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_17__check_env_vars_set,
        const_str_plain__check_env_vars_set,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a34ae73d8f795897cbc3555bccd4619d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_0f682ae315fc37e97d14dcc920e8b91d,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_18__fallback_default_verify_paths() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_18__fallback_default_verify_paths,
        const_str_plain__fallback_default_verify_paths,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_567d4caf802af0a89115f921ed8e28e3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_c9c6fa40ef38c8d28b115afb17db4e50,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_19_use_certificate_chain_file() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_19_use_certificate_chain_file,
        const_str_plain_use_certificate_chain_file,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_1dc98b765f924dc15a85607868c9dcc9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_6e6e0d8d93df9702d9c8795dc2391090,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_1___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_1___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0ab1750369bb8d45abc70b759d692236,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_20_use_certificate_file(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_20_use_certificate_file,
        const_str_plain_use_certificate_file,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_29af76d76b7406a6693f5b340243209e,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_e5bdbccc007b5187d287f36f3c9f8130,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_21_use_certificate() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_21_use_certificate,
        const_str_plain_use_certificate,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_1a8dfef65194129bda154b5d5d19c988,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_eda9ad2d7932cfc1d1f52f27a3ed06a8,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_22_add_extra_chain_cert() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_22_add_extra_chain_cert,
        const_str_plain_add_extra_chain_cert,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_822962a03b3cbac836e47fa1e36419fa,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_3d1ad7b2c9fa025afe944eacf471d909,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_23__raise_passphrase_exception() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_23__raise_passphrase_exception,
        const_str_plain__raise_passphrase_exception,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ff33e982614e50cd77cbd818f47a7a68,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_24_use_privatekey_file(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_24_use_privatekey_file,
        const_str_plain_use_privatekey_file,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c9eaa039e52a2d0cfe9a9fd0371f8a5f,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_794f687944b90121fa261238090835e1,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_25_use_privatekey() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_25_use_privatekey,
        const_str_plain_use_privatekey,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_5e575d8ecc92ab2025e10ae05258d327,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_1f9e090d5f76db9e818dd53fef9b8465,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_26_check_privatekey() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_26_check_privatekey,
        const_str_plain_check_privatekey,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c1f5ffac0bddcd92b9fd18b1877284a7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_ceaeeee7f342339744c9535ada3c62e3,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_27_load_client_ca() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_27_load_client_ca,
        const_str_plain_load_client_ca,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_2d489c67d8f0900c68ccd131eb39b31e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_68d768407778bc3b4c8ffc953440b717,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_28_set_session_id() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_28_set_session_id,
        const_str_plain_set_session_id,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_bd9f3e8d092c4130e2f017c3c9cd2b5e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_df17ae6c88635e3960d7bf94f5e880a4,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_29_set_session_cache_mode() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_29_set_session_cache_mode,
        const_str_plain_set_session_cache_mode,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c427551e2adf1aa767652146eebdf018,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_b65860d01f08f87c7391d19b5cfd9850,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_2_raise_if_problem() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_2_raise_if_problem,
        const_str_plain_raise_if_problem,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_10a2c3fa06ddc8ce7babebf4ab2a34ed,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_0438f8885bf87c226201350e81ca4f79,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_30_get_session_cache_mode() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_30_get_session_cache_mode,
        const_str_plain_get_session_cache_mode,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_5817b5e321e605b5e5aa93bf0883e885,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_73851dbd1821d646fbb8ad48e937548f,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_31_set_verify() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_31_set_verify,
        const_str_plain_set_verify,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c067e3d1636e863e171637342c310c8c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_c0087bb531594ec7f6b437fc33f5a397,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_32_set_verify_depth() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_32_set_verify_depth,
        const_str_plain_set_verify_depth,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_df923127bdb888edf2c0aee9d730721d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_c5585513b25f5127855be671a08a1332,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_33_get_verify_mode() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_33_get_verify_mode,
        const_str_plain_get_verify_mode,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a8347686a3eb5f3ebe1515762b155d4a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_6d088f969ab84bf3d60ab75faa431e51,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_34_get_verify_depth() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_34_get_verify_depth,
        const_str_plain_get_verify_depth,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_db4c7bea0bf7206725d167d502c6eba5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_723fb164f3e133051d00542dd747fe2d,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_35_load_tmp_dh() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_35_load_tmp_dh,
        const_str_plain_load_tmp_dh,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_30235f217fa5586477415a9239a3581a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_8e472bc9049677fa90a9da1a818ea22f,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_36_set_tmp_ecdh() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_36_set_tmp_ecdh,
        const_str_plain_set_tmp_ecdh,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_4617788626982375adc8761ce194469c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_62f84685dfb1efe6a65f54b5d84154ad,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_37_set_cipher_list() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_37_set_cipher_list,
        const_str_plain_set_cipher_list,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_2b3317a29293d550661be41a8c0a9de2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_0b1af5d020260df564f1f58f9f88daaa,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_38_set_client_ca_list() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_38_set_client_ca_list,
        const_str_plain_set_client_ca_list,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_08c15e906deacdd0080dc5380f603678,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_f7bf61568f9564a7aee5354f80d84343,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_39_add_client_ca() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_39_add_client_ca,
        const_str_plain_add_client_ca,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_13d36b1bd050046a04a5eb1214a2c430,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_f5da7ec1228a5c8d32fa9b786affa014,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_3___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_3___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_4708bc94e7cf08ee5e04fb7dbacf1bd1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_3___init__$$$function_1_wrapper() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_3___init__$$$function_1_wrapper,
        const_str_plain_wrapper,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_3ca30ec9f4bb68c7995e4dc075f1f8aa,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        2
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_40_set_timeout() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_40_set_timeout,
        const_str_plain_set_timeout,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a709177b545996fdc26d1f69a26d148a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_39dd8800b3995a2e161e8739b1bebc01,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_41_get_timeout() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_41_get_timeout,
        const_str_plain_get_timeout,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_01a9999db18bff60965b0449882ec682,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_0bb5eb9f5b32c979fadc3e4b702de2f7,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_42_set_info_callback() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_42_set_info_callback,
        const_str_plain_set_info_callback,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_8789032a2a2c430ee61b2a9a442b588d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_e04d236da419e1b15c5c13532be67a91,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_42_set_info_callback$$$function_1_wrapper() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_42_set_info_callback$$$function_1_wrapper,
        const_str_plain_wrapper,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a732a29d3f3e6b4a55e2a24a6a2d57ce,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_43_get_app_data() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_43_get_app_data,
        const_str_plain_get_app_data,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_9d4bbd15181b53f3bd7f364d6e6e4145,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_0d994cfb9823ffc5647bea3454d1e646,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_44_set_app_data() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_44_set_app_data,
        const_str_plain_set_app_data,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0a6cc7d4157b03d199984fd3c032b609,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_bae02e8783abd2cb1ef184c4ddb0f45d,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_45_get_cert_store() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_45_get_cert_store,
        const_str_plain_get_cert_store,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_15a969cf6b2c91b8e511081a7c0a39b6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_b55bbb0df6959d47693f7145ead6828a,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_46_set_options() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_46_set_options,
        const_str_plain_set_options,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0632cad59439bdd081092e8e08dbc92d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_3957b1b23f06761ef1844caf450dffd3,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_47_set_mode() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_47_set_mode,
        const_str_plain_set_mode,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_de42447e718b11e0e561f2def518a1f5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_8d1f7ec402c1b452808eeb662977982b,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_48_set_tlsext_servername_callback() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_48_set_tlsext_servername_callback,
        const_str_plain_set_tlsext_servername_callback,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_bfea99648ca6c20c83b6bfd2c85611c5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_d84d6f514b61e2d13913a11459387aca,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_48_set_tlsext_servername_callback$$$function_1_wrapper() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_48_set_tlsext_servername_callback$$$function_1_wrapper,
        const_str_plain_wrapper,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ce0f4a68c73e09b427efa61d82289d07,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_49_set_tlsext_use_srtp() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_49_set_tlsext_use_srtp,
        const_str_plain_set_tlsext_use_srtp,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d8df85ffb933c241e379fed2d072ff49,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_447836721d7454a13033957e012d7688,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_4___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_4___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0eb02023a95d73c29a7d3de33ad75951,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper,
        const_str_plain_wrapper,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_8b48c52cd2db4623bd0576fa41e4cfa3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        2
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_50_set_npn_advertise_callback() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_50_set_npn_advertise_callback,
        const_str_plain_set_npn_advertise_callback,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c82e8c12b8026efc371154571f833311,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_5e63447161ff7f7c21b2ac874cc6500c,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_51_set_npn_select_callback() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_51_set_npn_select_callback,
        const_str_plain_set_npn_select_callback,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_7e20264abef33d5c372261962149019f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_fe0750f479b57ce782e84a9b40cf000b,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_52_set_alpn_protos() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_52_set_alpn_protos,
        const_str_plain_set_alpn_protos,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ce17632235d529b0e086bbba8d5f4d69,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_cf5a529c83a60eab9bc87caa3430bc5c,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_53_set_alpn_select_callback() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_53_set_alpn_select_callback,
        const_str_plain_set_alpn_select_callback,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_42236c687cf1136b7c7bf18f19fec11f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_9c76bfc2ff06864d351211fc5c45c351,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_54__set_ocsp_callback() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_54__set_ocsp_callback,
        const_str_plain__set_ocsp_callback,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_638f4df5700a78f0b7a07a86c27fb3a2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_e7ed1590d11cbaaaf17420c6bdc13490,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_55_set_ocsp_server_callback(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_55_set_ocsp_server_callback,
        const_str_plain_set_ocsp_server_callback,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_03577ba5881bc60859c4e27b32960700,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_77c1b668370aaac8571fd41e2e807543,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_56_set_ocsp_client_callback(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_56_set_ocsp_client_callback,
        const_str_plain_set_ocsp_client_callback,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d67706623e0b60e72dc27ab285eeed79,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_7cc8f764b42656b144d56bfbd9df2b48,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_57___init__(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_57___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c93d963cdd7d7cda8b597989582cd847,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_149b7c0937a6a666f182d0520ebdf631,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_58___getattr__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_58___getattr__,
        const_str_plain___getattr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_9ff72b44efcfb2d4a96a40edcf67b8cf,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_eb75de26d3d89a0b83fc536ac20042b0,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_59__raise_ssl_error() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_59__raise_ssl_error,
        const_str_plain__raise_ssl_error,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ecbdc66f85a0b113e83a292b998563db,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_5___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_5___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_3beab920a481007f8daf7a784334bc50,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_5___init__$$$function_1_wrapper() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_5___init__$$$function_1_wrapper,
        const_str_plain_wrapper,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0228e96ca7a03ca447fc3f1bfe3f2f29,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        2
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_60_get_context() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_60_get_context,
        const_str_plain_get_context,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_85b9d973a13dac4e475a6908180fcbd0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_d71143a9aaaa613b59e0c4c3015a7c4a,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_61_set_context() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_61_set_context,
        const_str_plain_set_context,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_b2045a22f86b32602807c3a9b9a1b9a9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_fe9d923dffe7ca07e210d76d45bba668,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_62_get_servername() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_62_get_servername,
        const_str_plain_get_servername,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_4b891c2de54665c165f85dce04cb4cb8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_94e7111e03f9422114930bb75dfc492c,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_63_set_tlsext_host_name() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_63_set_tlsext_host_name,
        const_str_plain_set_tlsext_host_name,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_e3c8ae13ac9eb0f32a9b6fc044804d84,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_b2b544e0252baa92681eeaf8ffa03130,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_64_pending() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_64_pending,
        const_str_plain_pending,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_b6d73ec0251ecf129f902466d7d1010b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_1ba1651f4266e42e9b568d28fa131281,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_65_send(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_65_send,
        const_str_plain_send,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c3dfbb3b28d031b8f3e3ccaa5745dfa1,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_2c98e45dae0eb590d01836d5f4b5f54f,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_66_sendall(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_66_sendall,
        const_str_plain_sendall,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_b9ad0ac22cd13b3cff0f4d819d0dee45,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_2eac950a8b26412274fa98ea596054c5,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_67_recv(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_67_recv,
        const_str_plain_recv,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_97860a8503a242ea2870dd155ed6cf25,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_ebaec5436a48442094f25464a6eec24c,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_68_recv_into(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_68_recv_into,
        const_str_plain_recv_into,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_be94e691bb77258f38f88be8b8aadc60,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_6f72f23667e4f49591ed4cf6d6205ca5,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_69__handle_bio_errors() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_69__handle_bio_errors,
        const_str_plain__handle_bio_errors,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_8e1387e41345949ee09c7bd644ab240f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_6___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_6___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_6eecb9f929296113b11b777ecdee380a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_6___init__$$$function_1_wrapper() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_6___init__$$$function_1_wrapper,
        const_str_plain_wrapper,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_1f66bae567fc069e7269625d4e4a775a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        2
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_70_bio_read() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_70_bio_read,
        const_str_plain_bio_read,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_b7ca808cc5c4c80d7918d0eed15dff75,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_f68d1733f2e29d0ad83b903b8f287e14,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_71_bio_write() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_71_bio_write,
        const_str_plain_bio_write,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d5ed49f302d78d068853f841ba5561d8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_3c214455d63d6846892932f043ae8dab,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_72_renegotiate() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_72_renegotiate,
        const_str_plain_renegotiate,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_7028d427820f53c4d1e8a41a379a1710,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_91c07271f44b73503e7c77deea91aef1,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_73_do_handshake() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_73_do_handshake,
        const_str_plain_do_handshake,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_3a54cffed41af1aede27c16b10131e97,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_f85e475b3736c6da8cbd8e92af63eba4,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_74_renegotiate_pending() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_74_renegotiate_pending,
        const_str_plain_renegotiate_pending,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d6f61d72394bd98660c5c42254770e72,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_bd36e8cd21056831af843bc4658cec96,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_75_total_renegotiations() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_75_total_renegotiations,
        const_str_plain_total_renegotiations,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0fadfadb8bb4516eed76800a79e9a7f7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_61df355efe52f096d5251268bee9ada3,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_76_connect() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_76_connect,
        const_str_plain_connect,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_054eab96f8b2836c51e087bd4de8388e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_060a092ce142509580b5fc6c56b149a1,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_77_connect_ex() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_77_connect_ex,
        const_str_plain_connect_ex,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_79150ce062e76c9de8df0c58996d97fe,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_60759f97a8e448eec2208bd0c353d705,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_78_accept() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_78_accept,
        const_str_plain_accept,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_2f4c7f3e7e619c283f90e008af92ff2c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_592776beca582822ed747da68adba670,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_79_bio_shutdown() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_79_bio_shutdown,
        const_str_plain_bio_shutdown,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_e6af520114787689a5f9cf0c5c00fde7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_5ecd8d00ee49c82aecc9b4312a6eab51,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_7___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_7___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_31b7ea660237ae3ad6904b3b553dbb0b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_7___init__$$$function_1_wrapper() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_7___init__$$$function_1_wrapper,
        const_str_plain_wrapper,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_cd50f2607dc6e8cfc0715ef171ecbc55,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        2
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_80_shutdown() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_80_shutdown,
        const_str_plain_shutdown,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_6f36c0fa3d59052efa6a916f18f6c1e1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_9071118ef0006cb5d28d9100761be8e9,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_81_get_cipher_list() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_81_get_cipher_list,
        const_str_plain_get_cipher_list,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_dfa471f51052025d0f268f8ce73b5948,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_92d0e5bbbb594d3595c30b16879df5a0,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_82_get_client_ca_list() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_82_get_client_ca_list,
        const_str_plain_get_client_ca_list,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c7007220b0b459514c7b12300a002dc2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_92dae1d5c0e993b1b8bd25bfbbae5039,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_83_makefile() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_83_makefile,
        const_str_plain_makefile,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_433dfad8408328fc74fc1215c9a5f8eb,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_f45f13437cfffca595693525af90acd6,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_84_get_app_data() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_84_get_app_data,
        const_str_plain_get_app_data,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c7e9dcab9b20e02fc8fa7057fd275f11,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_8d7c284f25a4b19db8bcbef7a9895745,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_85_set_app_data() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_85_set_app_data,
        const_str_plain_set_app_data,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a30e6c3082d13f64248246c7b439f499,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_240fed82a102b949d0d53c00df42e330,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_86_get_shutdown() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_86_get_shutdown,
        const_str_plain_get_shutdown,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_290e9c85751ef278e20a65deeb074f76,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_0bdfe95b50c341a06f9727afb1a762dc,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_87_set_shutdown() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_87_set_shutdown,
        const_str_plain_set_shutdown,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a79065ffeacdb0a47f1382db19c35f3d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_655ba65e888ba33199198c92a8e95d70,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_88_get_state_string() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_88_get_state_string,
        const_str_plain_get_state_string,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_096b136f4a3b30d606655f40a0fcb7eb,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_6e6304d3afc4a993b41c01e5af499f6b,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_89_server_random() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_89_server_random,
        const_str_plain_server_random,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_cbb40621241b7978549d445047800574,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_ad463a4d3fa3baff68f13aea2d205572,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_8___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_8___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_5b498c42a86529628b46de5b97e617d3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_8___init__$$$function_1_wrapper() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_8___init__$$$function_1_wrapper,
        const_str_plain_wrapper,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_6dbabe0cc3fa56b737c573ecdbbbc1cc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        2
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_90_client_random() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_90_client_random,
        const_str_plain_client_random,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_4ad7fb1c164aa08c3de4745ff8bb3abb,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_ce6e46c47189c65d4c33b9ca8d5ba2ad,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_91_master_key() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_91_master_key,
        const_str_plain_master_key,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_bb87c94112fe99283e7d060ed1328b6e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_a94ef27b6600318cb26f98532a46ec7d,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_92_export_keying_material(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_92_export_keying_material,
        const_str_plain_export_keying_material,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_26dc7c955eece9f3eeb0e341a1ceda0b,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_cbc74855fdd069af46a5197a85921eab,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_93_sock_shutdown() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_93_sock_shutdown,
        const_str_plain_sock_shutdown,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0a0cad4a67aba10eabe93e57ee235747,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_159b478f00ae4e4ff337b75b4ff4b73e,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_94_get_certificate() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_94_get_certificate,
        const_str_plain_get_certificate,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_3946b9a412811e47d3779a1e62a72e4b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_770cbd653c9b65a44061ec243e0b5fd3,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_95_get_peer_certificate() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_95_get_peer_certificate,
        const_str_plain_get_peer_certificate,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_3f6bd2362b83f8e85f091e7fc006c6ad,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_5f09856be161f8b617a90e11db2ed735,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_96_get_peer_cert_chain() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_96_get_peer_cert_chain,
        const_str_plain_get_peer_cert_chain,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_b0089d377af5c5ab7b6943168bf04c70,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_b6ee2740f619fbeb4f2040d74693ca57,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_97_want_read() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_97_want_read,
        const_str_plain_want_read,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c34dc8d8e69e96a1fdc1da393173e7eb,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_bcb5a3a78e430302038d88f5e5d88cc5,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_98_want_write() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_98_want_write,
        const_str_plain_want_write,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f69b17c8965a6426ab8e389546eeab2c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_1f723e76cd26cf3162ae94f693472dd5,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_99_set_accept_state() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_99_set_accept_state,
        const_str_plain_set_accept_state,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_201bf75d84b5bdea5cfec00b8b8c8ba7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_3319904791e7df62e14d88cc362facc1,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_9__asFileDescriptor() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_9__asFileDescriptor,
        const_str_plain__asFileDescriptor,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_36419b8e55b17a9cf1f1164d41ec30e1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        0
    );

    return (PyObject *)result;
}



#if PYTHON_VERSION >= 300
static struct PyModuleDef mdef_OpenSSL$SSL =
{
    PyModuleDef_HEAD_INIT,
    NULL,                /* m_name, filled later */
    NULL,                /* m_doc */
    -1,                  /* m_size */
    NULL,                /* m_methods */
    NULL,                /* m_reload */
    NULL,                /* m_traverse */
    NULL,                /* m_clear */
    NULL,                /* m_free */
  };
#endif

extern PyObject *const_str_plain___compiled__;

extern PyObject *const_str_plain___package__;
extern PyObject *const_str_empty;

#if PYTHON_VERSION >= 300
extern PyObject *const_str_dot;
extern PyObject *const_str_plain___loader__;
#endif

#if PYTHON_VERSION >= 340
extern PyObject *const_str_plain___spec__;
extern PyObject *const_str_plain__initializing;
extern PyObject *const_str_plain_submodule_search_locations;
#endif

extern void _initCompiledCellType();
extern void _initCompiledGeneratorType();
extern void _initCompiledFunctionType();
extern void _initCompiledMethodType();
extern void _initCompiledFrameType();
#if PYTHON_VERSION >= 350
extern void _initCompiledCoroutineTypes();
#endif
#if PYTHON_VERSION >= 360
extern void _initCompiledAsyncgenTypes();
#endif

extern PyTypeObject Nuitka_Loader_Type;

#ifdef _NUITKA_PLUGIN_DILL_ENABLED
// Provide a way to create find a function via its C code and create it back
// in another process, useful for multiprocessing extensions like dill

function_impl_code functable_OpenSSL$SSL[] = {
    impl_OpenSSL$SSL$$$function_3___init__$$$function_1_wrapper,
    impl_OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper,
    impl_OpenSSL$SSL$$$function_5___init__$$$function_1_wrapper,
    impl_OpenSSL$SSL$$$function_6___init__$$$function_1_wrapper,
    impl_OpenSSL$SSL$$$function_7___init__$$$function_1_wrapper,
    impl_OpenSSL$SSL$$$function_8___init__$$$function_1_wrapper,
    impl_OpenSSL$SSL$$$function_11__make_requires$$$function_1__requires_decorator,
    impl_OpenSSL$SSL$$$function_11__make_requires$$$function_1__requires_decorator$$$function_1_explode,
    impl_OpenSSL$SSL$$$function_14__wrap_callback$$$function_1_wrapper,
    impl_OpenSSL$SSL$$$function_42_set_info_callback$$$function_1_wrapper,
    impl_OpenSSL$SSL$$$function_48_set_tlsext_servername_callback$$$function_1_wrapper,
    impl_OpenSSL$SSL$$$function_1___init__,
    impl_OpenSSL$SSL$$$function_2_raise_if_problem,
    impl_OpenSSL$SSL$$$function_3___init__,
    impl_OpenSSL$SSL$$$function_4___init__,
    impl_OpenSSL$SSL$$$function_5___init__,
    impl_OpenSSL$SSL$$$function_6___init__,
    impl_OpenSSL$SSL$$$function_7___init__,
    impl_OpenSSL$SSL$$$function_8___init__,
    impl_OpenSSL$SSL$$$function_9__asFileDescriptor,
    impl_OpenSSL$SSL$$$function_10_SSLeay_version,
    impl_OpenSSL$SSL$$$function_11__make_requires,
    impl_OpenSSL$SSL$$$function_12___init__,
    impl_OpenSSL$SSL$$$function_13_load_verify_locations,
    impl_OpenSSL$SSL$$$function_14__wrap_callback,
    impl_OpenSSL$SSL$$$function_15_set_passwd_cb,
    impl_OpenSSL$SSL$$$function_16_set_default_verify_paths,
    impl_OpenSSL$SSL$$$function_17__check_env_vars_set,
    impl_OpenSSL$SSL$$$function_18__fallback_default_verify_paths,
    impl_OpenSSL$SSL$$$function_19_use_certificate_chain_file,
    impl_OpenSSL$SSL$$$function_20_use_certificate_file,
    impl_OpenSSL$SSL$$$function_21_use_certificate,
    impl_OpenSSL$SSL$$$function_22_add_extra_chain_cert,
    impl_OpenSSL$SSL$$$function_23__raise_passphrase_exception,
    impl_OpenSSL$SSL$$$function_24_use_privatekey_file,
    impl_OpenSSL$SSL$$$function_25_use_privatekey,
    impl_OpenSSL$SSL$$$function_26_check_privatekey,
    impl_OpenSSL$SSL$$$function_27_load_client_ca,
    impl_OpenSSL$SSL$$$function_28_set_session_id,
    impl_OpenSSL$SSL$$$function_29_set_session_cache_mode,
    impl_OpenSSL$SSL$$$function_30_get_session_cache_mode,
    impl_OpenSSL$SSL$$$function_31_set_verify,
    impl_OpenSSL$SSL$$$function_32_set_verify_depth,
    impl_OpenSSL$SSL$$$function_33_get_verify_mode,
    impl_OpenSSL$SSL$$$function_34_get_verify_depth,
    impl_OpenSSL$SSL$$$function_35_load_tmp_dh,
    impl_OpenSSL$SSL$$$function_36_set_tmp_ecdh,
    impl_OpenSSL$SSL$$$function_37_set_cipher_list,
    impl_OpenSSL$SSL$$$function_38_set_client_ca_list,
    impl_OpenSSL$SSL$$$function_39_add_client_ca,
    impl_OpenSSL$SSL$$$function_40_set_timeout,
    impl_OpenSSL$SSL$$$function_41_get_timeout,
    impl_OpenSSL$SSL$$$function_42_set_info_callback,
    impl_OpenSSL$SSL$$$function_43_get_app_data,
    impl_OpenSSL$SSL$$$function_44_set_app_data,
    impl_OpenSSL$SSL$$$function_45_get_cert_store,
    impl_OpenSSL$SSL$$$function_46_set_options,
    impl_OpenSSL$SSL$$$function_47_set_mode,
    impl_OpenSSL$SSL$$$function_48_set_tlsext_servername_callback,
    impl_OpenSSL$SSL$$$function_49_set_tlsext_use_srtp,
    impl_OpenSSL$SSL$$$function_50_set_npn_advertise_callback,
    impl_OpenSSL$SSL$$$function_51_set_npn_select_callback,
    impl_OpenSSL$SSL$$$function_52_set_alpn_protos,
    impl_OpenSSL$SSL$$$function_53_set_alpn_select_callback,
    impl_OpenSSL$SSL$$$function_54__set_ocsp_callback,
    impl_OpenSSL$SSL$$$function_55_set_ocsp_server_callback,
    impl_OpenSSL$SSL$$$function_56_set_ocsp_client_callback,
    impl_OpenSSL$SSL$$$function_57___init__,
    impl_OpenSSL$SSL$$$function_58___getattr__,
    impl_OpenSSL$SSL$$$function_59__raise_ssl_error,
    impl_OpenSSL$SSL$$$function_60_get_context,
    impl_OpenSSL$SSL$$$function_61_set_context,
    impl_OpenSSL$SSL$$$function_62_get_servername,
    impl_OpenSSL$SSL$$$function_63_set_tlsext_host_name,
    impl_OpenSSL$SSL$$$function_64_pending,
    impl_OpenSSL$SSL$$$function_65_send,
    impl_OpenSSL$SSL$$$function_66_sendall,
    impl_OpenSSL$SSL$$$function_67_recv,
    impl_OpenSSL$SSL$$$function_68_recv_into,
    impl_OpenSSL$SSL$$$function_69__handle_bio_errors,
    impl_OpenSSL$SSL$$$function_70_bio_read,
    impl_OpenSSL$SSL$$$function_71_bio_write,
    impl_OpenSSL$SSL$$$function_72_renegotiate,
    impl_OpenSSL$SSL$$$function_73_do_handshake,
    impl_OpenSSL$SSL$$$function_74_renegotiate_pending,
    impl_OpenSSL$SSL$$$function_75_total_renegotiations,
    impl_OpenSSL$SSL$$$function_76_connect,
    impl_OpenSSL$SSL$$$function_77_connect_ex,
    impl_OpenSSL$SSL$$$function_78_accept,
    impl_OpenSSL$SSL$$$function_79_bio_shutdown,
    impl_OpenSSL$SSL$$$function_80_shutdown,
    impl_OpenSSL$SSL$$$function_81_get_cipher_list,
    impl_OpenSSL$SSL$$$function_82_get_client_ca_list,
    impl_OpenSSL$SSL$$$function_83_makefile,
    impl_OpenSSL$SSL$$$function_84_get_app_data,
    impl_OpenSSL$SSL$$$function_85_set_app_data,
    impl_OpenSSL$SSL$$$function_86_get_shutdown,
    impl_OpenSSL$SSL$$$function_87_set_shutdown,
    impl_OpenSSL$SSL$$$function_88_get_state_string,
    impl_OpenSSL$SSL$$$function_89_server_random,
    impl_OpenSSL$SSL$$$function_90_client_random,
    impl_OpenSSL$SSL$$$function_91_master_key,
    impl_OpenSSL$SSL$$$function_92_export_keying_material,
    impl_OpenSSL$SSL$$$function_93_sock_shutdown,
    impl_OpenSSL$SSL$$$function_94_get_certificate,
    impl_OpenSSL$SSL$$$function_95_get_peer_certificate,
    impl_OpenSSL$SSL$$$function_96_get_peer_cert_chain,
    impl_OpenSSL$SSL$$$function_97_want_read,
    impl_OpenSSL$SSL$$$function_98_want_write,
    impl_OpenSSL$SSL$$$function_99_set_accept_state,
    impl_OpenSSL$SSL$$$function_100_set_connect_state,
    impl_OpenSSL$SSL$$$function_101_get_session,
    impl_OpenSSL$SSL$$$function_102_set_session,
    impl_OpenSSL$SSL$$$function_103__get_finished_message,
    impl_OpenSSL$SSL$$$function_104_get_finished,
    impl_OpenSSL$SSL$$$function_105_get_peer_finished,
    impl_OpenSSL$SSL$$$function_106_get_cipher_name,
    impl_OpenSSL$SSL$$$function_107_get_cipher_bits,
    impl_OpenSSL$SSL$$$function_108_get_cipher_version,
    impl_OpenSSL$SSL$$$function_109_get_protocol_version_name,
    impl_OpenSSL$SSL$$$function_110_get_protocol_version,
    impl_OpenSSL$SSL$$$function_111_get_next_proto_negotiated,
    impl_OpenSSL$SSL$$$function_112_set_alpn_protos,
    impl_OpenSSL$SSL$$$function_113_get_alpn_proto_negotiated,
    impl_OpenSSL$SSL$$$function_114_request_ocsp,
    NULL
};

static char const *_reduce_compiled_function_argnames[] = {
    "func",
    NULL
};

static PyObject *_reduce_compiled_function(PyObject *self, PyObject *args, PyObject *kwds) {
    PyObject *func;

    if (!PyArg_ParseTupleAndKeywords(args, kwds, "O:reduce_compiled_function", (char **)_reduce_compiled_function_argnames, &func, NULL)) {
        return NULL;
    }

    if (Nuitka_Function_Check(func) == false) {
        PyErr_Format(PyExc_TypeError, "not a compiled function");
        return NULL;
    }

    struct Nuitka_FunctionObject *function = (struct Nuitka_FunctionObject *)func;

    function_impl_code *current = functable_OpenSSL$SSL;
    int offset = 0;

    while (*current != NULL) {
        if (*current == function->m_c_code) {
            break;
        }

        current += 1;
        offset += 1;
    }

    if (*current == NULL) {
        PyErr_Format(PyExc_TypeError, "Cannot find compiled function in module.");
        return NULL;
    }

    PyObject *code_object_desc = PyTuple_New(6);
    PyTuple_SET_ITEM0(code_object_desc, 0, function->m_code_object->co_filename);
    PyTuple_SET_ITEM0(code_object_desc, 1, function->m_code_object->co_name);
    PyTuple_SET_ITEM(code_object_desc, 2, PyLong_FromLong(function->m_code_object->co_firstlineno));
    PyTuple_SET_ITEM0(code_object_desc, 3, function->m_code_object->co_varnames);
    PyTuple_SET_ITEM(code_object_desc, 4, PyLong_FromLong(function->m_code_object->co_argcount));
    PyTuple_SET_ITEM(code_object_desc, 5, PyLong_FromLong(function->m_code_object->co_flags));

    CHECK_OBJECT_DEEP(code_object_desc);

    PyObject *result = PyTuple_New(4);
    PyTuple_SET_ITEM(result, 0, PyLong_FromLong(offset));
    PyTuple_SET_ITEM(result, 1, code_object_desc);
    PyTuple_SET_ITEM0(result, 2, function->m_defaults);
    PyTuple_SET_ITEM0(result, 3, function->m_doc != NULL ? function->m_doc : Py_None);

    CHECK_OBJECT_DEEP(result);

    return result;
}

static PyMethodDef _method_def_reduce_compiled_function = {"reduce_compiled_function", (PyCFunction)_reduce_compiled_function,
                                                           METH_VARARGS | METH_KEYWORDS, NULL};

static char const *_create_compiled_function_argnames[] = {
    "func",
    "code_object_desc",
    "defaults",
    "doc",
    NULL
};


static PyObject *_create_compiled_function(PyObject *self, PyObject *args, PyObject *kwds) {
    CHECK_OBJECT_DEEP(args);

    PyObject *func;
    PyObject *code_object_desc;
    PyObject *defaults;
    PyObject *doc;

    if (!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:create_compiled_function", (char **)_create_compiled_function_argnames, &func, &code_object_desc, &defaults, &doc, NULL)) {
        return NULL;
    }

    int offset = PyLong_AsLong(func);

    if (offset == -1 && ERROR_OCCURRED()) {
        return NULL;
    }

    if (offset > sizeof(functable_OpenSSL$SSL) || offset < 0) {
        PyErr_Format(PyExc_TypeError, "Wrong offset for compiled function.");
        return NULL;
    }

    PyObject *filename = PyTuple_GET_ITEM(code_object_desc, 0);
    PyObject *function_name = PyTuple_GET_ITEM(code_object_desc, 1);
    PyObject *line = PyTuple_GET_ITEM(code_object_desc, 2);
    int line_int = PyLong_AsLong(line);
    assert(!ERROR_OCCURRED());

    PyObject *argnames = PyTuple_GET_ITEM(code_object_desc, 3);
    PyObject *arg_count = PyTuple_GET_ITEM(code_object_desc, 4);
    int arg_count_int = PyLong_AsLong(arg_count);
    assert(!ERROR_OCCURRED());
    PyObject *flags = PyTuple_GET_ITEM(code_object_desc, 5);
    int flags_int = PyLong_AsLong(flags);
    assert(!ERROR_OCCURRED());

    PyCodeObject *code_object = MAKE_CODEOBJECT(
        filename,
        line_int,
        flags_int,
        function_name,
        argnames,
        arg_count_int,
        0, // TODO: Missing kw_only_count
        0 // TODO: Missing pos_only_count
    );

    // TODO: More stuff needed for Python3, best to re-order arguments of MAKE_CODEOBJECT.
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        functable_OpenSSL$SSL[offset],
        code_object->co_name,
#if PYTHON_VERSION >= 300
        NULL, // TODO: Not transferring qualname yet
#endif
        code_object,
        defaults,
#if PYTHON_VERSION >= 300
        NULL, // kwdefaults are done on the outside currently
        NULL, // TODO: Not transferring annotations
#endif
        module_OpenSSL$SSL,
        doc,
        0
    );

    return (PyObject *)result;
}

static PyMethodDef _method_def_create_compiled_function = {
    "create_compiled_function",
    (PyCFunction)_create_compiled_function,
    METH_VARARGS | METH_KEYWORDS, NULL
};


#endif

// Internal entry point for module code.
PyObject *modulecode_OpenSSL$SSL(char const *module_full_name) {
#if defined(_NUITKA_EXE) || PYTHON_VERSION >= 300
    static bool _init_done = false;

    // Modules might be imported repeatedly, which is to be ignored.
    if (_init_done) {
        return module_OpenSSL$SSL;
    } else {
        _init_done = true;
    }
#endif

#ifdef _NUITKA_MODULE
    // In case of a stand alone extension module, need to call initialization
    // the init here because that's the first and only time we are going to get
    // called here.

    // May have to activate constants blob.
#if defined(_NUITKA_CONSTANTS_FROM_RESOURCE)
    loadConstantsResource();
#endif

    // Initialize the constant values used.
    _initBuiltinModule();
    createGlobalConstants();

    /* Initialize the compiled types of Nuitka. */
    _initCompiledCellType();
    _initCompiledGeneratorType();
    _initCompiledFunctionType();
    _initCompiledMethodType();
    _initCompiledFrameType();
#if PYTHON_VERSION >= 350
    _initCompiledCoroutineTypes();
#endif
#if PYTHON_VERSION >= 360
    _initCompiledAsyncgenTypes();
#endif

#if PYTHON_VERSION < 300
    _initSlotCompare();
#endif
#if PYTHON_VERSION >= 270
    _initSlotIternext();
#endif

    patchBuiltinModule();
    patchTypeComparison();

    // Enable meta path based loader if not already done.
#ifdef _NUITKA_TRACE
    PRINT_STRING("OpenSSL.SSL: Calling setupMetaPathBasedLoader().\n");
#endif
    setupMetaPathBasedLoader();

#if PYTHON_VERSION >= 300
    patchInspectModule();
#endif

#endif

    /* The constants only used by this module are created now. */
#ifdef _NUITKA_TRACE
    PRINT_STRING("OpenSSL.SSL: Calling createModuleConstants().\n");
#endif
    createModuleConstants();

    /* The code objects used by this module are created now. */
#ifdef _NUITKA_TRACE
    PRINT_STRING("OpenSSL.SSL: Calling createModuleCodeObjects().\n");
#endif
    createModuleCodeObjects();

    // PRINT_STRING("in initOpenSSL$SSL\n");

    // Create the module object first. There are no methods initially, all are
    // added dynamically in actual code only.  Also no "__doc__" is initially
    // set at this time, as it could not contain NUL characters this way, they
    // are instead set in early module code.  No "self" for modules, we have no
    // use for it.
#if PYTHON_VERSION < 300
    module_OpenSSL$SSL = Py_InitModule4(
        module_full_name,        // Module Name
        NULL,                    // No methods initially, all are added
                                 // dynamically in actual module code only.
        NULL,                    // No "__doc__" is initially set, as it could
                                 // not contain NUL this way, added early in
                                 // actual code.
        NULL,                    // No self for modules, we don't use it.
        PYTHON_API_VERSION
    );
#else
    mdef_OpenSSL$SSL.m_name = module_full_name;
    module_OpenSSL$SSL = PyModule_Create(&mdef_OpenSSL$SSL);
#endif

    moduledict_OpenSSL$SSL = MODULE_DICT(module_OpenSSL$SSL);

#ifdef _NUITKA_PLUGIN_DILL_ENABLED
    {
        PyObject *function_tables = PyObject_GetAttrString((PyObject *)builtin_module, "compiled_function_tables");
        if (function_tables == NULL)
        {
            DROP_ERROR_OCCURRED();
            function_tables = PyDict_New();
        }
        PyObject_SetAttrString((PyObject *)builtin_module, "compiled_function_tables", function_tables);
        PyObject *funcs = PyTuple_New(2);
        PyTuple_SetItem(funcs, 0, PyCFunction_New(&_method_def_reduce_compiled_function, NULL));
        PyTuple_SetItem(funcs, 1, PyCFunction_New(&_method_def_create_compiled_function, NULL));
        PyDict_SetItemString(function_tables, module_full_name, funcs);
    }
#endif

    // Set "__compiled__" to what version information we have.
    UPDATE_STRING_DICT0(
        moduledict_OpenSSL$SSL,
        (Nuitka_StringObject *)const_str_plain___compiled__,
        Nuitka_dunder_compiled_value
    );

    // Update "__package__" value to what it ought to be.
    {
#if 0
        UPDATE_STRING_DICT0(
            moduledict_OpenSSL$SSL,
            (Nuitka_StringObject *)const_str_plain___package__,
            const_str_empty
        );
#elif 0
        PyObject *module_name = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain___name__);

        UPDATE_STRING_DICT0(
            moduledict_OpenSSL$SSL,
            (Nuitka_StringObject *)const_str_plain___package__,
            module_name
        );
#else

#if PYTHON_VERSION < 300
        PyObject *module_name = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain___name__);
        char const *module_name_cstr = PyString_AS_STRING(module_name);

        char const *last_dot = strrchr(module_name_cstr, '.');

        if (last_dot != NULL)
        {
            UPDATE_STRING_DICT1(
                moduledict_OpenSSL$SSL,
                (Nuitka_StringObject *)const_str_plain___package__,
                PyString_FromStringAndSize(module_name_cstr, last_dot - module_name_cstr)
            );
        }
#else
        PyObject *module_name = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain___name__);
        Py_ssize_t dot_index = PyUnicode_Find(module_name, const_str_dot, 0, PyUnicode_GetLength(module_name), -1);

        if (dot_index != -1)
        {
            UPDATE_STRING_DICT1(
                moduledict_OpenSSL$SSL,
                (Nuitka_StringObject *)const_str_plain___package__,
                PyUnicode_Substring(module_name, 0, dot_index)
            );
        }
#endif
#endif
    }

    CHECK_OBJECT(module_OpenSSL$SSL);

// Seems to work for Python2.7 out of the box, but for Python3, the module
// doesn't automatically enter "sys.modules", so do it manually.
#if PYTHON_VERSION >= 300
    {
        int r = PyDict_SetItemString(PyImport_GetModuleDict(), module_full_name, module_OpenSSL$SSL);
        assert(r != -1);
    }
#endif

    // For deep importing of a module we need to have "__builtins__", so we set
    // it ourselves in the same way than CPython does. Note: This must be done
    // before the frame object is allocated, or else it may fail.

    if (GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain___builtins__) == NULL)
    {
        PyObject *value = (PyObject *)builtin_module;

        // Check if main module, not a dict then but the module itself.
#if !defined(_NUITKA_EXE) || !0
        value = PyModule_GetDict(value);
#endif

        UPDATE_STRING_DICT0(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain___builtins__, value);
    }

#if PYTHON_VERSION >= 300
    UPDATE_STRING_DICT0(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain___loader__, (PyObject *)&Nuitka_Loader_Type);
#endif

#if PYTHON_VERSION >= 340
// Set the "__spec__" value

#if 0
    // Main modules just get "None" as spec.
    UPDATE_STRING_DICT0(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain___spec__, Py_None);
#else
    // Other modules get a "ModuleSpec" from the standard mechanism.
    {
        PyObject *bootstrap_module = PyImport_ImportModule("importlib._bootstrap");
        CHECK_OBJECT(bootstrap_module);
        PyObject *module_spec_class = PyObject_GetAttrString(bootstrap_module, "ModuleSpec");
        Py_DECREF(bootstrap_module);

        PyObject *args[] = {
            GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain___name__),
            (PyObject *)&Nuitka_Loader_Type
        };

        PyObject *spec_value = CALL_FUNCTION_WITH_ARGS2(
            module_spec_class,
            args
        );
        Py_DECREF(module_spec_class);

        // We can assume this to never fail, or else we are in trouble anyway.
        CHECK_OBJECT(spec_value);

// For packages set the submodule search locations as well, even if to empty
// list, so investigating code will consider it a package.
#if 0
        SET_ATTRIBUTE(spec_value, const_str_plain_submodule_search_locations, PyList_New(0));
#endif

// Mark the execution in the "__spec__" value.
        SET_ATTRIBUTE(spec_value, const_str_plain__initializing, Py_True);

        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain___spec__, spec_value);
    }
#endif
#endif

    // Temp variables if any
    PyObject *tmp_Context$genexpr_1__$0 = NULL;
    PyObject *tmp_class_creation_10__bases = NULL;
    PyObject *tmp_class_creation_10__class = NULL;
    PyObject *tmp_class_creation_10__class_dict = NULL;
    PyObject *tmp_class_creation_10__metaclass = NULL;
    PyObject *tmp_class_creation_11__bases = NULL;
    PyObject *tmp_class_creation_11__class = NULL;
    PyObject *tmp_class_creation_11__class_dict = NULL;
    PyObject *tmp_class_creation_11__metaclass = NULL;
    PyObject *tmp_class_creation_12__bases = NULL;
    PyObject *tmp_class_creation_12__class = NULL;
    PyObject *tmp_class_creation_12__class_dict = NULL;
    PyObject *tmp_class_creation_12__metaclass = NULL;
    PyObject *tmp_class_creation_13__bases = NULL;
    PyObject *tmp_class_creation_13__class = NULL;
    PyObject *tmp_class_creation_13__class_dict = NULL;
    PyObject *tmp_class_creation_13__metaclass = NULL;
    PyObject *tmp_class_creation_14__bases = NULL;
    PyObject *tmp_class_creation_14__class = NULL;
    PyObject *tmp_class_creation_14__class_dict = NULL;
    PyObject *tmp_class_creation_14__metaclass = NULL;
    PyObject *tmp_class_creation_15__class = NULL;
    PyObject *tmp_class_creation_15__class_dict = NULL;
    PyObject *tmp_class_creation_15__metaclass = NULL;
    PyObject *tmp_class_creation_16__class = NULL;
    PyObject *tmp_class_creation_16__class_dict = NULL;
    PyObject *tmp_class_creation_16__metaclass = NULL;
    PyObject *tmp_class_creation_17__class = NULL;
    PyObject *tmp_class_creation_17__class_dict = NULL;
    PyObject *tmp_class_creation_17__metaclass = NULL;
    PyObject *tmp_class_creation_2__class = NULL;
    PyObject *tmp_class_creation_2__class_dict = NULL;
    PyObject *tmp_class_creation_2__metaclass = NULL;
    PyObject *tmp_class_creation_3__bases = NULL;
    PyObject *tmp_class_creation_3__class = NULL;
    PyObject *tmp_class_creation_3__class_dict = NULL;
    PyObject *tmp_class_creation_3__metaclass = NULL;
    PyObject *tmp_class_creation_4__bases = NULL;
    PyObject *tmp_class_creation_4__class = NULL;
    PyObject *tmp_class_creation_4__class_dict = NULL;
    PyObject *tmp_class_creation_4__metaclass = NULL;
    PyObject *tmp_class_creation_5__bases = NULL;
    PyObject *tmp_class_creation_5__class = NULL;
    PyObject *tmp_class_creation_5__class_dict = NULL;
    PyObject *tmp_class_creation_5__metaclass = NULL;
    PyObject *tmp_class_creation_6__bases = NULL;
    PyObject *tmp_class_creation_6__class = NULL;
    PyObject *tmp_class_creation_6__class_dict = NULL;
    PyObject *tmp_class_creation_6__metaclass = NULL;
    PyObject *tmp_class_creation_7__bases = NULL;
    PyObject *tmp_class_creation_7__class = NULL;
    PyObject *tmp_class_creation_7__class_dict = NULL;
    PyObject *tmp_class_creation_7__metaclass = NULL;
    PyObject *tmp_class_creation_8__class = NULL;
    PyObject *tmp_class_creation_8__class_dict = NULL;
    PyObject *tmp_class_creation_8__metaclass = NULL;
    PyObject *tmp_class_creation_9__bases = NULL;
    PyObject *tmp_class_creation_9__class = NULL;
    PyObject *tmp_class_creation_9__class_dict = NULL;
    PyObject *tmp_class_creation_9__metaclass = NULL;
    PyObject *tmp_import_from_1__module = NULL;
    PyObject *tmp_import_from_2__module = NULL;
    PyObject *tmp_import_from_3__module = NULL;
    PyObject *tmp_import_from_4__module = NULL;
    PyObject *tmp_import_from_5__module = NULL;
    PyObject *tmp_locals_OpenSSL$SSL_269_key___init__ = NULL;
    PyObject *tmp_locals_OpenSSL$SSL_269_key_raise_if_problem = NULL;
    PyObject *tmp_select_metaclass_10__base = NULL;
    PyObject *tmp_select_metaclass_11__base = NULL;
    PyObject *tmp_select_metaclass_12__base = NULL;
    PyObject *tmp_select_metaclass_13__base = NULL;
    PyObject *tmp_select_metaclass_14__base = NULL;
    PyObject *tmp_select_metaclass_3__base = NULL;
    PyObject *tmp_select_metaclass_4__base = NULL;
    PyObject *tmp_select_metaclass_5__base = NULL;
    PyObject *tmp_select_metaclass_6__base = NULL;
    PyObject *tmp_select_metaclass_7__base = NULL;
    PyObject *tmp_select_metaclass_9__base = NULL;
    struct Nuitka_FrameObject *frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    int tmp_res;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;
    PyObject *locals_OpenSSL$SSL_249 = NULL;
    PyObject *tmp_dictset_value;
    PyObject *exception_keeper_type_6;
    PyObject *exception_keeper_value_6;
    PyTracebackObject *exception_keeper_tb_6;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_6;
    PyObject *exception_keeper_type_7;
    PyObject *exception_keeper_value_7;
    PyTracebackObject *exception_keeper_tb_7;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_7;
    PyObject *locals_OpenSSL$SSL_253 = NULL;
    PyObject *exception_keeper_type_8;
    PyObject *exception_keeper_value_8;
    PyTracebackObject *exception_keeper_tb_8;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_8;
    PyObject *exception_keeper_type_9;
    PyObject *exception_keeper_value_9;
    PyTracebackObject *exception_keeper_tb_9;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_9;
    PyObject *locals_OpenSSL$SSL_257 = NULL;
    PyObject *exception_keeper_type_10;
    PyObject *exception_keeper_value_10;
    PyTracebackObject *exception_keeper_tb_10;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_10;
    PyObject *exception_keeper_type_11;
    PyObject *exception_keeper_value_11;
    PyTracebackObject *exception_keeper_tb_11;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_11;
    PyObject *locals_OpenSSL$SSL_261 = NULL;
    PyObject *exception_keeper_type_12;
    PyObject *exception_keeper_value_12;
    PyTracebackObject *exception_keeper_tb_12;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_12;
    PyObject *exception_keeper_type_13;
    PyObject *exception_keeper_value_13;
    PyTracebackObject *exception_keeper_tb_13;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_13;
    PyObject *locals_OpenSSL$SSL_265 = NULL;
    PyObject *exception_keeper_type_14;
    PyObject *exception_keeper_value_14;
    PyTracebackObject *exception_keeper_tb_14;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_14;
    PyObject *exception_keeper_type_15;
    PyObject *exception_keeper_value_15;
    PyTracebackObject *exception_keeper_tb_15;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_15;
    PyObject *exception_keeper_type_16;
    PyObject *exception_keeper_value_16;
    PyTracebackObject *exception_keeper_tb_16;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_16;
    PyObject *locals_OpenSSL$SSL_297 = NULL;
    PyObject *exception_keeper_type_17;
    PyObject *exception_keeper_value_17;
    PyTracebackObject *exception_keeper_tb_17;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_17;
    PyObject *exception_keeper_type_18;
    PyObject *exception_keeper_value_18;
    PyTracebackObject *exception_keeper_tb_18;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_18;
    PyObject *locals_OpenSSL$SSL_336 = NULL;
    PyObject *exception_keeper_type_19;
    PyObject *exception_keeper_value_19;
    PyTracebackObject *exception_keeper_tb_19;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_19;
    PyObject *exception_keeper_type_20;
    PyObject *exception_keeper_value_20;
    PyTracebackObject *exception_keeper_tb_20;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_20;
    PyObject *locals_OpenSSL$SSL_377 = NULL;
    PyObject *exception_keeper_type_21;
    PyObject *exception_keeper_value_21;
    PyTracebackObject *exception_keeper_tb_21;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_21;
    PyObject *exception_keeper_type_22;
    PyObject *exception_keeper_value_22;
    PyTracebackObject *exception_keeper_tb_22;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_22;
    PyObject *locals_OpenSSL$SSL_426 = NULL;
    PyObject *exception_keeper_type_23;
    PyObject *exception_keeper_value_23;
    PyTracebackObject *exception_keeper_tb_23;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_23;
    PyObject *exception_keeper_type_24;
    PyObject *exception_keeper_value_24;
    PyTracebackObject *exception_keeper_tb_24;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_24;
    PyObject *locals_OpenSSL$SSL_477 = NULL;
    PyObject *exception_keeper_type_25;
    PyObject *exception_keeper_value_25;
    PyTracebackObject *exception_keeper_tb_25;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_25;
    PyObject *exception_keeper_type_26;
    PyObject *exception_keeper_value_26;
    PyTracebackObject *exception_keeper_tb_26;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_26;
    PyObject *locals_OpenSSL$SSL_544 = NULL;
    PyObject *exception_keeper_type_27;
    PyObject *exception_keeper_value_27;
    PyTracebackObject *exception_keeper_tb_27;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_27;
    PyObject *exception_keeper_type_28;
    PyObject *exception_keeper_value_28;
    PyTracebackObject *exception_keeper_tb_28;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_28;
    PyObject *exception_keeper_type_29;
    PyObject *exception_keeper_value_29;
    PyTracebackObject *exception_keeper_tb_29;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_29;
    PyObject *locals_OpenSSL$SSL_679 = NULL;
    struct Nuitka_FrameObject *frame_d641b83c6dc81d8049e076a80fd0abcb_2;
    NUITKA_MAY_BE_UNUSED char const *type_description_2 = NULL;
    static struct Nuitka_FrameObject *cache_frame_d641b83c6dc81d8049e076a80fd0abcb_2 = NULL;
    PyObject *exception_keeper_type_30;
    PyObject *exception_keeper_value_30;
    PyTracebackObject *exception_keeper_tb_30;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_30;
    PyObject *exception_keeper_type_31;
    PyObject *exception_keeper_value_31;
    PyTracebackObject *exception_keeper_tb_31;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_31;
    PyObject *locals_OpenSSL$SSL_1537 = NULL;
    struct Nuitka_FrameObject *frame_b51be28c00cf0bfc19c54f6f95b9174b_3;
    NUITKA_MAY_BE_UNUSED char const *type_description_3 = NULL;
    static struct Nuitka_FrameObject *cache_frame_b51be28c00cf0bfc19c54f6f95b9174b_3 = NULL;
    PyObject *exception_keeper_type_32;
    PyObject *exception_keeper_value_32;
    PyTracebackObject *exception_keeper_tb_32;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_32;
    PyObject *exception_keeper_type_33;
    PyObject *exception_keeper_value_33;
    PyTracebackObject *exception_keeper_tb_33;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_33;

    // Module code.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = Py_None;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain___doc__, tmp_assign_source_1);
    }
    {
        PyObject *tmp_assign_source_2;
        tmp_assign_source_2 = module_filename_obj;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain___file__, tmp_assign_source_2);
    }
    // Frame without reuse.
    frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e = MAKE_MODULE_FRAME(codeobj_9bf9e3fa2edc4bf3ebd1e712b4e8714e, module_OpenSSL$SSL);

    // Push the new frame as the currently active one, and we should be exclusively
    // owning it.
    pushFrameStack(frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e);
    assert(Py_REFCNT(frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e) == 2);

    // Framed code:
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_name_name_1;
        PyObject *tmp_globals_name_1;
        PyObject *tmp_locals_name_1;
        PyObject *tmp_fromlist_name_1;
        tmp_name_name_1 = const_str_plain_os;
        tmp_globals_name_1 = (PyObject *)moduledict_OpenSSL$SSL;
        tmp_locals_name_1 = Py_None;
        tmp_fromlist_name_1 = Py_None;
        frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e->m_frame.f_lineno = 1;
        tmp_assign_source_3 = IMPORT_MODULE4(tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1);
        if (tmp_assign_source_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_os, tmp_assign_source_3);
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_name_name_2;
        PyObject *tmp_globals_name_2;
        PyObject *tmp_locals_name_2;
        PyObject *tmp_fromlist_name_2;
        tmp_name_name_2 = const_str_plain_socket;
        tmp_globals_name_2 = (PyObject *)moduledict_OpenSSL$SSL;
        tmp_locals_name_2 = Py_None;
        tmp_fromlist_name_2 = Py_None;
        frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e->m_frame.f_lineno = 2;
        tmp_assign_source_4 = IMPORT_MODULE4(tmp_name_name_2, tmp_globals_name_2, tmp_locals_name_2, tmp_fromlist_name_2);
        if (tmp_assign_source_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_socket, tmp_assign_source_4);
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_import_name_from_1;
        PyObject *tmp_name_name_3;
        PyObject *tmp_globals_name_3;
        PyObject *tmp_locals_name_3;
        PyObject *tmp_fromlist_name_3;
        tmp_name_name_3 = const_str_plain_sys;
        tmp_globals_name_3 = (PyObject *)moduledict_OpenSSL$SSL;
        tmp_locals_name_3 = Py_None;
        tmp_fromlist_name_3 = const_tuple_str_plain_platform_tuple;
        frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e->m_frame.f_lineno = 3;
        tmp_import_name_from_1 = IMPORT_MODULE4(tmp_name_name_3, tmp_globals_name_3, tmp_locals_name_3, tmp_fromlist_name_3);
        assert(!(tmp_import_name_from_1 == NULL));
        tmp_assign_source_5 = IMPORT_NAME(tmp_import_name_from_1, const_str_plain_platform);
        Py_DECREF(tmp_import_name_from_1);
        assert(!(tmp_assign_source_5 == NULL));
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_platform, tmp_assign_source_5);
    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_name_name_4;
        PyObject *tmp_globals_name_4;
        PyObject *tmp_locals_name_4;
        PyObject *tmp_fromlist_name_4;
        tmp_name_name_4 = const_str_plain_functools;
        tmp_globals_name_4 = (PyObject *)moduledict_OpenSSL$SSL;
        tmp_locals_name_4 = Py_None;
        tmp_fromlist_name_4 = const_tuple_str_plain_wraps_str_plain_partial_tuple;
        frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e->m_frame.f_lineno = 4;
        tmp_assign_source_6 = IMPORT_MODULE4(tmp_name_name_4, tmp_globals_name_4, tmp_locals_name_4, tmp_fromlist_name_4);
        if (tmp_assign_source_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 4;

            goto frame_exception_exit_1;
        }
        assert(tmp_import_from_1__module == NULL);
        tmp_import_from_1__module = tmp_assign_source_6;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_import_name_from_2;
        CHECK_OBJECT(tmp_import_from_1__module);
        tmp_import_name_from_2 = tmp_import_from_1__module;
        tmp_assign_source_7 = IMPORT_NAME(tmp_import_name_from_2, const_str_plain_wraps);
        if (tmp_assign_source_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 4;

            goto try_except_handler_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_wraps, tmp_assign_source_7);
    }
    {
        PyObject *tmp_assign_source_8;
        PyObject *tmp_import_name_from_3;
        CHECK_OBJECT(tmp_import_from_1__module);
        tmp_import_name_from_3 = tmp_import_from_1__module;
        tmp_assign_source_8 = IMPORT_NAME(tmp_import_name_from_3, const_str_plain_partial);
        if (tmp_assign_source_8 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 4;

            goto try_except_handler_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_partial, tmp_assign_source_8);
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)tmp_import_from_1__module);
    Py_DECREF(tmp_import_from_1__module);
    tmp_import_from_1__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    CHECK_OBJECT((PyObject *)tmp_import_from_1__module);
    Py_DECREF(tmp_import_from_1__module);
    tmp_import_from_1__module = NULL;

    {
        PyObject *tmp_assign_source_9;
        PyObject *tmp_name_name_5;
        PyObject *tmp_globals_name_5;
        PyObject *tmp_locals_name_5;
        PyObject *tmp_fromlist_name_5;
        tmp_name_name_5 = const_str_plain_itertools;
        tmp_globals_name_5 = (PyObject *)moduledict_OpenSSL$SSL;
        tmp_locals_name_5 = Py_None;
        tmp_fromlist_name_5 = const_tuple_str_plain_count_str_plain_chain_tuple;
        frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e->m_frame.f_lineno = 5;
        tmp_assign_source_9 = IMPORT_MODULE4(tmp_name_name_5, tmp_globals_name_5, tmp_locals_name_5, tmp_fromlist_name_5);
        assert(!(tmp_assign_source_9 == NULL));
        assert(tmp_import_from_2__module == NULL);
        tmp_import_from_2__module = tmp_assign_source_9;
    }
    {
        PyObject *tmp_assign_source_10;
        PyObject *tmp_import_name_from_4;
        CHECK_OBJECT(tmp_import_from_2__module);
        tmp_import_name_from_4 = tmp_import_from_2__module;
        tmp_assign_source_10 = IMPORT_NAME(tmp_import_name_from_4, const_str_plain_count);
        assert(!(tmp_assign_source_10 == NULL));
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_count, tmp_assign_source_10);
    }
    {
        PyObject *tmp_assign_source_11;
        PyObject *tmp_import_name_from_5;
        CHECK_OBJECT(tmp_import_from_2__module);
        tmp_import_name_from_5 = tmp_import_from_2__module;
        tmp_assign_source_11 = IMPORT_NAME(tmp_import_name_from_5, const_str_plain_chain);
        assert(!(tmp_assign_source_11 == NULL));
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_chain, tmp_assign_source_11);
    }
    CHECK_OBJECT((PyObject *)tmp_import_from_2__module);
    Py_DECREF(tmp_import_from_2__module);
    tmp_import_from_2__module = NULL;

    {
        PyObject *tmp_assign_source_12;
        PyObject *tmp_import_name_from_6;
        PyObject *tmp_name_name_6;
        PyObject *tmp_globals_name_6;
        PyObject *tmp_locals_name_6;
        PyObject *tmp_fromlist_name_6;
        tmp_name_name_6 = const_str_plain_weakref;
        tmp_globals_name_6 = (PyObject *)moduledict_OpenSSL$SSL;
        tmp_locals_name_6 = Py_None;
        tmp_fromlist_name_6 = const_tuple_str_plain_WeakValueDictionary_tuple;
        frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e->m_frame.f_lineno = 6;
        tmp_import_name_from_6 = IMPORT_MODULE4(tmp_name_name_6, tmp_globals_name_6, tmp_locals_name_6, tmp_fromlist_name_6);
        if (tmp_import_name_from_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 6;

            goto frame_exception_exit_1;
        }
        tmp_assign_source_12 = IMPORT_NAME(tmp_import_name_from_6, const_str_plain_WeakValueDictionary);
        Py_DECREF(tmp_import_name_from_6);
        if (tmp_assign_source_12 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 6;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_WeakValueDictionary, tmp_assign_source_12);
    }
    {
        PyObject *tmp_assign_source_13;
        PyObject *tmp_import_name_from_7;
        PyObject *tmp_name_name_7;
        PyObject *tmp_globals_name_7;
        PyObject *tmp_locals_name_7;
        PyObject *tmp_fromlist_name_7;
        tmp_name_name_7 = const_str_plain_errno;
        tmp_globals_name_7 = (PyObject *)moduledict_OpenSSL$SSL;
        tmp_locals_name_7 = Py_None;
        tmp_fromlist_name_7 = const_tuple_str_plain_errorcode_tuple;
        frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e->m_frame.f_lineno = 7;
        tmp_import_name_from_7 = IMPORT_MODULE4(tmp_name_name_7, tmp_globals_name_7, tmp_locals_name_7, tmp_fromlist_name_7);
        assert(!(tmp_import_name_from_7 == NULL));
        tmp_assign_source_13 = IMPORT_NAME(tmp_import_name_from_7, const_str_plain_errorcode);
        Py_DECREF(tmp_import_name_from_7);
        assert(!(tmp_assign_source_13 == NULL));
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_errorcode, tmp_assign_source_13);
    }
    {
        PyObject *tmp_assign_source_14;
        PyObject *tmp_import_name_from_8;
        PyObject *tmp_name_name_8;
        PyObject *tmp_globals_name_8;
        PyObject *tmp_locals_name_8;
        PyObject *tmp_fromlist_name_8;
        tmp_name_name_8 = const_str_digest_8b0e1374dcc590bdb16ac8ec2446b5d1;
        tmp_globals_name_8 = (PyObject *)moduledict_OpenSSL$SSL;
        tmp_locals_name_8 = Py_None;
        tmp_fromlist_name_8 = const_tuple_str_plain_deprecated_tuple;
        frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e->m_frame.f_lineno = 9;
        tmp_import_name_from_8 = IMPORT_MODULE4(tmp_name_name_8, tmp_globals_name_8, tmp_locals_name_8, tmp_fromlist_name_8);
        if (tmp_import_name_from_8 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 9;

            goto frame_exception_exit_1;
        }
        tmp_assign_source_14 = IMPORT_NAME(tmp_import_name_from_8, const_str_plain_deprecated);
        Py_DECREF(tmp_import_name_from_8);
        if (tmp_assign_source_14 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 9;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_deprecated, tmp_assign_source_14);
    }
    {
        PyObject *tmp_assign_source_15;
        PyObject *tmp_name_name_9;
        PyObject *tmp_globals_name_9;
        PyObject *tmp_locals_name_9;
        PyObject *tmp_fromlist_name_9;
        tmp_name_name_9 = const_str_plain_six;
        tmp_globals_name_9 = (PyObject *)moduledict_OpenSSL$SSL;
        tmp_locals_name_9 = Py_None;
        tmp_fromlist_name_9 = const_tuple_26498c7c65e3c1d61715bb934548919d_tuple;
        frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e->m_frame.f_lineno = 11;
        tmp_assign_source_15 = IMPORT_MODULE4(tmp_name_name_9, tmp_globals_name_9, tmp_locals_name_9, tmp_fromlist_name_9);
        if (tmp_assign_source_15 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 11;

            goto frame_exception_exit_1;
        }
        assert(tmp_import_from_3__module == NULL);
        tmp_import_from_3__module = tmp_assign_source_15;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_16;
        PyObject *tmp_import_name_from_9;
        CHECK_OBJECT(tmp_import_from_3__module);
        tmp_import_name_from_9 = tmp_import_from_3__module;
        tmp_assign_source_16 = IMPORT_NAME(tmp_import_name_from_9, const_str_plain_binary_type);
        if (tmp_assign_source_16 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 11;

            goto try_except_handler_2;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__binary_type, tmp_assign_source_16);
    }
    {
        PyObject *tmp_assign_source_17;
        PyObject *tmp_import_name_from_10;
        CHECK_OBJECT(tmp_import_from_3__module);
        tmp_import_name_from_10 = tmp_import_from_3__module;
        tmp_assign_source_17 = IMPORT_NAME(tmp_import_name_from_10, const_str_plain_integer_types);
        if (tmp_assign_source_17 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 11;

            goto try_except_handler_2;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types, tmp_assign_source_17);
    }
    {
        PyObject *tmp_assign_source_18;
        PyObject *tmp_import_name_from_11;
        CHECK_OBJECT(tmp_import_from_3__module);
        tmp_import_name_from_11 = tmp_import_from_3__module;
        tmp_assign_source_18 = IMPORT_NAME(tmp_import_name_from_11, const_str_plain_int2byte);
        if (tmp_assign_source_18 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 11;

            goto try_except_handler_2;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_int2byte, tmp_assign_source_18);
    }
    {
        PyObject *tmp_assign_source_19;
        PyObject *tmp_import_name_from_12;
        CHECK_OBJECT(tmp_import_from_3__module);
        tmp_import_name_from_12 = tmp_import_from_3__module;
        tmp_assign_source_19 = IMPORT_NAME(tmp_import_name_from_12, const_str_plain_indexbytes);
        if (tmp_assign_source_19 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 11;

            goto try_except_handler_2;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_indexbytes, tmp_assign_source_19);
    }
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)tmp_import_from_3__module);
    Py_DECREF(tmp_import_from_3__module);
    tmp_import_from_3__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    CHECK_OBJECT((PyObject *)tmp_import_from_3__module);
    Py_DECREF(tmp_import_from_3__module);
    tmp_import_from_3__module = NULL;

    {
        PyObject *tmp_assign_source_20;
        PyObject *tmp_name_name_10;
        PyObject *tmp_globals_name_10;
        PyObject *tmp_locals_name_10;
        PyObject *tmp_fromlist_name_10;
        tmp_name_name_10 = const_str_digest_2c0accc407028fbaba46fefdee9c6c06;
        tmp_globals_name_10 = (PyObject *)moduledict_OpenSSL$SSL;
        tmp_locals_name_10 = Py_None;
        tmp_fromlist_name_10 = const_tuple_87f1641fb31961ccfc03a99691482662_tuple;
        frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e->m_frame.f_lineno = 15;
        tmp_assign_source_20 = IMPORT_MODULE4(tmp_name_name_10, tmp_globals_name_10, tmp_locals_name_10, tmp_fromlist_name_10);
        if (tmp_assign_source_20 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 15;

            goto frame_exception_exit_1;
        }
        assert(tmp_import_from_4__module == NULL);
        tmp_import_from_4__module = tmp_assign_source_20;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_21;
        PyObject *tmp_import_name_from_13;
        CHECK_OBJECT(tmp_import_from_4__module);
        tmp_import_name_from_13 = tmp_import_from_4__module;
        tmp_assign_source_21 = IMPORT_NAME(tmp_import_name_from_13, const_str_plain_UNSPECIFIED);
        if (tmp_assign_source_21 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 15;

            goto try_except_handler_3;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__UNSPECIFIED, tmp_assign_source_21);
    }
    {
        PyObject *tmp_assign_source_22;
        PyObject *tmp_import_name_from_14;
        CHECK_OBJECT(tmp_import_from_4__module);
        tmp_import_name_from_14 = tmp_import_from_4__module;
        tmp_assign_source_22 = IMPORT_NAME(tmp_import_name_from_14, const_str_plain_exception_from_error_queue);
        if (tmp_assign_source_22 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 15;

            goto try_except_handler_3;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__exception_from_error_queue, tmp_assign_source_22);
    }
    {
        PyObject *tmp_assign_source_23;
        PyObject *tmp_import_name_from_15;
        CHECK_OBJECT(tmp_import_from_4__module);
        tmp_import_name_from_15 = tmp_import_from_4__module;
        tmp_assign_source_23 = IMPORT_NAME(tmp_import_name_from_15, const_str_plain_ffi);
        if (tmp_assign_source_23 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 15;

            goto try_except_handler_3;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi, tmp_assign_source_23);
    }
    {
        PyObject *tmp_assign_source_24;
        PyObject *tmp_import_name_from_16;
        CHECK_OBJECT(tmp_import_from_4__module);
        tmp_import_name_from_16 = tmp_import_from_4__module;
        tmp_assign_source_24 = IMPORT_NAME(tmp_import_name_from_16, const_str_plain_lib);
        if (tmp_assign_source_24 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 15;

            goto try_except_handler_3;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib, tmp_assign_source_24);
    }
    {
        PyObject *tmp_assign_source_25;
        PyObject *tmp_import_name_from_17;
        CHECK_OBJECT(tmp_import_from_4__module);
        tmp_import_name_from_17 = tmp_import_from_4__module;
        tmp_assign_source_25 = IMPORT_NAME(tmp_import_name_from_17, const_str_plain_make_assert);
        if (tmp_assign_source_25 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 15;

            goto try_except_handler_3;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__make_assert, tmp_assign_source_25);
    }
    {
        PyObject *tmp_assign_source_26;
        PyObject *tmp_import_name_from_18;
        CHECK_OBJECT(tmp_import_from_4__module);
        tmp_import_name_from_18 = tmp_import_from_4__module;
        tmp_assign_source_26 = IMPORT_NAME(tmp_import_name_from_18, const_str_plain_native);
        if (tmp_assign_source_26 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 15;

            goto try_except_handler_3;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__native, tmp_assign_source_26);
    }
    {
        PyObject *tmp_assign_source_27;
        PyObject *tmp_import_name_from_19;
        CHECK_OBJECT(tmp_import_from_4__module);
        tmp_import_name_from_19 = tmp_import_from_4__module;
        tmp_assign_source_27 = IMPORT_NAME(tmp_import_name_from_19, const_str_plain_path_string);
        if (tmp_assign_source_27 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 15;

            goto try_except_handler_3;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__path_string, tmp_assign_source_27);
    }
    {
        PyObject *tmp_assign_source_28;
        PyObject *tmp_import_name_from_20;
        CHECK_OBJECT(tmp_import_from_4__module);
        tmp_import_name_from_20 = tmp_import_from_4__module;
        tmp_assign_source_28 = IMPORT_NAME(tmp_import_name_from_20, const_str_plain_text_to_bytes_and_warn);
        if (tmp_assign_source_28 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 15;

            goto try_except_handler_3;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn, tmp_assign_source_28);
    }
    {
        PyObject *tmp_assign_source_29;
        PyObject *tmp_import_name_from_21;
        CHECK_OBJECT(tmp_import_from_4__module);
        tmp_import_name_from_21 = tmp_import_from_4__module;
        tmp_assign_source_29 = IMPORT_NAME(tmp_import_name_from_21, const_str_plain_no_zero_allocator);
        if (tmp_assign_source_29 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 15;

            goto try_except_handler_3;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__no_zero_allocator, tmp_assign_source_29);
    }
    goto try_end_3;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)tmp_import_from_4__module);
    Py_DECREF(tmp_import_from_4__module);
    tmp_import_from_4__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;
    CHECK_OBJECT((PyObject *)tmp_import_from_4__module);
    Py_DECREF(tmp_import_from_4__module);
    tmp_import_from_4__module = NULL;

    {
        PyObject *tmp_assign_source_30;
        PyObject *tmp_name_name_11;
        PyObject *tmp_globals_name_11;
        PyObject *tmp_locals_name_11;
        PyObject *tmp_fromlist_name_11;
        tmp_name_name_11 = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
        tmp_globals_name_11 = (PyObject *)moduledict_OpenSSL$SSL;
        tmp_locals_name_11 = Py_None;
        tmp_fromlist_name_11 = const_tuple_c21a4bcc0d9dac830f44bc0c201bf7fd_tuple;
        frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e->m_frame.f_lineno = 27;
        tmp_assign_source_30 = IMPORT_MODULE4(tmp_name_name_11, tmp_globals_name_11, tmp_locals_name_11, tmp_fromlist_name_11);
        if (tmp_assign_source_30 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 27;

            goto frame_exception_exit_1;
        }
        assert(tmp_import_from_5__module == NULL);
        tmp_import_from_5__module = tmp_assign_source_30;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_31;
        PyObject *tmp_import_name_from_22;
        CHECK_OBJECT(tmp_import_from_5__module);
        tmp_import_name_from_22 = tmp_import_from_5__module;
        tmp_assign_source_31 = IMPORT_NAME(tmp_import_name_from_22, const_str_plain_FILETYPE_PEM);
        if (tmp_assign_source_31 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 27;

            goto try_except_handler_4;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM, tmp_assign_source_31);
    }
    {
        PyObject *tmp_assign_source_32;
        PyObject *tmp_import_name_from_23;
        CHECK_OBJECT(tmp_import_from_5__module);
        tmp_import_name_from_23 = tmp_import_from_5__module;
        tmp_assign_source_32 = IMPORT_NAME(tmp_import_name_from_23, const_str_plain__PassphraseHelper);
        if (tmp_assign_source_32 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 27;

            goto try_except_handler_4;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__PassphraseHelper, tmp_assign_source_32);
    }
    {
        PyObject *tmp_assign_source_33;
        PyObject *tmp_import_name_from_24;
        CHECK_OBJECT(tmp_import_from_5__module);
        tmp_import_name_from_24 = tmp_import_from_5__module;
        tmp_assign_source_33 = IMPORT_NAME(tmp_import_name_from_24, const_str_plain_PKey);
        if (tmp_assign_source_33 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 27;

            goto try_except_handler_4;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_PKey, tmp_assign_source_33);
    }
    {
        PyObject *tmp_assign_source_34;
        PyObject *tmp_import_name_from_25;
        CHECK_OBJECT(tmp_import_from_5__module);
        tmp_import_name_from_25 = tmp_import_from_5__module;
        tmp_assign_source_34 = IMPORT_NAME(tmp_import_name_from_25, const_str_plain_X509Name);
        if (tmp_assign_source_34 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 27;

            goto try_except_handler_4;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509Name, tmp_assign_source_34);
    }
    {
        PyObject *tmp_assign_source_35;
        PyObject *tmp_import_name_from_26;
        CHECK_OBJECT(tmp_import_from_5__module);
        tmp_import_name_from_26 = tmp_import_from_5__module;
        tmp_assign_source_35 = IMPORT_NAME(tmp_import_name_from_26, const_str_plain_X509);
        if (tmp_assign_source_35 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 27;

            goto try_except_handler_4;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509, tmp_assign_source_35);
    }
    {
        PyObject *tmp_assign_source_36;
        PyObject *tmp_import_name_from_27;
        CHECK_OBJECT(tmp_import_from_5__module);
        tmp_import_name_from_27 = tmp_import_from_5__module;
        tmp_assign_source_36 = IMPORT_NAME(tmp_import_name_from_27, const_str_plain_X509Store);
        if (tmp_assign_source_36 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 27;

            goto try_except_handler_4;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509Store, tmp_assign_source_36);
    }
    goto try_end_4;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)tmp_import_from_5__module);
    Py_DECREF(tmp_import_from_5__module);
    tmp_import_from_5__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto frame_exception_exit_1;
    // End of try:
    try_end_4:;
    CHECK_OBJECT((PyObject *)tmp_import_from_5__module);
    Py_DECREF(tmp_import_from_5__module);
    tmp_import_from_5__module = NULL;

    {
        PyObject *tmp_assign_source_37;
        tmp_assign_source_37 = LIST_COPY(const_list_3507872b18f9d5cd646e67697ec96e56_list);
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain___all__, tmp_assign_source_37);
    }
    {
        PyObject *tmp_assign_source_38;
        tmp_assign_source_38 = (PyObject *)&PyBuffer_Type;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__buffer, tmp_assign_source_38);
    }
    {
        PyObject *tmp_assign_source_39;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 121;

            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_assign_source_39 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_OPENSSL_VERSION_NUMBER);
        if (tmp_assign_source_39 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 121;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OPENSSL_VERSION_NUMBER, tmp_assign_source_39);
    }
    {
        PyObject *tmp_assign_source_40;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 122;

            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_assign_source_40 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_SSLEAY_VERSION);
        if (tmp_assign_source_40 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 122;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSLEAY_VERSION, tmp_assign_source_40);
    }
    {
        PyObject *tmp_assign_source_41;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_3;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 123;

            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_3;
        tmp_assign_source_41 = LOOKUP_ATTRIBUTE(tmp_source_name_3, const_str_plain_SSLEAY_CFLAGS);
        if (tmp_assign_source_41 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 123;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSLEAY_CFLAGS, tmp_assign_source_41);
    }
    {
        PyObject *tmp_assign_source_42;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_4;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 124;

            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_4;
        tmp_assign_source_42 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain_SSLEAY_PLATFORM);
        if (tmp_assign_source_42 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 124;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSLEAY_PLATFORM, tmp_assign_source_42);
    }
    {
        PyObject *tmp_assign_source_43;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_5;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 125;

            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_5;
        tmp_assign_source_43 = LOOKUP_ATTRIBUTE(tmp_source_name_5, const_str_plain_SSLEAY_DIR);
        if (tmp_assign_source_43 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 125;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSLEAY_DIR, tmp_assign_source_43);
    }
    {
        PyObject *tmp_assign_source_44;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_6;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_6 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 126;

            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_6;
        tmp_assign_source_44 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain_SSLEAY_BUILT_ON);
        if (tmp_assign_source_44 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 126;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSLEAY_BUILT_ON, tmp_assign_source_44);
    }
    {
        PyObject *tmp_assign_source_45;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_7;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_7 == NULL)) {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_7 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 128;

            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = tmp_mvar_value_7;
        tmp_assign_source_45 = LOOKUP_ATTRIBUTE(tmp_source_name_7, const_str_plain_SSL_SENT_SHUTDOWN);
        if (tmp_assign_source_45 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 128;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SENT_SHUTDOWN, tmp_assign_source_45);
    }
    {
        PyObject *tmp_assign_source_46;
        PyObject *tmp_source_name_8;
        PyObject *tmp_mvar_value_8;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_8 == NULL)) {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_8 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 129;

            goto frame_exception_exit_1;
        }

        tmp_source_name_8 = tmp_mvar_value_8;
        tmp_assign_source_46 = LOOKUP_ATTRIBUTE(tmp_source_name_8, const_str_plain_SSL_RECEIVED_SHUTDOWN);
        if (tmp_assign_source_46 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 129;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_RECEIVED_SHUTDOWN, tmp_assign_source_46);
    }
    {
        PyObject *tmp_assign_source_47;
        tmp_assign_source_47 = const_int_pos_1;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSLv2_METHOD, tmp_assign_source_47);
    }
    {
        PyObject *tmp_assign_source_48;
        tmp_assign_source_48 = const_int_pos_2;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSLv3_METHOD, tmp_assign_source_48);
    }
    {
        PyObject *tmp_assign_source_49;
        tmp_assign_source_49 = const_int_pos_3;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSLv23_METHOD, tmp_assign_source_49);
    }
    {
        PyObject *tmp_assign_source_50;
        tmp_assign_source_50 = const_int_pos_4;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_TLSv1_METHOD, tmp_assign_source_50);
    }
    {
        PyObject *tmp_assign_source_51;
        tmp_assign_source_51 = const_int_pos_5;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_TLSv1_1_METHOD, tmp_assign_source_51);
    }
    {
        PyObject *tmp_assign_source_52;
        tmp_assign_source_52 = const_int_pos_6;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_TLSv1_2_METHOD, tmp_assign_source_52);
    }
    {
        PyObject *tmp_assign_source_53;
        PyObject *tmp_source_name_9;
        PyObject *tmp_mvar_value_9;
        tmp_mvar_value_9 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_9 == NULL)) {
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_9 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 138;

            goto frame_exception_exit_1;
        }

        tmp_source_name_9 = tmp_mvar_value_9;
        tmp_assign_source_53 = LOOKUP_ATTRIBUTE(tmp_source_name_9, const_str_plain_SSL_OP_NO_SSLv2);
        if (tmp_assign_source_53 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 138;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_NO_SSLv2, tmp_assign_source_53);
    }
    {
        PyObject *tmp_assign_source_54;
        PyObject *tmp_source_name_10;
        PyObject *tmp_mvar_value_10;
        tmp_mvar_value_10 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_10 == NULL)) {
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_10 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 139;

            goto frame_exception_exit_1;
        }

        tmp_source_name_10 = tmp_mvar_value_10;
        tmp_assign_source_54 = LOOKUP_ATTRIBUTE(tmp_source_name_10, const_str_plain_SSL_OP_NO_SSLv3);
        if (tmp_assign_source_54 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 139;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_NO_SSLv3, tmp_assign_source_54);
    }
    {
        PyObject *tmp_assign_source_55;
        PyObject *tmp_source_name_11;
        PyObject *tmp_mvar_value_11;
        tmp_mvar_value_11 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_11 == NULL)) {
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_11 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 140;

            goto frame_exception_exit_1;
        }

        tmp_source_name_11 = tmp_mvar_value_11;
        tmp_assign_source_55 = LOOKUP_ATTRIBUTE(tmp_source_name_11, const_str_plain_SSL_OP_NO_TLSv1);
        if (tmp_assign_source_55 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 140;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_NO_TLSv1, tmp_assign_source_55);
    }
    {
        PyObject *tmp_assign_source_56;
        PyObject *tmp_source_name_12;
        PyObject *tmp_mvar_value_12;
        tmp_mvar_value_12 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_12 == NULL)) {
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_12 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 141;

            goto frame_exception_exit_1;
        }

        tmp_source_name_12 = tmp_mvar_value_12;
        tmp_assign_source_56 = LOOKUP_ATTRIBUTE(tmp_source_name_12, const_str_plain_SSL_OP_NO_TLSv1_1);
        if (tmp_assign_source_56 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 141;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_NO_TLSv1_1, tmp_assign_source_56);
    }
    {
        PyObject *tmp_assign_source_57;
        PyObject *tmp_source_name_13;
        PyObject *tmp_mvar_value_13;
        tmp_mvar_value_13 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_13 == NULL)) {
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_13 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 142;

            goto frame_exception_exit_1;
        }

        tmp_source_name_13 = tmp_mvar_value_13;
        tmp_assign_source_57 = LOOKUP_ATTRIBUTE(tmp_source_name_13, const_str_plain_SSL_OP_NO_TLSv1_2);
        if (tmp_assign_source_57 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 142;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_NO_TLSv1_2, tmp_assign_source_57);
    }
    {
        PyObject *tmp_assign_source_58;
        PyObject *tmp_source_name_14;
        PyObject *tmp_mvar_value_14;
        tmp_mvar_value_14 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_14 == NULL)) {
            tmp_mvar_value_14 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_14 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 144;

            goto frame_exception_exit_1;
        }

        tmp_source_name_14 = tmp_mvar_value_14;
        tmp_assign_source_58 = LOOKUP_ATTRIBUTE(tmp_source_name_14, const_str_plain_SSL_MODE_RELEASE_BUFFERS);
        if (tmp_assign_source_58 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 144;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_MODE_RELEASE_BUFFERS, tmp_assign_source_58);
    }
    {
        PyObject *tmp_assign_source_59;
        PyObject *tmp_source_name_15;
        PyObject *tmp_mvar_value_15;
        tmp_mvar_value_15 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_15 == NULL)) {
            tmp_mvar_value_15 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_15 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 146;

            goto frame_exception_exit_1;
        }

        tmp_source_name_15 = tmp_mvar_value_15;
        tmp_assign_source_59 = LOOKUP_ATTRIBUTE(tmp_source_name_15, const_str_plain_SSL_OP_SINGLE_DH_USE);
        if (tmp_assign_source_59 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 146;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_SINGLE_DH_USE, tmp_assign_source_59);
    }
    {
        PyObject *tmp_assign_source_60;
        PyObject *tmp_source_name_16;
        PyObject *tmp_mvar_value_16;
        tmp_mvar_value_16 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_16 == NULL)) {
            tmp_mvar_value_16 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_16 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 147;

            goto frame_exception_exit_1;
        }

        tmp_source_name_16 = tmp_mvar_value_16;
        tmp_assign_source_60 = LOOKUP_ATTRIBUTE(tmp_source_name_16, const_str_plain_SSL_OP_SINGLE_ECDH_USE);
        if (tmp_assign_source_60 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 147;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_SINGLE_ECDH_USE, tmp_assign_source_60);
    }
    {
        PyObject *tmp_assign_source_61;
        PyObject *tmp_source_name_17;
        PyObject *tmp_mvar_value_17;
        tmp_mvar_value_17 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_17 == NULL)) {
            tmp_mvar_value_17 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_17 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 148;

            goto frame_exception_exit_1;
        }

        tmp_source_name_17 = tmp_mvar_value_17;
        tmp_assign_source_61 = LOOKUP_ATTRIBUTE(tmp_source_name_17, const_str_plain_SSL_OP_EPHEMERAL_RSA);
        if (tmp_assign_source_61 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 148;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_EPHEMERAL_RSA, tmp_assign_source_61);
    }
    {
        PyObject *tmp_assign_source_62;
        PyObject *tmp_source_name_18;
        PyObject *tmp_mvar_value_18;
        tmp_mvar_value_18 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_18 == NULL)) {
            tmp_mvar_value_18 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_18 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 149;

            goto frame_exception_exit_1;
        }

        tmp_source_name_18 = tmp_mvar_value_18;
        tmp_assign_source_62 = LOOKUP_ATTRIBUTE(tmp_source_name_18, const_str_plain_SSL_OP_MICROSOFT_SESS_ID_BUG);
        if (tmp_assign_source_62 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 149;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_MICROSOFT_SESS_ID_BUG, tmp_assign_source_62);
    }
    {
        PyObject *tmp_assign_source_63;
        PyObject *tmp_source_name_19;
        PyObject *tmp_mvar_value_19;
        tmp_mvar_value_19 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_19 == NULL)) {
            tmp_mvar_value_19 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_19 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 150;

            goto frame_exception_exit_1;
        }

        tmp_source_name_19 = tmp_mvar_value_19;
        tmp_assign_source_63 = LOOKUP_ATTRIBUTE(tmp_source_name_19, const_str_plain_SSL_OP_NETSCAPE_CHALLENGE_BUG);
        if (tmp_assign_source_63 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 150;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_NETSCAPE_CHALLENGE_BUG, tmp_assign_source_63);
    }
    {
        PyObject *tmp_assign_source_64;
        PyObject *tmp_source_name_20;
        PyObject *tmp_mvar_value_20;
        tmp_mvar_value_20 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_20 == NULL)) {
            tmp_mvar_value_20 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_20 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 152;

            goto frame_exception_exit_1;
        }

        tmp_source_name_20 = tmp_mvar_value_20;
        tmp_assign_source_64 = LOOKUP_ATTRIBUTE(tmp_source_name_20, const_str_plain_SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG);
        if (tmp_assign_source_64 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 152;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG, tmp_assign_source_64);
    }
    {
        PyObject *tmp_assign_source_65;
        PyObject *tmp_source_name_21;
        PyObject *tmp_mvar_value_21;
        tmp_mvar_value_21 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_21 == NULL)) {
            tmp_mvar_value_21 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_21 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 154;

            goto frame_exception_exit_1;
        }

        tmp_source_name_21 = tmp_mvar_value_21;
        tmp_assign_source_65 = LOOKUP_ATTRIBUTE(tmp_source_name_21, const_str_plain_SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG);
        if (tmp_assign_source_65 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 154;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_SSLREF2_REUSE_CERT_TYPE_BUG, tmp_assign_source_65);
    }
    {
        PyObject *tmp_assign_source_66;
        PyObject *tmp_source_name_22;
        PyObject *tmp_mvar_value_22;
        tmp_mvar_value_22 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_22 == NULL)) {
            tmp_mvar_value_22 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_22 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 155;

            goto frame_exception_exit_1;
        }

        tmp_source_name_22 = tmp_mvar_value_22;
        tmp_assign_source_66 = LOOKUP_ATTRIBUTE(tmp_source_name_22, const_str_plain_SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER);
        if (tmp_assign_source_66 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 155;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_MICROSOFT_BIG_SSLV3_BUFFER, tmp_assign_source_66);
    }
    {
        PyObject *tmp_assign_source_67;
        PyObject *tmp_source_name_23;
        PyObject *tmp_mvar_value_23;
        tmp_mvar_value_23 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_23 == NULL)) {
            tmp_mvar_value_23 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_23 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 156;

            goto frame_exception_exit_1;
        }

        tmp_source_name_23 = tmp_mvar_value_23;
        tmp_assign_source_67 = LOOKUP_ATTRIBUTE(tmp_source_name_23, const_str_plain_SSL_OP_MSIE_SSLV2_RSA_PADDING);
        if (tmp_assign_source_67 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 156;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_MSIE_SSLV2_RSA_PADDING, tmp_assign_source_67);
    }
    {
        PyObject *tmp_assign_source_68;
        PyObject *tmp_source_name_24;
        PyObject *tmp_mvar_value_24;
        tmp_mvar_value_24 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_24 == NULL)) {
            tmp_mvar_value_24 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_24 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 157;

            goto frame_exception_exit_1;
        }

        tmp_source_name_24 = tmp_mvar_value_24;
        tmp_assign_source_68 = LOOKUP_ATTRIBUTE(tmp_source_name_24, const_str_plain_SSL_OP_SSLEAY_080_CLIENT_DH_BUG);
        if (tmp_assign_source_68 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 157;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_SSLEAY_080_CLIENT_DH_BUG, tmp_assign_source_68);
    }
    {
        PyObject *tmp_assign_source_69;
        PyObject *tmp_source_name_25;
        PyObject *tmp_mvar_value_25;
        tmp_mvar_value_25 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_25 == NULL)) {
            tmp_mvar_value_25 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_25 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 158;

            goto frame_exception_exit_1;
        }

        tmp_source_name_25 = tmp_mvar_value_25;
        tmp_assign_source_69 = LOOKUP_ATTRIBUTE(tmp_source_name_25, const_str_plain_SSL_OP_TLS_D5_BUG);
        if (tmp_assign_source_69 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 158;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_TLS_D5_BUG, tmp_assign_source_69);
    }
    {
        PyObject *tmp_assign_source_70;
        PyObject *tmp_source_name_26;
        PyObject *tmp_mvar_value_26;
        tmp_mvar_value_26 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_26 == NULL)) {
            tmp_mvar_value_26 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_26 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 159;

            goto frame_exception_exit_1;
        }

        tmp_source_name_26 = tmp_mvar_value_26;
        tmp_assign_source_70 = LOOKUP_ATTRIBUTE(tmp_source_name_26, const_str_plain_SSL_OP_TLS_BLOCK_PADDING_BUG);
        if (tmp_assign_source_70 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 159;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_TLS_BLOCK_PADDING_BUG, tmp_assign_source_70);
    }
    {
        PyObject *tmp_assign_source_71;
        PyObject *tmp_source_name_27;
        PyObject *tmp_mvar_value_27;
        tmp_mvar_value_27 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_27 == NULL)) {
            tmp_mvar_value_27 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_27 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 160;

            goto frame_exception_exit_1;
        }

        tmp_source_name_27 = tmp_mvar_value_27;
        tmp_assign_source_71 = LOOKUP_ATTRIBUTE(tmp_source_name_27, const_str_plain_SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS);
        if (tmp_assign_source_71 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 160;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_DONT_INSERT_EMPTY_FRAGMENTS, tmp_assign_source_71);
    }
    {
        PyObject *tmp_assign_source_72;
        PyObject *tmp_source_name_28;
        PyObject *tmp_mvar_value_28;
        tmp_mvar_value_28 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_28 == NULL)) {
            tmp_mvar_value_28 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_28 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 161;

            goto frame_exception_exit_1;
        }

        tmp_source_name_28 = tmp_mvar_value_28;
        tmp_assign_source_72 = LOOKUP_ATTRIBUTE(tmp_source_name_28, const_str_plain_SSL_OP_CIPHER_SERVER_PREFERENCE);
        if (tmp_assign_source_72 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 161;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_CIPHER_SERVER_PREFERENCE, tmp_assign_source_72);
    }
    {
        PyObject *tmp_assign_source_73;
        PyObject *tmp_source_name_29;
        PyObject *tmp_mvar_value_29;
        tmp_mvar_value_29 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_29 == NULL)) {
            tmp_mvar_value_29 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_29 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 162;

            goto frame_exception_exit_1;
        }

        tmp_source_name_29 = tmp_mvar_value_29;
        tmp_assign_source_73 = LOOKUP_ATTRIBUTE(tmp_source_name_29, const_str_plain_SSL_OP_TLS_ROLLBACK_BUG);
        if (tmp_assign_source_73 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 162;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_TLS_ROLLBACK_BUG, tmp_assign_source_73);
    }
    {
        PyObject *tmp_assign_source_74;
        PyObject *tmp_source_name_30;
        PyObject *tmp_mvar_value_30;
        tmp_mvar_value_30 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_30 == NULL)) {
            tmp_mvar_value_30 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_30 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 163;

            goto frame_exception_exit_1;
        }

        tmp_source_name_30 = tmp_mvar_value_30;
        tmp_assign_source_74 = LOOKUP_ATTRIBUTE(tmp_source_name_30, const_str_plain_SSL_OP_PKCS1_CHECK_1);
        if (tmp_assign_source_74 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 163;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_PKCS1_CHECK_1, tmp_assign_source_74);
    }
    {
        PyObject *tmp_assign_source_75;
        PyObject *tmp_source_name_31;
        PyObject *tmp_mvar_value_31;
        tmp_mvar_value_31 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_31 == NULL)) {
            tmp_mvar_value_31 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_31 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 164;

            goto frame_exception_exit_1;
        }

        tmp_source_name_31 = tmp_mvar_value_31;
        tmp_assign_source_75 = LOOKUP_ATTRIBUTE(tmp_source_name_31, const_str_plain_SSL_OP_PKCS1_CHECK_2);
        if (tmp_assign_source_75 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 164;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_PKCS1_CHECK_2, tmp_assign_source_75);
    }
    {
        PyObject *tmp_assign_source_76;
        PyObject *tmp_source_name_32;
        PyObject *tmp_mvar_value_32;
        tmp_mvar_value_32 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_32 == NULL)) {
            tmp_mvar_value_32 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_32 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 165;

            goto frame_exception_exit_1;
        }

        tmp_source_name_32 = tmp_mvar_value_32;
        tmp_assign_source_76 = LOOKUP_ATTRIBUTE(tmp_source_name_32, const_str_plain_SSL_OP_NETSCAPE_CA_DN_BUG);
        if (tmp_assign_source_76 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 165;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_NETSCAPE_CA_DN_BUG, tmp_assign_source_76);
    }
    {
        PyObject *tmp_assign_source_77;
        PyObject *tmp_source_name_33;
        PyObject *tmp_mvar_value_33;
        tmp_mvar_value_33 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_33 == NULL)) {
            tmp_mvar_value_33 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_33 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 167;

            goto frame_exception_exit_1;
        }

        tmp_source_name_33 = tmp_mvar_value_33;
        tmp_assign_source_77 = LOOKUP_ATTRIBUTE(tmp_source_name_33, const_str_plain_SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG);
        if (tmp_assign_source_77 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 167;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG, tmp_assign_source_77);
    }
    {
        PyObject *tmp_assign_source_78;
        PyObject *tmp_source_name_34;
        PyObject *tmp_mvar_value_34;
        tmp_mvar_value_34 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_34 == NULL)) {
            tmp_mvar_value_34 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_34 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 169;

            goto frame_exception_exit_1;
        }

        tmp_source_name_34 = tmp_mvar_value_34;
        tmp_assign_source_78 = LOOKUP_ATTRIBUTE(tmp_source_name_34, const_str_plain_SSL_OP_NO_COMPRESSION);
        if (tmp_assign_source_78 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 169;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_NO_COMPRESSION, tmp_assign_source_78);
    }
    {
        PyObject *tmp_assign_source_79;
        PyObject *tmp_source_name_35;
        PyObject *tmp_mvar_value_35;
        tmp_mvar_value_35 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_35 == NULL)) {
            tmp_mvar_value_35 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_35 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 171;

            goto frame_exception_exit_1;
        }

        tmp_source_name_35 = tmp_mvar_value_35;
        tmp_assign_source_79 = LOOKUP_ATTRIBUTE(tmp_source_name_35, const_str_plain_SSL_OP_NO_QUERY_MTU);
        if (tmp_assign_source_79 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 171;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_NO_QUERY_MTU, tmp_assign_source_79);
    }
    {
        PyObject *tmp_assign_source_80;
        PyObject *tmp_source_name_36;
        PyObject *tmp_mvar_value_36;
        tmp_mvar_value_36 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_36 == NULL)) {
            tmp_mvar_value_36 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_36 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 172;

            goto frame_exception_exit_1;
        }

        tmp_source_name_36 = tmp_mvar_value_36;
        tmp_assign_source_80 = LOOKUP_ATTRIBUTE(tmp_source_name_36, const_str_plain_SSL_OP_COOKIE_EXCHANGE);
        if (tmp_assign_source_80 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 172;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_COOKIE_EXCHANGE, tmp_assign_source_80);
    }
    {
        PyObject *tmp_assign_source_81;
        PyObject *tmp_source_name_37;
        PyObject *tmp_mvar_value_37;
        tmp_mvar_value_37 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_37 == NULL)) {
            tmp_mvar_value_37 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_37 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 173;

            goto frame_exception_exit_1;
        }

        tmp_source_name_37 = tmp_mvar_value_37;
        tmp_assign_source_81 = LOOKUP_ATTRIBUTE(tmp_source_name_37, const_str_plain_SSL_OP_NO_TICKET);
        if (tmp_assign_source_81 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 173;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_NO_TICKET, tmp_assign_source_81);
    }
    {
        PyObject *tmp_assign_source_82;
        PyObject *tmp_source_name_38;
        PyObject *tmp_mvar_value_38;
        tmp_mvar_value_38 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_38 == NULL)) {
            tmp_mvar_value_38 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_38 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 175;

            goto frame_exception_exit_1;
        }

        tmp_source_name_38 = tmp_mvar_value_38;
        tmp_assign_source_82 = LOOKUP_ATTRIBUTE(tmp_source_name_38, const_str_plain_SSL_OP_ALL);
        if (tmp_assign_source_82 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 175;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_ALL, tmp_assign_source_82);
    }
    {
        PyObject *tmp_assign_source_83;
        PyObject *tmp_source_name_39;
        PyObject *tmp_mvar_value_39;
        tmp_mvar_value_39 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_39 == NULL)) {
            tmp_mvar_value_39 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_39 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 177;

            goto frame_exception_exit_1;
        }

        tmp_source_name_39 = tmp_mvar_value_39;
        tmp_assign_source_83 = LOOKUP_ATTRIBUTE(tmp_source_name_39, const_str_plain_SSL_VERIFY_PEER);
        if (tmp_assign_source_83 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 177;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_VERIFY_PEER, tmp_assign_source_83);
    }
    {
        PyObject *tmp_assign_source_84;
        PyObject *tmp_source_name_40;
        PyObject *tmp_mvar_value_40;
        tmp_mvar_value_40 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_40 == NULL)) {
            tmp_mvar_value_40 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_40 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 178;

            goto frame_exception_exit_1;
        }

        tmp_source_name_40 = tmp_mvar_value_40;
        tmp_assign_source_84 = LOOKUP_ATTRIBUTE(tmp_source_name_40, const_str_plain_SSL_VERIFY_FAIL_IF_NO_PEER_CERT);
        if (tmp_assign_source_84 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 178;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_VERIFY_FAIL_IF_NO_PEER_CERT, tmp_assign_source_84);
    }
    {
        PyObject *tmp_assign_source_85;
        PyObject *tmp_source_name_41;
        PyObject *tmp_mvar_value_41;
        tmp_mvar_value_41 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_41 == NULL)) {
            tmp_mvar_value_41 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_41 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 179;

            goto frame_exception_exit_1;
        }

        tmp_source_name_41 = tmp_mvar_value_41;
        tmp_assign_source_85 = LOOKUP_ATTRIBUTE(tmp_source_name_41, const_str_plain_SSL_VERIFY_CLIENT_ONCE);
        if (tmp_assign_source_85 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 179;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_VERIFY_CLIENT_ONCE, tmp_assign_source_85);
    }
    {
        PyObject *tmp_assign_source_86;
        PyObject *tmp_source_name_42;
        PyObject *tmp_mvar_value_42;
        tmp_mvar_value_42 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_42 == NULL)) {
            tmp_mvar_value_42 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_42 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 180;

            goto frame_exception_exit_1;
        }

        tmp_source_name_42 = tmp_mvar_value_42;
        tmp_assign_source_86 = LOOKUP_ATTRIBUTE(tmp_source_name_42, const_str_plain_SSL_VERIFY_NONE);
        if (tmp_assign_source_86 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 180;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_VERIFY_NONE, tmp_assign_source_86);
    }
    {
        PyObject *tmp_assign_source_87;
        PyObject *tmp_source_name_43;
        PyObject *tmp_mvar_value_43;
        tmp_mvar_value_43 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_43 == NULL)) {
            tmp_mvar_value_43 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_43 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 182;

            goto frame_exception_exit_1;
        }

        tmp_source_name_43 = tmp_mvar_value_43;
        tmp_assign_source_87 = LOOKUP_ATTRIBUTE(tmp_source_name_43, const_str_plain_SSL_SESS_CACHE_OFF);
        if (tmp_assign_source_87 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 182;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SESS_CACHE_OFF, tmp_assign_source_87);
    }
    {
        PyObject *tmp_assign_source_88;
        PyObject *tmp_source_name_44;
        PyObject *tmp_mvar_value_44;
        tmp_mvar_value_44 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_44 == NULL)) {
            tmp_mvar_value_44 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_44 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 183;

            goto frame_exception_exit_1;
        }

        tmp_source_name_44 = tmp_mvar_value_44;
        tmp_assign_source_88 = LOOKUP_ATTRIBUTE(tmp_source_name_44, const_str_plain_SSL_SESS_CACHE_CLIENT);
        if (tmp_assign_source_88 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 183;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SESS_CACHE_CLIENT, tmp_assign_source_88);
    }
    {
        PyObject *tmp_assign_source_89;
        PyObject *tmp_source_name_45;
        PyObject *tmp_mvar_value_45;
        tmp_mvar_value_45 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_45 == NULL)) {
            tmp_mvar_value_45 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_45 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 184;

            goto frame_exception_exit_1;
        }

        tmp_source_name_45 = tmp_mvar_value_45;
        tmp_assign_source_89 = LOOKUP_ATTRIBUTE(tmp_source_name_45, const_str_plain_SSL_SESS_CACHE_SERVER);
        if (tmp_assign_source_89 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 184;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SESS_CACHE_SERVER, tmp_assign_source_89);
    }
    {
        PyObject *tmp_assign_source_90;
        PyObject *tmp_source_name_46;
        PyObject *tmp_mvar_value_46;
        tmp_mvar_value_46 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_46 == NULL)) {
            tmp_mvar_value_46 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_46 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 185;

            goto frame_exception_exit_1;
        }

        tmp_source_name_46 = tmp_mvar_value_46;
        tmp_assign_source_90 = LOOKUP_ATTRIBUTE(tmp_source_name_46, const_str_plain_SSL_SESS_CACHE_BOTH);
        if (tmp_assign_source_90 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 185;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SESS_CACHE_BOTH, tmp_assign_source_90);
    }
    {
        PyObject *tmp_assign_source_91;
        PyObject *tmp_source_name_47;
        PyObject *tmp_mvar_value_47;
        tmp_mvar_value_47 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_47 == NULL)) {
            tmp_mvar_value_47 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_47 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 186;

            goto frame_exception_exit_1;
        }

        tmp_source_name_47 = tmp_mvar_value_47;
        tmp_assign_source_91 = LOOKUP_ATTRIBUTE(tmp_source_name_47, const_str_plain_SSL_SESS_CACHE_NO_AUTO_CLEAR);
        if (tmp_assign_source_91 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 186;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SESS_CACHE_NO_AUTO_CLEAR, tmp_assign_source_91);
    }
    {
        PyObject *tmp_assign_source_92;
        PyObject *tmp_source_name_48;
        PyObject *tmp_mvar_value_48;
        tmp_mvar_value_48 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_48 == NULL)) {
            tmp_mvar_value_48 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_48 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 187;

            goto frame_exception_exit_1;
        }

        tmp_source_name_48 = tmp_mvar_value_48;
        tmp_assign_source_92 = LOOKUP_ATTRIBUTE(tmp_source_name_48, const_str_plain_SSL_SESS_CACHE_NO_INTERNAL_LOOKUP);
        if (tmp_assign_source_92 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 187;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SESS_CACHE_NO_INTERNAL_LOOKUP, tmp_assign_source_92);
    }
    {
        PyObject *tmp_assign_source_93;
        PyObject *tmp_source_name_49;
        PyObject *tmp_mvar_value_49;
        tmp_mvar_value_49 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_49 == NULL)) {
            tmp_mvar_value_49 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_49 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 188;

            goto frame_exception_exit_1;
        }

        tmp_source_name_49 = tmp_mvar_value_49;
        tmp_assign_source_93 = LOOKUP_ATTRIBUTE(tmp_source_name_49, const_str_plain_SSL_SESS_CACHE_NO_INTERNAL_STORE);
        if (tmp_assign_source_93 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 188;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SESS_CACHE_NO_INTERNAL_STORE, tmp_assign_source_93);
    }
    {
        PyObject *tmp_assign_source_94;
        PyObject *tmp_source_name_50;
        PyObject *tmp_mvar_value_50;
        tmp_mvar_value_50 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_50 == NULL)) {
            tmp_mvar_value_50 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_50 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 189;

            goto frame_exception_exit_1;
        }

        tmp_source_name_50 = tmp_mvar_value_50;
        tmp_assign_source_94 = LOOKUP_ATTRIBUTE(tmp_source_name_50, const_str_plain_SSL_SESS_CACHE_NO_INTERNAL);
        if (tmp_assign_source_94 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 189;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SESS_CACHE_NO_INTERNAL, tmp_assign_source_94);
    }
    {
        PyObject *tmp_assign_source_95;
        PyObject *tmp_source_name_51;
        PyObject *tmp_mvar_value_51;
        tmp_mvar_value_51 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_51 == NULL)) {
            tmp_mvar_value_51 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_51 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 191;

            goto frame_exception_exit_1;
        }

        tmp_source_name_51 = tmp_mvar_value_51;
        tmp_assign_source_95 = LOOKUP_ATTRIBUTE(tmp_source_name_51, const_str_plain_SSL_ST_CONNECT);
        if (tmp_assign_source_95 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 191;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_ST_CONNECT, tmp_assign_source_95);
    }
    {
        PyObject *tmp_assign_source_96;
        PyObject *tmp_source_name_52;
        PyObject *tmp_mvar_value_52;
        tmp_mvar_value_52 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_52 == NULL)) {
            tmp_mvar_value_52 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_52 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 192;

            goto frame_exception_exit_1;
        }

        tmp_source_name_52 = tmp_mvar_value_52;
        tmp_assign_source_96 = LOOKUP_ATTRIBUTE(tmp_source_name_52, const_str_plain_SSL_ST_ACCEPT);
        if (tmp_assign_source_96 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 192;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_ST_ACCEPT, tmp_assign_source_96);
    }
    {
        PyObject *tmp_assign_source_97;
        PyObject *tmp_source_name_53;
        PyObject *tmp_mvar_value_53;
        tmp_mvar_value_53 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_53 == NULL)) {
            tmp_mvar_value_53 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_53 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 193;

            goto frame_exception_exit_1;
        }

        tmp_source_name_53 = tmp_mvar_value_53;
        tmp_assign_source_97 = LOOKUP_ATTRIBUTE(tmp_source_name_53, const_str_plain_SSL_ST_MASK);
        if (tmp_assign_source_97 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 193;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_ST_MASK, tmp_assign_source_97);
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_source_name_54;
        PyObject *tmp_mvar_value_54;
        PyObject *tmp_attribute_value_1;
        int tmp_truth_name_1;
        tmp_mvar_value_54 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_54 == NULL)) {
            tmp_mvar_value_54 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_54 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 194;

            goto frame_exception_exit_1;
        }

        tmp_source_name_54 = tmp_mvar_value_54;
        tmp_attribute_value_1 = LOOKUP_ATTRIBUTE(tmp_source_name_54, const_str_plain_Cryptography_HAS_SSL_ST);
        if (tmp_attribute_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 194;

            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE(tmp_attribute_value_1);
        if (tmp_truth_name_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_attribute_value_1);

            exception_lineno = 194;

            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_attribute_value_1);
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_98;
            PyObject *tmp_source_name_55;
            PyObject *tmp_mvar_value_55;
            tmp_mvar_value_55 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_55 == NULL)) {
                tmp_mvar_value_55 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_55 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
                exception_tb = NULL;

                exception_lineno = 195;

                goto frame_exception_exit_1;
            }

            tmp_source_name_55 = tmp_mvar_value_55;
            tmp_assign_source_98 = LOOKUP_ATTRIBUTE(tmp_source_name_55, const_str_plain_SSL_ST_INIT);
            if (tmp_assign_source_98 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 195;

                goto frame_exception_exit_1;
            }
            UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_ST_INIT, tmp_assign_source_98);
        }
        {
            PyObject *tmp_assign_source_99;
            PyObject *tmp_source_name_56;
            PyObject *tmp_mvar_value_56;
            tmp_mvar_value_56 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_56 == NULL)) {
                tmp_mvar_value_56 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_56 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
                exception_tb = NULL;

                exception_lineno = 196;

                goto frame_exception_exit_1;
            }

            tmp_source_name_56 = tmp_mvar_value_56;
            tmp_assign_source_99 = LOOKUP_ATTRIBUTE(tmp_source_name_56, const_str_plain_SSL_ST_BEFORE);
            if (tmp_assign_source_99 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 196;

                goto frame_exception_exit_1;
            }
            UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_ST_BEFORE, tmp_assign_source_99);
        }
        {
            PyObject *tmp_assign_source_100;
            PyObject *tmp_source_name_57;
            PyObject *tmp_mvar_value_57;
            tmp_mvar_value_57 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_57 == NULL)) {
                tmp_mvar_value_57 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_57 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
                exception_tb = NULL;

                exception_lineno = 197;

                goto frame_exception_exit_1;
            }

            tmp_source_name_57 = tmp_mvar_value_57;
            tmp_assign_source_100 = LOOKUP_ATTRIBUTE(tmp_source_name_57, const_str_plain_SSL_ST_OK);
            if (tmp_assign_source_100 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 197;

                goto frame_exception_exit_1;
            }
            UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_ST_OK, tmp_assign_source_100);
        }
        {
            PyObject *tmp_assign_source_101;
            PyObject *tmp_source_name_58;
            PyObject *tmp_mvar_value_58;
            tmp_mvar_value_58 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

            if (unlikely(tmp_mvar_value_58 == NULL)) {
                tmp_mvar_value_58 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
            }

            if (tmp_mvar_value_58 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
                exception_tb = NULL;

                exception_lineno = 198;

                goto frame_exception_exit_1;
            }

            tmp_source_name_58 = tmp_mvar_value_58;
            tmp_assign_source_101 = LOOKUP_ATTRIBUTE(tmp_source_name_58, const_str_plain_SSL_ST_RENEGOTIATE);
            if (tmp_assign_source_101 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 198;

                goto frame_exception_exit_1;
            }
            UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_ST_RENEGOTIATE, tmp_assign_source_101);
        }
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_mvar_value_59;
            PyObject *tmp_call_result_1;
            PyObject *tmp_call_arg_element_1;
            tmp_mvar_value_59 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain___all__);

            if (unlikely(tmp_mvar_value_59 == NULL)) {
                tmp_mvar_value_59 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain___all__);
            }

            if (tmp_mvar_value_59 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 2026 ], 29, 0);
                exception_tb = NULL;

                exception_lineno = 199;

                goto frame_exception_exit_1;
            }

            tmp_called_instance_1 = tmp_mvar_value_59;
            tmp_call_arg_element_1 = LIST_COPY(const_list_3574eb54ef4ecf6f2c0597b9df34708e_list);
            frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e->m_frame.f_lineno = 199;
            {
                PyObject *call_args[] = {tmp_call_arg_element_1};
                tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_extend, call_args);
            }

            Py_DECREF(tmp_call_arg_element_1);
            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 199;

                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_1);
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_102;
        PyObject *tmp_source_name_59;
        PyObject *tmp_mvar_value_60;
        tmp_mvar_value_60 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_60 == NULL)) {
            tmp_mvar_value_60 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_60 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 206;

            goto frame_exception_exit_1;
        }

        tmp_source_name_59 = tmp_mvar_value_60;
        tmp_assign_source_102 = LOOKUP_ATTRIBUTE(tmp_source_name_59, const_str_plain_SSL_CB_LOOP);
        if (tmp_assign_source_102 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 206;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_CB_LOOP, tmp_assign_source_102);
    }
    {
        PyObject *tmp_assign_source_103;
        PyObject *tmp_source_name_60;
        PyObject *tmp_mvar_value_61;
        tmp_mvar_value_61 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_61 == NULL)) {
            tmp_mvar_value_61 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_61 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 207;

            goto frame_exception_exit_1;
        }

        tmp_source_name_60 = tmp_mvar_value_61;
        tmp_assign_source_103 = LOOKUP_ATTRIBUTE(tmp_source_name_60, const_str_plain_SSL_CB_EXIT);
        if (tmp_assign_source_103 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 207;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_CB_EXIT, tmp_assign_source_103);
    }
    {
        PyObject *tmp_assign_source_104;
        PyObject *tmp_source_name_61;
        PyObject *tmp_mvar_value_62;
        tmp_mvar_value_62 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_62 == NULL)) {
            tmp_mvar_value_62 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_62 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 208;

            goto frame_exception_exit_1;
        }

        tmp_source_name_61 = tmp_mvar_value_62;
        tmp_assign_source_104 = LOOKUP_ATTRIBUTE(tmp_source_name_61, const_str_plain_SSL_CB_READ);
        if (tmp_assign_source_104 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 208;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_CB_READ, tmp_assign_source_104);
    }
    {
        PyObject *tmp_assign_source_105;
        PyObject *tmp_source_name_62;
        PyObject *tmp_mvar_value_63;
        tmp_mvar_value_63 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_63 == NULL)) {
            tmp_mvar_value_63 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_63 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 209;

            goto frame_exception_exit_1;
        }

        tmp_source_name_62 = tmp_mvar_value_63;
        tmp_assign_source_105 = LOOKUP_ATTRIBUTE(tmp_source_name_62, const_str_plain_SSL_CB_WRITE);
        if (tmp_assign_source_105 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 209;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_CB_WRITE, tmp_assign_source_105);
    }
    {
        PyObject *tmp_assign_source_106;
        PyObject *tmp_source_name_63;
        PyObject *tmp_mvar_value_64;
        tmp_mvar_value_64 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_64 == NULL)) {
            tmp_mvar_value_64 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_64 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 210;

            goto frame_exception_exit_1;
        }

        tmp_source_name_63 = tmp_mvar_value_64;
        tmp_assign_source_106 = LOOKUP_ATTRIBUTE(tmp_source_name_63, const_str_plain_SSL_CB_ALERT);
        if (tmp_assign_source_106 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 210;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_CB_ALERT, tmp_assign_source_106);
    }
    {
        PyObject *tmp_assign_source_107;
        PyObject *tmp_source_name_64;
        PyObject *tmp_mvar_value_65;
        tmp_mvar_value_65 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_65 == NULL)) {
            tmp_mvar_value_65 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_65 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 211;

            goto frame_exception_exit_1;
        }

        tmp_source_name_64 = tmp_mvar_value_65;
        tmp_assign_source_107 = LOOKUP_ATTRIBUTE(tmp_source_name_64, const_str_plain_SSL_CB_READ_ALERT);
        if (tmp_assign_source_107 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 211;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_CB_READ_ALERT, tmp_assign_source_107);
    }
    {
        PyObject *tmp_assign_source_108;
        PyObject *tmp_source_name_65;
        PyObject *tmp_mvar_value_66;
        tmp_mvar_value_66 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_66 == NULL)) {
            tmp_mvar_value_66 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_66 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 212;

            goto frame_exception_exit_1;
        }

        tmp_source_name_65 = tmp_mvar_value_66;
        tmp_assign_source_108 = LOOKUP_ATTRIBUTE(tmp_source_name_65, const_str_plain_SSL_CB_WRITE_ALERT);
        if (tmp_assign_source_108 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 212;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_CB_WRITE_ALERT, tmp_assign_source_108);
    }
    {
        PyObject *tmp_assign_source_109;
        PyObject *tmp_source_name_66;
        PyObject *tmp_mvar_value_67;
        tmp_mvar_value_67 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_67 == NULL)) {
            tmp_mvar_value_67 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_67 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 213;

            goto frame_exception_exit_1;
        }

        tmp_source_name_66 = tmp_mvar_value_67;
        tmp_assign_source_109 = LOOKUP_ATTRIBUTE(tmp_source_name_66, const_str_plain_SSL_CB_ACCEPT_LOOP);
        if (tmp_assign_source_109 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 213;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_CB_ACCEPT_LOOP, tmp_assign_source_109);
    }
    {
        PyObject *tmp_assign_source_110;
        PyObject *tmp_source_name_67;
        PyObject *tmp_mvar_value_68;
        tmp_mvar_value_68 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_68 == NULL)) {
            tmp_mvar_value_68 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_68 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 214;

            goto frame_exception_exit_1;
        }

        tmp_source_name_67 = tmp_mvar_value_68;
        tmp_assign_source_110 = LOOKUP_ATTRIBUTE(tmp_source_name_67, const_str_plain_SSL_CB_ACCEPT_EXIT);
        if (tmp_assign_source_110 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 214;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_CB_ACCEPT_EXIT, tmp_assign_source_110);
    }
    {
        PyObject *tmp_assign_source_111;
        PyObject *tmp_source_name_68;
        PyObject *tmp_mvar_value_69;
        tmp_mvar_value_69 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_69 == NULL)) {
            tmp_mvar_value_69 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_69 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 215;

            goto frame_exception_exit_1;
        }

        tmp_source_name_68 = tmp_mvar_value_69;
        tmp_assign_source_111 = LOOKUP_ATTRIBUTE(tmp_source_name_68, const_str_plain_SSL_CB_CONNECT_LOOP);
        if (tmp_assign_source_111 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 215;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_CB_CONNECT_LOOP, tmp_assign_source_111);
    }
    {
        PyObject *tmp_assign_source_112;
        PyObject *tmp_source_name_69;
        PyObject *tmp_mvar_value_70;
        tmp_mvar_value_70 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_70 == NULL)) {
            tmp_mvar_value_70 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_70 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 216;

            goto frame_exception_exit_1;
        }

        tmp_source_name_69 = tmp_mvar_value_70;
        tmp_assign_source_112 = LOOKUP_ATTRIBUTE(tmp_source_name_69, const_str_plain_SSL_CB_CONNECT_EXIT);
        if (tmp_assign_source_112 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 216;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_CB_CONNECT_EXIT, tmp_assign_source_112);
    }
    {
        PyObject *tmp_assign_source_113;
        PyObject *tmp_source_name_70;
        PyObject *tmp_mvar_value_71;
        tmp_mvar_value_71 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_71 == NULL)) {
            tmp_mvar_value_71 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_71 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 217;

            goto frame_exception_exit_1;
        }

        tmp_source_name_70 = tmp_mvar_value_71;
        tmp_assign_source_113 = LOOKUP_ATTRIBUTE(tmp_source_name_70, const_str_plain_SSL_CB_HANDSHAKE_START);
        if (tmp_assign_source_113 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 217;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_CB_HANDSHAKE_START, tmp_assign_source_113);
    }
    {
        PyObject *tmp_assign_source_114;
        PyObject *tmp_source_name_71;
        PyObject *tmp_mvar_value_72;
        tmp_mvar_value_72 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_72 == NULL)) {
            tmp_mvar_value_72 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_72 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 218;

            goto frame_exception_exit_1;
        }

        tmp_source_name_71 = tmp_mvar_value_72;
        tmp_assign_source_114 = LOOKUP_ATTRIBUTE(tmp_source_name_71, const_str_plain_SSL_CB_HANDSHAKE_DONE);
        if (tmp_assign_source_114 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 218;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_CB_HANDSHAKE_DONE, tmp_assign_source_114);
    }
    {
        PyObject *tmp_assign_source_115;
        tmp_assign_source_115 = LIST_COPY(const_list_b44af29ad37821285e6b89a520342cf5_list);
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CERTIFICATE_FILE_LOCATIONS, tmp_assign_source_115);
    }
    {
        PyObject *tmp_assign_source_116;
        tmp_assign_source_116 = LIST_COPY(const_list_str_digest_746ae0014bb266cffee8b7b1473626af_list);
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CERTIFICATE_PATH_LOCATIONS, tmp_assign_source_116);
    }
    {
        PyObject *tmp_assign_source_117;
        tmp_assign_source_117 = const_str_digest_3b38b9684d0a691f727a5c25b49127cb;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CRYPTOGRAPHY_MANYLINUX1_CA_DIR, tmp_assign_source_117);
    }
    {
        PyObject *tmp_assign_source_118;
        tmp_assign_source_118 = const_str_digest_04211c3d50cdc4f69d9c36018d92c12f;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CRYPTOGRAPHY_MANYLINUX1_CA_FILE, tmp_assign_source_118);
    }
    {
        PyObject *tmp_assign_source_119;
        tmp_assign_source_119 = PyDict_Copy(const_dict_8204a0d80b2c8b5483fe77928e561739);
        assert(tmp_class_creation_2__class_dict == NULL);
        tmp_class_creation_2__class_dict = tmp_assign_source_119;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_120;
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_key_name_1;
        PyObject *tmp_dict_name_1;
        PyObject *tmp_dict_name_2;
        PyObject *tmp_key_name_2;
        tmp_key_name_1 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_2__class_dict);
        tmp_dict_name_1 = tmp_class_creation_2__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_1, tmp_key_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 239;

            goto try_except_handler_5;
        }
        tmp_condition_result_2 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_1;
        } else {
            goto condexpr_false_1;
        }
        condexpr_true_1:;
        CHECK_OBJECT(tmp_class_creation_2__class_dict);
        tmp_dict_name_2 = tmp_class_creation_2__class_dict;
        tmp_key_name_2 = const_str_plain___metaclass__;
        tmp_assign_source_120 = DICT_GET_ITEM(tmp_dict_name_2, tmp_key_name_2);
        if (tmp_assign_source_120 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 239;

            goto try_except_handler_5;
        }
        goto condexpr_end_1;
        condexpr_false_1:;
        tmp_assign_source_120 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_120);
        condexpr_end_1:;
        assert(tmp_class_creation_2__metaclass == NULL);
        tmp_class_creation_2__metaclass = tmp_assign_source_120;
    }
    {
        PyObject *tmp_assign_source_121;
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        CHECK_OBJECT(tmp_class_creation_2__metaclass);
        tmp_called_name_1 = tmp_class_creation_2__metaclass;
        tmp_args_element_name_1 = const_str_plain_Error;
        tmp_args_element_name_2 = const_tuple_type_Exception_tuple;
        CHECK_OBJECT(tmp_class_creation_2__class_dict);
        tmp_args_element_name_3 = tmp_class_creation_2__class_dict;
        frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e->m_frame.f_lineno = 239;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_assign_source_121 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_1, call_args);
        }

        if (tmp_assign_source_121 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 239;

            goto try_except_handler_5;
        }
        assert(tmp_class_creation_2__class == NULL);
        tmp_class_creation_2__class = tmp_assign_source_121;
    }
    goto try_end_5;
    // Exception handler code:
    try_except_handler_5:;
    exception_keeper_type_5 = exception_type;
    exception_keeper_value_5 = exception_value;
    exception_keeper_tb_5 = exception_tb;
    exception_keeper_lineno_5 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)tmp_class_creation_2__class_dict);
    Py_DECREF(tmp_class_creation_2__class_dict);
    tmp_class_creation_2__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_2__metaclass);
    tmp_class_creation_2__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_5;
    exception_value = exception_keeper_value_5;
    exception_tb = exception_keeper_tb_5;
    exception_lineno = exception_keeper_lineno_5;

    goto frame_exception_exit_1;
    // End of try:
    try_end_5:;
    {
        PyObject *tmp_assign_source_122;
        CHECK_OBJECT(tmp_class_creation_2__class);
        tmp_assign_source_122 = tmp_class_creation_2__class;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Error, tmp_assign_source_122);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_2__class);
    Py_DECREF(tmp_class_creation_2__class);
    tmp_class_creation_2__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_2__class_dict);
    Py_DECREF(tmp_class_creation_2__class_dict);
    tmp_class_creation_2__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_2__metaclass);
    Py_DECREF(tmp_class_creation_2__metaclass);
    tmp_class_creation_2__metaclass = NULL;

    {
        PyObject *tmp_assign_source_123;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_73;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_mvar_value_74;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_mvar_value_75;
        tmp_mvar_value_73 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_partial);

        if (unlikely(tmp_mvar_value_73 == NULL)) {
            tmp_mvar_value_73 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_partial);
        }

        if (tmp_mvar_value_73 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 2055 ], 29, 0);
            exception_tb = NULL;

            exception_lineno = 245;

            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_73;
        tmp_mvar_value_74 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__exception_from_error_queue);

        if (unlikely(tmp_mvar_value_74 == NULL)) {
            tmp_mvar_value_74 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__exception_from_error_queue);
        }

        if (tmp_mvar_value_74 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 2084 ], 49, 0);
            exception_tb = NULL;

            exception_lineno = 245;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_4 = tmp_mvar_value_74;
        tmp_mvar_value_75 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Error);

        if (unlikely(tmp_mvar_value_75 == NULL)) {
            tmp_mvar_value_75 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_Error);
        }

        if (tmp_mvar_value_75 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 56 ], 27, 0);
            exception_tb = NULL;

            exception_lineno = 245;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_5 = tmp_mvar_value_75;
        frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e->m_frame.f_lineno = 245;
        {
            PyObject *call_args[] = {tmp_args_element_name_4, tmp_args_element_name_5};
            tmp_assign_source_123 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        if (tmp_assign_source_123 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 245;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error, tmp_assign_source_123);
    }
    {
        PyObject *tmp_assign_source_124;
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_76;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_mvar_value_77;
        tmp_mvar_value_76 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__make_assert);

        if (unlikely(tmp_mvar_value_76 == NULL)) {
            tmp_mvar_value_76 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__make_assert);
        }

        if (tmp_mvar_value_76 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 2133 ], 34, 0);
            exception_tb = NULL;

            exception_lineno = 246;

            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_76;
        tmp_mvar_value_77 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Error);

        if (unlikely(tmp_mvar_value_77 == NULL)) {
            tmp_mvar_value_77 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_Error);
        }

        if (tmp_mvar_value_77 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 56 ], 27, 0);
            exception_tb = NULL;

            exception_lineno = 246;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_6 = tmp_mvar_value_77;
        frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e->m_frame.f_lineno = 246;
        tmp_assign_source_124 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_3, tmp_args_element_name_6);
        if (tmp_assign_source_124 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 246;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert, tmp_assign_source_124);
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_125;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_mvar_value_78;
        tmp_mvar_value_78 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Error);

        if (unlikely(tmp_mvar_value_78 == NULL)) {
            tmp_mvar_value_78 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_Error);
        }

        if (tmp_mvar_value_78 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 56 ], 27, 0);
            exception_tb = NULL;

            exception_lineno = 249;

            goto try_except_handler_6;
        }

        tmp_tuple_element_1 = tmp_mvar_value_78;
        tmp_assign_source_125 = PyTuple_New(1);
        Py_INCREF(tmp_tuple_element_1);
        PyTuple_SET_ITEM(tmp_assign_source_125, 0, tmp_tuple_element_1);
        assert(tmp_class_creation_3__bases == NULL);
        tmp_class_creation_3__bases = tmp_assign_source_125;
    }
    {
        PyObject *tmp_assign_source_126;
        {
            PyObject *tmp_set_locals_1;
            tmp_set_locals_1 = PyDict_New();
            locals_OpenSSL$SSL_249 = tmp_set_locals_1;
        }
        tmp_dictset_value = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_249, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        tmp_assign_source_126 = locals_OpenSSL$SSL_249;
        Py_INCREF(tmp_assign_source_126);
        goto try_return_handler_7;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        // Return handler code:
        try_return_handler_7:;
        Py_DECREF(locals_OpenSSL$SSL_249);
        locals_OpenSSL$SSL_249 = NULL;
        goto outline_result_1;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        outline_result_1:;
        assert(tmp_class_creation_3__class_dict == NULL);
        tmp_class_creation_3__class_dict = tmp_assign_source_126;
    }
    {
        PyObject *tmp_assign_source_127;
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_key_name_3;
        PyObject *tmp_dict_name_3;
        PyObject *tmp_dict_name_4;
        PyObject *tmp_key_name_4;
        tmp_key_name_3 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_3__class_dict);
        tmp_dict_name_3 = tmp_class_creation_3__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_3, tmp_key_name_3);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 249;

            goto try_except_handler_6;
        }
        tmp_condition_result_3 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_2;
        } else {
            goto condexpr_false_2;
        }
        condexpr_true_2:;
        CHECK_OBJECT(tmp_class_creation_3__class_dict);
        tmp_dict_name_4 = tmp_class_creation_3__class_dict;
        tmp_key_name_4 = const_str_plain___metaclass__;
        tmp_assign_source_127 = DICT_GET_ITEM(tmp_dict_name_4, tmp_key_name_4);
        if (tmp_assign_source_127 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 249;

            goto try_except_handler_6;
        }
        goto condexpr_end_2;
        condexpr_false_2:;
        {
            PyObject *tmp_assign_source_128;
            PyObject *tmp_subscribed_name_1;
            PyObject *tmp_subscript_name_1;
            CHECK_OBJECT(tmp_class_creation_3__bases);
            tmp_subscribed_name_1 = tmp_class_creation_3__bases;
            tmp_subscript_name_1 = const_int_0;
            tmp_assign_source_128 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_1, tmp_subscript_name_1, 0);
            if (tmp_assign_source_128 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 249;

                goto try_except_handler_6;
            }
            assert(tmp_select_metaclass_3__base == NULL);
            tmp_select_metaclass_3__base = tmp_assign_source_128;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_72;
            CHECK_OBJECT(tmp_select_metaclass_3__base);
            tmp_source_name_72 = tmp_select_metaclass_3__base;
            tmp_assign_source_127 = LOOKUP_ATTRIBUTE_CLASS_SLOT(tmp_source_name_72);
            if (tmp_assign_source_127 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 249;

                goto try_except_handler_9;
            }
            goto try_return_handler_8;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        // Exception handler code:
        try_except_handler_9:;
        exception_keeper_type_6 = exception_type;
        exception_keeper_value_6 = exception_value;
        exception_keeper_tb_6 = exception_tb;
        exception_keeper_lineno_6 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_1;
            Py_DECREF(exception_keeper_type_6);
            Py_XDECREF(exception_keeper_value_6);
            Py_XDECREF(exception_keeper_tb_6);
            CHECK_OBJECT(tmp_select_metaclass_3__base);
            tmp_type_arg_1 = tmp_select_metaclass_3__base;
            tmp_assign_source_127 = BUILTIN_TYPE1(tmp_type_arg_1);
            assert(!(tmp_assign_source_127 == NULL));
            goto try_return_handler_8;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        // Return handler code:
        try_return_handler_8:;
        CHECK_OBJECT((PyObject *)tmp_select_metaclass_3__base);
        Py_DECREF(tmp_select_metaclass_3__base);
        tmp_select_metaclass_3__base = NULL;

        goto outline_result_2;
        // End of try:
        CHECK_OBJECT((PyObject *)tmp_select_metaclass_3__base);
        Py_DECREF(tmp_select_metaclass_3__base);
        tmp_select_metaclass_3__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        outline_result_2:;
        condexpr_end_2:;
        assert(tmp_class_creation_3__metaclass == NULL);
        tmp_class_creation_3__metaclass = tmp_assign_source_127;
    }
    {
        PyObject *tmp_assign_source_129;
        PyObject *tmp_called_name_4;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_args_element_name_9;
        CHECK_OBJECT(tmp_class_creation_3__metaclass);
        tmp_called_name_4 = tmp_class_creation_3__metaclass;
        tmp_args_element_name_7 = const_str_plain_WantReadError;
        CHECK_OBJECT(tmp_class_creation_3__bases);
        tmp_args_element_name_8 = tmp_class_creation_3__bases;
        CHECK_OBJECT(tmp_class_creation_3__class_dict);
        tmp_args_element_name_9 = tmp_class_creation_3__class_dict;
        frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e->m_frame.f_lineno = 249;
        {
            PyObject *call_args[] = {tmp_args_element_name_7, tmp_args_element_name_8, tmp_args_element_name_9};
            tmp_assign_source_129 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_4, call_args);
        }

        if (tmp_assign_source_129 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 249;

            goto try_except_handler_6;
        }
        assert(tmp_class_creation_3__class == NULL);
        tmp_class_creation_3__class = tmp_assign_source_129;
    }
    goto try_end_6;
    // Exception handler code:
    try_except_handler_6:;
    exception_keeper_type_7 = exception_type;
    exception_keeper_value_7 = exception_value;
    exception_keeper_tb_7 = exception_tb;
    exception_keeper_lineno_7 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_3__bases);
    tmp_class_creation_3__bases = NULL;

    Py_XDECREF(tmp_class_creation_3__class_dict);
    tmp_class_creation_3__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_3__metaclass);
    tmp_class_creation_3__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_7;
    exception_value = exception_keeper_value_7;
    exception_tb = exception_keeper_tb_7;
    exception_lineno = exception_keeper_lineno_7;

    goto frame_exception_exit_1;
    // End of try:
    try_end_6:;
    {
        PyObject *tmp_assign_source_130;
        CHECK_OBJECT(tmp_class_creation_3__class);
        tmp_assign_source_130 = tmp_class_creation_3__class;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_WantReadError, tmp_assign_source_130);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_3__class);
    Py_DECREF(tmp_class_creation_3__class);
    tmp_class_creation_3__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_3__bases);
    Py_DECREF(tmp_class_creation_3__bases);
    tmp_class_creation_3__bases = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_3__class_dict);
    Py_DECREF(tmp_class_creation_3__class_dict);
    tmp_class_creation_3__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_3__metaclass);
    Py_DECREF(tmp_class_creation_3__metaclass);
    tmp_class_creation_3__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_131;
        PyObject *tmp_tuple_element_2;
        PyObject *tmp_mvar_value_79;
        tmp_mvar_value_79 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Error);

        if (unlikely(tmp_mvar_value_79 == NULL)) {
            tmp_mvar_value_79 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_Error);
        }

        if (tmp_mvar_value_79 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 56 ], 27, 0);
            exception_tb = NULL;

            exception_lineno = 253;

            goto try_except_handler_10;
        }

        tmp_tuple_element_2 = tmp_mvar_value_79;
        tmp_assign_source_131 = PyTuple_New(1);
        Py_INCREF(tmp_tuple_element_2);
        PyTuple_SET_ITEM(tmp_assign_source_131, 0, tmp_tuple_element_2);
        assert(tmp_class_creation_4__bases == NULL);
        tmp_class_creation_4__bases = tmp_assign_source_131;
    }
    {
        PyObject *tmp_assign_source_132;
        {
            PyObject *tmp_set_locals_2;
            tmp_set_locals_2 = PyDict_New();
            locals_OpenSSL$SSL_253 = tmp_set_locals_2;
        }
        tmp_dictset_value = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_253, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        tmp_assign_source_132 = locals_OpenSSL$SSL_253;
        Py_INCREF(tmp_assign_source_132);
        goto try_return_handler_11;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        // Return handler code:
        try_return_handler_11:;
        Py_DECREF(locals_OpenSSL$SSL_253);
        locals_OpenSSL$SSL_253 = NULL;
        goto outline_result_3;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        outline_result_3:;
        assert(tmp_class_creation_4__class_dict == NULL);
        tmp_class_creation_4__class_dict = tmp_assign_source_132;
    }
    {
        PyObject *tmp_assign_source_133;
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_key_name_5;
        PyObject *tmp_dict_name_5;
        PyObject *tmp_dict_name_6;
        PyObject *tmp_key_name_6;
        tmp_key_name_5 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_4__class_dict);
        tmp_dict_name_5 = tmp_class_creation_4__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_5, tmp_key_name_5);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 253;

            goto try_except_handler_10;
        }
        tmp_condition_result_4 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_4 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_3;
        } else {
            goto condexpr_false_3;
        }
        condexpr_true_3:;
        CHECK_OBJECT(tmp_class_creation_4__class_dict);
        tmp_dict_name_6 = tmp_class_creation_4__class_dict;
        tmp_key_name_6 = const_str_plain___metaclass__;
        tmp_assign_source_133 = DICT_GET_ITEM(tmp_dict_name_6, tmp_key_name_6);
        if (tmp_assign_source_133 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 253;

            goto try_except_handler_10;
        }
        goto condexpr_end_3;
        condexpr_false_3:;
        {
            PyObject *tmp_assign_source_134;
            PyObject *tmp_subscribed_name_2;
            PyObject *tmp_subscript_name_2;
            CHECK_OBJECT(tmp_class_creation_4__bases);
            tmp_subscribed_name_2 = tmp_class_creation_4__bases;
            tmp_subscript_name_2 = const_int_0;
            tmp_assign_source_134 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_2, tmp_subscript_name_2, 0);
            if (tmp_assign_source_134 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 253;

                goto try_except_handler_10;
            }
            assert(tmp_select_metaclass_4__base == NULL);
            tmp_select_metaclass_4__base = tmp_assign_source_134;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_73;
            CHECK_OBJECT(tmp_select_metaclass_4__base);
            tmp_source_name_73 = tmp_select_metaclass_4__base;
            tmp_assign_source_133 = LOOKUP_ATTRIBUTE_CLASS_SLOT(tmp_source_name_73);
            if (tmp_assign_source_133 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 253;

                goto try_except_handler_13;
            }
            goto try_return_handler_12;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        // Exception handler code:
        try_except_handler_13:;
        exception_keeper_type_8 = exception_type;
        exception_keeper_value_8 = exception_value;
        exception_keeper_tb_8 = exception_tb;
        exception_keeper_lineno_8 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_2;
            Py_DECREF(exception_keeper_type_8);
            Py_XDECREF(exception_keeper_value_8);
            Py_XDECREF(exception_keeper_tb_8);
            CHECK_OBJECT(tmp_select_metaclass_4__base);
            tmp_type_arg_2 = tmp_select_metaclass_4__base;
            tmp_assign_source_133 = BUILTIN_TYPE1(tmp_type_arg_2);
            assert(!(tmp_assign_source_133 == NULL));
            goto try_return_handler_12;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        // Return handler code:
        try_return_handler_12:;
        CHECK_OBJECT((PyObject *)tmp_select_metaclass_4__base);
        Py_DECREF(tmp_select_metaclass_4__base);
        tmp_select_metaclass_4__base = NULL;

        goto outline_result_4;
        // End of try:
        CHECK_OBJECT((PyObject *)tmp_select_metaclass_4__base);
        Py_DECREF(tmp_select_metaclass_4__base);
        tmp_select_metaclass_4__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        outline_result_4:;
        condexpr_end_3:;
        assert(tmp_class_creation_4__metaclass == NULL);
        tmp_class_creation_4__metaclass = tmp_assign_source_133;
    }
    {
        PyObject *tmp_assign_source_135;
        PyObject *tmp_called_name_5;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_args_element_name_11;
        PyObject *tmp_args_element_name_12;
        CHECK_OBJECT(tmp_class_creation_4__metaclass);
        tmp_called_name_5 = tmp_class_creation_4__metaclass;
        tmp_args_element_name_10 = const_str_plain_WantWriteError;
        CHECK_OBJECT(tmp_class_creation_4__bases);
        tmp_args_element_name_11 = tmp_class_creation_4__bases;
        CHECK_OBJECT(tmp_class_creation_4__class_dict);
        tmp_args_element_name_12 = tmp_class_creation_4__class_dict;
        frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e->m_frame.f_lineno = 253;
        {
            PyObject *call_args[] = {tmp_args_element_name_10, tmp_args_element_name_11, tmp_args_element_name_12};
            tmp_assign_source_135 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_5, call_args);
        }

        if (tmp_assign_source_135 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 253;

            goto try_except_handler_10;
        }
        assert(tmp_class_creation_4__class == NULL);
        tmp_class_creation_4__class = tmp_assign_source_135;
    }
    goto try_end_7;
    // Exception handler code:
    try_except_handler_10:;
    exception_keeper_type_9 = exception_type;
    exception_keeper_value_9 = exception_value;
    exception_keeper_tb_9 = exception_tb;
    exception_keeper_lineno_9 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_4__bases);
    tmp_class_creation_4__bases = NULL;

    Py_XDECREF(tmp_class_creation_4__class_dict);
    tmp_class_creation_4__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_4__metaclass);
    tmp_class_creation_4__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_9;
    exception_value = exception_keeper_value_9;
    exception_tb = exception_keeper_tb_9;
    exception_lineno = exception_keeper_lineno_9;

    goto frame_exception_exit_1;
    // End of try:
    try_end_7:;
    {
        PyObject *tmp_assign_source_136;
        CHECK_OBJECT(tmp_class_creation_4__class);
        tmp_assign_source_136 = tmp_class_creation_4__class;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_WantWriteError, tmp_assign_source_136);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_4__class);
    Py_DECREF(tmp_class_creation_4__class);
    tmp_class_creation_4__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_4__bases);
    Py_DECREF(tmp_class_creation_4__bases);
    tmp_class_creation_4__bases = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_4__class_dict);
    Py_DECREF(tmp_class_creation_4__class_dict);
    tmp_class_creation_4__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_4__metaclass);
    Py_DECREF(tmp_class_creation_4__metaclass);
    tmp_class_creation_4__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_137;
        PyObject *tmp_tuple_element_3;
        PyObject *tmp_mvar_value_80;
        tmp_mvar_value_80 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Error);

        if (unlikely(tmp_mvar_value_80 == NULL)) {
            tmp_mvar_value_80 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_Error);
        }

        if (tmp_mvar_value_80 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 56 ], 27, 0);
            exception_tb = NULL;

            exception_lineno = 257;

            goto try_except_handler_14;
        }

        tmp_tuple_element_3 = tmp_mvar_value_80;
        tmp_assign_source_137 = PyTuple_New(1);
        Py_INCREF(tmp_tuple_element_3);
        PyTuple_SET_ITEM(tmp_assign_source_137, 0, tmp_tuple_element_3);
        assert(tmp_class_creation_5__bases == NULL);
        tmp_class_creation_5__bases = tmp_assign_source_137;
    }
    {
        PyObject *tmp_assign_source_138;
        {
            PyObject *tmp_set_locals_3;
            tmp_set_locals_3 = PyDict_New();
            locals_OpenSSL$SSL_257 = tmp_set_locals_3;
        }
        tmp_dictset_value = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_257, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        tmp_assign_source_138 = locals_OpenSSL$SSL_257;
        Py_INCREF(tmp_assign_source_138);
        goto try_return_handler_15;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        // Return handler code:
        try_return_handler_15:;
        Py_DECREF(locals_OpenSSL$SSL_257);
        locals_OpenSSL$SSL_257 = NULL;
        goto outline_result_5;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        outline_result_5:;
        assert(tmp_class_creation_5__class_dict == NULL);
        tmp_class_creation_5__class_dict = tmp_assign_source_138;
    }
    {
        PyObject *tmp_assign_source_139;
        nuitka_bool tmp_condition_result_5;
        PyObject *tmp_key_name_7;
        PyObject *tmp_dict_name_7;
        PyObject *tmp_dict_name_8;
        PyObject *tmp_key_name_8;
        tmp_key_name_7 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_5__class_dict);
        tmp_dict_name_7 = tmp_class_creation_5__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_7, tmp_key_name_7);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 257;

            goto try_except_handler_14;
        }
        tmp_condition_result_5 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_5 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_4;
        } else {
            goto condexpr_false_4;
        }
        condexpr_true_4:;
        CHECK_OBJECT(tmp_class_creation_5__class_dict);
        tmp_dict_name_8 = tmp_class_creation_5__class_dict;
        tmp_key_name_8 = const_str_plain___metaclass__;
        tmp_assign_source_139 = DICT_GET_ITEM(tmp_dict_name_8, tmp_key_name_8);
        if (tmp_assign_source_139 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 257;

            goto try_except_handler_14;
        }
        goto condexpr_end_4;
        condexpr_false_4:;
        {
            PyObject *tmp_assign_source_140;
            PyObject *tmp_subscribed_name_3;
            PyObject *tmp_subscript_name_3;
            CHECK_OBJECT(tmp_class_creation_5__bases);
            tmp_subscribed_name_3 = tmp_class_creation_5__bases;
            tmp_subscript_name_3 = const_int_0;
            tmp_assign_source_140 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_3, tmp_subscript_name_3, 0);
            if (tmp_assign_source_140 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 257;

                goto try_except_handler_14;
            }
            assert(tmp_select_metaclass_5__base == NULL);
            tmp_select_metaclass_5__base = tmp_assign_source_140;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_74;
            CHECK_OBJECT(tmp_select_metaclass_5__base);
            tmp_source_name_74 = tmp_select_metaclass_5__base;
            tmp_assign_source_139 = LOOKUP_ATTRIBUTE_CLASS_SLOT(tmp_source_name_74);
            if (tmp_assign_source_139 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 257;

                goto try_except_handler_17;
            }
            goto try_return_handler_16;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        // Exception handler code:
        try_except_handler_17:;
        exception_keeper_type_10 = exception_type;
        exception_keeper_value_10 = exception_value;
        exception_keeper_tb_10 = exception_tb;
        exception_keeper_lineno_10 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_3;
            Py_DECREF(exception_keeper_type_10);
            Py_XDECREF(exception_keeper_value_10);
            Py_XDECREF(exception_keeper_tb_10);
            CHECK_OBJECT(tmp_select_metaclass_5__base);
            tmp_type_arg_3 = tmp_select_metaclass_5__base;
            tmp_assign_source_139 = BUILTIN_TYPE1(tmp_type_arg_3);
            assert(!(tmp_assign_source_139 == NULL));
            goto try_return_handler_16;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        // Return handler code:
        try_return_handler_16:;
        CHECK_OBJECT((PyObject *)tmp_select_metaclass_5__base);
        Py_DECREF(tmp_select_metaclass_5__base);
        tmp_select_metaclass_5__base = NULL;

        goto outline_result_6;
        // End of try:
        CHECK_OBJECT((PyObject *)tmp_select_metaclass_5__base);
        Py_DECREF(tmp_select_metaclass_5__base);
        tmp_select_metaclass_5__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        outline_result_6:;
        condexpr_end_4:;
        assert(tmp_class_creation_5__metaclass == NULL);
        tmp_class_creation_5__metaclass = tmp_assign_source_139;
    }
    {
        PyObject *tmp_assign_source_141;
        PyObject *tmp_called_name_6;
        PyObject *tmp_args_element_name_13;
        PyObject *tmp_args_element_name_14;
        PyObject *tmp_args_element_name_15;
        CHECK_OBJECT(tmp_class_creation_5__metaclass);
        tmp_called_name_6 = tmp_class_creation_5__metaclass;
        tmp_args_element_name_13 = const_str_plain_WantX509LookupError;
        CHECK_OBJECT(tmp_class_creation_5__bases);
        tmp_args_element_name_14 = tmp_class_creation_5__bases;
        CHECK_OBJECT(tmp_class_creation_5__class_dict);
        tmp_args_element_name_15 = tmp_class_creation_5__class_dict;
        frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e->m_frame.f_lineno = 257;
        {
            PyObject *call_args[] = {tmp_args_element_name_13, tmp_args_element_name_14, tmp_args_element_name_15};
            tmp_assign_source_141 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_6, call_args);
        }

        if (tmp_assign_source_141 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 257;

            goto try_except_handler_14;
        }
        assert(tmp_class_creation_5__class == NULL);
        tmp_class_creation_5__class = tmp_assign_source_141;
    }
    goto try_end_8;
    // Exception handler code:
    try_except_handler_14:;
    exception_keeper_type_11 = exception_type;
    exception_keeper_value_11 = exception_value;
    exception_keeper_tb_11 = exception_tb;
    exception_keeper_lineno_11 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_5__bases);
    tmp_class_creation_5__bases = NULL;

    Py_XDECREF(tmp_class_creation_5__class_dict);
    tmp_class_creation_5__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_5__metaclass);
    tmp_class_creation_5__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_11;
    exception_value = exception_keeper_value_11;
    exception_tb = exception_keeper_tb_11;
    exception_lineno = exception_keeper_lineno_11;

    goto frame_exception_exit_1;
    // End of try:
    try_end_8:;
    {
        PyObject *tmp_assign_source_142;
        CHECK_OBJECT(tmp_class_creation_5__class);
        tmp_assign_source_142 = tmp_class_creation_5__class;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_WantX509LookupError, tmp_assign_source_142);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_5__class);
    Py_DECREF(tmp_class_creation_5__class);
    tmp_class_creation_5__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_5__bases);
    Py_DECREF(tmp_class_creation_5__bases);
    tmp_class_creation_5__bases = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_5__class_dict);
    Py_DECREF(tmp_class_creation_5__class_dict);
    tmp_class_creation_5__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_5__metaclass);
    Py_DECREF(tmp_class_creation_5__metaclass);
    tmp_class_creation_5__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_143;
        PyObject *tmp_tuple_element_4;
        PyObject *tmp_mvar_value_81;
        tmp_mvar_value_81 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Error);

        if (unlikely(tmp_mvar_value_81 == NULL)) {
            tmp_mvar_value_81 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_Error);
        }

        if (tmp_mvar_value_81 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 56 ], 27, 0);
            exception_tb = NULL;

            exception_lineno = 261;

            goto try_except_handler_18;
        }

        tmp_tuple_element_4 = tmp_mvar_value_81;
        tmp_assign_source_143 = PyTuple_New(1);
        Py_INCREF(tmp_tuple_element_4);
        PyTuple_SET_ITEM(tmp_assign_source_143, 0, tmp_tuple_element_4);
        assert(tmp_class_creation_6__bases == NULL);
        tmp_class_creation_6__bases = tmp_assign_source_143;
    }
    {
        PyObject *tmp_assign_source_144;
        {
            PyObject *tmp_set_locals_4;
            tmp_set_locals_4 = PyDict_New();
            locals_OpenSSL$SSL_261 = tmp_set_locals_4;
        }
        tmp_dictset_value = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_261, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        tmp_assign_source_144 = locals_OpenSSL$SSL_261;
        Py_INCREF(tmp_assign_source_144);
        goto try_return_handler_19;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        // Return handler code:
        try_return_handler_19:;
        Py_DECREF(locals_OpenSSL$SSL_261);
        locals_OpenSSL$SSL_261 = NULL;
        goto outline_result_7;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        outline_result_7:;
        assert(tmp_class_creation_6__class_dict == NULL);
        tmp_class_creation_6__class_dict = tmp_assign_source_144;
    }
    {
        PyObject *tmp_assign_source_145;
        nuitka_bool tmp_condition_result_6;
        PyObject *tmp_key_name_9;
        PyObject *tmp_dict_name_9;
        PyObject *tmp_dict_name_10;
        PyObject *tmp_key_name_10;
        tmp_key_name_9 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_6__class_dict);
        tmp_dict_name_9 = tmp_class_creation_6__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_9, tmp_key_name_9);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 261;

            goto try_except_handler_18;
        }
        tmp_condition_result_6 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_6 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_5;
        } else {
            goto condexpr_false_5;
        }
        condexpr_true_5:;
        CHECK_OBJECT(tmp_class_creation_6__class_dict);
        tmp_dict_name_10 = tmp_class_creation_6__class_dict;
        tmp_key_name_10 = const_str_plain___metaclass__;
        tmp_assign_source_145 = DICT_GET_ITEM(tmp_dict_name_10, tmp_key_name_10);
        if (tmp_assign_source_145 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 261;

            goto try_except_handler_18;
        }
        goto condexpr_end_5;
        condexpr_false_5:;
        {
            PyObject *tmp_assign_source_146;
            PyObject *tmp_subscribed_name_4;
            PyObject *tmp_subscript_name_4;
            CHECK_OBJECT(tmp_class_creation_6__bases);
            tmp_subscribed_name_4 = tmp_class_creation_6__bases;
            tmp_subscript_name_4 = const_int_0;
            tmp_assign_source_146 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_4, tmp_subscript_name_4, 0);
            if (tmp_assign_source_146 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 261;

                goto try_except_handler_18;
            }
            assert(tmp_select_metaclass_6__base == NULL);
            tmp_select_metaclass_6__base = tmp_assign_source_146;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_75;
            CHECK_OBJECT(tmp_select_metaclass_6__base);
            tmp_source_name_75 = tmp_select_metaclass_6__base;
            tmp_assign_source_145 = LOOKUP_ATTRIBUTE_CLASS_SLOT(tmp_source_name_75);
            if (tmp_assign_source_145 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 261;

                goto try_except_handler_21;
            }
            goto try_return_handler_20;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        // Exception handler code:
        try_except_handler_21:;
        exception_keeper_type_12 = exception_type;
        exception_keeper_value_12 = exception_value;
        exception_keeper_tb_12 = exception_tb;
        exception_keeper_lineno_12 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_4;
            Py_DECREF(exception_keeper_type_12);
            Py_XDECREF(exception_keeper_value_12);
            Py_XDECREF(exception_keeper_tb_12);
            CHECK_OBJECT(tmp_select_metaclass_6__base);
            tmp_type_arg_4 = tmp_select_metaclass_6__base;
            tmp_assign_source_145 = BUILTIN_TYPE1(tmp_type_arg_4);
            assert(!(tmp_assign_source_145 == NULL));
            goto try_return_handler_20;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        // Return handler code:
        try_return_handler_20:;
        CHECK_OBJECT((PyObject *)tmp_select_metaclass_6__base);
        Py_DECREF(tmp_select_metaclass_6__base);
        tmp_select_metaclass_6__base = NULL;

        goto outline_result_8;
        // End of try:
        CHECK_OBJECT((PyObject *)tmp_select_metaclass_6__base);
        Py_DECREF(tmp_select_metaclass_6__base);
        tmp_select_metaclass_6__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        outline_result_8:;
        condexpr_end_5:;
        assert(tmp_class_creation_6__metaclass == NULL);
        tmp_class_creation_6__metaclass = tmp_assign_source_145;
    }
    {
        PyObject *tmp_assign_source_147;
        PyObject *tmp_called_name_7;
        PyObject *tmp_args_element_name_16;
        PyObject *tmp_args_element_name_17;
        PyObject *tmp_args_element_name_18;
        CHECK_OBJECT(tmp_class_creation_6__metaclass);
        tmp_called_name_7 = tmp_class_creation_6__metaclass;
        tmp_args_element_name_16 = const_str_plain_ZeroReturnError;
        CHECK_OBJECT(tmp_class_creation_6__bases);
        tmp_args_element_name_17 = tmp_class_creation_6__bases;
        CHECK_OBJECT(tmp_class_creation_6__class_dict);
        tmp_args_element_name_18 = tmp_class_creation_6__class_dict;
        frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e->m_frame.f_lineno = 261;
        {
            PyObject *call_args[] = {tmp_args_element_name_16, tmp_args_element_name_17, tmp_args_element_name_18};
            tmp_assign_source_147 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_7, call_args);
        }

        if (tmp_assign_source_147 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 261;

            goto try_except_handler_18;
        }
        assert(tmp_class_creation_6__class == NULL);
        tmp_class_creation_6__class = tmp_assign_source_147;
    }
    goto try_end_9;
    // Exception handler code:
    try_except_handler_18:;
    exception_keeper_type_13 = exception_type;
    exception_keeper_value_13 = exception_value;
    exception_keeper_tb_13 = exception_tb;
    exception_keeper_lineno_13 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_6__bases);
    tmp_class_creation_6__bases = NULL;

    Py_XDECREF(tmp_class_creation_6__class_dict);
    tmp_class_creation_6__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_6__metaclass);
    tmp_class_creation_6__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_13;
    exception_value = exception_keeper_value_13;
    exception_tb = exception_keeper_tb_13;
    exception_lineno = exception_keeper_lineno_13;

    goto frame_exception_exit_1;
    // End of try:
    try_end_9:;
    {
        PyObject *tmp_assign_source_148;
        CHECK_OBJECT(tmp_class_creation_6__class);
        tmp_assign_source_148 = tmp_class_creation_6__class;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_ZeroReturnError, tmp_assign_source_148);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_6__class);
    Py_DECREF(tmp_class_creation_6__class);
    tmp_class_creation_6__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_6__bases);
    Py_DECREF(tmp_class_creation_6__bases);
    tmp_class_creation_6__bases = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_6__class_dict);
    Py_DECREF(tmp_class_creation_6__class_dict);
    tmp_class_creation_6__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_6__metaclass);
    Py_DECREF(tmp_class_creation_6__metaclass);
    tmp_class_creation_6__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_149;
        PyObject *tmp_tuple_element_5;
        PyObject *tmp_mvar_value_82;
        tmp_mvar_value_82 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Error);

        if (unlikely(tmp_mvar_value_82 == NULL)) {
            tmp_mvar_value_82 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_Error);
        }

        if (tmp_mvar_value_82 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 56 ], 27, 0);
            exception_tb = NULL;

            exception_lineno = 265;

            goto try_except_handler_22;
        }

        tmp_tuple_element_5 = tmp_mvar_value_82;
        tmp_assign_source_149 = PyTuple_New(1);
        Py_INCREF(tmp_tuple_element_5);
        PyTuple_SET_ITEM(tmp_assign_source_149, 0, tmp_tuple_element_5);
        assert(tmp_class_creation_7__bases == NULL);
        tmp_class_creation_7__bases = tmp_assign_source_149;
    }
    {
        PyObject *tmp_assign_source_150;
        {
            PyObject *tmp_set_locals_5;
            tmp_set_locals_5 = PyDict_New();
            locals_OpenSSL$SSL_265 = tmp_set_locals_5;
        }
        tmp_dictset_value = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_265, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        tmp_assign_source_150 = locals_OpenSSL$SSL_265;
        Py_INCREF(tmp_assign_source_150);
        goto try_return_handler_23;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        // Return handler code:
        try_return_handler_23:;
        Py_DECREF(locals_OpenSSL$SSL_265);
        locals_OpenSSL$SSL_265 = NULL;
        goto outline_result_9;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        outline_result_9:;
        assert(tmp_class_creation_7__class_dict == NULL);
        tmp_class_creation_7__class_dict = tmp_assign_source_150;
    }
    {
        PyObject *tmp_assign_source_151;
        nuitka_bool tmp_condition_result_7;
        PyObject *tmp_key_name_11;
        PyObject *tmp_dict_name_11;
        PyObject *tmp_dict_name_12;
        PyObject *tmp_key_name_12;
        tmp_key_name_11 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_7__class_dict);
        tmp_dict_name_11 = tmp_class_creation_7__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_11, tmp_key_name_11);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 265;

            goto try_except_handler_22;
        }
        tmp_condition_result_7 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_7 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_6;
        } else {
            goto condexpr_false_6;
        }
        condexpr_true_6:;
        CHECK_OBJECT(tmp_class_creation_7__class_dict);
        tmp_dict_name_12 = tmp_class_creation_7__class_dict;
        tmp_key_name_12 = const_str_plain___metaclass__;
        tmp_assign_source_151 = DICT_GET_ITEM(tmp_dict_name_12, tmp_key_name_12);
        if (tmp_assign_source_151 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 265;

            goto try_except_handler_22;
        }
        goto condexpr_end_6;
        condexpr_false_6:;
        {
            PyObject *tmp_assign_source_152;
            PyObject *tmp_subscribed_name_5;
            PyObject *tmp_subscript_name_5;
            CHECK_OBJECT(tmp_class_creation_7__bases);
            tmp_subscribed_name_5 = tmp_class_creation_7__bases;
            tmp_subscript_name_5 = const_int_0;
            tmp_assign_source_152 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_5, tmp_subscript_name_5, 0);
            if (tmp_assign_source_152 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 265;

                goto try_except_handler_22;
            }
            assert(tmp_select_metaclass_7__base == NULL);
            tmp_select_metaclass_7__base = tmp_assign_source_152;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_76;
            CHECK_OBJECT(tmp_select_metaclass_7__base);
            tmp_source_name_76 = tmp_select_metaclass_7__base;
            tmp_assign_source_151 = LOOKUP_ATTRIBUTE_CLASS_SLOT(tmp_source_name_76);
            if (tmp_assign_source_151 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 265;

                goto try_except_handler_25;
            }
            goto try_return_handler_24;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        // Exception handler code:
        try_except_handler_25:;
        exception_keeper_type_14 = exception_type;
        exception_keeper_value_14 = exception_value;
        exception_keeper_tb_14 = exception_tb;
        exception_keeper_lineno_14 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_5;
            Py_DECREF(exception_keeper_type_14);
            Py_XDECREF(exception_keeper_value_14);
            Py_XDECREF(exception_keeper_tb_14);
            CHECK_OBJECT(tmp_select_metaclass_7__base);
            tmp_type_arg_5 = tmp_select_metaclass_7__base;
            tmp_assign_source_151 = BUILTIN_TYPE1(tmp_type_arg_5);
            assert(!(tmp_assign_source_151 == NULL));
            goto try_return_handler_24;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        // Return handler code:
        try_return_handler_24:;
        CHECK_OBJECT((PyObject *)tmp_select_metaclass_7__base);
        Py_DECREF(tmp_select_metaclass_7__base);
        tmp_select_metaclass_7__base = NULL;

        goto outline_result_10;
        // End of try:
        CHECK_OBJECT((PyObject *)tmp_select_metaclass_7__base);
        Py_DECREF(tmp_select_metaclass_7__base);
        tmp_select_metaclass_7__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        outline_result_10:;
        condexpr_end_6:;
        assert(tmp_class_creation_7__metaclass == NULL);
        tmp_class_creation_7__metaclass = tmp_assign_source_151;
    }
    {
        PyObject *tmp_assign_source_153;
        PyObject *tmp_called_name_8;
        PyObject *tmp_args_element_name_19;
        PyObject *tmp_args_element_name_20;
        PyObject *tmp_args_element_name_21;
        CHECK_OBJECT(tmp_class_creation_7__metaclass);
        tmp_called_name_8 = tmp_class_creation_7__metaclass;
        tmp_args_element_name_19 = const_str_plain_SysCallError;
        CHECK_OBJECT(tmp_class_creation_7__bases);
        tmp_args_element_name_20 = tmp_class_creation_7__bases;
        CHECK_OBJECT(tmp_class_creation_7__class_dict);
        tmp_args_element_name_21 = tmp_class_creation_7__class_dict;
        frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e->m_frame.f_lineno = 265;
        {
            PyObject *call_args[] = {tmp_args_element_name_19, tmp_args_element_name_20, tmp_args_element_name_21};
            tmp_assign_source_153 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_8, call_args);
        }

        if (tmp_assign_source_153 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 265;

            goto try_except_handler_22;
        }
        assert(tmp_class_creation_7__class == NULL);
        tmp_class_creation_7__class = tmp_assign_source_153;
    }
    goto try_end_10;
    // Exception handler code:
    try_except_handler_22:;
    exception_keeper_type_15 = exception_type;
    exception_keeper_value_15 = exception_value;
    exception_keeper_tb_15 = exception_tb;
    exception_keeper_lineno_15 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_7__bases);
    tmp_class_creation_7__bases = NULL;

    Py_XDECREF(tmp_class_creation_7__class_dict);
    tmp_class_creation_7__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_7__metaclass);
    tmp_class_creation_7__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_15;
    exception_value = exception_keeper_value_15;
    exception_tb = exception_keeper_tb_15;
    exception_lineno = exception_keeper_lineno_15;

    goto frame_exception_exit_1;
    // End of try:
    try_end_10:;
    {
        PyObject *tmp_assign_source_154;
        CHECK_OBJECT(tmp_class_creation_7__class);
        tmp_assign_source_154 = tmp_class_creation_7__class;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SysCallError, tmp_assign_source_154);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_7__class);
    Py_DECREF(tmp_class_creation_7__class);
    tmp_class_creation_7__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_7__bases);
    Py_DECREF(tmp_class_creation_7__bases);
    tmp_class_creation_7__bases = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_7__class_dict);
    Py_DECREF(tmp_class_creation_7__class_dict);
    tmp_class_creation_7__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_7__metaclass);
    Py_DECREF(tmp_class_creation_7__metaclass);
    tmp_class_creation_7__metaclass = NULL;

    {
        PyObject *tmp_assign_source_155;
        {
            PyObject *tmp_assign_source_156;
            tmp_assign_source_156 = MAKE_FUNCTION_OpenSSL$SSL$$$function_1___init__();



            assert(tmp_locals_OpenSSL$SSL_269_key___init__ == NULL);
            tmp_locals_OpenSSL$SSL_269_key___init__ = tmp_assign_source_156;
        }
        {
            PyObject *tmp_assign_source_157;
            tmp_assign_source_157 = MAKE_FUNCTION_OpenSSL$SSL$$$function_2_raise_if_problem();



            assert(tmp_locals_OpenSSL$SSL_269_key_raise_if_problem == NULL);
            tmp_locals_OpenSSL$SSL_269_key_raise_if_problem = tmp_assign_source_157;
        }
        // Tried code:
        {
            PyObject *tmp_dict_key_1;
            PyObject *tmp_dict_value_1;
            PyObject *tmp_dict_key_2;
            PyObject *tmp_dict_value_2;
            PyObject *tmp_dict_key_3;
            PyObject *tmp_dict_value_3;
            PyObject *tmp_dict_key_4;
            PyObject *tmp_dict_value_4;
            tmp_dict_value_1 = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
            tmp_dict_key_1 = const_str_plain___module__;
            tmp_assign_source_155 = _PyDict_NewPresized( 4 );
            tmp_res = PyDict_SetItem(tmp_assign_source_155, tmp_dict_key_1, tmp_dict_value_1);
            assert(!(tmp_res != 0));
            tmp_dict_value_2 = const_str_digest_03a9c0f25246f86801453ac49af67056;
            tmp_dict_key_2 = const_str_plain___doc__;
            tmp_res = PyDict_SetItem(tmp_assign_source_155, tmp_dict_key_2, tmp_dict_value_2);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$SSL_269_key___init__);
            tmp_dict_value_3 = tmp_locals_OpenSSL$SSL_269_key___init__;
            tmp_dict_key_3 = const_str_plain___init__;
            tmp_res = PyDict_SetItem(tmp_assign_source_155, tmp_dict_key_3, tmp_dict_value_3);
            assert(!(tmp_res != 0));
            CHECK_OBJECT(tmp_locals_OpenSSL$SSL_269_key_raise_if_problem);
            tmp_dict_value_4 = tmp_locals_OpenSSL$SSL_269_key_raise_if_problem;
            tmp_dict_key_4 = const_str_plain_raise_if_problem;
            tmp_res = PyDict_SetItem(tmp_assign_source_155, tmp_dict_key_4, tmp_dict_value_4);
            assert(!(tmp_res != 0));
            goto try_return_handler_26;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        // Return handler code:
        try_return_handler_26:;
        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$SSL_269_key___init__);
        Py_DECREF(tmp_locals_OpenSSL$SSL_269_key___init__);
        tmp_locals_OpenSSL$SSL_269_key___init__ = NULL;

        CHECK_OBJECT((PyObject *)tmp_locals_OpenSSL$SSL_269_key_raise_if_problem);
        Py_DECREF(tmp_locals_OpenSSL$SSL_269_key_raise_if_problem);
        tmp_locals_OpenSSL$SSL_269_key_raise_if_problem = NULL;

        goto outline_result_11;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        outline_result_11:;
        assert(tmp_class_creation_8__class_dict == NULL);
        tmp_class_creation_8__class_dict = tmp_assign_source_155;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_158;
        nuitka_bool tmp_condition_result_8;
        PyObject *tmp_key_name_13;
        PyObject *tmp_dict_name_13;
        PyObject *tmp_dict_name_14;
        PyObject *tmp_key_name_14;
        tmp_key_name_13 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_8__class_dict);
        tmp_dict_name_13 = tmp_class_creation_8__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_13, tmp_key_name_13);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 269;

            goto try_except_handler_27;
        }
        tmp_condition_result_8 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_8 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_7;
        } else {
            goto condexpr_false_7;
        }
        condexpr_true_7:;
        CHECK_OBJECT(tmp_class_creation_8__class_dict);
        tmp_dict_name_14 = tmp_class_creation_8__class_dict;
        tmp_key_name_14 = const_str_plain___metaclass__;
        tmp_assign_source_158 = DICT_GET_ITEM(tmp_dict_name_14, tmp_key_name_14);
        if (tmp_assign_source_158 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 269;

            goto try_except_handler_27;
        }
        goto condexpr_end_7;
        condexpr_false_7:;
        tmp_assign_source_158 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_158);
        condexpr_end_7:;
        assert(tmp_class_creation_8__metaclass == NULL);
        tmp_class_creation_8__metaclass = tmp_assign_source_158;
    }
    {
        PyObject *tmp_assign_source_159;
        PyObject *tmp_called_name_9;
        PyObject *tmp_args_element_name_22;
        PyObject *tmp_args_element_name_23;
        PyObject *tmp_args_element_name_24;
        CHECK_OBJECT(tmp_class_creation_8__metaclass);
        tmp_called_name_9 = tmp_class_creation_8__metaclass;
        tmp_args_element_name_22 = const_str_plain__CallbackExceptionHelper;
        tmp_args_element_name_23 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_8__class_dict);
        tmp_args_element_name_24 = tmp_class_creation_8__class_dict;
        frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e->m_frame.f_lineno = 269;
        {
            PyObject *call_args[] = {tmp_args_element_name_22, tmp_args_element_name_23, tmp_args_element_name_24};
            tmp_assign_source_159 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_9, call_args);
        }

        if (tmp_assign_source_159 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 269;

            goto try_except_handler_27;
        }
        assert(tmp_class_creation_8__class == NULL);
        tmp_class_creation_8__class = tmp_assign_source_159;
    }
    goto try_end_11;
    // Exception handler code:
    try_except_handler_27:;
    exception_keeper_type_16 = exception_type;
    exception_keeper_value_16 = exception_value;
    exception_keeper_tb_16 = exception_tb;
    exception_keeper_lineno_16 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)tmp_class_creation_8__class_dict);
    Py_DECREF(tmp_class_creation_8__class_dict);
    tmp_class_creation_8__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_8__metaclass);
    tmp_class_creation_8__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_16;
    exception_value = exception_keeper_value_16;
    exception_tb = exception_keeper_tb_16;
    exception_lineno = exception_keeper_lineno_16;

    goto frame_exception_exit_1;
    // End of try:
    try_end_11:;
    {
        PyObject *tmp_assign_source_160;
        CHECK_OBJECT(tmp_class_creation_8__class);
        tmp_assign_source_160 = tmp_class_creation_8__class;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper, tmp_assign_source_160);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_8__class);
    Py_DECREF(tmp_class_creation_8__class);
    tmp_class_creation_8__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_8__class_dict);
    Py_DECREF(tmp_class_creation_8__class_dict);
    tmp_class_creation_8__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_8__metaclass);
    Py_DECREF(tmp_class_creation_8__metaclass);
    tmp_class_creation_8__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_161;
        PyObject *tmp_tuple_element_6;
        PyObject *tmp_mvar_value_83;
        tmp_mvar_value_83 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper);

        if (unlikely(tmp_mvar_value_83 == NULL)) {
            tmp_mvar_value_83 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper);
        }

        if (tmp_mvar_value_83 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 90 ], 46, 0);
            exception_tb = NULL;

            exception_lineno = 297;

            goto try_except_handler_28;
        }

        tmp_tuple_element_6 = tmp_mvar_value_83;
        tmp_assign_source_161 = PyTuple_New(1);
        Py_INCREF(tmp_tuple_element_6);
        PyTuple_SET_ITEM(tmp_assign_source_161, 0, tmp_tuple_element_6);
        assert(tmp_class_creation_9__bases == NULL);
        tmp_class_creation_9__bases = tmp_assign_source_161;
    }
    {
        PyObject *tmp_assign_source_162;
        {
            PyObject *tmp_set_locals_6;
            tmp_set_locals_6 = PyDict_New();
            locals_OpenSSL$SSL_297 = tmp_set_locals_6;
        }
        tmp_dictset_value = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_297, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = const_str_digest_1494ae1301cb98a828389add570df55f;
        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_297, const_str_plain___doc__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_3___init__();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_297, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        tmp_assign_source_162 = locals_OpenSSL$SSL_297;
        Py_INCREF(tmp_assign_source_162);
        goto try_return_handler_29;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        // Return handler code:
        try_return_handler_29:;
        Py_DECREF(locals_OpenSSL$SSL_297);
        locals_OpenSSL$SSL_297 = NULL;
        goto outline_result_12;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        outline_result_12:;
        assert(tmp_class_creation_9__class_dict == NULL);
        tmp_class_creation_9__class_dict = tmp_assign_source_162;
    }
    {
        PyObject *tmp_assign_source_163;
        nuitka_bool tmp_condition_result_9;
        PyObject *tmp_key_name_15;
        PyObject *tmp_dict_name_15;
        PyObject *tmp_dict_name_16;
        PyObject *tmp_key_name_16;
        tmp_key_name_15 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_9__class_dict);
        tmp_dict_name_15 = tmp_class_creation_9__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_15, tmp_key_name_15);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 297;

            goto try_except_handler_28;
        }
        tmp_condition_result_9 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_9 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_8;
        } else {
            goto condexpr_false_8;
        }
        condexpr_true_8:;
        CHECK_OBJECT(tmp_class_creation_9__class_dict);
        tmp_dict_name_16 = tmp_class_creation_9__class_dict;
        tmp_key_name_16 = const_str_plain___metaclass__;
        tmp_assign_source_163 = DICT_GET_ITEM(tmp_dict_name_16, tmp_key_name_16);
        if (tmp_assign_source_163 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 297;

            goto try_except_handler_28;
        }
        goto condexpr_end_8;
        condexpr_false_8:;
        {
            PyObject *tmp_assign_source_164;
            PyObject *tmp_subscribed_name_6;
            PyObject *tmp_subscript_name_6;
            CHECK_OBJECT(tmp_class_creation_9__bases);
            tmp_subscribed_name_6 = tmp_class_creation_9__bases;
            tmp_subscript_name_6 = const_int_0;
            tmp_assign_source_164 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_6, tmp_subscript_name_6, 0);
            if (tmp_assign_source_164 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 297;

                goto try_except_handler_28;
            }
            assert(tmp_select_metaclass_9__base == NULL);
            tmp_select_metaclass_9__base = tmp_assign_source_164;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_77;
            CHECK_OBJECT(tmp_select_metaclass_9__base);
            tmp_source_name_77 = tmp_select_metaclass_9__base;
            tmp_assign_source_163 = LOOKUP_ATTRIBUTE_CLASS_SLOT(tmp_source_name_77);
            if (tmp_assign_source_163 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 297;

                goto try_except_handler_31;
            }
            goto try_return_handler_30;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        // Exception handler code:
        try_except_handler_31:;
        exception_keeper_type_17 = exception_type;
        exception_keeper_value_17 = exception_value;
        exception_keeper_tb_17 = exception_tb;
        exception_keeper_lineno_17 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_6;
            Py_DECREF(exception_keeper_type_17);
            Py_XDECREF(exception_keeper_value_17);
            Py_XDECREF(exception_keeper_tb_17);
            CHECK_OBJECT(tmp_select_metaclass_9__base);
            tmp_type_arg_6 = tmp_select_metaclass_9__base;
            tmp_assign_source_163 = BUILTIN_TYPE1(tmp_type_arg_6);
            assert(!(tmp_assign_source_163 == NULL));
            goto try_return_handler_30;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        // Return handler code:
        try_return_handler_30:;
        CHECK_OBJECT((PyObject *)tmp_select_metaclass_9__base);
        Py_DECREF(tmp_select_metaclass_9__base);
        tmp_select_metaclass_9__base = NULL;

        goto outline_result_13;
        // End of try:
        CHECK_OBJECT((PyObject *)tmp_select_metaclass_9__base);
        Py_DECREF(tmp_select_metaclass_9__base);
        tmp_select_metaclass_9__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        outline_result_13:;
        condexpr_end_8:;
        assert(tmp_class_creation_9__metaclass == NULL);
        tmp_class_creation_9__metaclass = tmp_assign_source_163;
    }
    {
        PyObject *tmp_assign_source_165;
        PyObject *tmp_called_name_10;
        PyObject *tmp_args_element_name_25;
        PyObject *tmp_args_element_name_26;
        PyObject *tmp_args_element_name_27;
        CHECK_OBJECT(tmp_class_creation_9__metaclass);
        tmp_called_name_10 = tmp_class_creation_9__metaclass;
        tmp_args_element_name_25 = const_str_plain__VerifyHelper;
        CHECK_OBJECT(tmp_class_creation_9__bases);
        tmp_args_element_name_26 = tmp_class_creation_9__bases;
        CHECK_OBJECT(tmp_class_creation_9__class_dict);
        tmp_args_element_name_27 = tmp_class_creation_9__class_dict;
        frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e->m_frame.f_lineno = 297;
        {
            PyObject *call_args[] = {tmp_args_element_name_25, tmp_args_element_name_26, tmp_args_element_name_27};
            tmp_assign_source_165 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_10, call_args);
        }

        if (tmp_assign_source_165 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 297;

            goto try_except_handler_28;
        }
        assert(tmp_class_creation_9__class == NULL);
        tmp_class_creation_9__class = tmp_assign_source_165;
    }
    goto try_end_12;
    // Exception handler code:
    try_except_handler_28:;
    exception_keeper_type_18 = exception_type;
    exception_keeper_value_18 = exception_value;
    exception_keeper_tb_18 = exception_tb;
    exception_keeper_lineno_18 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_9__bases);
    tmp_class_creation_9__bases = NULL;

    Py_XDECREF(tmp_class_creation_9__class_dict);
    tmp_class_creation_9__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_9__metaclass);
    tmp_class_creation_9__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_18;
    exception_value = exception_keeper_value_18;
    exception_tb = exception_keeper_tb_18;
    exception_lineno = exception_keeper_lineno_18;

    goto frame_exception_exit_1;
    // End of try:
    try_end_12:;
    {
        PyObject *tmp_assign_source_166;
        CHECK_OBJECT(tmp_class_creation_9__class);
        tmp_assign_source_166 = tmp_class_creation_9__class;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__VerifyHelper, tmp_assign_source_166);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_9__class);
    Py_DECREF(tmp_class_creation_9__class);
    tmp_class_creation_9__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_9__bases);
    Py_DECREF(tmp_class_creation_9__bases);
    tmp_class_creation_9__bases = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_9__class_dict);
    Py_DECREF(tmp_class_creation_9__class_dict);
    tmp_class_creation_9__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_9__metaclass);
    Py_DECREF(tmp_class_creation_9__metaclass);
    tmp_class_creation_9__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_167;
        PyObject *tmp_tuple_element_7;
        PyObject *tmp_mvar_value_84;
        tmp_mvar_value_84 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper);

        if (unlikely(tmp_mvar_value_84 == NULL)) {
            tmp_mvar_value_84 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper);
        }

        if (tmp_mvar_value_84 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 90 ], 46, 0);
            exception_tb = NULL;

            exception_lineno = 336;

            goto try_except_handler_32;
        }

        tmp_tuple_element_7 = tmp_mvar_value_84;
        tmp_assign_source_167 = PyTuple_New(1);
        Py_INCREF(tmp_tuple_element_7);
        PyTuple_SET_ITEM(tmp_assign_source_167, 0, tmp_tuple_element_7);
        assert(tmp_class_creation_10__bases == NULL);
        tmp_class_creation_10__bases = tmp_assign_source_167;
    }
    {
        PyObject *tmp_assign_source_168;
        {
            PyObject *tmp_set_locals_7;
            tmp_set_locals_7 = PyDict_New();
            locals_OpenSSL$SSL_336 = tmp_set_locals_7;
        }
        tmp_dictset_value = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_336, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = const_str_digest_bafb2b633667a6bc76266cfd60bf7f9d;
        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_336, const_str_plain___doc__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_4___init__();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_336, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        tmp_assign_source_168 = locals_OpenSSL$SSL_336;
        Py_INCREF(tmp_assign_source_168);
        goto try_return_handler_33;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        // Return handler code:
        try_return_handler_33:;
        Py_DECREF(locals_OpenSSL$SSL_336);
        locals_OpenSSL$SSL_336 = NULL;
        goto outline_result_14;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        outline_result_14:;
        assert(tmp_class_creation_10__class_dict == NULL);
        tmp_class_creation_10__class_dict = tmp_assign_source_168;
    }
    {
        PyObject *tmp_assign_source_169;
        nuitka_bool tmp_condition_result_10;
        PyObject *tmp_key_name_17;
        PyObject *tmp_dict_name_17;
        PyObject *tmp_dict_name_18;
        PyObject *tmp_key_name_18;
        tmp_key_name_17 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_10__class_dict);
        tmp_dict_name_17 = tmp_class_creation_10__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_17, tmp_key_name_17);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 336;

            goto try_except_handler_32;
        }
        tmp_condition_result_10 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_10 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_9;
        } else {
            goto condexpr_false_9;
        }
        condexpr_true_9:;
        CHECK_OBJECT(tmp_class_creation_10__class_dict);
        tmp_dict_name_18 = tmp_class_creation_10__class_dict;
        tmp_key_name_18 = const_str_plain___metaclass__;
        tmp_assign_source_169 = DICT_GET_ITEM(tmp_dict_name_18, tmp_key_name_18);
        if (tmp_assign_source_169 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 336;

            goto try_except_handler_32;
        }
        goto condexpr_end_9;
        condexpr_false_9:;
        {
            PyObject *tmp_assign_source_170;
            PyObject *tmp_subscribed_name_7;
            PyObject *tmp_subscript_name_7;
            CHECK_OBJECT(tmp_class_creation_10__bases);
            tmp_subscribed_name_7 = tmp_class_creation_10__bases;
            tmp_subscript_name_7 = const_int_0;
            tmp_assign_source_170 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_7, tmp_subscript_name_7, 0);
            if (tmp_assign_source_170 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 336;

                goto try_except_handler_32;
            }
            assert(tmp_select_metaclass_10__base == NULL);
            tmp_select_metaclass_10__base = tmp_assign_source_170;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_78;
            CHECK_OBJECT(tmp_select_metaclass_10__base);
            tmp_source_name_78 = tmp_select_metaclass_10__base;
            tmp_assign_source_169 = LOOKUP_ATTRIBUTE_CLASS_SLOT(tmp_source_name_78);
            if (tmp_assign_source_169 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 336;

                goto try_except_handler_35;
            }
            goto try_return_handler_34;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        // Exception handler code:
        try_except_handler_35:;
        exception_keeper_type_19 = exception_type;
        exception_keeper_value_19 = exception_value;
        exception_keeper_tb_19 = exception_tb;
        exception_keeper_lineno_19 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_7;
            Py_DECREF(exception_keeper_type_19);
            Py_XDECREF(exception_keeper_value_19);
            Py_XDECREF(exception_keeper_tb_19);
            CHECK_OBJECT(tmp_select_metaclass_10__base);
            tmp_type_arg_7 = tmp_select_metaclass_10__base;
            tmp_assign_source_169 = BUILTIN_TYPE1(tmp_type_arg_7);
            assert(!(tmp_assign_source_169 == NULL));
            goto try_return_handler_34;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        // Return handler code:
        try_return_handler_34:;
        CHECK_OBJECT((PyObject *)tmp_select_metaclass_10__base);
        Py_DECREF(tmp_select_metaclass_10__base);
        tmp_select_metaclass_10__base = NULL;

        goto outline_result_15;
        // End of try:
        CHECK_OBJECT((PyObject *)tmp_select_metaclass_10__base);
        Py_DECREF(tmp_select_metaclass_10__base);
        tmp_select_metaclass_10__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        outline_result_15:;
        condexpr_end_9:;
        assert(tmp_class_creation_10__metaclass == NULL);
        tmp_class_creation_10__metaclass = tmp_assign_source_169;
    }
    {
        PyObject *tmp_assign_source_171;
        PyObject *tmp_called_name_11;
        PyObject *tmp_args_element_name_28;
        PyObject *tmp_args_element_name_29;
        PyObject *tmp_args_element_name_30;
        CHECK_OBJECT(tmp_class_creation_10__metaclass);
        tmp_called_name_11 = tmp_class_creation_10__metaclass;
        tmp_args_element_name_28 = const_str_plain__NpnAdvertiseHelper;
        CHECK_OBJECT(tmp_class_creation_10__bases);
        tmp_args_element_name_29 = tmp_class_creation_10__bases;
        CHECK_OBJECT(tmp_class_creation_10__class_dict);
        tmp_args_element_name_30 = tmp_class_creation_10__class_dict;
        frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e->m_frame.f_lineno = 336;
        {
            PyObject *call_args[] = {tmp_args_element_name_28, tmp_args_element_name_29, tmp_args_element_name_30};
            tmp_assign_source_171 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_11, call_args);
        }

        if (tmp_assign_source_171 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 336;

            goto try_except_handler_32;
        }
        assert(tmp_class_creation_10__class == NULL);
        tmp_class_creation_10__class = tmp_assign_source_171;
    }
    goto try_end_13;
    // Exception handler code:
    try_except_handler_32:;
    exception_keeper_type_20 = exception_type;
    exception_keeper_value_20 = exception_value;
    exception_keeper_tb_20 = exception_tb;
    exception_keeper_lineno_20 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_10__bases);
    tmp_class_creation_10__bases = NULL;

    Py_XDECREF(tmp_class_creation_10__class_dict);
    tmp_class_creation_10__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_10__metaclass);
    tmp_class_creation_10__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_20;
    exception_value = exception_keeper_value_20;
    exception_tb = exception_keeper_tb_20;
    exception_lineno = exception_keeper_lineno_20;

    goto frame_exception_exit_1;
    // End of try:
    try_end_13:;
    {
        PyObject *tmp_assign_source_172;
        CHECK_OBJECT(tmp_class_creation_10__class);
        tmp_assign_source_172 = tmp_class_creation_10__class;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__NpnAdvertiseHelper, tmp_assign_source_172);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_10__class);
    Py_DECREF(tmp_class_creation_10__class);
    tmp_class_creation_10__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_10__bases);
    Py_DECREF(tmp_class_creation_10__bases);
    tmp_class_creation_10__bases = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_10__class_dict);
    Py_DECREF(tmp_class_creation_10__class_dict);
    tmp_class_creation_10__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_10__metaclass);
    Py_DECREF(tmp_class_creation_10__metaclass);
    tmp_class_creation_10__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_173;
        PyObject *tmp_tuple_element_8;
        PyObject *tmp_mvar_value_85;
        tmp_mvar_value_85 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper);

        if (unlikely(tmp_mvar_value_85 == NULL)) {
            tmp_mvar_value_85 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper);
        }

        if (tmp_mvar_value_85 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 90 ], 46, 0);
            exception_tb = NULL;

            exception_lineno = 377;

            goto try_except_handler_36;
        }

        tmp_tuple_element_8 = tmp_mvar_value_85;
        tmp_assign_source_173 = PyTuple_New(1);
        Py_INCREF(tmp_tuple_element_8);
        PyTuple_SET_ITEM(tmp_assign_source_173, 0, tmp_tuple_element_8);
        assert(tmp_class_creation_11__bases == NULL);
        tmp_class_creation_11__bases = tmp_assign_source_173;
    }
    {
        PyObject *tmp_assign_source_174;
        {
            PyObject *tmp_set_locals_8;
            tmp_set_locals_8 = PyDict_New();
            locals_OpenSSL$SSL_377 = tmp_set_locals_8;
        }
        tmp_dictset_value = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_377, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = const_str_digest_fded22d63d84a836b130c747fc61664e;
        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_377, const_str_plain___doc__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_5___init__();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_377, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        tmp_assign_source_174 = locals_OpenSSL$SSL_377;
        Py_INCREF(tmp_assign_source_174);
        goto try_return_handler_37;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        // Return handler code:
        try_return_handler_37:;
        Py_DECREF(locals_OpenSSL$SSL_377);
        locals_OpenSSL$SSL_377 = NULL;
        goto outline_result_16;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        outline_result_16:;
        assert(tmp_class_creation_11__class_dict == NULL);
        tmp_class_creation_11__class_dict = tmp_assign_source_174;
    }
    {
        PyObject *tmp_assign_source_175;
        nuitka_bool tmp_condition_result_11;
        PyObject *tmp_key_name_19;
        PyObject *tmp_dict_name_19;
        PyObject *tmp_dict_name_20;
        PyObject *tmp_key_name_20;
        tmp_key_name_19 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_11__class_dict);
        tmp_dict_name_19 = tmp_class_creation_11__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_19, tmp_key_name_19);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 377;

            goto try_except_handler_36;
        }
        tmp_condition_result_11 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_11 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_10;
        } else {
            goto condexpr_false_10;
        }
        condexpr_true_10:;
        CHECK_OBJECT(tmp_class_creation_11__class_dict);
        tmp_dict_name_20 = tmp_class_creation_11__class_dict;
        tmp_key_name_20 = const_str_plain___metaclass__;
        tmp_assign_source_175 = DICT_GET_ITEM(tmp_dict_name_20, tmp_key_name_20);
        if (tmp_assign_source_175 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 377;

            goto try_except_handler_36;
        }
        goto condexpr_end_10;
        condexpr_false_10:;
        {
            PyObject *tmp_assign_source_176;
            PyObject *tmp_subscribed_name_8;
            PyObject *tmp_subscript_name_8;
            CHECK_OBJECT(tmp_class_creation_11__bases);
            tmp_subscribed_name_8 = tmp_class_creation_11__bases;
            tmp_subscript_name_8 = const_int_0;
            tmp_assign_source_176 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_8, tmp_subscript_name_8, 0);
            if (tmp_assign_source_176 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 377;

                goto try_except_handler_36;
            }
            assert(tmp_select_metaclass_11__base == NULL);
            tmp_select_metaclass_11__base = tmp_assign_source_176;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_79;
            CHECK_OBJECT(tmp_select_metaclass_11__base);
            tmp_source_name_79 = tmp_select_metaclass_11__base;
            tmp_assign_source_175 = LOOKUP_ATTRIBUTE_CLASS_SLOT(tmp_source_name_79);
            if (tmp_assign_source_175 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 377;

                goto try_except_handler_39;
            }
            goto try_return_handler_38;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        // Exception handler code:
        try_except_handler_39:;
        exception_keeper_type_21 = exception_type;
        exception_keeper_value_21 = exception_value;
        exception_keeper_tb_21 = exception_tb;
        exception_keeper_lineno_21 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_8;
            Py_DECREF(exception_keeper_type_21);
            Py_XDECREF(exception_keeper_value_21);
            Py_XDECREF(exception_keeper_tb_21);
            CHECK_OBJECT(tmp_select_metaclass_11__base);
            tmp_type_arg_8 = tmp_select_metaclass_11__base;
            tmp_assign_source_175 = BUILTIN_TYPE1(tmp_type_arg_8);
            assert(!(tmp_assign_source_175 == NULL));
            goto try_return_handler_38;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        // Return handler code:
        try_return_handler_38:;
        CHECK_OBJECT((PyObject *)tmp_select_metaclass_11__base);
        Py_DECREF(tmp_select_metaclass_11__base);
        tmp_select_metaclass_11__base = NULL;

        goto outline_result_17;
        // End of try:
        CHECK_OBJECT((PyObject *)tmp_select_metaclass_11__base);
        Py_DECREF(tmp_select_metaclass_11__base);
        tmp_select_metaclass_11__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        outline_result_17:;
        condexpr_end_10:;
        assert(tmp_class_creation_11__metaclass == NULL);
        tmp_class_creation_11__metaclass = tmp_assign_source_175;
    }
    {
        PyObject *tmp_assign_source_177;
        PyObject *tmp_called_name_12;
        PyObject *tmp_args_element_name_31;
        PyObject *tmp_args_element_name_32;
        PyObject *tmp_args_element_name_33;
        CHECK_OBJECT(tmp_class_creation_11__metaclass);
        tmp_called_name_12 = tmp_class_creation_11__metaclass;
        tmp_args_element_name_31 = const_str_plain__NpnSelectHelper;
        CHECK_OBJECT(tmp_class_creation_11__bases);
        tmp_args_element_name_32 = tmp_class_creation_11__bases;
        CHECK_OBJECT(tmp_class_creation_11__class_dict);
        tmp_args_element_name_33 = tmp_class_creation_11__class_dict;
        frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e->m_frame.f_lineno = 377;
        {
            PyObject *call_args[] = {tmp_args_element_name_31, tmp_args_element_name_32, tmp_args_element_name_33};
            tmp_assign_source_177 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_12, call_args);
        }

        if (tmp_assign_source_177 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 377;

            goto try_except_handler_36;
        }
        assert(tmp_class_creation_11__class == NULL);
        tmp_class_creation_11__class = tmp_assign_source_177;
    }
    goto try_end_14;
    // Exception handler code:
    try_except_handler_36:;
    exception_keeper_type_22 = exception_type;
    exception_keeper_value_22 = exception_value;
    exception_keeper_tb_22 = exception_tb;
    exception_keeper_lineno_22 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_11__bases);
    tmp_class_creation_11__bases = NULL;

    Py_XDECREF(tmp_class_creation_11__class_dict);
    tmp_class_creation_11__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_11__metaclass);
    tmp_class_creation_11__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_22;
    exception_value = exception_keeper_value_22;
    exception_tb = exception_keeper_tb_22;
    exception_lineno = exception_keeper_lineno_22;

    goto frame_exception_exit_1;
    // End of try:
    try_end_14:;
    {
        PyObject *tmp_assign_source_178;
        CHECK_OBJECT(tmp_class_creation_11__class);
        tmp_assign_source_178 = tmp_class_creation_11__class;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__NpnSelectHelper, tmp_assign_source_178);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_11__class);
    Py_DECREF(tmp_class_creation_11__class);
    tmp_class_creation_11__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_11__bases);
    Py_DECREF(tmp_class_creation_11__bases);
    tmp_class_creation_11__bases = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_11__class_dict);
    Py_DECREF(tmp_class_creation_11__class_dict);
    tmp_class_creation_11__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_11__metaclass);
    Py_DECREF(tmp_class_creation_11__metaclass);
    tmp_class_creation_11__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_179;
        PyObject *tmp_tuple_element_9;
        PyObject *tmp_mvar_value_86;
        tmp_mvar_value_86 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper);

        if (unlikely(tmp_mvar_value_86 == NULL)) {
            tmp_mvar_value_86 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper);
        }

        if (tmp_mvar_value_86 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 90 ], 46, 0);
            exception_tb = NULL;

            exception_lineno = 426;

            goto try_except_handler_40;
        }

        tmp_tuple_element_9 = tmp_mvar_value_86;
        tmp_assign_source_179 = PyTuple_New(1);
        Py_INCREF(tmp_tuple_element_9);
        PyTuple_SET_ITEM(tmp_assign_source_179, 0, tmp_tuple_element_9);
        assert(tmp_class_creation_12__bases == NULL);
        tmp_class_creation_12__bases = tmp_assign_source_179;
    }
    {
        PyObject *tmp_assign_source_180;
        {
            PyObject *tmp_set_locals_9;
            tmp_set_locals_9 = PyDict_New();
            locals_OpenSSL$SSL_426 = tmp_set_locals_9;
        }
        tmp_dictset_value = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_426, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = const_str_digest_a9a754c6f4c1dd488de35af4ae59537f;
        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_426, const_str_plain___doc__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_6___init__();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_426, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        tmp_assign_source_180 = locals_OpenSSL$SSL_426;
        Py_INCREF(tmp_assign_source_180);
        goto try_return_handler_41;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        // Return handler code:
        try_return_handler_41:;
        Py_DECREF(locals_OpenSSL$SSL_426);
        locals_OpenSSL$SSL_426 = NULL;
        goto outline_result_18;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        outline_result_18:;
        assert(tmp_class_creation_12__class_dict == NULL);
        tmp_class_creation_12__class_dict = tmp_assign_source_180;
    }
    {
        PyObject *tmp_assign_source_181;
        nuitka_bool tmp_condition_result_12;
        PyObject *tmp_key_name_21;
        PyObject *tmp_dict_name_21;
        PyObject *tmp_dict_name_22;
        PyObject *tmp_key_name_22;
        tmp_key_name_21 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_12__class_dict);
        tmp_dict_name_21 = tmp_class_creation_12__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_21, tmp_key_name_21);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 426;

            goto try_except_handler_40;
        }
        tmp_condition_result_12 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_12 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_11;
        } else {
            goto condexpr_false_11;
        }
        condexpr_true_11:;
        CHECK_OBJECT(tmp_class_creation_12__class_dict);
        tmp_dict_name_22 = tmp_class_creation_12__class_dict;
        tmp_key_name_22 = const_str_plain___metaclass__;
        tmp_assign_source_181 = DICT_GET_ITEM(tmp_dict_name_22, tmp_key_name_22);
        if (tmp_assign_source_181 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 426;

            goto try_except_handler_40;
        }
        goto condexpr_end_11;
        condexpr_false_11:;
        {
            PyObject *tmp_assign_source_182;
            PyObject *tmp_subscribed_name_9;
            PyObject *tmp_subscript_name_9;
            CHECK_OBJECT(tmp_class_creation_12__bases);
            tmp_subscribed_name_9 = tmp_class_creation_12__bases;
            tmp_subscript_name_9 = const_int_0;
            tmp_assign_source_182 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_9, tmp_subscript_name_9, 0);
            if (tmp_assign_source_182 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 426;

                goto try_except_handler_40;
            }
            assert(tmp_select_metaclass_12__base == NULL);
            tmp_select_metaclass_12__base = tmp_assign_source_182;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_80;
            CHECK_OBJECT(tmp_select_metaclass_12__base);
            tmp_source_name_80 = tmp_select_metaclass_12__base;
            tmp_assign_source_181 = LOOKUP_ATTRIBUTE_CLASS_SLOT(tmp_source_name_80);
            if (tmp_assign_source_181 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 426;

                goto try_except_handler_43;
            }
            goto try_return_handler_42;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        // Exception handler code:
        try_except_handler_43:;
        exception_keeper_type_23 = exception_type;
        exception_keeper_value_23 = exception_value;
        exception_keeper_tb_23 = exception_tb;
        exception_keeper_lineno_23 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_9;
            Py_DECREF(exception_keeper_type_23);
            Py_XDECREF(exception_keeper_value_23);
            Py_XDECREF(exception_keeper_tb_23);
            CHECK_OBJECT(tmp_select_metaclass_12__base);
            tmp_type_arg_9 = tmp_select_metaclass_12__base;
            tmp_assign_source_181 = BUILTIN_TYPE1(tmp_type_arg_9);
            assert(!(tmp_assign_source_181 == NULL));
            goto try_return_handler_42;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        // Return handler code:
        try_return_handler_42:;
        CHECK_OBJECT((PyObject *)tmp_select_metaclass_12__base);
        Py_DECREF(tmp_select_metaclass_12__base);
        tmp_select_metaclass_12__base = NULL;

        goto outline_result_19;
        // End of try:
        CHECK_OBJECT((PyObject *)tmp_select_metaclass_12__base);
        Py_DECREF(tmp_select_metaclass_12__base);
        tmp_select_metaclass_12__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        outline_result_19:;
        condexpr_end_11:;
        assert(tmp_class_creation_12__metaclass == NULL);
        tmp_class_creation_12__metaclass = tmp_assign_source_181;
    }
    {
        PyObject *tmp_assign_source_183;
        PyObject *tmp_called_name_13;
        PyObject *tmp_args_element_name_34;
        PyObject *tmp_args_element_name_35;
        PyObject *tmp_args_element_name_36;
        CHECK_OBJECT(tmp_class_creation_12__metaclass);
        tmp_called_name_13 = tmp_class_creation_12__metaclass;
        tmp_args_element_name_34 = const_str_plain__ALPNSelectHelper;
        CHECK_OBJECT(tmp_class_creation_12__bases);
        tmp_args_element_name_35 = tmp_class_creation_12__bases;
        CHECK_OBJECT(tmp_class_creation_12__class_dict);
        tmp_args_element_name_36 = tmp_class_creation_12__class_dict;
        frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e->m_frame.f_lineno = 426;
        {
            PyObject *call_args[] = {tmp_args_element_name_34, tmp_args_element_name_35, tmp_args_element_name_36};
            tmp_assign_source_183 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_13, call_args);
        }

        if (tmp_assign_source_183 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 426;

            goto try_except_handler_40;
        }
        assert(tmp_class_creation_12__class == NULL);
        tmp_class_creation_12__class = tmp_assign_source_183;
    }
    goto try_end_15;
    // Exception handler code:
    try_except_handler_40:;
    exception_keeper_type_24 = exception_type;
    exception_keeper_value_24 = exception_value;
    exception_keeper_tb_24 = exception_tb;
    exception_keeper_lineno_24 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_12__bases);
    tmp_class_creation_12__bases = NULL;

    Py_XDECREF(tmp_class_creation_12__class_dict);
    tmp_class_creation_12__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_12__metaclass);
    tmp_class_creation_12__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_24;
    exception_value = exception_keeper_value_24;
    exception_tb = exception_keeper_tb_24;
    exception_lineno = exception_keeper_lineno_24;

    goto frame_exception_exit_1;
    // End of try:
    try_end_15:;
    {
        PyObject *tmp_assign_source_184;
        CHECK_OBJECT(tmp_class_creation_12__class);
        tmp_assign_source_184 = tmp_class_creation_12__class;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ALPNSelectHelper, tmp_assign_source_184);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_12__class);
    Py_DECREF(tmp_class_creation_12__class);
    tmp_class_creation_12__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_12__bases);
    Py_DECREF(tmp_class_creation_12__bases);
    tmp_class_creation_12__bases = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_12__class_dict);
    Py_DECREF(tmp_class_creation_12__class_dict);
    tmp_class_creation_12__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_12__metaclass);
    Py_DECREF(tmp_class_creation_12__metaclass);
    tmp_class_creation_12__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_185;
        PyObject *tmp_tuple_element_10;
        PyObject *tmp_mvar_value_87;
        tmp_mvar_value_87 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper);

        if (unlikely(tmp_mvar_value_87 == NULL)) {
            tmp_mvar_value_87 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper);
        }

        if (tmp_mvar_value_87 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 90 ], 46, 0);
            exception_tb = NULL;

            exception_lineno = 477;

            goto try_except_handler_44;
        }

        tmp_tuple_element_10 = tmp_mvar_value_87;
        tmp_assign_source_185 = PyTuple_New(1);
        Py_INCREF(tmp_tuple_element_10);
        PyTuple_SET_ITEM(tmp_assign_source_185, 0, tmp_tuple_element_10);
        assert(tmp_class_creation_13__bases == NULL);
        tmp_class_creation_13__bases = tmp_assign_source_185;
    }
    {
        PyObject *tmp_assign_source_186;
        {
            PyObject *tmp_set_locals_10;
            tmp_set_locals_10 = PyDict_New();
            locals_OpenSSL$SSL_477 = tmp_set_locals_10;
        }
        tmp_dictset_value = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_477, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = const_str_digest_ebc06328e68f0dbdd2e23e3f1f581b13;
        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_477, const_str_plain___doc__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_7___init__();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_477, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        tmp_assign_source_186 = locals_OpenSSL$SSL_477;
        Py_INCREF(tmp_assign_source_186);
        goto try_return_handler_45;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        // Return handler code:
        try_return_handler_45:;
        Py_DECREF(locals_OpenSSL$SSL_477);
        locals_OpenSSL$SSL_477 = NULL;
        goto outline_result_20;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        outline_result_20:;
        assert(tmp_class_creation_13__class_dict == NULL);
        tmp_class_creation_13__class_dict = tmp_assign_source_186;
    }
    {
        PyObject *tmp_assign_source_187;
        nuitka_bool tmp_condition_result_13;
        PyObject *tmp_key_name_23;
        PyObject *tmp_dict_name_23;
        PyObject *tmp_dict_name_24;
        PyObject *tmp_key_name_24;
        tmp_key_name_23 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_13__class_dict);
        tmp_dict_name_23 = tmp_class_creation_13__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_23, tmp_key_name_23);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 477;

            goto try_except_handler_44;
        }
        tmp_condition_result_13 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_13 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_12;
        } else {
            goto condexpr_false_12;
        }
        condexpr_true_12:;
        CHECK_OBJECT(tmp_class_creation_13__class_dict);
        tmp_dict_name_24 = tmp_class_creation_13__class_dict;
        tmp_key_name_24 = const_str_plain___metaclass__;
        tmp_assign_source_187 = DICT_GET_ITEM(tmp_dict_name_24, tmp_key_name_24);
        if (tmp_assign_source_187 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 477;

            goto try_except_handler_44;
        }
        goto condexpr_end_12;
        condexpr_false_12:;
        {
            PyObject *tmp_assign_source_188;
            PyObject *tmp_subscribed_name_10;
            PyObject *tmp_subscript_name_10;
            CHECK_OBJECT(tmp_class_creation_13__bases);
            tmp_subscribed_name_10 = tmp_class_creation_13__bases;
            tmp_subscript_name_10 = const_int_0;
            tmp_assign_source_188 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_10, tmp_subscript_name_10, 0);
            if (tmp_assign_source_188 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 477;

                goto try_except_handler_44;
            }
            assert(tmp_select_metaclass_13__base == NULL);
            tmp_select_metaclass_13__base = tmp_assign_source_188;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_81;
            CHECK_OBJECT(tmp_select_metaclass_13__base);
            tmp_source_name_81 = tmp_select_metaclass_13__base;
            tmp_assign_source_187 = LOOKUP_ATTRIBUTE_CLASS_SLOT(tmp_source_name_81);
            if (tmp_assign_source_187 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 477;

                goto try_except_handler_47;
            }
            goto try_return_handler_46;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        // Exception handler code:
        try_except_handler_47:;
        exception_keeper_type_25 = exception_type;
        exception_keeper_value_25 = exception_value;
        exception_keeper_tb_25 = exception_tb;
        exception_keeper_lineno_25 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_10;
            Py_DECREF(exception_keeper_type_25);
            Py_XDECREF(exception_keeper_value_25);
            Py_XDECREF(exception_keeper_tb_25);
            CHECK_OBJECT(tmp_select_metaclass_13__base);
            tmp_type_arg_10 = tmp_select_metaclass_13__base;
            tmp_assign_source_187 = BUILTIN_TYPE1(tmp_type_arg_10);
            assert(!(tmp_assign_source_187 == NULL));
            goto try_return_handler_46;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        // Return handler code:
        try_return_handler_46:;
        CHECK_OBJECT((PyObject *)tmp_select_metaclass_13__base);
        Py_DECREF(tmp_select_metaclass_13__base);
        tmp_select_metaclass_13__base = NULL;

        goto outline_result_21;
        // End of try:
        CHECK_OBJECT((PyObject *)tmp_select_metaclass_13__base);
        Py_DECREF(tmp_select_metaclass_13__base);
        tmp_select_metaclass_13__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        outline_result_21:;
        condexpr_end_12:;
        assert(tmp_class_creation_13__metaclass == NULL);
        tmp_class_creation_13__metaclass = tmp_assign_source_187;
    }
    {
        PyObject *tmp_assign_source_189;
        PyObject *tmp_called_name_14;
        PyObject *tmp_args_element_name_37;
        PyObject *tmp_args_element_name_38;
        PyObject *tmp_args_element_name_39;
        CHECK_OBJECT(tmp_class_creation_13__metaclass);
        tmp_called_name_14 = tmp_class_creation_13__metaclass;
        tmp_args_element_name_37 = const_str_plain__OCSPServerCallbackHelper;
        CHECK_OBJECT(tmp_class_creation_13__bases);
        tmp_args_element_name_38 = tmp_class_creation_13__bases;
        CHECK_OBJECT(tmp_class_creation_13__class_dict);
        tmp_args_element_name_39 = tmp_class_creation_13__class_dict;
        frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e->m_frame.f_lineno = 477;
        {
            PyObject *call_args[] = {tmp_args_element_name_37, tmp_args_element_name_38, tmp_args_element_name_39};
            tmp_assign_source_189 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_14, call_args);
        }

        if (tmp_assign_source_189 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 477;

            goto try_except_handler_44;
        }
        assert(tmp_class_creation_13__class == NULL);
        tmp_class_creation_13__class = tmp_assign_source_189;
    }
    goto try_end_16;
    // Exception handler code:
    try_except_handler_44:;
    exception_keeper_type_26 = exception_type;
    exception_keeper_value_26 = exception_value;
    exception_keeper_tb_26 = exception_tb;
    exception_keeper_lineno_26 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_13__bases);
    tmp_class_creation_13__bases = NULL;

    Py_XDECREF(tmp_class_creation_13__class_dict);
    tmp_class_creation_13__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_13__metaclass);
    tmp_class_creation_13__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_26;
    exception_value = exception_keeper_value_26;
    exception_tb = exception_keeper_tb_26;
    exception_lineno = exception_keeper_lineno_26;

    goto frame_exception_exit_1;
    // End of try:
    try_end_16:;
    {
        PyObject *tmp_assign_source_190;
        CHECK_OBJECT(tmp_class_creation_13__class);
        tmp_assign_source_190 = tmp_class_creation_13__class;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__OCSPServerCallbackHelper, tmp_assign_source_190);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_13__class);
    Py_DECREF(tmp_class_creation_13__class);
    tmp_class_creation_13__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_13__bases);
    Py_DECREF(tmp_class_creation_13__bases);
    tmp_class_creation_13__bases = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_13__class_dict);
    Py_DECREF(tmp_class_creation_13__class_dict);
    tmp_class_creation_13__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_13__metaclass);
    Py_DECREF(tmp_class_creation_13__metaclass);
    tmp_class_creation_13__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_191;
        PyObject *tmp_tuple_element_11;
        PyObject *tmp_mvar_value_88;
        tmp_mvar_value_88 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper);

        if (unlikely(tmp_mvar_value_88 == NULL)) {
            tmp_mvar_value_88 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper);
        }

        if (tmp_mvar_value_88 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 90 ], 46, 0);
            exception_tb = NULL;

            exception_lineno = 544;

            goto try_except_handler_48;
        }

        tmp_tuple_element_11 = tmp_mvar_value_88;
        tmp_assign_source_191 = PyTuple_New(1);
        Py_INCREF(tmp_tuple_element_11);
        PyTuple_SET_ITEM(tmp_assign_source_191, 0, tmp_tuple_element_11);
        assert(tmp_class_creation_14__bases == NULL);
        tmp_class_creation_14__bases = tmp_assign_source_191;
    }
    {
        PyObject *tmp_assign_source_192;
        {
            PyObject *tmp_set_locals_11;
            tmp_set_locals_11 = PyDict_New();
            locals_OpenSSL$SSL_544 = tmp_set_locals_11;
        }
        tmp_dictset_value = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_544, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = const_str_digest_fd8757ca246c476601094123086e9a80;
        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_544, const_str_plain___doc__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_8___init__();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_544, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        tmp_assign_source_192 = locals_OpenSSL$SSL_544;
        Py_INCREF(tmp_assign_source_192);
        goto try_return_handler_49;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        // Return handler code:
        try_return_handler_49:;
        Py_DECREF(locals_OpenSSL$SSL_544);
        locals_OpenSSL$SSL_544 = NULL;
        goto outline_result_22;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        outline_result_22:;
        assert(tmp_class_creation_14__class_dict == NULL);
        tmp_class_creation_14__class_dict = tmp_assign_source_192;
    }
    {
        PyObject *tmp_assign_source_193;
        nuitka_bool tmp_condition_result_14;
        PyObject *tmp_key_name_25;
        PyObject *tmp_dict_name_25;
        PyObject *tmp_dict_name_26;
        PyObject *tmp_key_name_26;
        tmp_key_name_25 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_14__class_dict);
        tmp_dict_name_25 = tmp_class_creation_14__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_25, tmp_key_name_25);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 544;

            goto try_except_handler_48;
        }
        tmp_condition_result_14 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_14 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_13;
        } else {
            goto condexpr_false_13;
        }
        condexpr_true_13:;
        CHECK_OBJECT(tmp_class_creation_14__class_dict);
        tmp_dict_name_26 = tmp_class_creation_14__class_dict;
        tmp_key_name_26 = const_str_plain___metaclass__;
        tmp_assign_source_193 = DICT_GET_ITEM(tmp_dict_name_26, tmp_key_name_26);
        if (tmp_assign_source_193 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 544;

            goto try_except_handler_48;
        }
        goto condexpr_end_13;
        condexpr_false_13:;
        {
            PyObject *tmp_assign_source_194;
            PyObject *tmp_subscribed_name_11;
            PyObject *tmp_subscript_name_11;
            CHECK_OBJECT(tmp_class_creation_14__bases);
            tmp_subscribed_name_11 = tmp_class_creation_14__bases;
            tmp_subscript_name_11 = const_int_0;
            tmp_assign_source_194 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_11, tmp_subscript_name_11, 0);
            if (tmp_assign_source_194 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 544;

                goto try_except_handler_48;
            }
            assert(tmp_select_metaclass_14__base == NULL);
            tmp_select_metaclass_14__base = tmp_assign_source_194;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_82;
            CHECK_OBJECT(tmp_select_metaclass_14__base);
            tmp_source_name_82 = tmp_select_metaclass_14__base;
            tmp_assign_source_193 = LOOKUP_ATTRIBUTE_CLASS_SLOT(tmp_source_name_82);
            if (tmp_assign_source_193 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 544;

                goto try_except_handler_51;
            }
            goto try_return_handler_50;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        // Exception handler code:
        try_except_handler_51:;
        exception_keeper_type_27 = exception_type;
        exception_keeper_value_27 = exception_value;
        exception_keeper_tb_27 = exception_tb;
        exception_keeper_lineno_27 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_11;
            Py_DECREF(exception_keeper_type_27);
            Py_XDECREF(exception_keeper_value_27);
            Py_XDECREF(exception_keeper_tb_27);
            CHECK_OBJECT(tmp_select_metaclass_14__base);
            tmp_type_arg_11 = tmp_select_metaclass_14__base;
            tmp_assign_source_193 = BUILTIN_TYPE1(tmp_type_arg_11);
            assert(!(tmp_assign_source_193 == NULL));
            goto try_return_handler_50;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        // Return handler code:
        try_return_handler_50:;
        CHECK_OBJECT((PyObject *)tmp_select_metaclass_14__base);
        Py_DECREF(tmp_select_metaclass_14__base);
        tmp_select_metaclass_14__base = NULL;

        goto outline_result_23;
        // End of try:
        CHECK_OBJECT((PyObject *)tmp_select_metaclass_14__base);
        Py_DECREF(tmp_select_metaclass_14__base);
        tmp_select_metaclass_14__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        outline_result_23:;
        condexpr_end_13:;
        assert(tmp_class_creation_14__metaclass == NULL);
        tmp_class_creation_14__metaclass = tmp_assign_source_193;
    }
    {
        PyObject *tmp_assign_source_195;
        PyObject *tmp_called_name_15;
        PyObject *tmp_args_element_name_40;
        PyObject *tmp_args_element_name_41;
        PyObject *tmp_args_element_name_42;
        CHECK_OBJECT(tmp_class_creation_14__metaclass);
        tmp_called_name_15 = tmp_class_creation_14__metaclass;
        tmp_args_element_name_40 = const_str_plain__OCSPClientCallbackHelper;
        CHECK_OBJECT(tmp_class_creation_14__bases);
        tmp_args_element_name_41 = tmp_class_creation_14__bases;
        CHECK_OBJECT(tmp_class_creation_14__class_dict);
        tmp_args_element_name_42 = tmp_class_creation_14__class_dict;
        frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e->m_frame.f_lineno = 544;
        {
            PyObject *call_args[] = {tmp_args_element_name_40, tmp_args_element_name_41, tmp_args_element_name_42};
            tmp_assign_source_195 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_15, call_args);
        }

        if (tmp_assign_source_195 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 544;

            goto try_except_handler_48;
        }
        assert(tmp_class_creation_14__class == NULL);
        tmp_class_creation_14__class = tmp_assign_source_195;
    }
    goto try_end_17;
    // Exception handler code:
    try_except_handler_48:;
    exception_keeper_type_28 = exception_type;
    exception_keeper_value_28 = exception_value;
    exception_keeper_tb_28 = exception_tb;
    exception_keeper_lineno_28 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_14__bases);
    tmp_class_creation_14__bases = NULL;

    Py_XDECREF(tmp_class_creation_14__class_dict);
    tmp_class_creation_14__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_14__metaclass);
    tmp_class_creation_14__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_28;
    exception_value = exception_keeper_value_28;
    exception_tb = exception_keeper_tb_28;
    exception_lineno = exception_keeper_lineno_28;

    goto frame_exception_exit_1;
    // End of try:
    try_end_17:;
    {
        PyObject *tmp_assign_source_196;
        CHECK_OBJECT(tmp_class_creation_14__class);
        tmp_assign_source_196 = tmp_class_creation_14__class;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__OCSPClientCallbackHelper, tmp_assign_source_196);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_14__class);
    Py_DECREF(tmp_class_creation_14__class);
    tmp_class_creation_14__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_14__bases);
    Py_DECREF(tmp_class_creation_14__bases);
    tmp_class_creation_14__bases = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_14__class_dict);
    Py_DECREF(tmp_class_creation_14__class_dict);
    tmp_class_creation_14__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_14__metaclass);
    Py_DECREF(tmp_class_creation_14__metaclass);
    tmp_class_creation_14__metaclass = NULL;

    {
        PyObject *tmp_assign_source_197;
        tmp_assign_source_197 = MAKE_FUNCTION_OpenSSL$SSL$$$function_9__asFileDescriptor();



        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__asFileDescriptor, tmp_assign_source_197);
    }
    {
        PyObject *tmp_assign_source_198;
        tmp_assign_source_198 = MAKE_FUNCTION_OpenSSL$SSL$$$function_10_SSLeay_version();



        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSLeay_version, tmp_assign_source_198);
    }
    {
        PyObject *tmp_assign_source_199;
        tmp_assign_source_199 = MAKE_FUNCTION_OpenSSL$SSL$$$function_11__make_requires();



        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__make_requires, tmp_assign_source_199);
    }
    {
        PyObject *tmp_assign_source_200;
        PyObject *tmp_called_name_16;
        PyObject *tmp_mvar_value_89;
        PyObject *tmp_args_element_name_43;
        PyObject *tmp_source_name_83;
        PyObject *tmp_mvar_value_90;
        PyObject *tmp_args_element_name_44;
        tmp_mvar_value_89 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__make_requires);

        if (unlikely(tmp_mvar_value_89 == NULL)) {
            tmp_mvar_value_89 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__make_requires);
        }

        CHECK_OBJECT(tmp_mvar_value_89);
        tmp_called_name_16 = tmp_mvar_value_89;
        tmp_mvar_value_90 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_90 == NULL)) {
            tmp_mvar_value_90 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_90 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 654;

            goto frame_exception_exit_1;
        }

        tmp_source_name_83 = tmp_mvar_value_90;
        tmp_args_element_name_43 = LOOKUP_ATTRIBUTE(tmp_source_name_83, const_str_plain_Cryptography_HAS_NEXTPROTONEG);
        if (tmp_args_element_name_43 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 654;

            goto frame_exception_exit_1;
        }
        tmp_args_element_name_44 = const_str_digest_47543c17fa95d5ac5c9bf71145417a30;
        frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e->m_frame.f_lineno = 653;
        {
            PyObject *call_args[] = {tmp_args_element_name_43, tmp_args_element_name_44};
            tmp_assign_source_200 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_16, call_args);
        }

        Py_DECREF(tmp_args_element_name_43);
        if (tmp_assign_source_200 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 653;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__requires_npn, tmp_assign_source_200);
    }
    {
        PyObject *tmp_assign_source_201;
        PyObject *tmp_called_name_17;
        PyObject *tmp_mvar_value_91;
        PyObject *tmp_args_element_name_45;
        PyObject *tmp_source_name_84;
        PyObject *tmp_mvar_value_92;
        PyObject *tmp_args_element_name_46;
        tmp_mvar_value_91 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__make_requires);

        if (unlikely(tmp_mvar_value_91 == NULL)) {
            tmp_mvar_value_91 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__make_requires);
        }

        if (tmp_mvar_value_91 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 2167 ], 36, 0);
            exception_tb = NULL;

            exception_lineno = 658;

            goto frame_exception_exit_1;
        }

        tmp_called_name_17 = tmp_mvar_value_91;
        tmp_mvar_value_92 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_92 == NULL)) {
            tmp_mvar_value_92 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_92 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 659;

            goto frame_exception_exit_1;
        }

        tmp_source_name_84 = tmp_mvar_value_92;
        tmp_args_element_name_45 = LOOKUP_ATTRIBUTE(tmp_source_name_84, const_str_plain_Cryptography_HAS_ALPN);
        if (tmp_args_element_name_45 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 659;

            goto frame_exception_exit_1;
        }
        tmp_args_element_name_46 = const_str_digest_616719c4a0cde3344203a07484a7fb54;
        frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e->m_frame.f_lineno = 658;
        {
            PyObject *call_args[] = {tmp_args_element_name_45, tmp_args_element_name_46};
            tmp_assign_source_201 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_17, call_args);
        }

        Py_DECREF(tmp_args_element_name_45);
        if (tmp_assign_source_201 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 658;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__requires_alpn, tmp_assign_source_201);
    }
    {
        PyObject *tmp_assign_source_202;
        PyObject *tmp_called_name_18;
        PyObject *tmp_mvar_value_93;
        PyObject *tmp_args_element_name_47;
        PyObject *tmp_source_name_85;
        PyObject *tmp_mvar_value_94;
        PyObject *tmp_args_element_name_48;
        tmp_mvar_value_93 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__make_requires);

        if (unlikely(tmp_mvar_value_93 == NULL)) {
            tmp_mvar_value_93 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__make_requires);
        }

        if (tmp_mvar_value_93 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 2167 ], 36, 0);
            exception_tb = NULL;

            exception_lineno = 663;

            goto frame_exception_exit_1;
        }

        tmp_called_name_18 = tmp_mvar_value_93;
        tmp_mvar_value_94 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_94 == NULL)) {
            tmp_mvar_value_94 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_94 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 664;

            goto frame_exception_exit_1;
        }

        tmp_source_name_85 = tmp_mvar_value_94;
        tmp_args_element_name_47 = LOOKUP_ATTRIBUTE(tmp_source_name_85, const_str_plain_Cryptography_HAS_TLSEXT_HOSTNAME);
        if (tmp_args_element_name_47 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 664;

            goto frame_exception_exit_1;
        }
        tmp_args_element_name_48 = const_str_digest_94c36790285a25f5d9268c8333413cf2;
        frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e->m_frame.f_lineno = 663;
        {
            PyObject *call_args[] = {tmp_args_element_name_47, tmp_args_element_name_48};
            tmp_assign_source_202 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_18, call_args);
        }

        Py_DECREF(tmp_args_element_name_47);
        if (tmp_assign_source_202 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 663;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__requires_sni, tmp_assign_source_202);
    }
    {
        PyObject *tmp_assign_source_203;
        tmp_assign_source_203 = PyDict_Copy(const_dict_c3a065e676a930b8196978eb12fcba71);
        assert(tmp_class_creation_15__class_dict == NULL);
        tmp_class_creation_15__class_dict = tmp_assign_source_203;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_204;
        nuitka_bool tmp_condition_result_15;
        PyObject *tmp_key_name_27;
        PyObject *tmp_dict_name_27;
        PyObject *tmp_dict_name_28;
        PyObject *tmp_key_name_28;
        tmp_key_name_27 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_15__class_dict);
        tmp_dict_name_27 = tmp_class_creation_15__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_27, tmp_key_name_27);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 668;

            goto try_except_handler_52;
        }
        tmp_condition_result_15 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_15 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_14;
        } else {
            goto condexpr_false_14;
        }
        condexpr_true_14:;
        CHECK_OBJECT(tmp_class_creation_15__class_dict);
        tmp_dict_name_28 = tmp_class_creation_15__class_dict;
        tmp_key_name_28 = const_str_plain___metaclass__;
        tmp_assign_source_204 = DICT_GET_ITEM(tmp_dict_name_28, tmp_key_name_28);
        if (tmp_assign_source_204 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 668;

            goto try_except_handler_52;
        }
        goto condexpr_end_14;
        condexpr_false_14:;
        tmp_assign_source_204 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_204);
        condexpr_end_14:;
        assert(tmp_class_creation_15__metaclass == NULL);
        tmp_class_creation_15__metaclass = tmp_assign_source_204;
    }
    {
        PyObject *tmp_assign_source_205;
        PyObject *tmp_called_name_19;
        PyObject *tmp_args_element_name_49;
        PyObject *tmp_args_element_name_50;
        PyObject *tmp_args_element_name_51;
        CHECK_OBJECT(tmp_class_creation_15__metaclass);
        tmp_called_name_19 = tmp_class_creation_15__metaclass;
        tmp_args_element_name_49 = const_str_plain_Session;
        tmp_args_element_name_50 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_15__class_dict);
        tmp_args_element_name_51 = tmp_class_creation_15__class_dict;
        frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e->m_frame.f_lineno = 668;
        {
            PyObject *call_args[] = {tmp_args_element_name_49, tmp_args_element_name_50, tmp_args_element_name_51};
            tmp_assign_source_205 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_19, call_args);
        }

        if (tmp_assign_source_205 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 668;

            goto try_except_handler_52;
        }
        assert(tmp_class_creation_15__class == NULL);
        tmp_class_creation_15__class = tmp_assign_source_205;
    }
    goto try_end_18;
    // Exception handler code:
    try_except_handler_52:;
    exception_keeper_type_29 = exception_type;
    exception_keeper_value_29 = exception_value;
    exception_keeper_tb_29 = exception_tb;
    exception_keeper_lineno_29 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)tmp_class_creation_15__class_dict);
    Py_DECREF(tmp_class_creation_15__class_dict);
    tmp_class_creation_15__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_15__metaclass);
    tmp_class_creation_15__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_29;
    exception_value = exception_keeper_value_29;
    exception_tb = exception_keeper_tb_29;
    exception_lineno = exception_keeper_lineno_29;

    goto frame_exception_exit_1;
    // End of try:
    try_end_18:;
    {
        PyObject *tmp_assign_source_206;
        CHECK_OBJECT(tmp_class_creation_15__class);
        tmp_assign_source_206 = tmp_class_creation_15__class;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Session, tmp_assign_source_206);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_15__class);
    Py_DECREF(tmp_class_creation_15__class);
    tmp_class_creation_15__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_15__class_dict);
    Py_DECREF(tmp_class_creation_15__class_dict);
    tmp_class_creation_15__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_15__metaclass);
    Py_DECREF(tmp_class_creation_15__metaclass);
    tmp_class_creation_15__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_207;
        {
            PyObject *tmp_set_locals_12;
            tmp_set_locals_12 = PyDict_New();
            locals_OpenSSL$SSL_679 = tmp_set_locals_12;
        }
        tmp_dictset_value = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = const_str_digest_91220ffd97efb14a503e0ecf9d7ff0d1;
        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain___doc__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_d641b83c6dc81d8049e076a80fd0abcb_2, codeobj_d641b83c6dc81d8049e076a80fd0abcb, module_OpenSSL$SSL, 0);
        frame_d641b83c6dc81d8049e076a80fd0abcb_2 = cache_frame_d641b83c6dc81d8049e076a80fd0abcb_2;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_d641b83c6dc81d8049e076a80fd0abcb_2);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_d641b83c6dc81d8049e076a80fd0abcb_2) == 2); // Frame stack

        // Framed code:
        {
            PyObject *tmp_dict_key_5;
            PyObject *tmp_dict_value_5;
            PyObject *tmp_mvar_value_95;
            PyObject *tmp_dict_key_6;
            PyObject *tmp_dict_value_6;
            PyObject *tmp_mvar_value_96;
            PyObject *tmp_dict_key_7;
            PyObject *tmp_dict_value_7;
            PyObject *tmp_mvar_value_97;
            PyObject *tmp_dict_key_8;
            PyObject *tmp_dict_value_8;
            PyObject *tmp_mvar_value_98;
            PyObject *tmp_dict_key_9;
            PyObject *tmp_dict_value_9;
            PyObject *tmp_mvar_value_99;
            PyObject *tmp_dict_key_10;
            PyObject *tmp_dict_value_10;
            PyObject *tmp_mvar_value_100;
            tmp_dict_value_5 = const_str_plain_SSLv2_method;
            tmp_mvar_value_95 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSLv2_METHOD);

            if (unlikely(tmp_mvar_value_95 == NULL)) {
                tmp_mvar_value_95 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_SSLv2_METHOD);
            }

            if (tmp_mvar_value_95 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 2203 ], 34, 0);
                exception_tb = NULL;

                exception_lineno = 688;

                goto frame_exception_exit_2;
            }

            tmp_dict_key_5 = tmp_mvar_value_95;
            tmp_dictset_value = _PyDict_NewPresized( 6 );
            tmp_res = PyDict_SetItem(tmp_dictset_value, tmp_dict_key_5, tmp_dict_value_5);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_dictset_value);

                exception_lineno = 687;

                goto frame_exception_exit_2;
            }
            tmp_dict_value_6 = const_str_plain_SSLv3_method;
            tmp_mvar_value_96 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSLv3_METHOD);

            if (unlikely(tmp_mvar_value_96 == NULL)) {
                tmp_mvar_value_96 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_SSLv3_METHOD);
            }

            if (tmp_mvar_value_96 == NULL) {
                Py_DECREF(tmp_dictset_value);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 2237 ], 34, 0);
                exception_tb = NULL;

                exception_lineno = 689;

                goto frame_exception_exit_2;
            }

            tmp_dict_key_6 = tmp_mvar_value_96;
            tmp_res = PyDict_SetItem(tmp_dictset_value, tmp_dict_key_6, tmp_dict_value_6);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_dictset_value);

                exception_lineno = 687;

                goto frame_exception_exit_2;
            }
            tmp_dict_value_7 = const_str_plain_SSLv23_method;
            tmp_mvar_value_97 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSLv23_METHOD);

            if (unlikely(tmp_mvar_value_97 == NULL)) {
                tmp_mvar_value_97 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_SSLv23_METHOD);
            }

            if (tmp_mvar_value_97 == NULL) {
                Py_DECREF(tmp_dictset_value);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 2271 ], 35, 0);
                exception_tb = NULL;

                exception_lineno = 690;

                goto frame_exception_exit_2;
            }

            tmp_dict_key_7 = tmp_mvar_value_97;
            tmp_res = PyDict_SetItem(tmp_dictset_value, tmp_dict_key_7, tmp_dict_value_7);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_dictset_value);

                exception_lineno = 687;

                goto frame_exception_exit_2;
            }
            tmp_dict_value_8 = const_str_plain_TLSv1_method;
            tmp_mvar_value_98 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_TLSv1_METHOD);

            if (unlikely(tmp_mvar_value_98 == NULL)) {
                tmp_mvar_value_98 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_TLSv1_METHOD);
            }

            if (tmp_mvar_value_98 == NULL) {
                Py_DECREF(tmp_dictset_value);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 2306 ], 34, 0);
                exception_tb = NULL;

                exception_lineno = 691;

                goto frame_exception_exit_2;
            }

            tmp_dict_key_8 = tmp_mvar_value_98;
            tmp_res = PyDict_SetItem(tmp_dictset_value, tmp_dict_key_8, tmp_dict_value_8);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_dictset_value);

                exception_lineno = 687;

                goto frame_exception_exit_2;
            }
            tmp_dict_value_9 = const_str_plain_TLSv1_1_method;
            tmp_mvar_value_99 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_TLSv1_1_METHOD);

            if (unlikely(tmp_mvar_value_99 == NULL)) {
                tmp_mvar_value_99 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_TLSv1_1_METHOD);
            }

            if (tmp_mvar_value_99 == NULL) {
                Py_DECREF(tmp_dictset_value);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 2340 ], 36, 0);
                exception_tb = NULL;

                exception_lineno = 692;

                goto frame_exception_exit_2;
            }

            tmp_dict_key_9 = tmp_mvar_value_99;
            tmp_res = PyDict_SetItem(tmp_dictset_value, tmp_dict_key_9, tmp_dict_value_9);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_dictset_value);

                exception_lineno = 687;

                goto frame_exception_exit_2;
            }
            tmp_dict_value_10 = const_str_plain_TLSv1_2_method;
            tmp_mvar_value_100 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_TLSv1_2_METHOD);

            if (unlikely(tmp_mvar_value_100 == NULL)) {
                tmp_mvar_value_100 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_TLSv1_2_METHOD);
            }

            if (tmp_mvar_value_100 == NULL) {
                Py_DECREF(tmp_dictset_value);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 2376 ], 36, 0);
                exception_tb = NULL;

                exception_lineno = 693;

                goto frame_exception_exit_2;
            }

            tmp_dict_key_10 = tmp_mvar_value_100;
            tmp_res = PyDict_SetItem(tmp_dictset_value, tmp_dict_key_10, tmp_dict_value_10);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_dictset_value);

                exception_lineno = 687;

                goto frame_exception_exit_2;
            }
            tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain__methods, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 687;

                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_dict_seq_1;
            {
                PyObject *tmp_assign_source_208;
                PyObject *tmp_iter_arg_1;
                PyObject *tmp_called_instance_2;
                tmp_called_instance_2 = PyDict_GetItem(locals_OpenSSL$SSL_679, const_str_plain__methods);

                if (tmp_called_instance_2 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 2412 ], 30, 0);
                    exception_tb = NULL;

                    exception_lineno = 697;

                    goto frame_exception_exit_2;
                }

                if (tmp_called_instance_2 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 697;

                    goto frame_exception_exit_2;
                }
                frame_d641b83c6dc81d8049e076a80fd0abcb_2->m_frame.f_lineno = 697;
                tmp_iter_arg_1 = CALL_METHOD_NO_ARGS(tmp_called_instance_2, const_str_plain_items);
                if (tmp_iter_arg_1 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 697;

                    goto frame_exception_exit_2;
                }
                tmp_assign_source_208 = MAKE_ITERATOR(tmp_iter_arg_1);
                Py_DECREF(tmp_iter_arg_1);
                if (tmp_assign_source_208 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 696;

                    goto frame_exception_exit_2;
                }
                assert(tmp_Context$genexpr_1__$0 == NULL);
                tmp_Context$genexpr_1__$0 = tmp_assign_source_208;
            }
            // Tried code:
            tmp_dict_seq_1 = OpenSSL$SSL$$$genexpr_1_genexpr_maker();

            ((struct Nuitka_GeneratorObject *)tmp_dict_seq_1)->m_closure[0] = PyCell_NEW0(tmp_Context$genexpr_1__$0);


            goto try_return_handler_55;
            // tried codes exits in all cases
            NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
            return NULL;
            // Return handler code:
            try_return_handler_55:;
            CHECK_OBJECT((PyObject *)tmp_Context$genexpr_1__$0);
            Py_DECREF(tmp_Context$genexpr_1__$0);
            tmp_Context$genexpr_1__$0 = NULL;

            goto outline_result_25;
            // End of try:
            CHECK_OBJECT((PyObject *)tmp_Context$genexpr_1__$0);
            Py_DECREF(tmp_Context$genexpr_1__$0);
            tmp_Context$genexpr_1__$0 = NULL;

            // Return statement must have exited already.
            NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
            return NULL;
            outline_result_25:;
            tmp_dictset_value = TO_DICT(tmp_dict_seq_1, NULL);
            Py_DECREF(tmp_dict_seq_1);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 695;

                goto frame_exception_exit_2;
            }
            tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain__methods, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 695;

                goto frame_exception_exit_2;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_12___init__();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        {
            PyObject *tmp_defaults_1;
            tmp_defaults_1 = const_tuple_none_tuple;
            Py_INCREF(tmp_defaults_1);
            tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_13_load_verify_locations(tmp_defaults_1);



            tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain_load_verify_locations, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            assert(!(tmp_res != 0));
        }
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_14__wrap_callback();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain__wrap_callback, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        {
            PyObject *tmp_defaults_2;
            tmp_defaults_2 = const_tuple_none_tuple;
            Py_INCREF(tmp_defaults_2);
            tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_15_set_passwd_cb(tmp_defaults_2);



            tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain_set_passwd_cb, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            assert(!(tmp_res != 0));
        }
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_16_set_default_verify_paths();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain_set_default_verify_paths, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_17__check_env_vars_set();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain__check_env_vars_set, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_18__fallback_default_verify_paths();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain__fallback_default_verify_paths, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_19_use_certificate_chain_file();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain_use_certificate_chain_file, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        {
            PyObject *tmp_defaults_3;
            PyObject *tmp_tuple_element_12;
            PyObject *tmp_mvar_value_101;
            tmp_mvar_value_101 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM);

            if (unlikely(tmp_mvar_value_101 == NULL)) {
                tmp_mvar_value_101 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM);
            }

            if (tmp_mvar_value_101 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 639 ], 34, 0);
                exception_tb = NULL;

                exception_lineno = 910;

                goto frame_exception_exit_2;
            }

            tmp_tuple_element_12 = tmp_mvar_value_101;
            tmp_defaults_3 = PyTuple_New(1);
            Py_INCREF(tmp_tuple_element_12);
            PyTuple_SET_ITEM(tmp_defaults_3, 0, tmp_tuple_element_12);
            tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_20_use_certificate_file(tmp_defaults_3);



            tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain_use_certificate_file, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 910;

                goto frame_exception_exit_2;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_21_use_certificate();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain_use_certificate, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_22_add_extra_chain_cert();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain_add_extra_chain_cert, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_23__raise_passphrase_exception();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain__raise_passphrase_exception, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        {
            PyObject *tmp_defaults_4;
            PyObject *tmp_tuple_element_13;
            PyObject *tmp_mvar_value_102;
            tmp_mvar_value_102 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__UNSPECIFIED);

            if (unlikely(tmp_mvar_value_102 == NULL)) {
                tmp_mvar_value_102 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__UNSPECIFIED);
            }

            if (tmp_mvar_value_102 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 944 ], 34, 0);
                exception_tb = NULL;

                exception_lineno = 969;

                goto frame_exception_exit_2;
            }

            tmp_tuple_element_13 = tmp_mvar_value_102;
            tmp_defaults_4 = PyTuple_New(1);
            Py_INCREF(tmp_tuple_element_13);
            PyTuple_SET_ITEM(tmp_defaults_4, 0, tmp_tuple_element_13);
            tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_24_use_privatekey_file(tmp_defaults_4);



            tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain_use_privatekey_file, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 969;

                goto frame_exception_exit_2;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_25_use_privatekey();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain_use_privatekey, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_26_check_privatekey();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain_check_privatekey, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_27_load_client_ca();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain_load_client_ca, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_28_set_session_id();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain_set_session_id, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_29_set_session_cache_mode();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain_set_session_cache_mode, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_30_get_session_cache_mode();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain_get_session_cache_mode, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_31_set_verify();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain_set_verify, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_32_set_verify_depth();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain_set_verify_depth, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_33_get_verify_mode();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain_get_verify_mode, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_34_get_verify_depth();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain_get_verify_depth, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_35_load_tmp_dh();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain_load_tmp_dh, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_36_set_tmp_ecdh();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain_set_tmp_ecdh, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_37_set_cipher_list();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain_set_cipher_list, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_38_set_client_ca_list();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain_set_client_ca_list, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_39_add_client_ca();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain_add_client_ca, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_40_set_timeout();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain_set_timeout, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_41_get_timeout();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain_get_timeout, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_42_set_info_callback();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain_set_info_callback, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_43_get_app_data();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain_get_app_data, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_44_set_app_data();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain_set_app_data, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_45_get_cert_store();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain_get_cert_store, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_46_set_options();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain_set_options, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_47_set_mode();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain_set_mode, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        {
            PyObject *tmp_called_name_20;
            PyObject *tmp_mvar_value_103;
            PyObject *tmp_args_element_name_52;
            tmp_mvar_value_103 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__requires_sni);

            if (unlikely(tmp_mvar_value_103 == NULL)) {
                tmp_mvar_value_103 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__requires_sni);
            }

            if (tmp_mvar_value_103 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 2442 ], 35, 0);
                exception_tb = NULL;

                exception_lineno = 1361;

                goto frame_exception_exit_2;
            }

            tmp_called_name_20 = tmp_mvar_value_103;
            tmp_args_element_name_52 = MAKE_FUNCTION_OpenSSL$SSL$$$function_48_set_tlsext_servername_callback();



            frame_d641b83c6dc81d8049e076a80fd0abcb_2->m_frame.f_lineno = 1361;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_20, tmp_args_element_name_52);
            Py_DECREF(tmp_args_element_name_52);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1361;

                goto frame_exception_exit_2;
            }
            tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain_set_tlsext_servername_callback, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1361;

                goto frame_exception_exit_2;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_49_set_tlsext_use_srtp();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain_set_tlsext_use_srtp, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        {
            PyObject *tmp_called_name_21;
            PyObject *tmp_mvar_value_104;
            PyObject *tmp_args_element_name_53;
            tmp_mvar_value_104 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__requires_npn);

            if (unlikely(tmp_mvar_value_104 == NULL)) {
                tmp_mvar_value_104 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__requires_npn);
            }

            if (tmp_mvar_value_104 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 2477 ], 35, 0);
                exception_tb = NULL;

                exception_lineno = 1397;

                goto frame_exception_exit_2;
            }

            tmp_called_name_21 = tmp_mvar_value_104;
            tmp_args_element_name_53 = MAKE_FUNCTION_OpenSSL$SSL$$$function_50_set_npn_advertise_callback();



            frame_d641b83c6dc81d8049e076a80fd0abcb_2->m_frame.f_lineno = 1397;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_21, tmp_args_element_name_53);
            Py_DECREF(tmp_args_element_name_53);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1397;

                goto frame_exception_exit_2;
            }
            tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain_set_npn_advertise_callback, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1397;

                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_called_name_22;
            PyObject *tmp_mvar_value_105;
            PyObject *tmp_args_element_name_54;
            tmp_mvar_value_105 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__requires_npn);

            if (unlikely(tmp_mvar_value_105 == NULL)) {
                tmp_mvar_value_105 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__requires_npn);
            }

            if (tmp_mvar_value_105 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 2477 ], 35, 0);
                exception_tb = NULL;

                exception_lineno = 1416;

                goto frame_exception_exit_2;
            }

            tmp_called_name_22 = tmp_mvar_value_105;
            tmp_args_element_name_54 = MAKE_FUNCTION_OpenSSL$SSL$$$function_51_set_npn_select_callback();



            frame_d641b83c6dc81d8049e076a80fd0abcb_2->m_frame.f_lineno = 1416;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_22, tmp_args_element_name_54);
            Py_DECREF(tmp_args_element_name_54);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1416;

                goto frame_exception_exit_2;
            }
            tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain_set_npn_select_callback, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1416;

                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_called_name_23;
            PyObject *tmp_mvar_value_106;
            PyObject *tmp_args_element_name_55;
            tmp_mvar_value_106 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__requires_alpn);

            if (unlikely(tmp_mvar_value_106 == NULL)) {
                tmp_mvar_value_106 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__requires_alpn);
            }

            if (tmp_mvar_value_106 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 2512 ], 36, 0);
                exception_tb = NULL;

                exception_lineno = 1434;

                goto frame_exception_exit_2;
            }

            tmp_called_name_23 = tmp_mvar_value_106;
            tmp_args_element_name_55 = MAKE_FUNCTION_OpenSSL$SSL$$$function_52_set_alpn_protos();



            frame_d641b83c6dc81d8049e076a80fd0abcb_2->m_frame.f_lineno = 1434;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_23, tmp_args_element_name_55);
            Py_DECREF(tmp_args_element_name_55);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1434;

                goto frame_exception_exit_2;
            }
            tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain_set_alpn_protos, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1434;

                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_called_name_24;
            PyObject *tmp_mvar_value_107;
            PyObject *tmp_args_element_name_56;
            tmp_mvar_value_107 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__requires_alpn);

            if (unlikely(tmp_mvar_value_107 == NULL)) {
                tmp_mvar_value_107 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__requires_alpn);
            }

            if (tmp_mvar_value_107 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 2512 ], 36, 0);
                exception_tb = NULL;

                exception_lineno = 1456;

                goto frame_exception_exit_2;
            }

            tmp_called_name_24 = tmp_mvar_value_107;
            tmp_args_element_name_56 = MAKE_FUNCTION_OpenSSL$SSL$$$function_53_set_alpn_select_callback();



            frame_d641b83c6dc81d8049e076a80fd0abcb_2->m_frame.f_lineno = 1456;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_24, tmp_args_element_name_56);
            Py_DECREF(tmp_args_element_name_56);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1456;

                goto frame_exception_exit_2;
            }
            tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain_set_alpn_select_callback, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1456;

                goto frame_exception_exit_2;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_d641b83c6dc81d8049e076a80fd0abcb_2);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_1;

        frame_exception_exit_2:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_d641b83c6dc81d8049e076a80fd0abcb_2);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_d641b83c6dc81d8049e076a80fd0abcb_2, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_d641b83c6dc81d8049e076a80fd0abcb_2->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_d641b83c6dc81d8049e076a80fd0abcb_2, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_d641b83c6dc81d8049e076a80fd0abcb_2,
            type_description_2
        );


        // Release cached frame.
        if (frame_d641b83c6dc81d8049e076a80fd0abcb_2 == cache_frame_d641b83c6dc81d8049e076a80fd0abcb_2) {
            Py_DECREF(frame_d641b83c6dc81d8049e076a80fd0abcb_2);
        }
        cache_frame_d641b83c6dc81d8049e076a80fd0abcb_2 = NULL;

        assertFrameObject(frame_d641b83c6dc81d8049e076a80fd0abcb_2);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_1;

        frame_no_exception_1:;
        goto skip_nested_handling_1;
        nested_frame_exit_1:;

        goto try_except_handler_54;
        skip_nested_handling_1:;
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_54__set_ocsp_callback();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain__set_ocsp_callback, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        {
            PyObject *tmp_defaults_5;
            tmp_defaults_5 = const_tuple_none_tuple;
            Py_INCREF(tmp_defaults_5);
            tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_55_set_ocsp_server_callback(tmp_defaults_5);



            tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain_set_ocsp_server_callback, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            assert(!(tmp_res != 0));
        }
        {
            PyObject *tmp_defaults_6;
            tmp_defaults_6 = const_tuple_none_tuple;
            Py_INCREF(tmp_defaults_6);
            tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_56_set_ocsp_client_callback(tmp_defaults_6);



            tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_679, const_str_plain_set_ocsp_client_callback, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            assert(!(tmp_res != 0));
        }
        tmp_assign_source_207 = locals_OpenSSL$SSL_679;
        Py_INCREF(tmp_assign_source_207);
        goto try_return_handler_54;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        // Return handler code:
        try_return_handler_54:;
        Py_DECREF(locals_OpenSSL$SSL_679);
        locals_OpenSSL$SSL_679 = NULL;
        goto outline_result_24;
        // Exception handler code:
        try_except_handler_54:;
        exception_keeper_type_30 = exception_type;
        exception_keeper_value_30 = exception_value;
        exception_keeper_tb_30 = exception_tb;
        exception_keeper_lineno_30 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_OpenSSL$SSL_679);
        locals_OpenSSL$SSL_679 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_30;
        exception_value = exception_keeper_value_30;
        exception_tb = exception_keeper_tb_30;
        exception_lineno = exception_keeper_lineno_30;

        goto outline_exception_1;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        outline_exception_1:;
        exception_lineno = 679;
        goto try_except_handler_53;
        outline_result_24:;
        assert(tmp_class_creation_16__class_dict == NULL);
        tmp_class_creation_16__class_dict = tmp_assign_source_207;
    }
    {
        PyObject *tmp_assign_source_209;
        nuitka_bool tmp_condition_result_16;
        PyObject *tmp_key_name_29;
        PyObject *tmp_dict_name_29;
        PyObject *tmp_dict_name_30;
        PyObject *tmp_key_name_30;
        tmp_key_name_29 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_16__class_dict);
        tmp_dict_name_29 = tmp_class_creation_16__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_29, tmp_key_name_29);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 679;

            goto try_except_handler_53;
        }
        tmp_condition_result_16 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_16 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_15;
        } else {
            goto condexpr_false_15;
        }
        condexpr_true_15:;
        CHECK_OBJECT(tmp_class_creation_16__class_dict);
        tmp_dict_name_30 = tmp_class_creation_16__class_dict;
        tmp_key_name_30 = const_str_plain___metaclass__;
        tmp_assign_source_209 = DICT_GET_ITEM(tmp_dict_name_30, tmp_key_name_30);
        if (tmp_assign_source_209 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 679;

            goto try_except_handler_53;
        }
        goto condexpr_end_15;
        condexpr_false_15:;
        tmp_assign_source_209 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_209);
        condexpr_end_15:;
        assert(tmp_class_creation_16__metaclass == NULL);
        tmp_class_creation_16__metaclass = tmp_assign_source_209;
    }
    {
        PyObject *tmp_assign_source_210;
        PyObject *tmp_called_name_25;
        PyObject *tmp_args_element_name_57;
        PyObject *tmp_args_element_name_58;
        PyObject *tmp_args_element_name_59;
        CHECK_OBJECT(tmp_class_creation_16__metaclass);
        tmp_called_name_25 = tmp_class_creation_16__metaclass;
        tmp_args_element_name_57 = const_str_plain_Context;
        tmp_args_element_name_58 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_16__class_dict);
        tmp_args_element_name_59 = tmp_class_creation_16__class_dict;
        frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e->m_frame.f_lineno = 679;
        {
            PyObject *call_args[] = {tmp_args_element_name_57, tmp_args_element_name_58, tmp_args_element_name_59};
            tmp_assign_source_210 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_25, call_args);
        }

        if (tmp_assign_source_210 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 679;

            goto try_except_handler_53;
        }
        assert(tmp_class_creation_16__class == NULL);
        tmp_class_creation_16__class = tmp_assign_source_210;
    }
    goto try_end_19;
    // Exception handler code:
    try_except_handler_53:;
    exception_keeper_type_31 = exception_type;
    exception_keeper_value_31 = exception_value;
    exception_keeper_tb_31 = exception_tb;
    exception_keeper_lineno_31 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_16__class_dict);
    tmp_class_creation_16__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_16__metaclass);
    tmp_class_creation_16__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_31;
    exception_value = exception_keeper_value_31;
    exception_tb = exception_keeper_tb_31;
    exception_lineno = exception_keeper_lineno_31;

    goto frame_exception_exit_1;
    // End of try:
    try_end_19:;
    {
        PyObject *tmp_assign_source_211;
        CHECK_OBJECT(tmp_class_creation_16__class);
        tmp_assign_source_211 = tmp_class_creation_16__class;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Context, tmp_assign_source_211);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_16__class);
    Py_DECREF(tmp_class_creation_16__class);
    tmp_class_creation_16__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_16__class_dict);
    Py_DECREF(tmp_class_creation_16__class_dict);
    tmp_class_creation_16__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_16__metaclass);
    Py_DECREF(tmp_class_creation_16__metaclass);
    tmp_class_creation_16__metaclass = NULL;

    {
        PyObject *tmp_assign_source_212;
        PyObject *tmp_called_name_26;
        PyObject *tmp_mvar_value_108;
        PyObject *tmp_args_element_name_60;
        PyObject *tmp_mvar_value_109;
        PyObject *tmp_args_element_name_61;
        PyObject *tmp_args_element_name_62;
        PyObject *tmp_args_element_name_63;
        PyObject *tmp_mvar_value_110;
        tmp_mvar_value_108 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_deprecated);

        if (unlikely(tmp_mvar_value_108 == NULL)) {
            tmp_mvar_value_108 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_deprecated);
        }

        if (tmp_mvar_value_108 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 2548 ], 32, 0);
            exception_tb = NULL;

            exception_lineno = 1531;

            goto frame_exception_exit_1;
        }

        tmp_called_name_26 = tmp_mvar_value_108;
        tmp_mvar_value_109 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Context);

        if (unlikely(tmp_mvar_value_109 == NULL)) {
            tmp_mvar_value_109 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_Context);
        }

        if (tmp_mvar_value_109 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 1434 ], 29, 0);
            exception_tb = NULL;

            exception_lineno = 1532;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_60 = tmp_mvar_value_109;
        tmp_args_element_name_61 = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
        tmp_args_element_name_62 = const_str_digest_b7964fdc1d8df81dacc8b4450db712e3;
        tmp_mvar_value_110 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_DeprecationWarning);

        if (unlikely(tmp_mvar_value_110 == NULL)) {
            tmp_mvar_value_110 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_DeprecationWarning);
        }

        if (tmp_mvar_value_110 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 2580 ], 40, 0);
            exception_tb = NULL;

            exception_lineno = 1533;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_63 = tmp_mvar_value_110;
        frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e->m_frame.f_lineno = 1531;
        {
            PyObject *call_args[] = {tmp_args_element_name_60, tmp_args_element_name_61, tmp_args_element_name_62, tmp_args_element_name_63};
            tmp_assign_source_212 = CALL_FUNCTION_WITH_ARGS4(tmp_called_name_26, call_args);
        }

        if (tmp_assign_source_212 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1531;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_ContextType, tmp_assign_source_212);
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_213;
        {
            PyObject *tmp_set_locals_13;
            tmp_set_locals_13 = PyDict_New();
            locals_OpenSSL$SSL_1537 = tmp_set_locals_13;
        }
        tmp_dictset_value = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain___module__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = const_str_digest_ca4a6d4d96b227b5bd17bc5998515ec3;
        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain___doc__, tmp_dictset_value);
        assert(!(tmp_res != 0));
        // Tried code:
        MAKE_OR_REUSE_FRAME(cache_frame_b51be28c00cf0bfc19c54f6f95b9174b_3, codeobj_b51be28c00cf0bfc19c54f6f95b9174b, module_OpenSSL$SSL, 0);
        frame_b51be28c00cf0bfc19c54f6f95b9174b_3 = cache_frame_b51be28c00cf0bfc19c54f6f95b9174b_3;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_b51be28c00cf0bfc19c54f6f95b9174b_3);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_b51be28c00cf0bfc19c54f6f95b9174b_3) == 2); // Frame stack

        // Framed code:
        {
            PyObject *tmp_called_name_27;
            PyObject *tmp_mvar_value_111;
            tmp_mvar_value_111 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_WeakValueDictionary);

            if (unlikely(tmp_mvar_value_111 == NULL)) {
                tmp_mvar_value_111 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_WeakValueDictionary);
            }

            if (tmp_mvar_value_111 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 2620 ], 41, 0);
                exception_tb = NULL;

                exception_lineno = 1540;

                goto frame_exception_exit_3;
            }

            tmp_called_name_27 = tmp_mvar_value_111;
            frame_b51be28c00cf0bfc19c54f6f95b9174b_3->m_frame.f_lineno = 1540;
            tmp_dictset_value = CALL_FUNCTION_NO_ARGS(tmp_called_name_27);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1540;

                goto frame_exception_exit_3;
            }
            tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain__reverse_mapping, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1540;

                goto frame_exception_exit_3;
            }
        }
        {
            PyObject *tmp_defaults_7;
            tmp_defaults_7 = const_tuple_none_tuple;
            Py_INCREF(tmp_defaults_7);
            tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_57___init__(tmp_defaults_7);



            tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain___init__, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            assert(!(tmp_res != 0));
        }
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_58___getattr__();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain___getattr__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_59__raise_ssl_error();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain__raise_ssl_error, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_60_get_context();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_get_context, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_61_set_context();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_set_context, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        {
            PyObject *tmp_called_name_28;
            PyObject *tmp_mvar_value_112;
            PyObject *tmp_args_element_name_64;
            tmp_mvar_value_112 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__requires_sni);

            if (unlikely(tmp_mvar_value_112 == NULL)) {
                tmp_mvar_value_112 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__requires_sni);
            }

            if (tmp_mvar_value_112 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 2442 ], 35, 0);
                exception_tb = NULL;

                exception_lineno = 1669;

                goto frame_exception_exit_3;
            }

            tmp_called_name_28 = tmp_mvar_value_112;
            tmp_args_element_name_64 = MAKE_FUNCTION_OpenSSL$SSL$$$function_62_get_servername();



            frame_b51be28c00cf0bfc19c54f6f95b9174b_3->m_frame.f_lineno = 1669;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_28, tmp_args_element_name_64);
            Py_DECREF(tmp_args_element_name_64);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1669;

                goto frame_exception_exit_3;
            }
            tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_get_servername, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1669;

                goto frame_exception_exit_3;
            }
        }
        {
            PyObject *tmp_called_name_29;
            PyObject *tmp_mvar_value_113;
            PyObject *tmp_args_element_name_65;
            tmp_mvar_value_113 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__requires_sni);

            if (unlikely(tmp_mvar_value_113 == NULL)) {
                tmp_mvar_value_113 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__requires_sni);
            }

            if (tmp_mvar_value_113 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 2442 ], 35, 0);
                exception_tb = NULL;

                exception_lineno = 1687;

                goto frame_exception_exit_3;
            }

            tmp_called_name_29 = tmp_mvar_value_113;
            tmp_args_element_name_65 = MAKE_FUNCTION_OpenSSL$SSL$$$function_63_set_tlsext_host_name();



            frame_b51be28c00cf0bfc19c54f6f95b9174b_3->m_frame.f_lineno = 1687;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_29, tmp_args_element_name_65);
            Py_DECREF(tmp_args_element_name_65);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1687;

                goto frame_exception_exit_3;
            }
            tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_set_tlsext_host_name, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1687;

                goto frame_exception_exit_3;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_64_pending();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_pending, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        {
            PyObject *tmp_defaults_8;
            tmp_defaults_8 = const_tuple_int_0_tuple;
            Py_INCREF(tmp_defaults_8);
            tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_65_send(tmp_defaults_8);



            tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_send, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            assert(!(tmp_res != 0));
        }
        tmp_dictset_value = PyDict_GetItem(locals_OpenSSL$SSL_1537, const_str_plain_send);

        if (tmp_dictset_value == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 2661 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 1739;

            goto frame_exception_exit_3;
        }

        if (tmp_dictset_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1739;

            goto frame_exception_exit_3;
        }
        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_write, tmp_dictset_value);
        assert(!(tmp_res != 0));
        {
            PyObject *tmp_defaults_9;
            tmp_defaults_9 = const_tuple_int_0_tuple;
            Py_INCREF(tmp_defaults_9);
            tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_66_sendall(tmp_defaults_9);



            tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_sendall, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            assert(!(tmp_res != 0));
        }
        {
            PyObject *tmp_defaults_10;
            tmp_defaults_10 = const_tuple_none_tuple;
            Py_INCREF(tmp_defaults_10);
            tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_67_recv(tmp_defaults_10);



            tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_recv, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            assert(!(tmp_res != 0));
        }
        tmp_dictset_value = PyDict_GetItem(locals_OpenSSL$SSL_1537, const_str_plain_recv);

        if (tmp_dictset_value == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 2687 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 1793;

            goto frame_exception_exit_3;
        }

        if (tmp_dictset_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1793;

            goto frame_exception_exit_3;
        }
        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_read, tmp_dictset_value);
        assert(!(tmp_res != 0));
        {
            PyObject *tmp_defaults_11;
            tmp_defaults_11 = const_tuple_none_none_tuple;
            Py_INCREF(tmp_defaults_11);
            tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_68_recv_into(tmp_defaults_11);



            tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_recv_into, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            assert(!(tmp_res != 0));
        }
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_69__handle_bio_errors();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain__handle_bio_errors, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_70_bio_read();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_bio_read, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_71_bio_write();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_bio_write, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_72_renegotiate();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_renegotiate, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_73_do_handshake();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_do_handshake, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_74_renegotiate_pending();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_renegotiate_pending, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_75_total_renegotiations();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_total_renegotiations, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_76_connect();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_connect, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_77_connect_ex();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_connect_ex, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_78_accept();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_accept, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_79_bio_shutdown();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_bio_shutdown, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_80_shutdown();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_shutdown, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_81_get_cipher_list();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_get_cipher_list, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_82_get_client_ca_list();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_get_client_ca_list, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_83_makefile();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_makefile, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_84_get_app_data();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_get_app_data, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_85_set_app_data();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_set_app_data, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_86_get_shutdown();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_get_shutdown, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_87_set_shutdown();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_set_shutdown, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_88_get_state_string();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_get_state_string, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_89_server_random();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_server_random, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_90_client_random();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_client_random, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_91_master_key();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_master_key, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        {
            PyObject *tmp_defaults_12;
            tmp_defaults_12 = const_tuple_none_tuple;
            Py_INCREF(tmp_defaults_12);
            tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_92_export_keying_material(tmp_defaults_12);



            tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_export_keying_material, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            assert(!(tmp_res != 0));
        }
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_93_sock_shutdown();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_sock_shutdown, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_94_get_certificate();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_get_certificate, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_95_get_peer_certificate();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_get_peer_certificate, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_96_get_peer_cert_chain();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_get_peer_cert_chain, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_97_want_read();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_want_read, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_98_want_write();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_want_write, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_99_set_accept_state();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_set_accept_state, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_100_set_connect_state();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_set_connect_state, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_101_get_session();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_get_session, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_102_set_session();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_set_session, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_103__get_finished_message();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain__get_finished_message, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_104_get_finished();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_get_finished, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_105_get_peer_finished();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_get_peer_finished, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_106_get_cipher_name();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_get_cipher_name, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_107_get_cipher_bits();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_get_cipher_bits, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_108_get_cipher_version();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_get_cipher_version, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_109_get_protocol_version_name();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_get_protocol_version_name, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_110_get_protocol_version();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_get_protocol_version, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        {
            PyObject *tmp_called_name_30;
            PyObject *tmp_mvar_value_114;
            PyObject *tmp_args_element_name_66;
            tmp_mvar_value_114 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__requires_npn);

            if (unlikely(tmp_mvar_value_114 == NULL)) {
                tmp_mvar_value_114 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__requires_npn);
            }

            if (tmp_mvar_value_114 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 2477 ], 35, 0);
                exception_tb = NULL;

                exception_lineno = 2429;

                goto frame_exception_exit_3;
            }

            tmp_called_name_30 = tmp_mvar_value_114;
            tmp_args_element_name_66 = MAKE_FUNCTION_OpenSSL$SSL$$$function_111_get_next_proto_negotiated();



            frame_b51be28c00cf0bfc19c54f6f95b9174b_3->m_frame.f_lineno = 2429;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_30, tmp_args_element_name_66);
            Py_DECREF(tmp_args_element_name_66);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2429;

                goto frame_exception_exit_3;
            }
            tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_get_next_proto_negotiated, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2429;

                goto frame_exception_exit_3;
            }
        }
        {
            PyObject *tmp_called_name_31;
            PyObject *tmp_mvar_value_115;
            PyObject *tmp_args_element_name_67;
            tmp_mvar_value_115 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__requires_alpn);

            if (unlikely(tmp_mvar_value_115 == NULL)) {
                tmp_mvar_value_115 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__requires_alpn);
            }

            if (tmp_mvar_value_115 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 2512 ], 36, 0);
                exception_tb = NULL;

                exception_lineno = 2446;

                goto frame_exception_exit_3;
            }

            tmp_called_name_31 = tmp_mvar_value_115;
            tmp_args_element_name_67 = MAKE_FUNCTION_OpenSSL$SSL$$$function_112_set_alpn_protos();



            frame_b51be28c00cf0bfc19c54f6f95b9174b_3->m_frame.f_lineno = 2446;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_31, tmp_args_element_name_67);
            Py_DECREF(tmp_args_element_name_67);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2446;

                goto frame_exception_exit_3;
            }
            tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_set_alpn_protos, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2446;

                goto frame_exception_exit_3;
            }
        }
        {
            PyObject *tmp_called_name_32;
            PyObject *tmp_mvar_value_116;
            PyObject *tmp_args_element_name_68;
            tmp_mvar_value_116 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__requires_alpn);

            if (unlikely(tmp_mvar_value_116 == NULL)) {
                tmp_mvar_value_116 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__requires_alpn);
            }

            if (tmp_mvar_value_116 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 2512 ], 36, 0);
                exception_tb = NULL;

                exception_lineno = 2468;

                goto frame_exception_exit_3;
            }

            tmp_called_name_32 = tmp_mvar_value_116;
            tmp_args_element_name_68 = MAKE_FUNCTION_OpenSSL$SSL$$$function_113_get_alpn_proto_negotiated();



            frame_b51be28c00cf0bfc19c54f6f95b9174b_3->m_frame.f_lineno = 2468;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_32, tmp_args_element_name_68);
            Py_DECREF(tmp_args_element_name_68);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2468;

                goto frame_exception_exit_3;
            }
            tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_get_alpn_proto_negotiated, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 2468;

                goto frame_exception_exit_3;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_b51be28c00cf0bfc19c54f6f95b9174b_3);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_2;

        frame_exception_exit_3:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_b51be28c00cf0bfc19c54f6f95b9174b_3);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_b51be28c00cf0bfc19c54f6f95b9174b_3, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_b51be28c00cf0bfc19c54f6f95b9174b_3->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_b51be28c00cf0bfc19c54f6f95b9174b_3, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_b51be28c00cf0bfc19c54f6f95b9174b_3,
            type_description_2
        );


        // Release cached frame.
        if (frame_b51be28c00cf0bfc19c54f6f95b9174b_3 == cache_frame_b51be28c00cf0bfc19c54f6f95b9174b_3) {
            Py_DECREF(frame_b51be28c00cf0bfc19c54f6f95b9174b_3);
        }
        cache_frame_b51be28c00cf0bfc19c54f6f95b9174b_3 = NULL;

        assertFrameObject(frame_b51be28c00cf0bfc19c54f6f95b9174b_3);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_2;

        frame_no_exception_2:;
        goto skip_nested_handling_2;
        nested_frame_exit_2:;

        goto try_except_handler_57;
        skip_nested_handling_2:;
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_114_request_ocsp();



        tmp_res = PyDict_SetItem(locals_OpenSSL$SSL_1537, const_str_plain_request_ocsp, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
        tmp_assign_source_213 = locals_OpenSSL$SSL_1537;
        Py_INCREF(tmp_assign_source_213);
        goto try_return_handler_57;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        // Return handler code:
        try_return_handler_57:;
        Py_DECREF(locals_OpenSSL$SSL_1537);
        locals_OpenSSL$SSL_1537 = NULL;
        goto outline_result_26;
        // Exception handler code:
        try_except_handler_57:;
        exception_keeper_type_32 = exception_type;
        exception_keeper_value_32 = exception_value;
        exception_keeper_tb_32 = exception_tb;
        exception_keeper_lineno_32 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_OpenSSL$SSL_1537);
        locals_OpenSSL$SSL_1537 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_32;
        exception_value = exception_keeper_value_32;
        exception_tb = exception_keeper_tb_32;
        exception_lineno = exception_keeper_lineno_32;

        goto outline_exception_2;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(OpenSSL$SSL);
        return NULL;
        outline_exception_2:;
        exception_lineno = 1537;
        goto try_except_handler_56;
        outline_result_26:;
        assert(tmp_class_creation_17__class_dict == NULL);
        tmp_class_creation_17__class_dict = tmp_assign_source_213;
    }
    {
        PyObject *tmp_assign_source_214;
        nuitka_bool tmp_condition_result_17;
        PyObject *tmp_key_name_31;
        PyObject *tmp_dict_name_31;
        PyObject *tmp_dict_name_32;
        PyObject *tmp_key_name_32;
        tmp_key_name_31 = const_str_plain___metaclass__;
        CHECK_OBJECT(tmp_class_creation_17__class_dict);
        tmp_dict_name_31 = tmp_class_creation_17__class_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_31, tmp_key_name_31);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1537;

            goto try_except_handler_56;
        }
        tmp_condition_result_17 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_17 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_16;
        } else {
            goto condexpr_false_16;
        }
        condexpr_true_16:;
        CHECK_OBJECT(tmp_class_creation_17__class_dict);
        tmp_dict_name_32 = tmp_class_creation_17__class_dict;
        tmp_key_name_32 = const_str_plain___metaclass__;
        tmp_assign_source_214 = DICT_GET_ITEM(tmp_dict_name_32, tmp_key_name_32);
        if (tmp_assign_source_214 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1537;

            goto try_except_handler_56;
        }
        goto condexpr_end_16;
        condexpr_false_16:;
        tmp_assign_source_214 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_assign_source_214);
        condexpr_end_16:;
        assert(tmp_class_creation_17__metaclass == NULL);
        tmp_class_creation_17__metaclass = tmp_assign_source_214;
    }
    {
        PyObject *tmp_assign_source_215;
        PyObject *tmp_called_name_33;
        PyObject *tmp_args_element_name_69;
        PyObject *tmp_args_element_name_70;
        PyObject *tmp_args_element_name_71;
        CHECK_OBJECT(tmp_class_creation_17__metaclass);
        tmp_called_name_33 = tmp_class_creation_17__metaclass;
        tmp_args_element_name_69 = const_str_plain_Connection;
        tmp_args_element_name_70 = const_tuple_type_object_tuple;
        CHECK_OBJECT(tmp_class_creation_17__class_dict);
        tmp_args_element_name_71 = tmp_class_creation_17__class_dict;
        frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e->m_frame.f_lineno = 1537;
        {
            PyObject *call_args[] = {tmp_args_element_name_69, tmp_args_element_name_70, tmp_args_element_name_71};
            tmp_assign_source_215 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_33, call_args);
        }

        if (tmp_assign_source_215 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1537;

            goto try_except_handler_56;
        }
        assert(tmp_class_creation_17__class == NULL);
        tmp_class_creation_17__class = tmp_assign_source_215;
    }
    goto try_end_20;
    // Exception handler code:
    try_except_handler_56:;
    exception_keeper_type_33 = exception_type;
    exception_keeper_value_33 = exception_value;
    exception_keeper_tb_33 = exception_tb;
    exception_keeper_lineno_33 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_17__class_dict);
    tmp_class_creation_17__class_dict = NULL;

    Py_XDECREF(tmp_class_creation_17__metaclass);
    tmp_class_creation_17__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_33;
    exception_value = exception_keeper_value_33;
    exception_tb = exception_keeper_tb_33;
    exception_lineno = exception_keeper_lineno_33;

    goto frame_exception_exit_1;
    // End of try:
    try_end_20:;
    {
        PyObject *tmp_assign_source_216;
        CHECK_OBJECT(tmp_class_creation_17__class);
        tmp_assign_source_216 = tmp_class_creation_17__class;
        UPDATE_STRING_DICT0(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Connection, tmp_assign_source_216);
    }
    CHECK_OBJECT((PyObject *)tmp_class_creation_17__class);
    Py_DECREF(tmp_class_creation_17__class);
    tmp_class_creation_17__class = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_17__class_dict);
    Py_DECREF(tmp_class_creation_17__class_dict);
    tmp_class_creation_17__class_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_17__metaclass);
    Py_DECREF(tmp_class_creation_17__metaclass);
    tmp_class_creation_17__metaclass = NULL;

    {
        PyObject *tmp_assign_source_217;
        PyObject *tmp_called_name_34;
        PyObject *tmp_mvar_value_117;
        PyObject *tmp_args_element_name_72;
        PyObject *tmp_mvar_value_118;
        PyObject *tmp_args_element_name_73;
        PyObject *tmp_args_element_name_74;
        PyObject *tmp_args_element_name_75;
        PyObject *tmp_mvar_value_119;
        tmp_mvar_value_117 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_deprecated);

        if (unlikely(tmp_mvar_value_117 == NULL)) {
            tmp_mvar_value_117 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_deprecated);
        }

        if (tmp_mvar_value_117 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 2548 ], 32, 0);
            exception_tb = NULL;

            exception_lineno = 2499;

            goto frame_exception_exit_1;
        }

        tmp_called_name_34 = tmp_mvar_value_117;
        tmp_mvar_value_118 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Connection);

        if (unlikely(tmp_mvar_value_118 == NULL)) {
            tmp_mvar_value_118 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_Connection);
        }

        if (tmp_mvar_value_118 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 276 ], 32, 0);
            exception_tb = NULL;

            exception_lineno = 2500;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_72 = tmp_mvar_value_118;
        tmp_args_element_name_73 = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
        tmp_args_element_name_74 = const_str_digest_2db82bf07fbb595fa9b0bb5b41c7d7cb;
        tmp_mvar_value_119 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_DeprecationWarning);

        if (unlikely(tmp_mvar_value_119 == NULL)) {
            tmp_mvar_value_119 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_DeprecationWarning);
        }

        if (tmp_mvar_value_119 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 2580 ], 40, 0);
            exception_tb = NULL;

            exception_lineno = 2502;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_75 = tmp_mvar_value_119;
        frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e->m_frame.f_lineno = 2499;
        {
            PyObject *call_args[] = {tmp_args_element_name_72, tmp_args_element_name_73, tmp_args_element_name_74, tmp_args_element_name_75};
            tmp_assign_source_217 = CALL_FUNCTION_WITH_ARGS4(tmp_called_name_34, call_args);
        }

        if (tmp_assign_source_217 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2499;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_ConnectionType, tmp_assign_source_217);
    }
    {
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_120;
        PyObject *tmp_call_result_2;
        tmp_mvar_value_120 = GET_STRING_DICT_VALUE(moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib);

        if (unlikely(tmp_mvar_value_120 == NULL)) {
            tmp_mvar_value_120 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain__lib);
        }

        if (tmp_mvar_value_120 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 210 ], 26, 0);
            exception_tb = NULL;

            exception_lineno = 2507;

            goto frame_exception_exit_1;
        }

        tmp_called_instance_3 = tmp_mvar_value_120;
        frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e->m_frame.f_lineno = 2507;
        tmp_call_result_2 = CALL_METHOD_NO_ARGS(tmp_called_instance_3, const_str_plain_SSL_library_init);
        if (tmp_call_result_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 2507;

            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_2);
    }

    // Restore frame exception if necessary.
#if 0
    RESTORE_FRAME_EXCEPTION(frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e);
#endif
    popFrameStack();

    assertFrameObject(frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e);

    goto frame_no_exception_3;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e);
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK(frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_9bf9e3fa2edc4bf3ebd1e712b4e8714e, exception_lineno);
    }

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto module_exception_exit;

    frame_no_exception_3:;

    return module_OpenSSL$SSL;
    module_exception_exit:
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);
    return NULL;
}
